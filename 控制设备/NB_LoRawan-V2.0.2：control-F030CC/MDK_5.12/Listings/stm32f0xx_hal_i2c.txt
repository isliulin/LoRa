; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f0xx_hal_i2c.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f0xx_hal_i2c.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS\Device\ST\STM32F0xx\Include -I..\CMSIS\Include -I..\stm32f03xx_HAL\Inc -I..\USER -I..\HAL\inc -I..\HAL\system -I..\Lib\LoRawan-node\misc -I..\Lib\LoRawan-node\crypto -I..\Lib\LoRawan-node\mac -I..\Lib\LoRawan-node\radio -I..\Lib\LoRawan-node\radio\sx1276 -I..\Lib -IE:\NBI项目\NBI_LoRa\LoRa版本备份\NB_LoRawan-V2.0.2：control-F030CC\MDK_5.12\RTE -ID:\mysaftware\keil_5.12\ARM\PACK\Keil\STM32F0xx_DFP\1.5.0\Device\Include -ID:\mysaftware\keil_5.12\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=518 -DSTM32F030xC -DUSE_HAL_DRIVER -DSTM32F030xC -DUSE_MODEM_LORA -DUSE_BAND_433 --omf_browse=.\objects\stm32f0xx_hal_i2c.crf ..\stm32f03xx_HAL\Src\stm32f0xx_hal_i2c.c]
                          THUMB

                          AREA ||i.HAL_I2C_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_AbortCpltCallback PROC
;;;3177     */
;;;3178   __weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3179   {
;;;3180     /* Prevent unused argument(s) compilation warning */
;;;3181     UNUSED(hi2c);
;;;3182   
;;;3183     /* NOTE : This function should not be modified, when the callback is needed,
;;;3184               the HAL_I2C_AbortCpltCallback could be implemented in the user file
;;;3185      */
;;;3186   }
;;;3187   
                          ENDP


                          AREA ||i.HAL_I2C_AddrCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_AddrCallback PROC
;;;3095     */
;;;3096   __weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
000000  4770              BX       lr
;;;3097   {
;;;3098     /* Prevent unused argument(s) compilation warning */
;;;3099     UNUSED(hi2c);
;;;3100     UNUSED(TransferDirection);
;;;3101     UNUSED(AddrMatchCode);
;;;3102   
;;;3103     /* NOTE : This function should not be modified, when the callback is needed,
;;;3104               the HAL_I2C_AddrCallback() could be implemented in the user file
;;;3105      */
;;;3106   }
;;;3107   
                          ENDP


                          AREA ||i.HAL_I2C_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_DeInit PROC
;;;490      */
;;;491    HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;492    {
000002  4604              MOV      r4,r0
;;;493      /* Check the I2C handle allocation */
;;;494      if(hi2c == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L3.12|
;;;495      {
;;;496        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L3.10|
;;;497      }
;;;498    
;;;499      /* Check the parameters */
;;;500      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;501    
;;;502      hi2c->State = HAL_I2C_STATE_BUSY;
;;;503    
;;;504      /* Disable the I2C Peripheral Clock */
;;;505      __HAL_I2C_DISABLE(hi2c);
;;;506    
;;;507      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;508      HAL_I2C_MspDeInit(hi2c);
;;;509    
;;;510      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;511      hi2c->State = HAL_I2C_STATE_RESET;
;;;512      hi2c->PreviousState = I2C_STATE_NONE;
;;;513      hi2c->Mode = HAL_I2C_MODE_NONE;
;;;514    
;;;515      /* Release Lock */
;;;516      __HAL_UNLOCK(hi2c);
;;;517    
;;;518      return HAL_OK;
;;;519    }
00000a  bd10              POP      {r4,pc}
                  |L3.12|
00000c  2124              MOVS     r1,#0x24              ;502
00000e  2041              MOVS     r0,#0x41              ;502
000010  5501              STRB     r1,[r0,r4]            ;502
000012  6820              LDR      r0,[r4,#0]            ;505
000014  6800              LDR      r0,[r0,#0]            ;505
000016  0840              LSRS     r0,r0,#1              ;505
000018  0040              LSLS     r0,r0,#1              ;505
00001a  6821              LDR      r1,[r4,#0]            ;505
00001c  6008              STR      r0,[r1,#0]            ;505
00001e  4620              MOV      r0,r4                 ;508
000020  f7fffffe          BL       HAL_I2C_MspDeInit
000024  2000              MOVS     r0,#0                 ;510
000026  6460              STR      r0,[r4,#0x44]         ;510
000028  2100              MOVS     r1,#0                 ;511
00002a  2041              MOVS     r0,#0x41              ;511
00002c  5501              STRB     r1,[r0,r4]            ;511
00002e  2000              MOVS     r0,#0                 ;512
000030  6320              STR      r0,[r4,#0x30]         ;512
000032  2042              MOVS     r0,#0x42              ;513
000034  5501              STRB     r1,[r0,r4]            ;513
000036  bf00              NOP                            ;516
000038  2040              MOVS     r0,#0x40              ;516
00003a  5501              STRB     r1,[r0,r4]            ;516
00003c  bf00              NOP                            ;516
00003e  2000              MOVS     r0,#0                 ;518
000040  e7e3              B        |L3.10|
;;;520    
                          ENDP


                          AREA ||i.HAL_I2C_DisableListen_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_DisableListen_IT PROC
;;;2883     */
;;;2884   HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;2885   {
000002  4604              MOV      r4,r0
;;;2886     /* Declaration of tmp to prevent undefined behavior of volatile usage */
;;;2887     uint32_t tmp;
;;;2888   
;;;2889     /* Disable Address listen mode only if a transfer is not ongoing */
;;;2890     if(hi2c->State == HAL_I2C_STATE_LISTEN)
000004  2041              MOVS     r0,#0x41
000006  5d00              LDRB     r0,[r0,r4]
000008  2828              CMP      r0,#0x28
00000a  d115              BNE      |L4.56|
;;;2891     {
;;;2892       tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
00000c  2041              MOVS     r0,#0x41
00000e  5d00              LDRB     r0,[r0,r4]
000010  0785              LSLS     r5,r0,#30
000012  0fad              LSRS     r5,r5,#30
;;;2893       hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
000014  2042              MOVS     r0,#0x42
000016  5d00              LDRB     r0,[r0,r4]
000018  4328              ORRS     r0,r0,r5
00001a  6320              STR      r0,[r4,#0x30]
;;;2894       hi2c->State = HAL_I2C_STATE_READY;
00001c  2120              MOVS     r1,#0x20
00001e  2041              MOVS     r0,#0x41
000020  5501              STRB     r1,[r0,r4]
;;;2895       hi2c->Mode = HAL_I2C_MODE_NONE;
000022  2100              MOVS     r1,#0
000024  2042              MOVS     r0,#0x42
000026  5501              STRB     r1,[r0,r4]
;;;2896       hi2c->XferISR = NULL;
000028  2000              MOVS     r0,#0
00002a  6360              STR      r0,[r4,#0x34]
;;;2897   
;;;2898       /* Disable the Address Match interrupt */
;;;2899       I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
00002c  2104              MOVS     r1,#4
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       I2C_Disable_IRQ
;;;2900   
;;;2901       return HAL_OK;
000034  2000              MOVS     r0,#0
                  |L4.54|
;;;2902     }
;;;2903     else
;;;2904     {
;;;2905       return HAL_BUSY;
;;;2906     }
;;;2907   }
000036  bd70              POP      {r4-r6,pc}
                  |L4.56|
000038  2002              MOVS     r0,#2                 ;2905
00003a  e7fc              B        |L4.54|
;;;2908   
                          ENDP


                          AREA ||i.HAL_I2C_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ER_IRQHandler PROC
;;;2985     */
;;;2986   void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;2987   {
000002  4604              MOV      r4,r0
;;;2988     uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
000004  6820              LDR      r0,[r4,#0]
000006  6985              LDR      r5,[r0,#0x18]
;;;2989     uint32_t itsources = READ_REG(hi2c->Instance->CR1);
000008  6820              LDR      r0,[r4,#0]
00000a  6806              LDR      r6,[r0,#0]
;;;2990   
;;;2991     /* I2C Bus error interrupt occurred ------------------------------------*/
;;;2992     if(((itflags & I2C_FLAG_BERR) != RESET) && ((itsources & I2C_IT_ERRI) != RESET))
00000c  20ff              MOVS     r0,#0xff
00000e  3001              ADDS     r0,#1
000010  4028              ANDS     r0,r0,r5
000012  2800              CMP      r0,#0
000014  d00a              BEQ      |L5.44|
000016  2080              MOVS     r0,#0x80
000018  4030              ANDS     r0,r0,r6
00001a  2800              CMP      r0,#0
00001c  d006              BEQ      |L5.44|
;;;2993     {
;;;2994       hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
00001e  6c60              LDR      r0,[r4,#0x44]
000020  2101              MOVS     r1,#1
000022  4308              ORRS     r0,r0,r1
000024  6460              STR      r0,[r4,#0x44]
;;;2995   
;;;2996       /* Clear BERR flag */
;;;2997       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
000026  0208              LSLS     r0,r1,#8
000028  6821              LDR      r1,[r4,#0]
00002a  61c8              STR      r0,[r1,#0x1c]
                  |L5.44|
;;;2998     }
;;;2999   
;;;3000     /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
;;;3001     if(((itflags & I2C_FLAG_OVR) != RESET) && ((itsources & I2C_IT_ERRI) != RESET))
00002c  2001              MOVS     r0,#1
00002e  0280              LSLS     r0,r0,#10
000030  4028              ANDS     r0,r0,r5
000032  2800              CMP      r0,#0
000034  d00a              BEQ      |L5.76|
000036  2080              MOVS     r0,#0x80
000038  4030              ANDS     r0,r0,r6
00003a  2800              CMP      r0,#0
00003c  d006              BEQ      |L5.76|
;;;3002     {
;;;3003       hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
00003e  6c60              LDR      r0,[r4,#0x44]
000040  2108              MOVS     r1,#8
000042  4308              ORRS     r0,r0,r1
000044  6460              STR      r0,[r4,#0x44]
;;;3004   
;;;3005       /* Clear OVR flag */
;;;3006       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
000046  01c8              LSLS     r0,r1,#7
000048  6821              LDR      r1,[r4,#0]
00004a  61c8              STR      r0,[r1,#0x1c]
                  |L5.76|
;;;3007     }
;;;3008   
;;;3009     /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
;;;3010     if(((itflags & I2C_FLAG_ARLO) != RESET) && ((itsources & I2C_IT_ERRI) != RESET))
00004c  2001              MOVS     r0,#1
00004e  0240              LSLS     r0,r0,#9
000050  4028              ANDS     r0,r0,r5
000052  2800              CMP      r0,#0
000054  d00a              BEQ      |L5.108|
000056  2080              MOVS     r0,#0x80
000058  4030              ANDS     r0,r0,r6
00005a  2800              CMP      r0,#0
00005c  d006              BEQ      |L5.108|
;;;3011     {
;;;3012       hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
00005e  6c60              LDR      r0,[r4,#0x44]
000060  2102              MOVS     r1,#2
000062  4308              ORRS     r0,r0,r1
000064  6460              STR      r0,[r4,#0x44]
;;;3013   
;;;3014       /* Clear ARLO flag */
;;;3015       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
000066  0208              LSLS     r0,r1,#8
000068  6821              LDR      r1,[r4,#0]
00006a  61c8              STR      r0,[r1,#0x1c]
                  |L5.108|
;;;3016     }
;;;3017   
;;;3018     /* Call the Error Callback in case of Error detected */
;;;3019     if((hi2c->ErrorCode & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
00006c  6c60              LDR      r0,[r4,#0x44]
00006e  210b              MOVS     r1,#0xb
000070  4008              ANDS     r0,r0,r1
000072  2800              CMP      r0,#0
000074  d003              BEQ      |L5.126|
;;;3020     {
;;;3021       I2C_ITError(hi2c, hi2c->ErrorCode);
000076  6c61              LDR      r1,[r4,#0x44]
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       I2C_ITError
                  |L5.126|
;;;3022     }
;;;3023   }
00007e  bd70              POP      {r4-r6,pc}
;;;3024   
                          ENDP


                          AREA ||i.HAL_I2C_EV_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_I2C_EV_IRQHandler PROC
;;;2966     */
;;;2967   void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
000000  b570              PUSH     {r4-r6,lr}
;;;2968   {
000002  4604              MOV      r4,r0
;;;2969     /* Get current IT Flags and IT sources value */
;;;2970     uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
000004  6820              LDR      r0,[r4,#0]
000006  6985              LDR      r5,[r0,#0x18]
;;;2971     uint32_t itsources = READ_REG(hi2c->Instance->CR1);
000008  6820              LDR      r0,[r4,#0]
00000a  6806              LDR      r6,[r0,#0]
;;;2972   
;;;2973     /* I2C events treatment -------------------------------------*/
;;;2974     if(hi2c->XferISR != NULL)
00000c  6b60              LDR      r0,[r4,#0x34]
00000e  2800              CMP      r0,#0
000010  d004              BEQ      |L6.28|
;;;2975     {
;;;2976       hi2c->XferISR(hi2c, itflags, itsources);
000012  4632              MOV      r2,r6
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  6b63              LDR      r3,[r4,#0x34]
00001a  4798              BLX      r3
                  |L6.28|
;;;2977     }
;;;2978   }
00001c  bd70              POP      {r4-r6,pc}
;;;2979   
                          ENDP


                          AREA ||i.HAL_I2C_EnableListen_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_EnableListen_IT PROC
;;;2859     */
;;;2860   HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;2861   {
000002  4604              MOV      r4,r0
;;;2862     if(hi2c->State == HAL_I2C_STATE_READY)
000004  2041              MOVS     r0,#0x41
000006  5d00              LDRB     r0,[r0,r4]
000008  2820              CMP      r0,#0x20
00000a  d10a              BNE      |L7.34|
;;;2863     {
;;;2864       hi2c->State = HAL_I2C_STATE_LISTEN;
00000c  2128              MOVS     r1,#0x28
00000e  2041              MOVS     r0,#0x41
000010  5501              STRB     r1,[r0,r4]
;;;2865       hi2c->XferISR = I2C_Slave_ISR_IT;
000012  4805              LDR      r0,|L7.40|
000014  6360              STR      r0,[r4,#0x34]
;;;2866   
;;;2867       /* Enable the Address Match interrupt */
;;;2868       I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
000016  2104              MOVS     r1,#4
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       I2C_Enable_IRQ
;;;2869   
;;;2870       return HAL_OK;
00001e  2000              MOVS     r0,#0
                  |L7.32|
;;;2871     }
;;;2872     else
;;;2873     {
;;;2874       return HAL_BUSY;
;;;2875     }
;;;2876   }
000020  bd10              POP      {r4,pc}
                  |L7.34|
000022  2002              MOVS     r0,#2                 ;2874
000024  e7fc              B        |L7.32|
;;;2877   
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      I2C_Slave_ISR_IT

                          AREA ||i.HAL_I2C_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ErrorCallback PROC
;;;3161     */
;;;3162   __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3163   {
;;;3164     /* Prevent unused argument(s) compilation warning */
;;;3165     UNUSED(hi2c);
;;;3166   
;;;3167     /* NOTE : This function should not be modified, when the callback is needed,
;;;3168               the HAL_I2C_ErrorCallback could be implemented in the user file
;;;3169      */
;;;3170   }
;;;3171   
                          ENDP


                          AREA ||i.HAL_I2C_GetError||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetError PROC
;;;3235   */
;;;3236   uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;3237   {
;;;3238     return hi2c->ErrorCode;
000002  6c48              LDR      r0,[r1,#0x44]
;;;3239   }
000004  4770              BX       lr
;;;3240   
                          ENDP


                          AREA ||i.HAL_I2C_GetMode||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetMode PROC
;;;3224     */
;;;3225   HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;3226   {
;;;3227     return hi2c->Mode;
000002  2042              MOVS     r0,#0x42
000004  5c40              LDRB     r0,[r0,r1]
;;;3228   }
000006  4770              BX       lr
;;;3229   
                          ENDP


                          AREA ||i.HAL_I2C_GetState||, CODE, READONLY, ALIGN=1

                  HAL_I2C_GetState PROC
;;;3212     */
;;;3213   HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
000000  4601              MOV      r1,r0
;;;3214   {
;;;3215     /* Return I2C handle state */
;;;3216     return hi2c->State;
000002  2041              MOVS     r0,#0x41
000004  5c40              LDRB     r0,[r0,r1]
;;;3217   }
000006  4770              BX       lr
;;;3218   
                          ENDP


                          AREA ||i.HAL_I2C_Init||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Init PROC
;;;403      */
;;;404    HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;405    {
000002  4604              MOV      r4,r0
;;;406      /* Check the I2C handle allocation */
;;;407      if(hi2c == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L12.12|
;;;408      {
;;;409        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L12.10|
;;;410      }
;;;411    
;;;412      /* Check the parameters */
;;;413      assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;414      assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
;;;415      assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
;;;416      assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
;;;417      assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
;;;418      assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
;;;419      assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
;;;420      assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
;;;421    
;;;422      if(hi2c->State == HAL_I2C_STATE_RESET)
;;;423      {
;;;424        /* Allocate lock resource and initialize it */
;;;425        hi2c->Lock = HAL_UNLOCKED;
;;;426    
;;;427        /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
;;;428        HAL_I2C_MspInit(hi2c);
;;;429      }
;;;430    
;;;431      hi2c->State = HAL_I2C_STATE_BUSY;
;;;432    
;;;433      /* Disable the selected I2C peripheral */
;;;434      __HAL_I2C_DISABLE(hi2c);
;;;435    
;;;436      /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
;;;437      /* Configure I2Cx: Frequency range */
;;;438      hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
;;;439    
;;;440      /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
;;;441      /* Disable Own Address1 before set the Own Address1 configuration */
;;;442      hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
;;;443    
;;;444      /* Configure I2Cx: Own Address1 and ack own address1 mode */
;;;445      if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
;;;446      {
;;;447        hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
;;;448      }
;;;449      else /* I2C_ADDRESSINGMODE_10BIT */
;;;450      {
;;;451        hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
;;;452      }
;;;453    
;;;454      /*---------------------------- I2Cx CR2 Configuration ----------------------*/
;;;455      /* Configure I2Cx: Addressing Master mode */
;;;456      if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
;;;457      {
;;;458        hi2c->Instance->CR2 = (I2C_CR2_ADD10);
;;;459      }
;;;460      /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
;;;461      hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
;;;462    
;;;463      /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
;;;464      /* Disable Own Address2 before set the Own Address2 configuration */
;;;465      hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
;;;466    
;;;467      /* Configure I2Cx: Dual mode and Own Address2 */
;;;468      hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
;;;469    
;;;470      /*---------------------------- I2Cx CR1 Configuration ----------------------*/
;;;471      /* Configure I2Cx: Generalcall and NoStretch mode */
;;;472      hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
;;;473    
;;;474      /* Enable the selected I2C peripheral */
;;;475      __HAL_I2C_ENABLE(hi2c);
;;;476    
;;;477      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;478      hi2c->State = HAL_I2C_STATE_READY;
;;;479      hi2c->PreviousState = I2C_STATE_NONE;
;;;480      hi2c->Mode = HAL_I2C_MODE_NONE;
;;;481    
;;;482      return HAL_OK;
;;;483    }
00000a  bd10              POP      {r4,pc}
                  |L12.12|
00000c  2041              MOVS     r0,#0x41              ;422
00000e  5d00              LDRB     r0,[r0,r4]            ;422
000010  2800              CMP      r0,#0                 ;422
000012  d105              BNE      |L12.32|
000014  2100              MOVS     r1,#0                 ;425
000016  2040              MOVS     r0,#0x40              ;425
000018  5501              STRB     r1,[r0,r4]            ;425
00001a  4620              MOV      r0,r4                 ;428
00001c  f7fffffe          BL       HAL_I2C_MspInit
                  |L12.32|
000020  2124              MOVS     r1,#0x24              ;431
000022  2041              MOVS     r0,#0x41              ;431
000024  5501              STRB     r1,[r0,r4]            ;431
000026  6820              LDR      r0,[r4,#0]            ;434
000028  6800              LDR      r0,[r0,#0]            ;434
00002a  0840              LSRS     r0,r0,#1              ;434
00002c  0040              LSLS     r0,r0,#1              ;434
00002e  6821              LDR      r1,[r4,#0]            ;434
000030  6008              STR      r0,[r1,#0]            ;434
000032  210f              MOVS     r1,#0xf               ;438
000034  0609              LSLS     r1,r1,#24             ;438
000036  6860              LDR      r0,[r4,#4]            ;438
000038  4388              BICS     r0,r0,r1              ;438
00003a  6821              LDR      r1,[r4,#0]            ;438
00003c  6108              STR      r0,[r1,#0x10]         ;438
00003e  6820              LDR      r0,[r4,#0]            ;442
000040  6880              LDR      r0,[r0,#8]            ;442
000042  2101              MOVS     r1,#1                 ;442
000044  03c9              LSLS     r1,r1,#15             ;442
000046  4388              BICS     r0,r0,r1              ;442
000048  6821              LDR      r1,[r4,#0]            ;442
00004a  6088              STR      r0,[r1,#8]            ;442
00004c  68e0              LDR      r0,[r4,#0xc]          ;445
00004e  2801              CMP      r0,#1                 ;445
000050  d106              BNE      |L12.96|
000052  2101              MOVS     r1,#1                 ;447
000054  03c9              LSLS     r1,r1,#15             ;447
000056  68a0              LDR      r0,[r4,#8]            ;447
000058  4308              ORRS     r0,r0,r1              ;447
00005a  6821              LDR      r1,[r4,#0]            ;447
00005c  6088              STR      r0,[r1,#8]            ;447
00005e  e005              B        |L12.108|
                  |L12.96|
000060  2121              MOVS     r1,#0x21              ;451
000062  0289              LSLS     r1,r1,#10             ;451
000064  68a0              LDR      r0,[r4,#8]            ;451
000066  4308              ORRS     r0,r0,r1              ;451
000068  6821              LDR      r1,[r4,#0]            ;451
00006a  6088              STR      r0,[r1,#8]            ;451
                  |L12.108|
00006c  68e0              LDR      r0,[r4,#0xc]          ;456
00006e  2802              CMP      r0,#2                 ;456
000070  d102              BNE      |L12.120|
000072  0280              LSLS     r0,r0,#10             ;458
000074  6821              LDR      r1,[r4,#0]            ;458
000076  6048              STR      r0,[r1,#4]            ;458
                  |L12.120|
000078  6820              LDR      r0,[r4,#0]            ;461
00007a  6840              LDR      r0,[r0,#4]            ;461
00007c  4914              LDR      r1,|L12.208|
00007e  4308              ORRS     r0,r0,r1              ;461
000080  6821              LDR      r1,[r4,#0]            ;461
000082  6048              STR      r0,[r1,#4]            ;461
000084  6820              LDR      r0,[r4,#0]            ;465
000086  68c0              LDR      r0,[r0,#0xc]          ;465
000088  2101              MOVS     r1,#1                 ;465
00008a  03c9              LSLS     r1,r1,#15             ;465
00008c  4388              BICS     r0,r0,r1              ;465
00008e  6821              LDR      r1,[r4,#0]            ;465
000090  60c8              STR      r0,[r1,#0xc]          ;465
000092  6961              LDR      r1,[r4,#0x14]         ;468
000094  6920              LDR      r0,[r4,#0x10]         ;468
000096  4308              ORRS     r0,r0,r1              ;468
000098  69a1              LDR      r1,[r4,#0x18]         ;468
00009a  0209              LSLS     r1,r1,#8              ;468
00009c  4308              ORRS     r0,r0,r1              ;468
00009e  6821              LDR      r1,[r4,#0]            ;468
0000a0  60c8              STR      r0,[r1,#0xc]          ;468
0000a2  6a21              LDR      r1,[r4,#0x20]         ;472
0000a4  69e0              LDR      r0,[r4,#0x1c]         ;472
0000a6  4308              ORRS     r0,r0,r1              ;472
0000a8  6821              LDR      r1,[r4,#0]            ;472
0000aa  6008              STR      r0,[r1,#0]            ;472
0000ac  6820              LDR      r0,[r4,#0]            ;475
0000ae  6800              LDR      r0,[r0,#0]            ;475
0000b0  2101              MOVS     r1,#1                 ;475
0000b2  4308              ORRS     r0,r0,r1              ;475
0000b4  6821              LDR      r1,[r4,#0]            ;475
0000b6  6008              STR      r0,[r1,#0]            ;475
0000b8  2000              MOVS     r0,#0                 ;477
0000ba  6460              STR      r0,[r4,#0x44]         ;477
0000bc  2120              MOVS     r1,#0x20              ;478
0000be  2041              MOVS     r0,#0x41              ;478
0000c0  5501              STRB     r1,[r0,r4]            ;478
0000c2  2000              MOVS     r0,#0                 ;479
0000c4  6320              STR      r0,[r4,#0x30]         ;479
0000c6  2100              MOVS     r1,#0                 ;480
0000c8  2042              MOVS     r0,#0x42              ;480
0000ca  5501              STRB     r1,[r0,r4]            ;480
0000cc  2000              MOVS     r0,#0                 ;482
0000ce  e79c              B        |L12.10|
;;;484    
                          ENDP

                  |L12.208|
                          DCD      0x02008000

                          AREA ||i.HAL_I2C_IsDeviceReady||, CODE, READONLY, ALIGN=1

                  HAL_I2C_IsDeviceReady PROC
;;;2452     */
;;;2453   HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;2454   {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  461d              MOV      r5,r3
;;;2455     uint32_t tickstart = 0U;
00000a  2600              MOVS     r6,#0
;;;2456   
;;;2457     __IO uint32_t I2C_Trials = 0U;
00000c  2000              MOVS     r0,#0
00000e  9002              STR      r0,[sp,#8]
;;;2458   
;;;2459     if(hi2c->State == HAL_I2C_STATE_READY)
000010  2041              MOVS     r0,#0x41
000012  5d00              LDRB     r0,[r0,r4]
000014  2820              CMP      r0,#0x20
000016  d16f              BNE      |L13.248|
;;;2460     {
;;;2461       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
000018  6820              LDR      r0,[r4,#0]
00001a  6980              LDR      r0,[r0,#0x18]
00001c  2101              MOVS     r1,#1
00001e  03c9              LSLS     r1,r1,#15
000020  4008              ANDS     r0,r0,r1
000022  0bc0              LSRS     r0,r0,#15
000024  2800              CMP      r0,#0
000026  d002              BEQ      |L13.46|
;;;2462       {
;;;2463         return HAL_BUSY;
000028  2002              MOVS     r0,#2
                  |L13.42|
;;;2464       }
;;;2465   
;;;2466       /* Process Locked */
;;;2467       __HAL_LOCK(hi2c);
;;;2468   
;;;2469       hi2c->State = HAL_I2C_STATE_BUSY;
;;;2470       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2471   
;;;2472       do
;;;2473       {
;;;2474         /* Generate Start */
;;;2475         hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode,DevAddress);
;;;2476   
;;;2477         /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
;;;2478         /* Wait until STOPF flag is set or a NACK flag is set*/
;;;2479         tickstart = HAL_GetTick();
;;;2480         while((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET) && (hi2c->State != HAL_I2C_STATE_TIMEOUT))
;;;2481         {
;;;2482         	if(Timeout != HAL_MAX_DELAY)
;;;2483         	{
;;;2484             if((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
;;;2485             {
;;;2486               /* Device is ready */
;;;2487               hi2c->State = HAL_I2C_STATE_READY;
;;;2488               /* Process Unlocked */
;;;2489               __HAL_UNLOCK(hi2c);
;;;2490               return HAL_TIMEOUT;
;;;2491             }
;;;2492           } 
;;;2493         }
;;;2494   
;;;2495         /* Check if the NACKF flag has not been set */
;;;2496         if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
;;;2497         {
;;;2498           /* Wait until STOPF flag is reset */ 
;;;2499           if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
;;;2500           {
;;;2501             return HAL_TIMEOUT;
;;;2502           }
;;;2503   
;;;2504           /* Clear STOP Flag */
;;;2505           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;2506   
;;;2507           /* Device is ready */
;;;2508           hi2c->State = HAL_I2C_STATE_READY;
;;;2509   
;;;2510           /* Process Unlocked */
;;;2511           __HAL_UNLOCK(hi2c);
;;;2512   
;;;2513           return HAL_OK;
;;;2514         }
;;;2515         else
;;;2516         {
;;;2517           /* Wait until STOPF flag is reset */
;;;2518           if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
;;;2519           {
;;;2520             return HAL_TIMEOUT;
;;;2521           }
;;;2522   
;;;2523           /* Clear NACK Flag */
;;;2524           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;2525   
;;;2526           /* Clear STOP Flag, auto generated with autoend*/
;;;2527           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;2528         }
;;;2529   
;;;2530         /* Check if the maximum allowed number of trials has been reached */
;;;2531         if (I2C_Trials++ == Trials)
;;;2532         {
;;;2533           /* Generate Stop */
;;;2534           hi2c->Instance->CR2 |= I2C_CR2_STOP;
;;;2535   
;;;2536           /* Wait until STOPF flag is reset */ 
;;;2537           if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
;;;2538           {
;;;2539             return HAL_TIMEOUT;
;;;2540           }
;;;2541   
;;;2542           /* Clear STOP Flag */
;;;2543           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;2544         }
;;;2545       }while(I2C_Trials < Trials);
;;;2546   
;;;2547       hi2c->State = HAL_I2C_STATE_READY;
;;;2548   
;;;2549       /* Process Unlocked */
;;;2550       __HAL_UNLOCK(hi2c);
;;;2551   
;;;2552       return HAL_TIMEOUT;
;;;2553     }
;;;2554     else
;;;2555     {
;;;2556       return HAL_BUSY;
;;;2557     }
;;;2558   }
00002a  b007              ADD      sp,sp,#0x1c
00002c  bdf0              POP      {r4-r7,pc}
                  |L13.46|
00002e  bf00              NOP                            ;2467
000030  2040              MOVS     r0,#0x40              ;2467
000032  5d00              LDRB     r0,[r0,r4]            ;2467
000034  2801              CMP      r0,#1                 ;2467
000036  d101              BNE      |L13.60|
000038  2002              MOVS     r0,#2                 ;2467
00003a  e7f6              B        |L13.42|
                  |L13.60|
00003c  2101              MOVS     r1,#1                 ;2467
00003e  2040              MOVS     r0,#0x40              ;2467
000040  5501              STRB     r1,[r0,r4]            ;2467
000042  bf00              NOP                            ;2467
000044  2124              MOVS     r1,#0x24              ;2469
000046  2041              MOVS     r0,#0x41              ;2469
000048  5501              STRB     r1,[r0,r4]            ;2469
00004a  2000              MOVS     r0,#0                 ;2470
00004c  6460              STR      r0,[r4,#0x44]         ;2470
00004e  bf00              NOP                            ;2472
                  |L13.80|
000050  68e0              LDR      r0,[r4,#0xc]          ;2475
000052  2801              CMP      r0,#1                 ;2475
000054  d109              BNE      |L13.106|
000056  05b8              LSLS     r0,r7,#22             ;2475
000058  0d80              LSRS     r0,r0,#22             ;2475
00005a  2101              MOVS     r1,#1                 ;2475
00005c  0349              LSLS     r1,r1,#13             ;2475
00005e  1840              ADDS     r0,r0,r1              ;2475
000060  0309              LSLS     r1,r1,#12             ;2475
000062  1840              ADDS     r0,r0,r1              ;2475
000064  13c9              ASRS     r1,r1,#15             ;2475
000066  4388              BICS     r0,r0,r1              ;2475
000068  e008              B        |L13.124|
                  |L13.106|
00006a  05b8              LSLS     r0,r7,#22             ;2475
00006c  0d80              LSRS     r0,r0,#22             ;2475
00006e  2101              MOVS     r1,#1                 ;2475
000070  02c9              LSLS     r1,r1,#11             ;2475
000072  1840              ADDS     r0,r0,r1              ;2475
000074  0089              LSLS     r1,r1,#2              ;2475
000076  1840              ADDS     r0,r0,r1              ;2475
000078  10c9              ASRS     r1,r1,#3              ;2475
00007a  4388              BICS     r0,r0,r1              ;2475
                  |L13.124|
00007c  6821              LDR      r1,[r4,#0]            ;2475
00007e  6048              STR      r0,[r1,#4]            ;2475
000080  f7fffffe          BL       HAL_GetTick
000084  4606              MOV      r6,r0                 ;2479
000086  e013              B        |L13.176|
                  |L13.136|
000088  1c68              ADDS     r0,r5,#1              ;2482
00008a  2800              CMP      r0,#0                 ;2482
00008c  d010              BEQ      |L13.176|
00008e  2d00              CMP      r5,#0                 ;2484
000090  d004              BEQ      |L13.156|
000092  f7fffffe          BL       HAL_GetTick
000096  1b80              SUBS     r0,r0,r6              ;2484
000098  42a8              CMP      r0,r5                 ;2484
00009a  d909              BLS      |L13.176|
                  |L13.156|
00009c  2120              MOVS     r1,#0x20              ;2487
00009e  2041              MOVS     r0,#0x41              ;2487
0000a0  5501              STRB     r1,[r0,r4]            ;2487
0000a2  bf00              NOP                            ;2489
0000a4  2100              MOVS     r1,#0                 ;2489
0000a6  2040              MOVS     r0,#0x40              ;2489
0000a8  5501              STRB     r1,[r0,r4]            ;2489
0000aa  bf00              NOP                            ;2489
0000ac  2003              MOVS     r0,#3                 ;2490
0000ae  e7bc              B        |L13.42|
                  |L13.176|
0000b0  6820              LDR      r0,[r4,#0]            ;2480
0000b2  6980              LDR      r0,[r0,#0x18]         ;2480
0000b4  2120              MOVS     r1,#0x20              ;2480
0000b6  4008              ANDS     r0,r0,r1              ;2480
0000b8  0940              LSRS     r0,r0,#5              ;2480
0000ba  2800              CMP      r0,#0                 ;2480
0000bc  d10a              BNE      |L13.212|
0000be  6820              LDR      r0,[r4,#0]            ;2480
0000c0  6980              LDR      r0,[r0,#0x18]         ;2480
0000c2  2110              MOVS     r1,#0x10              ;2480
0000c4  4008              ANDS     r0,r0,r1              ;2480
0000c6  0900              LSRS     r0,r0,#4              ;2480
0000c8  2800              CMP      r0,#0                 ;2480
0000ca  d103              BNE      |L13.212|
0000cc  2041              MOVS     r0,#0x41              ;2480
0000ce  5d00              LDRB     r0,[r0,r4]            ;2480
0000d0  28a0              CMP      r0,#0xa0              ;2480
0000d2  d1d9              BNE      |L13.136|
                  |L13.212|
0000d4  6820              LDR      r0,[r4,#0]            ;2496
0000d6  6980              LDR      r0,[r0,#0x18]         ;2496
0000d8  2110              MOVS     r1,#0x10              ;2496
0000da  4008              ANDS     r0,r0,r1              ;2496
0000dc  0900              LSRS     r0,r0,#4              ;2496
0000de  2800              CMP      r0,#0                 ;2496
0000e0  d118              BNE      |L13.276|
0000e2  462b              MOV      r3,r5                 ;2499
0000e4  2200              MOVS     r2,#0                 ;2499
0000e6  2120              MOVS     r1,#0x20              ;2499
0000e8  4620              MOV      r0,r4                 ;2499
0000ea  9600              STR      r6,[sp,#0]            ;2499
0000ec  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000f0  2800              CMP      r0,#0                 ;2499
0000f2  d002              BEQ      |L13.250|
0000f4  2003              MOVS     r0,#3                 ;2501
0000f6  e798              B        |L13.42|
                  |L13.248|
0000f8  e047              B        |L13.394|
                  |L13.250|
0000fa  2020              MOVS     r0,#0x20              ;2505
0000fc  6821              LDR      r1,[r4,#0]            ;2505
0000fe  61c8              STR      r0,[r1,#0x1c]         ;2505
000100  2120              MOVS     r1,#0x20              ;2508
000102  2041              MOVS     r0,#0x41              ;2508
000104  5501              STRB     r1,[r0,r4]            ;2508
000106  bf00              NOP                            ;2511
000108  2100              MOVS     r1,#0                 ;2511
00010a  2040              MOVS     r0,#0x40              ;2511
00010c  5501              STRB     r1,[r0,r4]            ;2511
00010e  bf00              NOP                            ;2511
000110  2000              MOVS     r0,#0                 ;2513
000112  e78a              B        |L13.42|
                  |L13.276|
000114  462b              MOV      r3,r5                 ;2518
000116  2200              MOVS     r2,#0                 ;2518
000118  2120              MOVS     r1,#0x20              ;2518
00011a  4620              MOV      r0,r4                 ;2518
00011c  9600              STR      r6,[sp,#0]            ;2518
00011e  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000122  2800              CMP      r0,#0                 ;2518
000124  d001              BEQ      |L13.298|
000126  2003              MOVS     r0,#3                 ;2520
000128  e77f              B        |L13.42|
                  |L13.298|
00012a  2010              MOVS     r0,#0x10              ;2524
00012c  6821              LDR      r1,[r4,#0]            ;2524
00012e  61c8              STR      r0,[r1,#0x1c]         ;2524
000130  2020              MOVS     r0,#0x20              ;2527
000132  6821              LDR      r1,[r4,#0]            ;2527
000134  61c8              STR      r0,[r1,#0x1c]         ;2527
000136  9802              LDR      r0,[sp,#8]            ;2531
000138  1c41              ADDS     r1,r0,#1              ;2531
00013a  9102              STR      r1,[sp,#8]            ;2531
00013c  9905              LDR      r1,[sp,#0x14]         ;2531
00013e  4288              CMP      r0,r1                 ;2531
000140  d114              BNE      |L13.364|
000142  6820              LDR      r0,[r4,#0]            ;2534
000144  6840              LDR      r0,[r0,#4]            ;2534
000146  2101              MOVS     r1,#1                 ;2534
000148  0389              LSLS     r1,r1,#14             ;2534
00014a  4308              ORRS     r0,r0,r1              ;2534
00014c  6821              LDR      r1,[r4,#0]            ;2534
00014e  6048              STR      r0,[r1,#4]            ;2534
000150  462b              MOV      r3,r5                 ;2537
000152  2200              MOVS     r2,#0                 ;2537
000154  2120              MOVS     r1,#0x20              ;2537
000156  4620              MOV      r0,r4                 ;2537
000158  9600              STR      r6,[sp,#0]            ;2537
00015a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00015e  2800              CMP      r0,#0                 ;2537
000160  d001              BEQ      |L13.358|
000162  2003              MOVS     r0,#3                 ;2539
000164  e761              B        |L13.42|
                  |L13.358|
000166  2020              MOVS     r0,#0x20              ;2543
000168  6821              LDR      r1,[r4,#0]            ;2543
00016a  61c8              STR      r0,[r1,#0x1c]         ;2543
                  |L13.364|
00016c  9902              LDR      r1,[sp,#8]            ;2545
00016e  9805              LDR      r0,[sp,#0x14]         ;2545
000170  4281              CMP      r1,r0                 ;2545
000172  d200              BCS      |L13.374|
000174  e76c              B        |L13.80|
                  |L13.374|
000176  2120              MOVS     r1,#0x20              ;2547
000178  2041              MOVS     r0,#0x41              ;2547
00017a  5501              STRB     r1,[r0,r4]            ;2547
00017c  bf00              NOP                            ;2550
00017e  2100              MOVS     r1,#0                 ;2550
000180  2040              MOVS     r0,#0x40              ;2550
000182  5501              STRB     r1,[r0,r4]            ;2550
000184  bf00              NOP                            ;2550
000186  2003              MOVS     r0,#3                 ;2552
000188  e74f              B        |L13.42|
                  |L13.394|
00018a  2002              MOVS     r0,#2                 ;2556
00018c  e74d              B        |L13.42|
;;;2559   
                          ENDP


                          AREA ||i.HAL_I2C_ListenCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_ListenCpltCallback PROC
;;;3113     */
;;;3114   __weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3115   {
;;;3116     /* Prevent unused argument(s) compilation warning */
;;;3117     UNUSED(hi2c);
;;;3118   
;;;3119     /* NOTE : This function should not be modified, when the callback is needed,
;;;3120               the HAL_I2C_ListenCpltCallback() could be implemented in the user file
;;;3121      */
;;;3122   }
;;;3123   
                          ENDP


                          AREA ||i.HAL_I2C_MasterRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterRxCpltCallback PROC
;;;3046     */
;;;3047   __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3048   {
;;;3049     /* Prevent unused argument(s) compilation warning */
;;;3050     UNUSED(hi2c);
;;;3051   
;;;3052     /* NOTE : This function should not be modified, when the callback is needed,
;;;3053               the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
;;;3054      */
;;;3055   }
;;;3056   
                          ENDP


                          AREA ||i.HAL_I2C_MasterTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MasterTxCpltCallback PROC
;;;3030     */
;;;3031   __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3032   {
;;;3033     /* Prevent unused argument(s) compilation warning */
;;;3034     UNUSED(hi2c);
;;;3035   
;;;3036     /* NOTE : This function should not be modified, when the callback is needed,
;;;3037               the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
;;;3038      */
;;;3039   }
;;;3040   
                          ENDP


                          AREA ||i.HAL_I2C_Master_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Master_Abort_IT PROC
;;;2916     */
;;;2917   HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
000000  b538              PUSH     {r3-r5,lr}
;;;2918   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2919     if(hi2c->Mode == HAL_I2C_MODE_MASTER)
000006  2042              MOVS     r0,#0x42
000008  5d00              LDRB     r0,[r0,r4]
00000a  2810              CMP      r0,#0x10
00000c  d129              BNE      |L17.98|
;;;2920     {
;;;2921       /* Process Locked */
;;;2922       __HAL_LOCK(hi2c);
00000e  bf00              NOP      
000010  2040              MOVS     r0,#0x40
000012  5d00              LDRB     r0,[r0,r4]
000014  2801              CMP      r0,#1
000016  d101              BNE      |L17.28|
000018  2002              MOVS     r0,#2
                  |L17.26|
;;;2923   
;;;2924       /* Disable Interrupts */
;;;2925       I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
;;;2926       I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;2927   
;;;2928       /* Set State at HAL_I2C_STATE_ABORT */
;;;2929       hi2c->State = HAL_I2C_STATE_ABORT;
;;;2930   
;;;2931       /* Set NBYTES to 1 to generate a dummy read on I2C peripheral */
;;;2932       /* Set AUTOEND mode, this will generate a NACK then STOP condition to abort the current transfer */
;;;2933       I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);
;;;2934   
;;;2935       /* Process Unlocked */
;;;2936       __HAL_UNLOCK(hi2c);
;;;2937   
;;;2938       /* Note : The I2C interrupts must be enabled after unlocking current process 
;;;2939                 to avoid the risk of I2C interrupt handle execution before current
;;;2940                 process unlock */
;;;2941       I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
;;;2942   
;;;2943       return HAL_OK;
;;;2944     }
;;;2945     else
;;;2946     {
;;;2947       /* Wrong usage of abort function */
;;;2948       /* This function should be used only in case of abort monitored by master device */
;;;2949       return HAL_ERROR;
;;;2950     }
;;;2951   }
00001a  bd38              POP      {r3-r5,pc}
                  |L17.28|
00001c  2101              MOVS     r1,#1                 ;2922
00001e  2040              MOVS     r0,#0x40              ;2922
000020  5501              STRB     r1,[r0,r4]            ;2922
000022  bf00              NOP                            ;2922
000024  2102              MOVS     r1,#2                 ;2925
000026  4620              MOV      r0,r4                 ;2925
000028  f7fffffe          BL       I2C_Disable_IRQ
00002c  2101              MOVS     r1,#1                 ;2926
00002e  4620              MOV      r0,r4                 ;2926
000030  f7fffffe          BL       I2C_Disable_IRQ
000034  2160              MOVS     r1,#0x60              ;2929
000036  2041              MOVS     r0,#0x41              ;2929
000038  5501              STRB     r1,[r0,r4]            ;2929
00003a  2001              MOVS     r0,#1                 ;2933
00003c  0380              LSLS     r0,r0,#14             ;2933
00003e  02c3              LSLS     r3,r0,#11             ;2933
000040  2201              MOVS     r2,#1                 ;2933
000042  4629              MOV      r1,r5                 ;2933
000044  9000              STR      r0,[sp,#0]            ;2933
000046  4620              MOV      r0,r4                 ;2933
000048  f7fffffe          BL       I2C_TransferConfig
00004c  bf00              NOP                            ;2936
00004e  2100              MOVS     r1,#0                 ;2936
000050  2040              MOVS     r0,#0x40              ;2936
000052  5501              STRB     r1,[r0,r4]            ;2936
000054  bf00              NOP                            ;2936
000056  2112              MOVS     r1,#0x12              ;2941
000058  4620              MOV      r0,r4                 ;2941
00005a  f7fffffe          BL       I2C_Enable_IRQ
00005e  2000              MOVS     r0,#0                 ;2943
000060  e7db              B        |L17.26|
                  |L17.98|
000062  2001              MOVS     r0,#1                 ;2949
000064  e7d9              B        |L17.26|
;;;2952   
                          ENDP


                          AREA ||i.HAL_I2C_Master_Receive||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive PROC
;;;750      */
;;;751    HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;752    {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;753      uint32_t tickstart = 0U;
00000a  2500              MOVS     r5,#0
;;;754    
;;;755      if(hi2c->State == HAL_I2C_STATE_READY)
00000c  2041              MOVS     r0,#0x41
00000e  5d00              LDRB     r0,[r0,r4]
000010  2820              CMP      r0,#0x20
000012  d16e              BNE      |L18.242|
;;;756      {
;;;757        /* Process Locked */
;;;758        __HAL_LOCK(hi2c);
000014  bf00              NOP      
000016  2040              MOVS     r0,#0x40
000018  5d00              LDRB     r0,[r0,r4]
00001a  2801              CMP      r0,#1
00001c  d102              BNE      |L18.36|
00001e  2002              MOVS     r0,#2
                  |L18.32|
;;;759    
;;;760        /* Init tickstart for timeout management*/
;;;761        tickstart = HAL_GetTick();
;;;762    
;;;763        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
;;;764        {
;;;765          return HAL_TIMEOUT;
;;;766        }
;;;767    
;;;768        hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;769        hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;770        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;771    
;;;772        /* Prepare transfer parameters */
;;;773        hi2c->pBuffPtr  = pData;
;;;774        hi2c->XferCount = Size;
;;;775        hi2c->XferISR   = NULL;
;;;776    
;;;777        /* Send Slave Address */
;;;778        /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;779        if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;780        {
;;;781          hi2c->XferSize = MAX_NBYTE_SIZE;
;;;782          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
;;;783        }
;;;784        else
;;;785        {
;;;786          hi2c->XferSize = hi2c->XferCount;
;;;787          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
;;;788        }
;;;789    
;;;790        while(hi2c->XferCount > 0U)
;;;791        {
;;;792          /* Wait until RXNE flag is set */
;;;793          if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;794          {
;;;795            if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;796            {
;;;797              return HAL_ERROR;
;;;798            }
;;;799            else
;;;800            {
;;;801              return HAL_TIMEOUT;
;;;802            }
;;;803          }
;;;804    
;;;805          /* Read data from RXDR */
;;;806          (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
;;;807          hi2c->XferSize--;
;;;808          hi2c->XferCount--;
;;;809    
;;;810          if((hi2c->XferSize == 0U) && (hi2c->XferCount != 0U))
;;;811          {
;;;812            /* Wait until TCR flag is set */
;;;813            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
;;;814            {
;;;815              return HAL_TIMEOUT;
;;;816            }
;;;817    
;;;818            if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;819            {
;;;820              hi2c->XferSize = MAX_NBYTE_SIZE;
;;;821              I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
;;;822            }
;;;823            else
;;;824            {
;;;825              hi2c->XferSize = hi2c->XferCount;
;;;826              I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
;;;827            }
;;;828          }
;;;829        }
;;;830    
;;;831        /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
;;;832        /* Wait until STOPF flag is set */
;;;833        if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;834        {
;;;835          if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;836          {
;;;837            return HAL_ERROR;
;;;838          }
;;;839          else
;;;840          {
;;;841            return HAL_TIMEOUT;
;;;842          }
;;;843        }
;;;844    
;;;845        /* Clear STOP Flag */
;;;846        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;847    
;;;848        /* Clear Configuration Register 2 */
;;;849        I2C_RESET_CR2(hi2c);
;;;850    
;;;851        hi2c->State = HAL_I2C_STATE_READY;
;;;852        hi2c->Mode  = HAL_I2C_MODE_NONE;
;;;853    
;;;854        /* Process Unlocked */
;;;855        __HAL_UNLOCK(hi2c);
;;;856    
;;;857        return HAL_OK;
;;;858      }
;;;859      else
;;;860      {
;;;861        return HAL_BUSY;
;;;862      }
;;;863    }
000020  b005              ADD      sp,sp,#0x14
000022  bdf0              POP      {r4-r7,pc}
                  |L18.36|
000024  2101              MOVS     r1,#1                 ;758
000026  2040              MOVS     r0,#0x40              ;758
000028  5501              STRB     r1,[r0,r4]            ;758
00002a  bf00              NOP                            ;758
00002c  f7fffffe          BL       HAL_GetTick
000030  4605              MOV      r5,r0                 ;761
000032  2319              MOVS     r3,#0x19              ;763
000034  2201              MOVS     r2,#1                 ;763
000036  03d1              LSLS     r1,r2,#15             ;763
000038  4620              MOV      r0,r4                 ;763
00003a  9500              STR      r5,[sp,#0]            ;763
00003c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000040  2800              CMP      r0,#0                 ;763
000042  d001              BEQ      |L18.72|
000044  2003              MOVS     r0,#3                 ;765
000046  e7eb              B        |L18.32|
                  |L18.72|
000048  2122              MOVS     r1,#0x22              ;768
00004a  2041              MOVS     r0,#0x41              ;768
00004c  5501              STRB     r1,[r0,r4]            ;768
00004e  2110              MOVS     r1,#0x10              ;769
000050  2042              MOVS     r0,#0x42              ;769
000052  5501              STRB     r1,[r0,r4]            ;769
000054  2000              MOVS     r0,#0                 ;770
000056  6460              STR      r0,[r4,#0x44]         ;770
000058  6266              STR      r6,[r4,#0x24]         ;773
00005a  8567              STRH     r7,[r4,#0x2a]         ;774
00005c  6360              STR      r0,[r4,#0x34]         ;775
00005e  8d60              LDRH     r0,[r4,#0x2a]         ;779
000060  28ff              CMP      r0,#0xff              ;779
000062  d90c              BLS      |L18.126|
000064  20ff              MOVS     r0,#0xff              ;781
000066  8520              STRH     r0,[r4,#0x28]         ;781
000068  2009              MOVS     r0,#9                 ;782
00006a  0280              LSLS     r0,r0,#10             ;782
00006c  9000              STR      r0,[sp,#0]            ;782
00006e  8d20              LDRH     r0,[r4,#0x28]         ;782
000070  b2c2              UXTB     r2,r0                 ;782
000072  050b              LSLS     r3,r1,#20             ;782
000074  4620              MOV      r0,r4                 ;782
000076  9902              LDR      r1,[sp,#8]            ;782
000078  f7fffffe          BL       I2C_TransferConfig
00007c  e00c              B        |L18.152|
                  |L18.126|
00007e  8d60              LDRH     r0,[r4,#0x2a]         ;786
000080  8520              STRH     r0,[r4,#0x28]         ;786
000082  2009              MOVS     r0,#9                 ;787
000084  0280              LSLS     r0,r0,#10             ;787
000086  9000              STR      r0,[sp,#0]            ;787
000088  8d20              LDRH     r0,[r4,#0x28]         ;787
00008a  b2c2              UXTB     r2,r0                 ;787
00008c  2301              MOVS     r3,#1                 ;787
00008e  065b              LSLS     r3,r3,#25             ;787
000090  4620              MOV      r0,r4                 ;787
000092  9902              LDR      r1,[sp,#8]            ;787
000094  f7fffffe          BL       I2C_TransferConfig
                  |L18.152|
000098  e048              B        |L18.300|
                  |L18.154|
00009a  462a              MOV      r2,r5                 ;793
00009c  4620              MOV      r0,r4                 ;793
00009e  990a              LDR      r1,[sp,#0x28]         ;793
0000a0  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
0000a4  2800              CMP      r0,#0                 ;793
0000a6  d006              BEQ      |L18.182|
0000a8  6c60              LDR      r0,[r4,#0x44]         ;795
0000aa  2804              CMP      r0,#4                 ;795
0000ac  d101              BNE      |L18.178|
0000ae  2001              MOVS     r0,#1                 ;797
0000b0  e7b6              B        |L18.32|
                  |L18.178|
0000b2  2003              MOVS     r0,#3                 ;801
0000b4  e7b4              B        |L18.32|
                  |L18.182|
0000b6  6820              LDR      r0,[r4,#0]            ;806
0000b8  6a40              LDR      r0,[r0,#0x24]         ;806
0000ba  b2c1              UXTB     r1,r0                 ;806
0000bc  6a62              LDR      r2,[r4,#0x24]         ;806
0000be  1c50              ADDS     r0,r2,#1              ;806
0000c0  6260              STR      r0,[r4,#0x24]         ;806
0000c2  7011              STRB     r1,[r2,#0]            ;806
0000c4  8d20              LDRH     r0,[r4,#0x28]         ;807
0000c6  1e40              SUBS     r0,r0,#1              ;807
0000c8  8520              STRH     r0,[r4,#0x28]         ;807
0000ca  8d60              LDRH     r0,[r4,#0x2a]         ;808
0000cc  1e40              SUBS     r0,r0,#1              ;808
0000ce  8560              STRH     r0,[r4,#0x2a]         ;808
0000d0  8d20              LDRH     r0,[r4,#0x28]         ;810
0000d2  2800              CMP      r0,#0                 ;810
0000d4  d12a              BNE      |L18.300|
0000d6  8d60              LDRH     r0,[r4,#0x2a]         ;810
0000d8  2800              CMP      r0,#0                 ;810
0000da  d027              BEQ      |L18.300|
0000dc  9500              STR      r5,[sp,#0]            ;813
0000de  2200              MOVS     r2,#0                 ;813
0000e0  2180              MOVS     r1,#0x80              ;813
0000e2  4620              MOV      r0,r4                 ;813
0000e4  9b0a              LDR      r3,[sp,#0x28]         ;813
0000e6  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000ea  2800              CMP      r0,#0                 ;813
0000ec  d002              BEQ      |L18.244|
0000ee  2003              MOVS     r0,#3                 ;815
0000f0  e796              B        |L18.32|
                  |L18.242|
0000f2  e041              B        |L18.376|
                  |L18.244|
0000f4  8d60              LDRH     r0,[r4,#0x2a]         ;818
0000f6  28ff              CMP      r0,#0xff              ;818
0000f8  d90c              BLS      |L18.276|
0000fa  20ff              MOVS     r0,#0xff              ;820
0000fc  8520              STRH     r0,[r4,#0x28]         ;820
0000fe  2000              MOVS     r0,#0                 ;821
000100  9000              STR      r0,[sp,#0]            ;821
000102  8d20              LDRH     r0,[r4,#0x28]         ;821
000104  b2c2              UXTB     r2,r0                 ;821
000106  2301              MOVS     r3,#1                 ;821
000108  061b              LSLS     r3,r3,#24             ;821
00010a  4620              MOV      r0,r4                 ;821
00010c  9902              LDR      r1,[sp,#8]            ;821
00010e  f7fffffe          BL       I2C_TransferConfig
000112  e00b              B        |L18.300|
                  |L18.276|
000114  8d60              LDRH     r0,[r4,#0x2a]         ;825
000116  8520              STRH     r0,[r4,#0x28]         ;825
000118  2000              MOVS     r0,#0                 ;826
00011a  9000              STR      r0,[sp,#0]            ;826
00011c  8d20              LDRH     r0,[r4,#0x28]         ;826
00011e  b2c2              UXTB     r2,r0                 ;826
000120  2301              MOVS     r3,#1                 ;826
000122  065b              LSLS     r3,r3,#25             ;826
000124  4620              MOV      r0,r4                 ;826
000126  9902              LDR      r1,[sp,#8]            ;826
000128  f7fffffe          BL       I2C_TransferConfig
                  |L18.300|
00012c  8d60              LDRH     r0,[r4,#0x2a]         ;790
00012e  2800              CMP      r0,#0                 ;790
000130  d1b3              BNE      |L18.154|
000132  462a              MOV      r2,r5                 ;833
000134  4620              MOV      r0,r4                 ;833
000136  990a              LDR      r1,[sp,#0x28]         ;833
000138  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
00013c  2800              CMP      r0,#0                 ;833
00013e  d006              BEQ      |L18.334|
000140  6c60              LDR      r0,[r4,#0x44]         ;835
000142  2804              CMP      r0,#4                 ;835
000144  d101              BNE      |L18.330|
000146  2001              MOVS     r0,#1                 ;837
000148  e76a              B        |L18.32|
                  |L18.330|
00014a  2003              MOVS     r0,#3                 ;841
00014c  e768              B        |L18.32|
                  |L18.334|
00014e  2020              MOVS     r0,#0x20              ;846
000150  6821              LDR      r1,[r4,#0]            ;846
000152  61c8              STR      r0,[r1,#0x1c]         ;846
000154  6820              LDR      r0,[r4,#0]            ;849
000156  6840              LDR      r0,[r0,#4]            ;849
000158  4908              LDR      r1,|L18.380|
00015a  4008              ANDS     r0,r0,r1              ;849
00015c  6821              LDR      r1,[r4,#0]            ;849
00015e  6048              STR      r0,[r1,#4]            ;849
000160  2120              MOVS     r1,#0x20              ;851
000162  2041              MOVS     r0,#0x41              ;851
000164  5501              STRB     r1,[r0,r4]            ;851
000166  2100              MOVS     r1,#0                 ;852
000168  2042              MOVS     r0,#0x42              ;852
00016a  5501              STRB     r1,[r0,r4]            ;852
00016c  bf00              NOP                            ;855
00016e  2040              MOVS     r0,#0x40              ;855
000170  5501              STRB     r1,[r0,r4]            ;855
000172  bf00              NOP                            ;855
000174  2000              MOVS     r0,#0                 ;857
000176  e753              B        |L18.32|
                  |L18.376|
000178  2002              MOVS     r0,#2                 ;861
00017a  e751              B        |L18.32|
;;;864    
                          ENDP

                  |L18.380|
                          DCD      0xfe00e800

                          AREA ||i.HAL_I2C_Master_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_DMA PROC
;;;1489     */
;;;1490   HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1491   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;1492     uint32_t xfermode = 0U;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;1493   
;;;1494     if(hi2c->State == HAL_I2C_STATE_READY)
00000e  2041              MOVS     r0,#0x41
000010  5d00              LDRB     r0,[r0,r4]
000012  2820              CMP      r0,#0x20
000014  d17d              BNE      |L19.274|
;;;1495     {
;;;1496       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
000016  6820              LDR      r0,[r4,#0]
000018  6980              LDR      r0,[r0,#0x18]
00001a  2101              MOVS     r1,#1
00001c  03c9              LSLS     r1,r1,#15
00001e  4008              ANDS     r0,r0,r1
000020  0bc0              LSRS     r0,r0,#15
000022  2800              CMP      r0,#0
000024  d001              BEQ      |L19.42|
;;;1497       {
;;;1498         return HAL_BUSY;
000026  2002              MOVS     r0,#2
                  |L19.40|
;;;1499       }
;;;1500   
;;;1501       /* Process Locked */
;;;1502       __HAL_LOCK(hi2c);
;;;1503   
;;;1504       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1505       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1506       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1507   
;;;1508       /* Prepare transfer parameters */
;;;1509       hi2c->pBuffPtr    = pData;
;;;1510       hi2c->XferCount   = Size;
;;;1511       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1512       hi2c->XferISR     = I2C_Master_ISR_DMA;
;;;1513       
;;;1514       if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1515       {
;;;1516         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1517         xfermode = I2C_RELOAD_MODE;
;;;1518       }
;;;1519       else
;;;1520       {
;;;1521         hi2c->XferSize = hi2c->XferCount;
;;;1522         xfermode = I2C_AUTOEND_MODE;
;;;1523       }
;;;1524   
;;;1525       if(hi2c->XferSize > 0U)
;;;1526       {
;;;1527         /* Set the I2C DMA transfer complete callback */
;;;1528         hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
;;;1529   
;;;1530         /* Set the DMA error callback */
;;;1531         hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;1532   
;;;1533         /* Set the unused DMA callbacks to NULL */
;;;1534         hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;1535         hi2c->hdmarx->XferAbortCallback = NULL;
;;;1536   
;;;1537         /* Enable the DMA channel */
;;;1538         HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
;;;1539   
;;;1540         /* Send Slave Address */
;;;1541         /* Set NBYTES to read and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;1542         I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
;;;1543   
;;;1544         /* Update XferCount value */
;;;1545         hi2c->XferCount -= hi2c->XferSize;
;;;1546   
;;;1547         /* Process Unlocked */
;;;1548         __HAL_UNLOCK(hi2c);
;;;1549   
;;;1550         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1551                   to avoid the risk of I2C interrupt handle execution before current
;;;1552                   process unlock */
;;;1553         /* Enable ERR and NACK interrupts */
;;;1554         I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
;;;1555   
;;;1556         /* Enable DMA Request */
;;;1557         hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
;;;1558       }
;;;1559       else
;;;1560       {
;;;1561         /* Update Transfer ISR function pointer */
;;;1562         hi2c->XferISR = I2C_Master_ISR_IT;
;;;1563         
;;;1564         /* Send Slave Address */
;;;1565         /* Set NBYTES to read and generate START condition */
;;;1566         I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
;;;1567   
;;;1568         /* Process Unlocked */
;;;1569         __HAL_UNLOCK(hi2c);
;;;1570   
;;;1571         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1572                   to avoid the risk of I2C interrupt handle execution before current
;;;1573                   process unlock */
;;;1574         /* Enable ERR, TC, STOP, NACK, TXI interrupt */
;;;1575         /* possible to enable all of these */
;;;1576         /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;1577         I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;1578       }
;;;1579       return HAL_OK;
;;;1580     }
;;;1581     else
;;;1582     {
;;;1583       return HAL_BUSY;
;;;1584     }
;;;1585   }
000028  bdfe              POP      {r1-r7,pc}
                  |L19.42|
00002a  bf00              NOP                            ;1502
00002c  2040              MOVS     r0,#0x40              ;1502
00002e  5d00              LDRB     r0,[r0,r4]            ;1502
000030  2801              CMP      r0,#1                 ;1502
000032  d101              BNE      |L19.56|
000034  2002              MOVS     r0,#2                 ;1502
000036  e7f7              B        |L19.40|
                  |L19.56|
000038  2101              MOVS     r1,#1                 ;1502
00003a  2040              MOVS     r0,#0x40              ;1502
00003c  5501              STRB     r1,[r0,r4]            ;1502
00003e  bf00              NOP                            ;1502
000040  2122              MOVS     r1,#0x22              ;1504
000042  2041              MOVS     r0,#0x41              ;1504
000044  5501              STRB     r1,[r0,r4]            ;1504
000046  2110              MOVS     r1,#0x10              ;1505
000048  2042              MOVS     r0,#0x42              ;1505
00004a  5501              STRB     r1,[r0,r4]            ;1505
00004c  2000              MOVS     r0,#0                 ;1506
00004e  6460              STR      r0,[r4,#0x44]         ;1506
000050  6265              STR      r5,[r4,#0x24]         ;1509
000052  8566              STRH     r6,[r4,#0x2a]         ;1510
000054  4830              LDR      r0,|L19.280|
000056  62e0              STR      r0,[r4,#0x2c]         ;1511
000058  4830              LDR      r0,|L19.284|
00005a  6360              STR      r0,[r4,#0x34]         ;1512
00005c  8d60              LDRH     r0,[r4,#0x2a]         ;1514
00005e  28ff              CMP      r0,#0xff              ;1514
000060  d904              BLS      |L19.108|
000062  20ff              MOVS     r0,#0xff              ;1516
000064  8520              STRH     r0,[r4,#0x28]         ;1516
000066  0508              LSLS     r0,r1,#20             ;1517
000068  9001              STR      r0,[sp,#4]            ;1517
00006a  e004              B        |L19.118|
                  |L19.108|
00006c  8d60              LDRH     r0,[r4,#0x2a]         ;1521
00006e  8520              STRH     r0,[r4,#0x28]         ;1521
000070  2001              MOVS     r0,#1                 ;1522
000072  0640              LSLS     r0,r0,#25             ;1522
000074  9001              STR      r0,[sp,#4]            ;1522
                  |L19.118|
000076  8d20              LDRH     r0,[r4,#0x28]         ;1525
000078  2800              CMP      r0,#0                 ;1525
00007a  d031              BEQ      |L19.224|
00007c  4828              LDR      r0,|L19.288|
00007e  6be1              LDR      r1,[r4,#0x3c]         ;1528
000080  6288              STR      r0,[r1,#0x28]         ;1528
000082  4828              LDR      r0,|L19.292|
000084  6be1              LDR      r1,[r4,#0x3c]         ;1531
000086  6308              STR      r0,[r1,#0x30]         ;1531
000088  2000              MOVS     r0,#0                 ;1534
00008a  6be1              LDR      r1,[r4,#0x3c]         ;1534
00008c  62c8              STR      r0,[r1,#0x2c]         ;1534
00008e  6be1              LDR      r1,[r4,#0x3c]         ;1535
000090  6348              STR      r0,[r1,#0x34]         ;1535
000092  8d23              LDRH     r3,[r4,#0x28]         ;1538
000094  6822              LDR      r2,[r4,#0]            ;1538
000096  4611              MOV      r1,r2                 ;1538
000098  3124              ADDS     r1,r1,#0x24           ;1538
00009a  462a              MOV      r2,r5                 ;1538
00009c  6be0              LDR      r0,[r4,#0x3c]         ;1538
00009e  f7fffffe          BL       HAL_DMA_Start_IT
0000a2  2009              MOVS     r0,#9                 ;1542
0000a4  0280              LSLS     r0,r0,#10             ;1542
0000a6  9000              STR      r0,[sp,#0]            ;1542
0000a8  8d20              LDRH     r0,[r4,#0x28]         ;1542
0000aa  b2c2              UXTB     r2,r0                 ;1542
0000ac  4639              MOV      r1,r7                 ;1542
0000ae  4620              MOV      r0,r4                 ;1542
0000b0  9b01              LDR      r3,[sp,#4]            ;1542
0000b2  f7fffffe          BL       I2C_TransferConfig
0000b6  8d60              LDRH     r0,[r4,#0x2a]         ;1545
0000b8  8d21              LDRH     r1,[r4,#0x28]         ;1545
0000ba  1a40              SUBS     r0,r0,r1              ;1545
0000bc  8560              STRH     r0,[r4,#0x2a]         ;1545
0000be  bf00              NOP                            ;1548
0000c0  2100              MOVS     r1,#0                 ;1548
0000c2  2040              MOVS     r0,#0x40              ;1548
0000c4  5501              STRB     r1,[r0,r4]            ;1548
0000c6  bf00              NOP                            ;1548
0000c8  2111              MOVS     r1,#0x11              ;1554
0000ca  4620              MOV      r0,r4                 ;1554
0000cc  f7fffffe          BL       I2C_Enable_IRQ
0000d0  6820              LDR      r0,[r4,#0]            ;1557
0000d2  6800              LDR      r0,[r0,#0]            ;1557
0000d4  2101              MOVS     r1,#1                 ;1557
0000d6  03c9              LSLS     r1,r1,#15             ;1557
0000d8  4308              ORRS     r0,r0,r1              ;1557
0000da  6821              LDR      r1,[r4,#0]            ;1557
0000dc  6008              STR      r0,[r1,#0]            ;1557
0000de  e015              B        |L19.268|
                  |L19.224|
0000e0  4811              LDR      r0,|L19.296|
0000e2  6360              STR      r0,[r4,#0x34]         ;1562
0000e4  2009              MOVS     r0,#9                 ;1566
0000e6  0280              LSLS     r0,r0,#10             ;1566
0000e8  9000              STR      r0,[sp,#0]            ;1566
0000ea  8d20              LDRH     r0,[r4,#0x28]         ;1566
0000ec  b2c2              UXTB     r2,r0                 ;1566
0000ee  2301              MOVS     r3,#1                 ;1566
0000f0  065b              LSLS     r3,r3,#25             ;1566
0000f2  4639              MOV      r1,r7                 ;1566
0000f4  4620              MOV      r0,r4                 ;1566
0000f6  f7fffffe          BL       I2C_TransferConfig
0000fa  bf00              NOP                            ;1569
0000fc  2100              MOVS     r1,#0                 ;1569
0000fe  2040              MOVS     r0,#0x40              ;1569
000100  5501              STRB     r1,[r0,r4]            ;1569
000102  bf00              NOP                            ;1569
000104  2101              MOVS     r1,#1                 ;1577
000106  4620              MOV      r0,r4                 ;1577
000108  f7fffffe          BL       I2C_Enable_IRQ
                  |L19.268|
00010c  2000              MOVS     r0,#0                 ;1579
00010e  e78b              B        |L19.40|
000110  e7ff              B        |L19.274|
                  |L19.274|
000112  2002              MOVS     r0,#2                 ;1583
000114  e788              B        |L19.40|
;;;1586   
                          ENDP

000116  0000              DCW      0x0000
                  |L19.280|
                          DCD      0xffff0000
                  |L19.284|
                          DCD      I2C_Master_ISR_DMA
                  |L19.288|
                          DCD      I2C_DMAMasterReceiveCplt
                  |L19.292|
                          DCD      I2C_DMAError
                  |L19.296|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_Master_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Receive_IT PROC
;;;1214     */
;;;1215   HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1216   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;1217     uint32_t xfermode = 0U;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;1218   
;;;1219     if(hi2c->State == HAL_I2C_STATE_READY)
00000e  2041              MOVS     r0,#0x41
000010  5d00              LDRB     r0,[r0,r4]
000012  2820              CMP      r0,#0x20
000014  d144              BNE      |L20.160|
;;;1220     {
;;;1221       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
000016  6820              LDR      r0,[r4,#0]
000018  6980              LDR      r0,[r0,#0x18]
00001a  2101              MOVS     r1,#1
00001c  03c9              LSLS     r1,r1,#15
00001e  4008              ANDS     r0,r0,r1
000020  0bc0              LSRS     r0,r0,#15
000022  2800              CMP      r0,#0
000024  d001              BEQ      |L20.42|
;;;1222       {
;;;1223         return HAL_BUSY;
000026  2002              MOVS     r0,#2
                  |L20.40|
;;;1224       }
;;;1225   
;;;1226       /* Process Locked */
;;;1227       __HAL_LOCK(hi2c);
;;;1228   
;;;1229       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1230       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1231       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1232   
;;;1233       /* Prepare transfer parameters */
;;;1234       hi2c->pBuffPtr    = pData;
;;;1235       hi2c->XferCount   = Size;
;;;1236       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1237       hi2c->XferISR     = I2C_Master_ISR_IT;
;;;1238       
;;;1239       if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1240       {
;;;1241         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1242         xfermode = I2C_RELOAD_MODE;
;;;1243       }
;;;1244       else
;;;1245       {
;;;1246         hi2c->XferSize = hi2c->XferCount;
;;;1247         xfermode = I2C_AUTOEND_MODE;
;;;1248       }
;;;1249   
;;;1250       /* Send Slave Address */
;;;1251       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
;;;1252       I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
;;;1253       
;;;1254       /* Process Unlocked */
;;;1255       __HAL_UNLOCK(hi2c);
;;;1256   
;;;1257       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1258                 to avoid the risk of I2C interrupt handle execution before current
;;;1259                 process unlock */
;;;1260   
;;;1261       /* Enable ERR, TC, STOP, NACK, RXI interrupt */
;;;1262       /* possible to enable all of these */
;;;1263       /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;1264       I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
;;;1265   
;;;1266       return HAL_OK;
;;;1267     }
;;;1268     else
;;;1269     {
;;;1270       return HAL_BUSY;
;;;1271     }
;;;1272   }
000028  bdfe              POP      {r1-r7,pc}
                  |L20.42|
00002a  bf00              NOP                            ;1227
00002c  2040              MOVS     r0,#0x40              ;1227
00002e  5d00              LDRB     r0,[r0,r4]            ;1227
000030  2801              CMP      r0,#1                 ;1227
000032  d101              BNE      |L20.56|
000034  2002              MOVS     r0,#2                 ;1227
000036  e7f7              B        |L20.40|
                  |L20.56|
000038  2101              MOVS     r1,#1                 ;1227
00003a  2040              MOVS     r0,#0x40              ;1227
00003c  5501              STRB     r1,[r0,r4]            ;1227
00003e  bf00              NOP                            ;1227
000040  2122              MOVS     r1,#0x22              ;1229
000042  2041              MOVS     r0,#0x41              ;1229
000044  5501              STRB     r1,[r0,r4]            ;1229
000046  2110              MOVS     r1,#0x10              ;1230
000048  2042              MOVS     r0,#0x42              ;1230
00004a  5501              STRB     r1,[r0,r4]            ;1230
00004c  2000              MOVS     r0,#0                 ;1231
00004e  6460              STR      r0,[r4,#0x44]         ;1231
000050  6265              STR      r5,[r4,#0x24]         ;1234
000052  8566              STRH     r6,[r4,#0x2a]         ;1235
000054  4813              LDR      r0,|L20.164|
000056  62e0              STR      r0,[r4,#0x2c]         ;1236
000058  4813              LDR      r0,|L20.168|
00005a  6360              STR      r0,[r4,#0x34]         ;1237
00005c  8d60              LDRH     r0,[r4,#0x2a]         ;1239
00005e  28ff              CMP      r0,#0xff              ;1239
000060  d904              BLS      |L20.108|
000062  20ff              MOVS     r0,#0xff              ;1241
000064  8520              STRH     r0,[r4,#0x28]         ;1241
000066  0508              LSLS     r0,r1,#20             ;1242
000068  9001              STR      r0,[sp,#4]            ;1242
00006a  e004              B        |L20.118|
                  |L20.108|
00006c  8d60              LDRH     r0,[r4,#0x2a]         ;1246
00006e  8520              STRH     r0,[r4,#0x28]         ;1246
000070  2001              MOVS     r0,#1                 ;1247
000072  0640              LSLS     r0,r0,#25             ;1247
000074  9001              STR      r0,[sp,#4]            ;1247
                  |L20.118|
000076  2009              MOVS     r0,#9                 ;1252
000078  0280              LSLS     r0,r0,#10             ;1252
00007a  9000              STR      r0,[sp,#0]            ;1252
00007c  8d20              LDRH     r0,[r4,#0x28]         ;1252
00007e  b2c2              UXTB     r2,r0                 ;1252
000080  4639              MOV      r1,r7                 ;1252
000082  4620              MOV      r0,r4                 ;1252
000084  9b01              LDR      r3,[sp,#4]            ;1252
000086  f7fffffe          BL       I2C_TransferConfig
00008a  bf00              NOP                            ;1255
00008c  2100              MOVS     r1,#0                 ;1255
00008e  2040              MOVS     r0,#0x40              ;1255
000090  5501              STRB     r1,[r0,r4]            ;1255
000092  bf00              NOP                            ;1255
000094  2102              MOVS     r1,#2                 ;1264
000096  4620              MOV      r0,r4                 ;1264
000098  f7fffffe          BL       I2C_Enable_IRQ
00009c  2000              MOVS     r0,#0                 ;1266
00009e  e7c3              B        |L20.40|
                  |L20.160|
0000a0  2002              MOVS     r0,#2                 ;1270
0000a2  e7c1              B        |L20.40|
;;;1273   
                          ENDP

                  |L20.164|
                          DCD      0xffff0000
                  |L20.168|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_Master_Sequential_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Sequential_Receive_IT PROC
;;;2644     */
;;;2645   HAL_StatusTypeDef HAL_I2C_Master_Sequential_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b5fe              PUSH     {r1-r7,lr}
;;;2646   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;2647     uint32_t xfermode = 0U;
00000a  2000              MOVS     r0,#0
00000c  9002              STR      r0,[sp,#8]
;;;2648     uint32_t xferrequest = I2C_GENERATE_START_READ;
00000e  2009              MOVS     r0,#9
000010  0280              LSLS     r0,r0,#10
000012  9001              STR      r0,[sp,#4]
;;;2649   
;;;2650     /* Check the parameters */
;;;2651     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;2652   
;;;2653     if(hi2c->State == HAL_I2C_STATE_READY)
000014  2041              MOVS     r0,#0x41
000016  5d00              LDRB     r0,[r0,r4]
000018  2820              CMP      r0,#0x20
00001a  d13d              BNE      |L21.152|
;;;2654     {
;;;2655       /* Process Locked */
;;;2656       __HAL_LOCK(hi2c);
00001c  bf00              NOP      
00001e  2040              MOVS     r0,#0x40
000020  5d00              LDRB     r0,[r0,r4]
000022  2801              CMP      r0,#1
000024  d101              BNE      |L21.42|
000026  2002              MOVS     r0,#2
                  |L21.40|
;;;2657   
;;;2658       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;2659       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;2660       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2661   
;;;2662       /* Prepare transfer parameters */
;;;2663       hi2c->pBuffPtr    = pData;
;;;2664       hi2c->XferCount   = Size;
;;;2665       hi2c->XferOptions = XferOptions;
;;;2666       hi2c->XferISR     = I2C_Master_ISR_IT;
;;;2667   
;;;2668       /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
;;;2669       if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2670       {
;;;2671         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2672         xfermode = I2C_RELOAD_MODE;
;;;2673       }
;;;2674       else
;;;2675       {
;;;2676         hi2c->XferSize = hi2c->XferCount;
;;;2677         xfermode = hi2c->XferOptions;
;;;2678       }
;;;2679   
;;;2680       /* If transfer direction not change, do not generate Restart Condition */
;;;2681       /* Mean Previous state is same as current state */
;;;2682       if(hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX)
;;;2683       {
;;;2684         xferrequest = I2C_NO_STARTSTOP;
;;;2685       }
;;;2686   
;;;2687       /* Send Slave Address and set NBYTES to read */
;;;2688       I2C_TransferConfig(hi2c,DevAddress, hi2c->XferSize, xfermode, xferrequest);
;;;2689   
;;;2690       /* Process Unlocked */
;;;2691       __HAL_UNLOCK(hi2c);
;;;2692   
;;;2693       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2694                 to avoid the risk of I2C interrupt handle execution before current
;;;2695                 process unlock */
;;;2696       I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
;;;2697   
;;;2698       return HAL_OK;
;;;2699     }
;;;2700     else
;;;2701     {
;;;2702       return HAL_BUSY;
;;;2703     }
;;;2704   }
000028  bdfe              POP      {r1-r7,pc}
                  |L21.42|
00002a  2101              MOVS     r1,#1                 ;2656
00002c  2040              MOVS     r0,#0x40              ;2656
00002e  5501              STRB     r1,[r0,r4]            ;2656
000030  bf00              NOP                            ;2656
000032  2122              MOVS     r1,#0x22              ;2658
000034  2041              MOVS     r0,#0x41              ;2658
000036  5501              STRB     r1,[r0,r4]            ;2658
000038  2110              MOVS     r1,#0x10              ;2659
00003a  2042              MOVS     r0,#0x42              ;2659
00003c  5501              STRB     r1,[r0,r4]            ;2659
00003e  2000              MOVS     r0,#0                 ;2660
000040  6460              STR      r0,[r4,#0x44]         ;2660
000042  6265              STR      r5,[r4,#0x24]         ;2663
000044  8566              STRH     r6,[r4,#0x2a]         ;2664
000046  9808              LDR      r0,[sp,#0x20]         ;2665
000048  62e0              STR      r0,[r4,#0x2c]         ;2665
00004a  4814              LDR      r0,|L21.156|
00004c  6360              STR      r0,[r4,#0x34]         ;2666
00004e  8d60              LDRH     r0,[r4,#0x2a]         ;2669
000050  28ff              CMP      r0,#0xff              ;2669
000052  d904              BLS      |L21.94|
000054  20ff              MOVS     r0,#0xff              ;2671
000056  8520              STRH     r0,[r4,#0x28]         ;2671
000058  0508              LSLS     r0,r1,#20             ;2672
00005a  9002              STR      r0,[sp,#8]            ;2672
00005c  e003              B        |L21.102|
                  |L21.94|
00005e  8d60              LDRH     r0,[r4,#0x2a]         ;2676
000060  8520              STRH     r0,[r4,#0x28]         ;2676
000062  6ae0              LDR      r0,[r4,#0x2c]         ;2677
000064  9002              STR      r0,[sp,#8]            ;2677
                  |L21.102|
000066  6b20              LDR      r0,[r4,#0x30]         ;2682
000068  2812              CMP      r0,#0x12              ;2682
00006a  d101              BNE      |L21.112|
00006c  2000              MOVS     r0,#0                 ;2684
00006e  9001              STR      r0,[sp,#4]            ;2684
                  |L21.112|
000070  9801              LDR      r0,[sp,#4]            ;2688
000072  9000              STR      r0,[sp,#0]            ;2688
000074  8d20              LDRH     r0,[r4,#0x28]         ;2688
000076  b2c2              UXTB     r2,r0                 ;2688
000078  4639              MOV      r1,r7                 ;2688
00007a  4620              MOV      r0,r4                 ;2688
00007c  9b02              LDR      r3,[sp,#8]            ;2688
00007e  f7fffffe          BL       I2C_TransferConfig
000082  bf00              NOP                            ;2691
000084  2100              MOVS     r1,#0                 ;2691
000086  2040              MOVS     r0,#0x40              ;2691
000088  5501              STRB     r1,[r0,r4]            ;2691
00008a  bf00              NOP                            ;2691
00008c  2102              MOVS     r1,#2                 ;2696
00008e  4620              MOV      r0,r4                 ;2696
000090  f7fffffe          BL       I2C_Enable_IRQ
000094  2000              MOVS     r0,#0                 ;2698
000096  e7c7              B        |L21.40|
                  |L21.152|
000098  2002              MOVS     r0,#2                 ;2702
00009a  e7c5              B        |L21.40|
;;;2705   
                          ENDP

                  |L21.156|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_Master_Sequential_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Sequential_Transmit_IT PROC
;;;2571     */
;;;2572   HAL_StatusTypeDef HAL_I2C_Master_Sequential_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b5fe              PUSH     {r1-r7,lr}
;;;2573   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;2574     uint32_t xfermode = 0U;
00000a  2000              MOVS     r0,#0
00000c  9002              STR      r0,[sp,#8]
;;;2575     uint32_t xferrequest = I2C_GENERATE_START_WRITE;
00000e  2001              MOVS     r0,#1
000010  0340              LSLS     r0,r0,#13
000012  9001              STR      r0,[sp,#4]
;;;2576   
;;;2577     /* Check the parameters */
;;;2578     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;2579   
;;;2580     if(hi2c->State == HAL_I2C_STATE_READY)
000014  2041              MOVS     r0,#0x41
000016  5d00              LDRB     r0,[r0,r4]
000018  2820              CMP      r0,#0x20
00001a  d13d              BNE      |L22.152|
;;;2581     {
;;;2582       /* Process Locked */
;;;2583       __HAL_LOCK(hi2c);
00001c  bf00              NOP      
00001e  2040              MOVS     r0,#0x40
000020  5d00              LDRB     r0,[r0,r4]
000022  2801              CMP      r0,#1
000024  d101              BNE      |L22.42|
000026  2002              MOVS     r0,#2
                  |L22.40|
;;;2584   
;;;2585       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;2586       hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;2587       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2588   
;;;2589       /* Prepare transfer parameters */
;;;2590       hi2c->pBuffPtr    = pData;
;;;2591       hi2c->XferCount   = Size;
;;;2592       hi2c->XferOptions = XferOptions;
;;;2593       hi2c->XferISR     = I2C_Master_ISR_IT;
;;;2594   
;;;2595       /* If size > MAX_NBYTE_SIZE, use reload mode */
;;;2596       if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2597       {
;;;2598         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2599         xfermode = I2C_RELOAD_MODE;
;;;2600       }
;;;2601       else
;;;2602       {
;;;2603         hi2c->XferSize = hi2c->XferCount;
;;;2604         xfermode = hi2c->XferOptions;
;;;2605       }
;;;2606   
;;;2607       /* If transfer direction not change, do not generate Restart Condition */
;;;2608       /* Mean Previous state is same as current state */
;;;2609       if(hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX)
;;;2610       {
;;;2611         xferrequest = I2C_NO_STARTSTOP;
;;;2612       }
;;;2613   
;;;2614       /* Send Slave Address and set NBYTES to write */
;;;2615       I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, xfermode, xferrequest);
;;;2616   
;;;2617       /* Process Unlocked */
;;;2618       __HAL_UNLOCK(hi2c);
;;;2619   
;;;2620       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2621                 to avoid the risk of I2C interrupt handle execution before current
;;;2622                 process unlock */
;;;2623       I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;2624   
;;;2625       return HAL_OK;
;;;2626     }
;;;2627     else
;;;2628     {
;;;2629       return HAL_BUSY;
;;;2630     }
;;;2631   }
000028  bdfe              POP      {r1-r7,pc}
                  |L22.42|
00002a  2101              MOVS     r1,#1                 ;2583
00002c  2040              MOVS     r0,#0x40              ;2583
00002e  5501              STRB     r1,[r0,r4]            ;2583
000030  bf00              NOP                            ;2583
000032  2121              MOVS     r1,#0x21              ;2585
000034  2041              MOVS     r0,#0x41              ;2585
000036  5501              STRB     r1,[r0,r4]            ;2585
000038  2110              MOVS     r1,#0x10              ;2586
00003a  2042              MOVS     r0,#0x42              ;2586
00003c  5501              STRB     r1,[r0,r4]            ;2586
00003e  2000              MOVS     r0,#0                 ;2587
000040  6460              STR      r0,[r4,#0x44]         ;2587
000042  6265              STR      r5,[r4,#0x24]         ;2590
000044  8566              STRH     r6,[r4,#0x2a]         ;2591
000046  9808              LDR      r0,[sp,#0x20]         ;2592
000048  62e0              STR      r0,[r4,#0x2c]         ;2592
00004a  4814              LDR      r0,|L22.156|
00004c  6360              STR      r0,[r4,#0x34]         ;2593
00004e  8d60              LDRH     r0,[r4,#0x2a]         ;2596
000050  28ff              CMP      r0,#0xff              ;2596
000052  d904              BLS      |L22.94|
000054  20ff              MOVS     r0,#0xff              ;2598
000056  8520              STRH     r0,[r4,#0x28]         ;2598
000058  0508              LSLS     r0,r1,#20             ;2599
00005a  9002              STR      r0,[sp,#8]            ;2599
00005c  e003              B        |L22.102|
                  |L22.94|
00005e  8d60              LDRH     r0,[r4,#0x2a]         ;2603
000060  8520              STRH     r0,[r4,#0x28]         ;2603
000062  6ae0              LDR      r0,[r4,#0x2c]         ;2604
000064  9002              STR      r0,[sp,#8]            ;2604
                  |L22.102|
000066  6b20              LDR      r0,[r4,#0x30]         ;2609
000068  2811              CMP      r0,#0x11              ;2609
00006a  d101              BNE      |L22.112|
00006c  2000              MOVS     r0,#0                 ;2611
00006e  9001              STR      r0,[sp,#4]            ;2611
                  |L22.112|
000070  9801              LDR      r0,[sp,#4]            ;2615
000072  9000              STR      r0,[sp,#0]            ;2615
000074  8d20              LDRH     r0,[r4,#0x28]         ;2615
000076  b2c2              UXTB     r2,r0                 ;2615
000078  4639              MOV      r1,r7                 ;2615
00007a  4620              MOV      r0,r4                 ;2615
00007c  9b02              LDR      r3,[sp,#8]            ;2615
00007e  f7fffffe          BL       I2C_TransferConfig
000082  bf00              NOP                            ;2618
000084  2100              MOVS     r1,#0                 ;2618
000086  2040              MOVS     r0,#0x40              ;2618
000088  5501              STRB     r1,[r0,r4]            ;2618
00008a  bf00              NOP                            ;2618
00008c  2101              MOVS     r1,#1                 ;2623
00008e  4620              MOV      r0,r4                 ;2623
000090  f7fffffe          BL       I2C_Enable_IRQ
000094  2000              MOVS     r0,#0                 ;2625
000096  e7c7              B        |L22.40|
                  |L22.152|
000098  2002              MOVS     r0,#2                 ;2629
00009a  e7c5              B        |L22.40|
;;;2632   
                          ENDP

                  |L22.156|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_Master_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit PROC
;;;626      */
;;;627    HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;628    {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;629      uint32_t tickstart = 0U;
00000a  2500              MOVS     r5,#0
;;;630    
;;;631      if(hi2c->State == HAL_I2C_STATE_READY)
00000c  2041              MOVS     r0,#0x41
00000e  5d00              LDRB     r0,[r0,r4]
000010  2820              CMP      r0,#0x20
000012  d17c              BNE      |L23.270|
;;;632      {
;;;633        /* Process Locked */
;;;634        __HAL_LOCK(hi2c);
000014  bf00              NOP      
000016  2040              MOVS     r0,#0x40
000018  5d00              LDRB     r0,[r0,r4]
00001a  2801              CMP      r0,#1
00001c  d102              BNE      |L23.36|
00001e  2002              MOVS     r0,#2
                  |L23.32|
;;;635    
;;;636        /* Init tickstart for timeout management*/
;;;637        tickstart = HAL_GetTick();
;;;638    
;;;639        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
;;;640        {
;;;641          return HAL_TIMEOUT;
;;;642        }
;;;643    
;;;644        hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;645        hi2c->Mode      = HAL_I2C_MODE_MASTER;
;;;646        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;647        
;;;648        /* Prepare transfer parameters */
;;;649        hi2c->pBuffPtr  = pData;
;;;650        hi2c->XferCount = Size;
;;;651        hi2c->XferISR   = NULL;
;;;652    
;;;653        /* Send Slave Address */
;;;654        /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;655        if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;656        {
;;;657          hi2c->XferSize = MAX_NBYTE_SIZE;
;;;658          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
;;;659        }
;;;660        else
;;;661        {
;;;662          hi2c->XferSize = hi2c->XferCount;
;;;663          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
;;;664        }
;;;665    
;;;666        while(hi2c->XferCount > 0U)
;;;667        {
;;;668          /* Wait until TXIS flag is set */
;;;669          if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;670          {
;;;671            if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;672            {
;;;673              return HAL_ERROR;
;;;674            }
;;;675            else
;;;676            {
;;;677              return HAL_TIMEOUT;
;;;678            }
;;;679          }
;;;680          /* Write data to TXDR */
;;;681          hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
;;;682          hi2c->XferCount--;
;;;683          hi2c->XferSize--;
;;;684    
;;;685          if((hi2c->XferSize == 0U) && (hi2c->XferCount!=0U))
;;;686          {
;;;687            /* Wait until TCR flag is set */
;;;688            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
;;;689            {
;;;690              return HAL_TIMEOUT;
;;;691            }
;;;692    
;;;693            if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;694            {
;;;695              hi2c->XferSize = MAX_NBYTE_SIZE;
;;;696              I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
;;;697            }
;;;698            else
;;;699            {
;;;700              hi2c->XferSize = hi2c->XferCount;
;;;701              I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
;;;702            }
;;;703          }
;;;704        }
;;;705    
;;;706        /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
;;;707        /* Wait until STOPF flag is set */
;;;708        if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;709        {
;;;710          if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;711          {
;;;712            return HAL_ERROR;
;;;713          }
;;;714          else
;;;715          {
;;;716            return HAL_TIMEOUT;
;;;717          }
;;;718        }
;;;719    
;;;720        /* Clear STOP Flag */
;;;721        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;722    
;;;723        /* Clear Configuration Register 2 */
;;;724        I2C_RESET_CR2(hi2c);
;;;725    
;;;726        hi2c->State = HAL_I2C_STATE_READY;
;;;727        hi2c->Mode  = HAL_I2C_MODE_NONE;
;;;728    
;;;729        /* Process Unlocked */
;;;730        __HAL_UNLOCK(hi2c);
;;;731    
;;;732        return HAL_OK;
;;;733      }
;;;734      else
;;;735      {
;;;736        return HAL_BUSY;
;;;737      }
;;;738    }
000020  b005              ADD      sp,sp,#0x14
000022  bdf0              POP      {r4-r7,pc}
                  |L23.36|
000024  2101              MOVS     r1,#1                 ;634
000026  2040              MOVS     r0,#0x40              ;634
000028  5501              STRB     r1,[r0,r4]            ;634
00002a  bf00              NOP                            ;634
00002c  f7fffffe          BL       HAL_GetTick
000030  4605              MOV      r5,r0                 ;637
000032  2319              MOVS     r3,#0x19              ;639
000034  2201              MOVS     r2,#1                 ;639
000036  03d1              LSLS     r1,r2,#15             ;639
000038  4620              MOV      r0,r4                 ;639
00003a  9500              STR      r5,[sp,#0]            ;639
00003c  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000040  2800              CMP      r0,#0                 ;639
000042  d001              BEQ      |L23.72|
000044  2003              MOVS     r0,#3                 ;641
000046  e7eb              B        |L23.32|
                  |L23.72|
000048  2121              MOVS     r1,#0x21              ;644
00004a  2041              MOVS     r0,#0x41              ;644
00004c  5501              STRB     r1,[r0,r4]            ;644
00004e  2110              MOVS     r1,#0x10              ;645
000050  2042              MOVS     r0,#0x42              ;645
000052  5501              STRB     r1,[r0,r4]            ;645
000054  2000              MOVS     r0,#0                 ;646
000056  6460              STR      r0,[r4,#0x44]         ;646
000058  6266              STR      r6,[r4,#0x24]         ;649
00005a  8567              STRH     r7,[r4,#0x2a]         ;650
00005c  6360              STR      r0,[r4,#0x34]         ;651
00005e  8d60              LDRH     r0,[r4,#0x2a]         ;655
000060  28ff              CMP      r0,#0xff              ;655
000062  d90b              BLS      |L23.124|
000064  20ff              MOVS     r0,#0xff              ;657
000066  8520              STRH     r0,[r4,#0x28]         ;657
000068  0248              LSLS     r0,r1,#9              ;658
00006a  9000              STR      r0,[sp,#0]            ;658
00006c  8d20              LDRH     r0,[r4,#0x28]         ;658
00006e  b2c2              UXTB     r2,r0                 ;658
000070  050b              LSLS     r3,r1,#20             ;658
000072  4620              MOV      r0,r4                 ;658
000074  9902              LDR      r1,[sp,#8]            ;658
000076  f7fffffe          BL       I2C_TransferConfig
00007a  e00c              B        |L23.150|
                  |L23.124|
00007c  8d60              LDRH     r0,[r4,#0x2a]         ;662
00007e  8520              STRH     r0,[r4,#0x28]         ;662
000080  2001              MOVS     r0,#1                 ;663
000082  0340              LSLS     r0,r0,#13             ;663
000084  9000              STR      r0,[sp,#0]            ;663
000086  8d20              LDRH     r0,[r4,#0x28]         ;663
000088  b2c2              UXTB     r2,r0                 ;663
00008a  2301              MOVS     r3,#1                 ;663
00008c  065b              LSLS     r3,r3,#25             ;663
00008e  4620              MOV      r0,r4                 ;663
000090  9902              LDR      r1,[sp,#8]            ;663
000092  f7fffffe          BL       I2C_TransferConfig
                  |L23.150|
000096  e047              B        |L23.296|
                  |L23.152|
000098  462a              MOV      r2,r5                 ;669
00009a  4620              MOV      r0,r4                 ;669
00009c  990a              LDR      r1,[sp,#0x28]         ;669
00009e  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
0000a2  2800              CMP      r0,#0                 ;669
0000a4  d006              BEQ      |L23.180|
0000a6  6c60              LDR      r0,[r4,#0x44]         ;671
0000a8  2804              CMP      r0,#4                 ;671
0000aa  d101              BNE      |L23.176|
0000ac  2001              MOVS     r0,#1                 ;673
0000ae  e7b7              B        |L23.32|
                  |L23.176|
0000b0  2003              MOVS     r0,#3                 ;677
0000b2  e7b5              B        |L23.32|
                  |L23.180|
0000b4  6a61              LDR      r1,[r4,#0x24]         ;681
0000b6  1c48              ADDS     r0,r1,#1              ;681
0000b8  6260              STR      r0,[r4,#0x24]         ;681
0000ba  7808              LDRB     r0,[r1,#0]            ;681
0000bc  6821              LDR      r1,[r4,#0]            ;681
0000be  6288              STR      r0,[r1,#0x28]         ;681
0000c0  8d60              LDRH     r0,[r4,#0x2a]         ;682
0000c2  1e40              SUBS     r0,r0,#1              ;682
0000c4  8560              STRH     r0,[r4,#0x2a]         ;682
0000c6  8d20              LDRH     r0,[r4,#0x28]         ;683
0000c8  1e40              SUBS     r0,r0,#1              ;683
0000ca  8520              STRH     r0,[r4,#0x28]         ;683
0000cc  8d20              LDRH     r0,[r4,#0x28]         ;685
0000ce  2800              CMP      r0,#0                 ;685
0000d0  d12a              BNE      |L23.296|
0000d2  8d60              LDRH     r0,[r4,#0x2a]         ;685
0000d4  2800              CMP      r0,#0                 ;685
0000d6  d027              BEQ      |L23.296|
0000d8  9500              STR      r5,[sp,#0]            ;688
0000da  2200              MOVS     r2,#0                 ;688
0000dc  2180              MOVS     r1,#0x80              ;688
0000de  4620              MOV      r0,r4                 ;688
0000e0  9b0a              LDR      r3,[sp,#0x28]         ;688
0000e2  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000e6  2800              CMP      r0,#0                 ;688
0000e8  d001              BEQ      |L23.238|
0000ea  2003              MOVS     r0,#3                 ;690
0000ec  e798              B        |L23.32|
                  |L23.238|
0000ee  8d60              LDRH     r0,[r4,#0x2a]         ;693
0000f0  28ff              CMP      r0,#0xff              ;693
0000f2  d90d              BLS      |L23.272|
0000f4  20ff              MOVS     r0,#0xff              ;695
0000f6  8520              STRH     r0,[r4,#0x28]         ;695
0000f8  2000              MOVS     r0,#0                 ;696
0000fa  9000              STR      r0,[sp,#0]            ;696
0000fc  8d20              LDRH     r0,[r4,#0x28]         ;696
0000fe  b2c2              UXTB     r2,r0                 ;696
000100  2301              MOVS     r3,#1                 ;696
000102  061b              LSLS     r3,r3,#24             ;696
000104  4620              MOV      r0,r4                 ;696
000106  9902              LDR      r1,[sp,#8]            ;696
000108  f7fffffe          BL       I2C_TransferConfig
00010c  e00c              B        |L23.296|
                  |L23.270|
00010e  e031              B        |L23.372|
                  |L23.272|
000110  8d60              LDRH     r0,[r4,#0x2a]         ;700
000112  8520              STRH     r0,[r4,#0x28]         ;700
000114  2000              MOVS     r0,#0                 ;701
000116  9000              STR      r0,[sp,#0]            ;701
000118  8d20              LDRH     r0,[r4,#0x28]         ;701
00011a  b2c2              UXTB     r2,r0                 ;701
00011c  2301              MOVS     r3,#1                 ;701
00011e  065b              LSLS     r3,r3,#25             ;701
000120  4620              MOV      r0,r4                 ;701
000122  9902              LDR      r1,[sp,#8]            ;701
000124  f7fffffe          BL       I2C_TransferConfig
                  |L23.296|
000128  8d60              LDRH     r0,[r4,#0x2a]         ;666
00012a  2800              CMP      r0,#0                 ;666
00012c  d1b4              BNE      |L23.152|
00012e  462a              MOV      r2,r5                 ;708
000130  4620              MOV      r0,r4                 ;708
000132  990a              LDR      r1,[sp,#0x28]         ;708
000134  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
000138  2800              CMP      r0,#0                 ;708
00013a  d006              BEQ      |L23.330|
00013c  6c60              LDR      r0,[r4,#0x44]         ;710
00013e  2804              CMP      r0,#4                 ;710
000140  d101              BNE      |L23.326|
000142  2001              MOVS     r0,#1                 ;712
000144  e76c              B        |L23.32|
                  |L23.326|
000146  2003              MOVS     r0,#3                 ;716
000148  e76a              B        |L23.32|
                  |L23.330|
00014a  2020              MOVS     r0,#0x20              ;721
00014c  6821              LDR      r1,[r4,#0]            ;721
00014e  61c8              STR      r0,[r1,#0x1c]         ;721
000150  6820              LDR      r0,[r4,#0]            ;724
000152  6840              LDR      r0,[r0,#4]            ;724
000154  4908              LDR      r1,|L23.376|
000156  4008              ANDS     r0,r0,r1              ;724
000158  6821              LDR      r1,[r4,#0]            ;724
00015a  6048              STR      r0,[r1,#4]            ;724
00015c  2120              MOVS     r1,#0x20              ;726
00015e  2041              MOVS     r0,#0x41              ;726
000160  5501              STRB     r1,[r0,r4]            ;726
000162  2100              MOVS     r1,#0                 ;727
000164  2042              MOVS     r0,#0x42              ;727
000166  5501              STRB     r1,[r0,r4]            ;727
000168  bf00              NOP                            ;730
00016a  2040              MOVS     r0,#0x40              ;730
00016c  5501              STRB     r1,[r0,r4]            ;730
00016e  bf00              NOP                            ;730
000170  2000              MOVS     r0,#0                 ;732
000172  e755              B        |L23.32|
                  |L23.372|
000174  2002              MOVS     r0,#2                 ;736
000176  e753              B        |L23.32|
;;;739    
                          ENDP

                  |L23.376|
                          DCD      0xfe00e800

                          AREA ||i.HAL_I2C_Master_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_DMA PROC
;;;1381     */
;;;1382   HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1383   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;1384     uint32_t xfermode = 0U;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;1385   
;;;1386     if(hi2c->State == HAL_I2C_STATE_READY)
00000e  2041              MOVS     r0,#0x41
000010  5d00              LDRB     r0,[r0,r4]
000012  2820              CMP      r0,#0x20
000014  d17d              BNE      |L24.274|
;;;1387     {
;;;1388       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
000016  6820              LDR      r0,[r4,#0]
000018  6980              LDR      r0,[r0,#0x18]
00001a  2101              MOVS     r1,#1
00001c  03c9              LSLS     r1,r1,#15
00001e  4008              ANDS     r0,r0,r1
000020  0bc0              LSRS     r0,r0,#15
000022  2800              CMP      r0,#0
000024  d001              BEQ      |L24.42|
;;;1389       {
;;;1390         return HAL_BUSY;
000026  2002              MOVS     r0,#2
                  |L24.40|
;;;1391       }
;;;1392   
;;;1393       /* Process Locked */
;;;1394       __HAL_LOCK(hi2c);
;;;1395   
;;;1396       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1397       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1398       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1399   
;;;1400       /* Prepare transfer parameters */
;;;1401       hi2c->pBuffPtr    = pData;
;;;1402       hi2c->XferCount   = Size;
;;;1403       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1404       hi2c->XferISR     = I2C_Master_ISR_DMA;
;;;1405       
;;;1406       if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1407       {
;;;1408         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1409         xfermode = I2C_RELOAD_MODE;
;;;1410       }
;;;1411       else
;;;1412       {
;;;1413         hi2c->XferSize = hi2c->XferCount;
;;;1414         xfermode = I2C_AUTOEND_MODE;
;;;1415       }
;;;1416   
;;;1417       if(hi2c->XferSize > 0U)
;;;1418       {
;;;1419         /* Set the I2C DMA transfer complete callback */
;;;1420         hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
;;;1421   
;;;1422         /* Set the DMA error callback */
;;;1423         hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;1424   
;;;1425         /* Set the unused DMA callbacks to NULL */
;;;1426         hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;1427         hi2c->hdmatx->XferAbortCallback = NULL;
;;;1428   
;;;1429         /* Enable the DMA channel */
;;;1430         HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
;;;1431   
;;;1432         /* Send Slave Address */
;;;1433         /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;1434         I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
;;;1435   
;;;1436         /* Update XferCount value */
;;;1437         hi2c->XferCount -= hi2c->XferSize;
;;;1438   
;;;1439         /* Process Unlocked */
;;;1440         __HAL_UNLOCK(hi2c);
;;;1441   
;;;1442         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1443                   to avoid the risk of I2C interrupt handle execution before current
;;;1444                   process unlock */
;;;1445         /* Enable ERR and NACK interrupts */
;;;1446         I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
;;;1447   
;;;1448         /* Enable DMA Request */
;;;1449         hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
;;;1450       }
;;;1451       else
;;;1452       {
;;;1453         /* Update Transfer ISR function pointer */
;;;1454         hi2c->XferISR = I2C_Master_ISR_IT;
;;;1455         
;;;1456         /* Send Slave Address */
;;;1457         /* Set NBYTES to write and generate START condition */
;;;1458         I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
;;;1459   
;;;1460         /* Process Unlocked */
;;;1461         __HAL_UNLOCK(hi2c);
;;;1462   
;;;1463         /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1464                   to avoid the risk of I2C interrupt handle execution before current
;;;1465                   process unlock */
;;;1466         /* Enable ERR, TC, STOP, NACK, TXI interrupt */
;;;1467         /* possible to enable all of these */
;;;1468         /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;1469         I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;1470       }
;;;1471   
;;;1472       return HAL_OK;
;;;1473     }
;;;1474     else
;;;1475     {
;;;1476       return HAL_BUSY;
;;;1477     }
;;;1478   }
000028  bdfe              POP      {r1-r7,pc}
                  |L24.42|
00002a  bf00              NOP                            ;1394
00002c  2040              MOVS     r0,#0x40              ;1394
00002e  5d00              LDRB     r0,[r0,r4]            ;1394
000030  2801              CMP      r0,#1                 ;1394
000032  d101              BNE      |L24.56|
000034  2002              MOVS     r0,#2                 ;1394
000036  e7f7              B        |L24.40|
                  |L24.56|
000038  2101              MOVS     r1,#1                 ;1394
00003a  2040              MOVS     r0,#0x40              ;1394
00003c  5501              STRB     r1,[r0,r4]            ;1394
00003e  bf00              NOP                            ;1394
000040  2121              MOVS     r1,#0x21              ;1396
000042  2041              MOVS     r0,#0x41              ;1396
000044  5501              STRB     r1,[r0,r4]            ;1396
000046  2110              MOVS     r1,#0x10              ;1397
000048  2042              MOVS     r0,#0x42              ;1397
00004a  5501              STRB     r1,[r0,r4]            ;1397
00004c  2000              MOVS     r0,#0                 ;1398
00004e  6460              STR      r0,[r4,#0x44]         ;1398
000050  6265              STR      r5,[r4,#0x24]         ;1401
000052  8566              STRH     r6,[r4,#0x2a]         ;1402
000054  4830              LDR      r0,|L24.280|
000056  62e0              STR      r0,[r4,#0x2c]         ;1403
000058  4830              LDR      r0,|L24.284|
00005a  6360              STR      r0,[r4,#0x34]         ;1404
00005c  8d60              LDRH     r0,[r4,#0x2a]         ;1406
00005e  28ff              CMP      r0,#0xff              ;1406
000060  d904              BLS      |L24.108|
000062  20ff              MOVS     r0,#0xff              ;1408
000064  8520              STRH     r0,[r4,#0x28]         ;1408
000066  0508              LSLS     r0,r1,#20             ;1409
000068  9001              STR      r0,[sp,#4]            ;1409
00006a  e004              B        |L24.118|
                  |L24.108|
00006c  8d60              LDRH     r0,[r4,#0x2a]         ;1413
00006e  8520              STRH     r0,[r4,#0x28]         ;1413
000070  2001              MOVS     r0,#1                 ;1414
000072  0640              LSLS     r0,r0,#25             ;1414
000074  9001              STR      r0,[sp,#4]            ;1414
                  |L24.118|
000076  8d20              LDRH     r0,[r4,#0x28]         ;1417
000078  2800              CMP      r0,#0                 ;1417
00007a  d031              BEQ      |L24.224|
00007c  4828              LDR      r0,|L24.288|
00007e  6ba1              LDR      r1,[r4,#0x38]         ;1420
000080  6288              STR      r0,[r1,#0x28]         ;1420
000082  4828              LDR      r0,|L24.292|
000084  6ba1              LDR      r1,[r4,#0x38]         ;1423
000086  6308              STR      r0,[r1,#0x30]         ;1423
000088  2000              MOVS     r0,#0                 ;1426
00008a  6ba1              LDR      r1,[r4,#0x38]         ;1426
00008c  62c8              STR      r0,[r1,#0x2c]         ;1426
00008e  6ba1              LDR      r1,[r4,#0x38]         ;1427
000090  6348              STR      r0,[r1,#0x34]         ;1427
000092  8d23              LDRH     r3,[r4,#0x28]         ;1430
000094  6821              LDR      r1,[r4,#0]            ;1430
000096  460a              MOV      r2,r1                 ;1430
000098  3228              ADDS     r2,r2,#0x28           ;1430
00009a  4629              MOV      r1,r5                 ;1430
00009c  6ba0              LDR      r0,[r4,#0x38]         ;1430
00009e  f7fffffe          BL       HAL_DMA_Start_IT
0000a2  2001              MOVS     r0,#1                 ;1434
0000a4  0340              LSLS     r0,r0,#13             ;1434
0000a6  9000              STR      r0,[sp,#0]            ;1434
0000a8  8d20              LDRH     r0,[r4,#0x28]         ;1434
0000aa  b2c2              UXTB     r2,r0                 ;1434
0000ac  4639              MOV      r1,r7                 ;1434
0000ae  4620              MOV      r0,r4                 ;1434
0000b0  9b01              LDR      r3,[sp,#4]            ;1434
0000b2  f7fffffe          BL       I2C_TransferConfig
0000b6  8d60              LDRH     r0,[r4,#0x2a]         ;1437
0000b8  8d21              LDRH     r1,[r4,#0x28]         ;1437
0000ba  1a40              SUBS     r0,r0,r1              ;1437
0000bc  8560              STRH     r0,[r4,#0x2a]         ;1437
0000be  bf00              NOP                            ;1440
0000c0  2100              MOVS     r1,#0                 ;1440
0000c2  2040              MOVS     r0,#0x40              ;1440
0000c4  5501              STRB     r1,[r0,r4]            ;1440
0000c6  bf00              NOP                            ;1440
0000c8  2111              MOVS     r1,#0x11              ;1446
0000ca  4620              MOV      r0,r4                 ;1446
0000cc  f7fffffe          BL       I2C_Enable_IRQ
0000d0  6820              LDR      r0,[r4,#0]            ;1449
0000d2  6800              LDR      r0,[r0,#0]            ;1449
0000d4  2101              MOVS     r1,#1                 ;1449
0000d6  0389              LSLS     r1,r1,#14             ;1449
0000d8  4308              ORRS     r0,r0,r1              ;1449
0000da  6821              LDR      r1,[r4,#0]            ;1449
0000dc  6008              STR      r0,[r1,#0]            ;1449
0000de  e015              B        |L24.268|
                  |L24.224|
0000e0  4811              LDR      r0,|L24.296|
0000e2  6360              STR      r0,[r4,#0x34]         ;1454
0000e4  2001              MOVS     r0,#1                 ;1458
0000e6  0340              LSLS     r0,r0,#13             ;1458
0000e8  9000              STR      r0,[sp,#0]            ;1458
0000ea  8d20              LDRH     r0,[r4,#0x28]         ;1458
0000ec  b2c2              UXTB     r2,r0                 ;1458
0000ee  2301              MOVS     r3,#1                 ;1458
0000f0  065b              LSLS     r3,r3,#25             ;1458
0000f2  4639              MOV      r1,r7                 ;1458
0000f4  4620              MOV      r0,r4                 ;1458
0000f6  f7fffffe          BL       I2C_TransferConfig
0000fa  bf00              NOP                            ;1461
0000fc  2100              MOVS     r1,#0                 ;1461
0000fe  2040              MOVS     r0,#0x40              ;1461
000100  5501              STRB     r1,[r0,r4]            ;1461
000102  bf00              NOP                            ;1461
000104  2101              MOVS     r1,#1                 ;1469
000106  4620              MOV      r0,r4                 ;1469
000108  f7fffffe          BL       I2C_Enable_IRQ
                  |L24.268|
00010c  2000              MOVS     r0,#0                 ;1472
00010e  e78b              B        |L24.40|
000110  e7ff              B        |L24.274|
                  |L24.274|
000112  2002              MOVS     r0,#2                 ;1476
000114  e788              B        |L24.40|
;;;1479   
                          ENDP

000116  0000              DCW      0x0000
                  |L24.280|
                          DCD      0xffff0000
                  |L24.284|
                          DCD      I2C_Master_ISR_DMA
                  |L24.288|
                          DCD      I2C_DMAMasterTransmitCplt
                  |L24.292|
                          DCD      I2C_DMAError
                  |L24.296|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_Master_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Master_Transmit_IT PROC
;;;1145     */
;;;1146   HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1147   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;1148     uint32_t xfermode = 0U;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;1149   
;;;1150     if(hi2c->State == HAL_I2C_STATE_READY)
00000e  2041              MOVS     r0,#0x41
000010  5d00              LDRB     r0,[r0,r4]
000012  2820              CMP      r0,#0x20
000014  d144              BNE      |L25.160|
;;;1151     {
;;;1152       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
000016  6820              LDR      r0,[r4,#0]
000018  6980              LDR      r0,[r0,#0x18]
00001a  2101              MOVS     r1,#1
00001c  03c9              LSLS     r1,r1,#15
00001e  4008              ANDS     r0,r0,r1
000020  0bc0              LSRS     r0,r0,#15
000022  2800              CMP      r0,#0
000024  d001              BEQ      |L25.42|
;;;1153       {
;;;1154         return HAL_BUSY;
000026  2002              MOVS     r0,#2
                  |L25.40|
;;;1155       }
;;;1156   
;;;1157       /* Process Locked */
;;;1158       __HAL_LOCK(hi2c);
;;;1159   
;;;1160       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1161       hi2c->Mode        = HAL_I2C_MODE_MASTER;
;;;1162       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1163   
;;;1164       /* Prepare transfer parameters */
;;;1165       hi2c->pBuffPtr    = pData;
;;;1166       hi2c->XferCount   = Size;
;;;1167       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1168       hi2c->XferISR     = I2C_Master_ISR_IT;
;;;1169       
;;;1170       if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1171       {
;;;1172         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1173         xfermode = I2C_RELOAD_MODE;
;;;1174       }
;;;1175       else
;;;1176       {
;;;1177         hi2c->XferSize = hi2c->XferCount;
;;;1178         xfermode = I2C_AUTOEND_MODE;
;;;1179       }
;;;1180   
;;;1181       /* Send Slave Address */
;;;1182       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
;;;1183       I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
;;;1184   
;;;1185       /* Process Unlocked */
;;;1186       __HAL_UNLOCK(hi2c); 
;;;1187   
;;;1188       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1189                 to avoid the risk of I2C interrupt handle execution before current
;;;1190                 process unlock */
;;;1191   
;;;1192       /* Enable ERR, TC, STOP, NACK, TXI interrupt */
;;;1193       /* possible to enable all of these */
;;;1194       /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;1195       I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;1196   
;;;1197       return HAL_OK;
;;;1198     }
;;;1199     else
;;;1200     {
;;;1201       return HAL_BUSY;
;;;1202     }
;;;1203   }
000028  bdfe              POP      {r1-r7,pc}
                  |L25.42|
00002a  bf00              NOP                            ;1158
00002c  2040              MOVS     r0,#0x40              ;1158
00002e  5d00              LDRB     r0,[r0,r4]            ;1158
000030  2801              CMP      r0,#1                 ;1158
000032  d101              BNE      |L25.56|
000034  2002              MOVS     r0,#2                 ;1158
000036  e7f7              B        |L25.40|
                  |L25.56|
000038  2101              MOVS     r1,#1                 ;1158
00003a  2040              MOVS     r0,#0x40              ;1158
00003c  5501              STRB     r1,[r0,r4]            ;1158
00003e  bf00              NOP                            ;1158
000040  2121              MOVS     r1,#0x21              ;1160
000042  2041              MOVS     r0,#0x41              ;1160
000044  5501              STRB     r1,[r0,r4]            ;1160
000046  2110              MOVS     r1,#0x10              ;1161
000048  2042              MOVS     r0,#0x42              ;1161
00004a  5501              STRB     r1,[r0,r4]            ;1161
00004c  2000              MOVS     r0,#0                 ;1162
00004e  6460              STR      r0,[r4,#0x44]         ;1162
000050  6265              STR      r5,[r4,#0x24]         ;1165
000052  8566              STRH     r6,[r4,#0x2a]         ;1166
000054  4813              LDR      r0,|L25.164|
000056  62e0              STR      r0,[r4,#0x2c]         ;1167
000058  4813              LDR      r0,|L25.168|
00005a  6360              STR      r0,[r4,#0x34]         ;1168
00005c  8d60              LDRH     r0,[r4,#0x2a]         ;1170
00005e  28ff              CMP      r0,#0xff              ;1170
000060  d904              BLS      |L25.108|
000062  20ff              MOVS     r0,#0xff              ;1172
000064  8520              STRH     r0,[r4,#0x28]         ;1172
000066  0508              LSLS     r0,r1,#20             ;1173
000068  9001              STR      r0,[sp,#4]            ;1173
00006a  e004              B        |L25.118|
                  |L25.108|
00006c  8d60              LDRH     r0,[r4,#0x2a]         ;1177
00006e  8520              STRH     r0,[r4,#0x28]         ;1177
000070  2001              MOVS     r0,#1                 ;1178
000072  0640              LSLS     r0,r0,#25             ;1178
000074  9001              STR      r0,[sp,#4]            ;1178
                  |L25.118|
000076  2001              MOVS     r0,#1                 ;1183
000078  0340              LSLS     r0,r0,#13             ;1183
00007a  9000              STR      r0,[sp,#0]            ;1183
00007c  8d20              LDRH     r0,[r4,#0x28]         ;1183
00007e  b2c2              UXTB     r2,r0                 ;1183
000080  4639              MOV      r1,r7                 ;1183
000082  4620              MOV      r0,r4                 ;1183
000084  9b01              LDR      r3,[sp,#4]            ;1183
000086  f7fffffe          BL       I2C_TransferConfig
00008a  bf00              NOP                            ;1186
00008c  2100              MOVS     r1,#0                 ;1186
00008e  2040              MOVS     r0,#0x40              ;1186
000090  5501              STRB     r1,[r0,r4]            ;1186
000092  bf00              NOP                            ;1186
000094  2101              MOVS     r1,#1                 ;1195
000096  4620              MOV      r0,r4                 ;1195
000098  f7fffffe          BL       I2C_Enable_IRQ
00009c  2000              MOVS     r0,#0                 ;1197
00009e  e7c3              B        |L25.40|
                  |L25.160|
0000a0  2002              MOVS     r0,#2                 ;1201
0000a2  e7c1              B        |L25.40|
;;;1204   
                          ENDP

                  |L25.164|
                          DCD      0xffff0000
                  |L25.168|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_MemRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemRxCpltCallback PROC
;;;3145     */
;;;3146   __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3147   {
;;;3148     /* Prevent unused argument(s) compilation warning */
;;;3149     UNUSED(hi2c);
;;;3150   
;;;3151     /* NOTE : This function should not be modified, when the callback is needed,
;;;3152               the HAL_I2C_MemRxCpltCallback could be implemented in the user file
;;;3153      */
;;;3154   }
;;;3155   
                          ENDP


                          AREA ||i.HAL_I2C_MemTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MemTxCpltCallback PROC
;;;3129     */
;;;3130   __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3131   {
;;;3132     /* Prevent unused argument(s) compilation warning */
;;;3133     UNUSED(hi2c);
;;;3134   
;;;3135     /* NOTE : This function should not be modified, when the callback is needed,
;;;3136               the HAL_I2C_MemTxCpltCallback could be implemented in the user file
;;;3137      */
;;;3138   }
;;;3139   
                          ENDP


                          AREA ||i.HAL_I2C_Mem_Read||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read PROC
;;;1882     */
;;;1883   HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1884   {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
000006  9f0c              LDR      r7,[sp,#0x30]
000008  9e0e              LDR      r6,[sp,#0x38]
;;;1885     uint32_t tickstart = 0U;
00000a  2500              MOVS     r5,#0
;;;1886   
;;;1887     /* Check the parameters */
;;;1888     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;1889   
;;;1890     if(hi2c->State == HAL_I2C_STATE_READY)
00000c  2041              MOVS     r0,#0x41
00000e  5d00              LDRB     r0,[r0,r4]
000010  2820              CMP      r0,#0x20
000012  d171              BNE      |L28.248|
;;;1891     {
;;;1892       if((pData == NULL) || (Size == 0U))
000014  2f00              CMP      r7,#0
000016  d002              BEQ      |L28.30|
000018  980d              LDR      r0,[sp,#0x34]
00001a  2800              CMP      r0,#0
00001c  d102              BNE      |L28.36|
                  |L28.30|
;;;1893       {
;;;1894         return  HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L28.32|
;;;1895       }
;;;1896   
;;;1897       /* Process Locked */
;;;1898       __HAL_LOCK(hi2c);
;;;1899   
;;;1900       /* Init tickstart for timeout management*/
;;;1901       tickstart = HAL_GetTick();
;;;1902   
;;;1903       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
;;;1904       {
;;;1905         return HAL_TIMEOUT;
;;;1906       }
;;;1907   
;;;1908       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;1909       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;1910       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1911   
;;;1912       /* Prepare transfer parameters */
;;;1913       hi2c->pBuffPtr  = pData;
;;;1914       hi2c->XferCount = Size;
;;;1915       hi2c->XferISR   = NULL;
;;;1916   
;;;1917       /* Send Slave Address and Memory Address */
;;;1918       if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
;;;1919       {
;;;1920         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1921         {
;;;1922           /* Process Unlocked */
;;;1923           __HAL_UNLOCK(hi2c);
;;;1924           return HAL_ERROR;
;;;1925         }
;;;1926         else
;;;1927         {
;;;1928           /* Process Unlocked */
;;;1929           __HAL_UNLOCK(hi2c);
;;;1930           return HAL_TIMEOUT;
;;;1931         }
;;;1932       }
;;;1933   
;;;1934       /* Send Slave Address */
;;;1935       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;1936       if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1937       {
;;;1938         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1939         I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
;;;1940       }
;;;1941       else
;;;1942       {
;;;1943         hi2c->XferSize = hi2c->XferCount;
;;;1944         I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
;;;1945       }
;;;1946   
;;;1947       do
;;;1948       {
;;;1949         /* Wait until RXNE flag is set */
;;;1950         if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
;;;1951         {
;;;1952           return HAL_TIMEOUT;
;;;1953         }
;;;1954   
;;;1955         /* Read data from RXDR */
;;;1956         (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
;;;1957         hi2c->XferSize--;
;;;1958         hi2c->XferCount--;
;;;1959   
;;;1960         if((hi2c->XferSize == 0U) && (hi2c->XferCount != 0U))
;;;1961         {
;;;1962           /* Wait until TCR flag is set */
;;;1963           if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
;;;1964           {
;;;1965             return HAL_TIMEOUT;
;;;1966           }
;;;1967   
;;;1968           if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1969           {
;;;1970             hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1971             I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
;;;1972           }
;;;1973           else
;;;1974           {
;;;1975             hi2c->XferSize = hi2c->XferCount;
;;;1976             I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
;;;1977           }
;;;1978         }
;;;1979       }while(hi2c->XferCount > 0U);
;;;1980   
;;;1981       /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
;;;1982       /* Wait until STOPF flag is reset */ 
;;;1983       if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1984       {
;;;1985         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1986         {
;;;1987           return HAL_ERROR;
;;;1988         }
;;;1989         else
;;;1990         {
;;;1991           return HAL_TIMEOUT;
;;;1992         }
;;;1993       }
;;;1994   
;;;1995       /* Clear STOP Flag */
;;;1996       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;1997   
;;;1998       /* Clear Configuration Register 2 */
;;;1999       I2C_RESET_CR2(hi2c);
;;;2000   
;;;2001       hi2c->State = HAL_I2C_STATE_READY;
;;;2002       hi2c->Mode  = HAL_I2C_MODE_NONE;
;;;2003   
;;;2004       /* Process Unlocked */
;;;2005       __HAL_UNLOCK(hi2c);
;;;2006   
;;;2007       return HAL_OK;
;;;2008     }
;;;2009     else
;;;2010     {
;;;2011       return HAL_BUSY;
;;;2012     }
;;;2013   }
000020  b007              ADD      sp,sp,#0x1c
000022  bdf0              POP      {r4-r7,pc}
                  |L28.36|
000024  bf00              NOP                            ;1898
000026  2040              MOVS     r0,#0x40              ;1898
000028  5d00              LDRB     r0,[r0,r4]            ;1898
00002a  2801              CMP      r0,#1                 ;1898
00002c  d101              BNE      |L28.50|
00002e  2002              MOVS     r0,#2                 ;1898
000030  e7f6              B        |L28.32|
                  |L28.50|
000032  2101              MOVS     r1,#1                 ;1898
000034  2040              MOVS     r0,#0x40              ;1898
000036  5501              STRB     r1,[r0,r4]            ;1898
000038  bf00              NOP                            ;1898
00003a  f7fffffe          BL       HAL_GetTick
00003e  4605              MOV      r5,r0                 ;1901
000040  2319              MOVS     r3,#0x19              ;1903
000042  2201              MOVS     r2,#1                 ;1903
000044  03d1              LSLS     r1,r2,#15             ;1903
000046  4620              MOV      r0,r4                 ;1903
000048  9500              STR      r5,[sp,#0]            ;1903
00004a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00004e  2800              CMP      r0,#0                 ;1903
000050  d001              BEQ      |L28.86|
000052  2003              MOVS     r0,#3                 ;1905
000054  e7e4              B        |L28.32|
                  |L28.86|
000056  2122              MOVS     r1,#0x22              ;1908
000058  2041              MOVS     r0,#0x41              ;1908
00005a  5501              STRB     r1,[r0,r4]            ;1908
00005c  2140              MOVS     r1,#0x40              ;1909
00005e  2042              MOVS     r0,#0x42              ;1909
000060  5501              STRB     r1,[r0,r4]            ;1909
000062  2000              MOVS     r0,#0                 ;1910
000064  6460              STR      r0,[r4,#0x44]         ;1910
000066  6267              STR      r7,[r4,#0x24]         ;1913
000068  980d              LDR      r0,[sp,#0x34]         ;1914
00006a  8560              STRH     r0,[r4,#0x2a]         ;1914
00006c  2000              MOVS     r0,#0                 ;1915
00006e  6360              STR      r0,[r4,#0x34]         ;1915
000070  9600              STR      r6,[sp,#0]            ;1918
000072  9501              STR      r5,[sp,#4]            ;1918
000074  4620              MOV      r0,r4                 ;1918
000076  a904              ADD      r1,sp,#0x10           ;1918
000078  c90e              LDM      r1,{r1-r3}            ;1918
00007a  f7fffffe          BL       I2C_RequestMemoryRead
00007e  2800              CMP      r0,#0                 ;1918
000080  d010              BEQ      |L28.164|
000082  6c60              LDR      r0,[r4,#0x44]         ;1920
000084  2804              CMP      r0,#4                 ;1920
000086  d106              BNE      |L28.150|
000088  bf00              NOP                            ;1923
00008a  2100              MOVS     r1,#0                 ;1923
00008c  2040              MOVS     r0,#0x40              ;1923
00008e  5501              STRB     r1,[r0,r4]            ;1923
000090  bf00              NOP                            ;1923
000092  2001              MOVS     r0,#1                 ;1924
000094  e7c4              B        |L28.32|
                  |L28.150|
000096  bf00              NOP                            ;1929
000098  2100              MOVS     r1,#0                 ;1929
00009a  2040              MOVS     r0,#0x40              ;1929
00009c  5501              STRB     r1,[r0,r4]            ;1929
00009e  bf00              NOP                            ;1929
0000a0  2003              MOVS     r0,#3                 ;1930
0000a2  e7bd              B        |L28.32|
                  |L28.164|
0000a4  8d60              LDRH     r0,[r4,#0x2a]         ;1936
0000a6  28ff              CMP      r0,#0xff              ;1936
0000a8  d90d              BLS      |L28.198|
0000aa  20ff              MOVS     r0,#0xff              ;1938
0000ac  8520              STRH     r0,[r4,#0x28]         ;1938
0000ae  2009              MOVS     r0,#9                 ;1939
0000b0  0280              LSLS     r0,r0,#10             ;1939
0000b2  9000              STR      r0,[sp,#0]            ;1939
0000b4  8d20              LDRH     r0,[r4,#0x28]         ;1939
0000b6  b2c2              UXTB     r2,r0                 ;1939
0000b8  2301              MOVS     r3,#1                 ;1939
0000ba  061b              LSLS     r3,r3,#24             ;1939
0000bc  4620              MOV      r0,r4                 ;1939
0000be  9904              LDR      r1,[sp,#0x10]         ;1939
0000c0  f7fffffe          BL       I2C_TransferConfig
0000c4  e00c              B        |L28.224|
                  |L28.198|
0000c6  8d60              LDRH     r0,[r4,#0x2a]         ;1943
0000c8  8520              STRH     r0,[r4,#0x28]         ;1943
0000ca  2009              MOVS     r0,#9                 ;1944
0000cc  0280              LSLS     r0,r0,#10             ;1944
0000ce  9000              STR      r0,[sp,#0]            ;1944
0000d0  8d20              LDRH     r0,[r4,#0x28]         ;1944
0000d2  b2c2              UXTB     r2,r0                 ;1944
0000d4  2301              MOVS     r3,#1                 ;1944
0000d6  065b              LSLS     r3,r3,#25             ;1944
0000d8  4620              MOV      r0,r4                 ;1944
0000da  9904              LDR      r1,[sp,#0x10]         ;1944
0000dc  f7fffffe          BL       I2C_TransferConfig
                  |L28.224|
0000e0  bf00              NOP                            ;1947
                  |L28.226|
0000e2  4633              MOV      r3,r6                 ;1950
0000e4  2200              MOVS     r2,#0                 ;1950
0000e6  2104              MOVS     r1,#4                 ;1950
0000e8  4620              MOV      r0,r4                 ;1950
0000ea  9500              STR      r5,[sp,#0]            ;1950
0000ec  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000f0  2800              CMP      r0,#0                 ;1950
0000f2  d002              BEQ      |L28.250|
0000f4  2003              MOVS     r0,#3                 ;1952
0000f6  e793              B        |L28.32|
                  |L28.248|
0000f8  e05f              B        |L28.442|
                  |L28.250|
0000fa  6820              LDR      r0,[r4,#0]            ;1956
0000fc  6a40              LDR      r0,[r0,#0x24]         ;1956
0000fe  b2c1              UXTB     r1,r0                 ;1956
000100  6a62              LDR      r2,[r4,#0x24]         ;1956
000102  1c50              ADDS     r0,r2,#1              ;1956
000104  6260              STR      r0,[r4,#0x24]         ;1956
000106  7011              STRB     r1,[r2,#0]            ;1956
000108  8d20              LDRH     r0,[r4,#0x28]         ;1957
00010a  1e40              SUBS     r0,r0,#1              ;1957
00010c  8520              STRH     r0,[r4,#0x28]         ;1957
00010e  8d60              LDRH     r0,[r4,#0x2a]         ;1958
000110  1e40              SUBS     r0,r0,#1              ;1958
000112  8560              STRH     r0,[r4,#0x2a]         ;1958
000114  8d20              LDRH     r0,[r4,#0x28]         ;1960
000116  2800              CMP      r0,#0                 ;1960
000118  d129              BNE      |L28.366|
00011a  8d60              LDRH     r0,[r4,#0x2a]         ;1960
00011c  2800              CMP      r0,#0                 ;1960
00011e  d026              BEQ      |L28.366|
000120  4633              MOV      r3,r6                 ;1963
000122  2200              MOVS     r2,#0                 ;1963
000124  2180              MOVS     r1,#0x80              ;1963
000126  4620              MOV      r0,r4                 ;1963
000128  9500              STR      r5,[sp,#0]            ;1963
00012a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00012e  2800              CMP      r0,#0                 ;1963
000130  d001              BEQ      |L28.310|
000132  2003              MOVS     r0,#3                 ;1965
000134  e774              B        |L28.32|
                  |L28.310|
000136  8d60              LDRH     r0,[r4,#0x2a]         ;1968
000138  28ff              CMP      r0,#0xff              ;1968
00013a  d90c              BLS      |L28.342|
00013c  20ff              MOVS     r0,#0xff              ;1970
00013e  8520              STRH     r0,[r4,#0x28]         ;1970
000140  2000              MOVS     r0,#0                 ;1971
000142  9000              STR      r0,[sp,#0]            ;1971
000144  8d20              LDRH     r0,[r4,#0x28]         ;1971
000146  b2c2              UXTB     r2,r0                 ;1971
000148  2301              MOVS     r3,#1                 ;1971
00014a  061b              LSLS     r3,r3,#24             ;1971
00014c  4620              MOV      r0,r4                 ;1971
00014e  9904              LDR      r1,[sp,#0x10]         ;1971
000150  f7fffffe          BL       I2C_TransferConfig
000154  e00b              B        |L28.366|
                  |L28.342|
000156  8d60              LDRH     r0,[r4,#0x2a]         ;1975
000158  8520              STRH     r0,[r4,#0x28]         ;1975
00015a  2000              MOVS     r0,#0                 ;1976
00015c  9000              STR      r0,[sp,#0]            ;1976
00015e  8d20              LDRH     r0,[r4,#0x28]         ;1976
000160  b2c2              UXTB     r2,r0                 ;1976
000162  2301              MOVS     r3,#1                 ;1976
000164  065b              LSLS     r3,r3,#25             ;1976
000166  4620              MOV      r0,r4                 ;1976
000168  9904              LDR      r1,[sp,#0x10]         ;1976
00016a  f7fffffe          BL       I2C_TransferConfig
                  |L28.366|
00016e  8d60              LDRH     r0,[r4,#0x2a]         ;1979
000170  2800              CMP      r0,#0                 ;1979
000172  d1b6              BNE      |L28.226|
000174  462a              MOV      r2,r5                 ;1983
000176  4631              MOV      r1,r6                 ;1983
000178  4620              MOV      r0,r4                 ;1983
00017a  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
00017e  2800              CMP      r0,#0                 ;1983
000180  d006              BEQ      |L28.400|
000182  6c60              LDR      r0,[r4,#0x44]         ;1985
000184  2804              CMP      r0,#4                 ;1985
000186  d101              BNE      |L28.396|
000188  2001              MOVS     r0,#1                 ;1987
00018a  e749              B        |L28.32|
                  |L28.396|
00018c  2003              MOVS     r0,#3                 ;1991
00018e  e747              B        |L28.32|
                  |L28.400|
000190  2020              MOVS     r0,#0x20              ;1996
000192  6821              LDR      r1,[r4,#0]            ;1996
000194  61c8              STR      r0,[r1,#0x1c]         ;1996
000196  6820              LDR      r0,[r4,#0]            ;1999
000198  6840              LDR      r0,[r0,#4]            ;1999
00019a  4909              LDR      r1,|L28.448|
00019c  4008              ANDS     r0,r0,r1              ;1999
00019e  6821              LDR      r1,[r4,#0]            ;1999
0001a0  6048              STR      r0,[r1,#4]            ;1999
0001a2  2120              MOVS     r1,#0x20              ;2001
0001a4  2041              MOVS     r0,#0x41              ;2001
0001a6  5501              STRB     r1,[r0,r4]            ;2001
0001a8  2100              MOVS     r1,#0                 ;2002
0001aa  2042              MOVS     r0,#0x42              ;2002
0001ac  5501              STRB     r1,[r0,r4]            ;2002
0001ae  bf00              NOP                            ;2005
0001b0  2040              MOVS     r0,#0x40              ;2005
0001b2  5501              STRB     r1,[r0,r4]            ;2005
0001b4  bf00              NOP                            ;2005
0001b6  2000              MOVS     r0,#0                 ;2007
0001b8  e732              B        |L28.32|
                  |L28.442|
0001ba  2002              MOVS     r0,#2                 ;2011
0001bc  e730              B        |L28.32|
;;;2014   /**
                          ENDP

0001be  0000              DCW      0x0000
                  |L28.448|
                          DCD      0xfe00e800

                          AREA ||i.HAL_I2C_Mem_Read_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_DMA PROC
;;;2338     */
;;;2339   HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  b5ff              PUSH     {r0-r7,lr}
;;;2340   {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
000006  9e0d              LDR      r6,[sp,#0x34]
000008  9d0c              LDR      r5,[sp,#0x30]
;;;2341     uint32_t tickstart = 0U;
00000a  2700              MOVS     r7,#0
;;;2342     uint32_t xfermode = 0U;
00000c  2000              MOVS     r0,#0
00000e  9002              STR      r0,[sp,#8]
;;;2343   
;;;2344     /* Check the parameters */
;;;2345     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2346   
;;;2347     if(hi2c->State == HAL_I2C_STATE_READY)
000010  2041              MOVS     r0,#0x41
000012  5d00              LDRB     r0,[r0,r4]
000014  2820              CMP      r0,#0x20
000016  d17d              BNE      |L29.276|
;;;2348     {
;;;2349       if((pData == NULL) || (Size == 0U))
000018  2d00              CMP      r5,#0
00001a  d001              BEQ      |L29.32|
00001c  2e00              CMP      r6,#0
00001e  d102              BNE      |L29.38|
                  |L29.32|
;;;2350       {
;;;2351         return  HAL_ERROR;
000020  2001              MOVS     r0,#1
                  |L29.34|
;;;2352       }
;;;2353   
;;;2354       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
;;;2355       {
;;;2356         return HAL_BUSY;
;;;2357       }
;;;2358   
;;;2359       /* Process Locked */
;;;2360       __HAL_LOCK(hi2c);
;;;2361   
;;;2362       /* Init tickstart for timeout management*/
;;;2363       tickstart = HAL_GetTick();
;;;2364   
;;;2365       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;2366       hi2c->Mode        = HAL_I2C_MODE_MEM;
;;;2367       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;2368   
;;;2369       /* Prepare transfer parameters */
;;;2370       hi2c->pBuffPtr    = pData;
;;;2371       hi2c->XferCount   = Size;
;;;2372       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2373       hi2c->XferISR     = I2C_Master_ISR_DMA;
;;;2374   
;;;2375       if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2376       {
;;;2377         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2378         xfermode = I2C_RELOAD_MODE;
;;;2379       }
;;;2380       else
;;;2381       {
;;;2382         hi2c->XferSize = hi2c->XferCount;
;;;2383         xfermode = I2C_AUTOEND_MODE;
;;;2384       }
;;;2385   
;;;2386       /* Send Slave Address and Memory Address */
;;;2387       if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;2388       {
;;;2389         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2390         {
;;;2391           /* Process Unlocked */
;;;2392           __HAL_UNLOCK(hi2c);
;;;2393           return HAL_ERROR;
;;;2394         }
;;;2395         else
;;;2396         {
;;;2397           /* Process Unlocked */
;;;2398           __HAL_UNLOCK(hi2c);
;;;2399           return HAL_TIMEOUT;
;;;2400         }
;;;2401       }
;;;2402   
;;;2403       /* Set the I2C DMA transfer complete callback */
;;;2404       hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
;;;2405   
;;;2406       /* Set the DMA error callback */
;;;2407       hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;2408   
;;;2409       /* Set the unused DMA callbacks to NULL */
;;;2410       hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;2411       hi2c->hdmarx->XferAbortCallback = NULL;
;;;2412   
;;;2413       /* Enable the DMA channel */
;;;2414       HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
;;;2415   
;;;2416       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;2417       I2C_TransferConfig(hi2c,DevAddress, hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
;;;2418   
;;;2419       /* Update XferCount value */
;;;2420       hi2c->XferCount -= hi2c->XferSize;
;;;2421   
;;;2422       /* Process Unlocked */
;;;2423       __HAL_UNLOCK(hi2c);
;;;2424   
;;;2425       /* Enable DMA Request */
;;;2426       hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
;;;2427   
;;;2428       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2429                 to avoid the risk of I2C interrupt handle execution before current
;;;2430                 process unlock */
;;;2431       /* Enable ERR and NACK interrupts */
;;;2432       I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
;;;2433   
;;;2434       return HAL_OK;
;;;2435     }
;;;2436     else
;;;2437     {
;;;2438       return HAL_BUSY;
;;;2439     }
;;;2440   }
000022  b007              ADD      sp,sp,#0x1c
000024  bdf0              POP      {r4-r7,pc}
                  |L29.38|
000026  6820              LDR      r0,[r4,#0]            ;2354
000028  6980              LDR      r0,[r0,#0x18]         ;2354
00002a  2101              MOVS     r1,#1                 ;2354
00002c  03c9              LSLS     r1,r1,#15             ;2354
00002e  4008              ANDS     r0,r0,r1              ;2354
000030  0bc0              LSRS     r0,r0,#15             ;2354
000032  2800              CMP      r0,#0                 ;2354
000034  d001              BEQ      |L29.58|
000036  2002              MOVS     r0,#2                 ;2356
000038  e7f3              B        |L29.34|
                  |L29.58|
00003a  bf00              NOP                            ;2360
00003c  2040              MOVS     r0,#0x40              ;2360
00003e  5d00              LDRB     r0,[r0,r4]            ;2360
000040  2801              CMP      r0,#1                 ;2360
000042  d101              BNE      |L29.72|
000044  2002              MOVS     r0,#2                 ;2360
000046  e7ec              B        |L29.34|
                  |L29.72|
000048  2101              MOVS     r1,#1                 ;2360
00004a  2040              MOVS     r0,#0x40              ;2360
00004c  5501              STRB     r1,[r0,r4]            ;2360
00004e  bf00              NOP                            ;2360
000050  f7fffffe          BL       HAL_GetTick
000054  4607              MOV      r7,r0                 ;2363
000056  2122              MOVS     r1,#0x22              ;2365
000058  2041              MOVS     r0,#0x41              ;2365
00005a  5501              STRB     r1,[r0,r4]            ;2365
00005c  2140              MOVS     r1,#0x40              ;2366
00005e  2042              MOVS     r0,#0x42              ;2366
000060  5501              STRB     r1,[r0,r4]            ;2366
000062  2000              MOVS     r0,#0                 ;2367
000064  6460              STR      r0,[r4,#0x44]         ;2367
000066  6265              STR      r5,[r4,#0x24]         ;2370
000068  8566              STRH     r6,[r4,#0x2a]         ;2371
00006a  4831              LDR      r0,|L29.304|
00006c  62e0              STR      r0,[r4,#0x2c]         ;2372
00006e  4831              LDR      r0,|L29.308|
000070  6360              STR      r0,[r4,#0x34]         ;2373
000072  8d60              LDRH     r0,[r4,#0x2a]         ;2375
000074  28ff              CMP      r0,#0xff              ;2375
000076  d904              BLS      |L29.130|
000078  20ff              MOVS     r0,#0xff              ;2377
00007a  8520              STRH     r0,[r4,#0x28]         ;2377
00007c  0488              LSLS     r0,r1,#18             ;2378
00007e  9002              STR      r0,[sp,#8]            ;2378
000080  e004              B        |L29.140|
                  |L29.130|
000082  8d60              LDRH     r0,[r4,#0x2a]         ;2382
000084  8520              STRH     r0,[r4,#0x28]         ;2382
000086  2001              MOVS     r0,#1                 ;2383
000088  0640              LSLS     r0,r0,#25             ;2383
00008a  9002              STR      r0,[sp,#8]            ;2383
                  |L29.140|
00008c  2019              MOVS     r0,#0x19              ;2387
00008e  9701              STR      r7,[sp,#4]            ;2387
000090  9000              STR      r0,[sp,#0]            ;2387
000092  4620              MOV      r0,r4                 ;2387
000094  a904              ADD      r1,sp,#0x10           ;2387
000096  c90e              LDM      r1,{r1-r3}            ;2387
000098  f7fffffe          BL       I2C_RequestMemoryRead
00009c  2800              CMP      r0,#0                 ;2387
00009e  d010              BEQ      |L29.194|
0000a0  6c60              LDR      r0,[r4,#0x44]         ;2389
0000a2  2804              CMP      r0,#4                 ;2389
0000a4  d106              BNE      |L29.180|
0000a6  bf00              NOP                            ;2392
0000a8  2100              MOVS     r1,#0                 ;2392
0000aa  2040              MOVS     r0,#0x40              ;2392
0000ac  5501              STRB     r1,[r0,r4]            ;2392
0000ae  bf00              NOP                            ;2392
0000b0  2001              MOVS     r0,#1                 ;2393
0000b2  e7b6              B        |L29.34|
                  |L29.180|
0000b4  bf00              NOP                            ;2398
0000b6  2100              MOVS     r1,#0                 ;2398
0000b8  2040              MOVS     r0,#0x40              ;2398
0000ba  5501              STRB     r1,[r0,r4]            ;2398
0000bc  bf00              NOP                            ;2398
0000be  2003              MOVS     r0,#3                 ;2399
0000c0  e7af              B        |L29.34|
                  |L29.194|
0000c2  481d              LDR      r0,|L29.312|
0000c4  6be1              LDR      r1,[r4,#0x3c]         ;2404
0000c6  6288              STR      r0,[r1,#0x28]         ;2404
0000c8  481c              LDR      r0,|L29.316|
0000ca  6be1              LDR      r1,[r4,#0x3c]         ;2407
0000cc  6308              STR      r0,[r1,#0x30]         ;2407
0000ce  2000              MOVS     r0,#0                 ;2410
0000d0  6be1              LDR      r1,[r4,#0x3c]         ;2410
0000d2  62c8              STR      r0,[r1,#0x2c]         ;2410
0000d4  6be1              LDR      r1,[r4,#0x3c]         ;2411
0000d6  6348              STR      r0,[r1,#0x34]         ;2411
0000d8  8d23              LDRH     r3,[r4,#0x28]         ;2414
0000da  6822              LDR      r2,[r4,#0]            ;2414
0000dc  4611              MOV      r1,r2                 ;2414
0000de  3124              ADDS     r1,r1,#0x24           ;2414
0000e0  462a              MOV      r2,r5                 ;2414
0000e2  6be0              LDR      r0,[r4,#0x3c]         ;2414
0000e4  f7fffffe          BL       HAL_DMA_Start_IT
0000e8  2009              MOVS     r0,#9                 ;2417
0000ea  0280              LSLS     r0,r0,#10             ;2417
0000ec  9000              STR      r0,[sp,#0]            ;2417
0000ee  8d20              LDRH     r0,[r4,#0x28]         ;2417
0000f0  b2c2              UXTB     r2,r0                 ;2417
0000f2  4620              MOV      r0,r4                 ;2417
0000f4  9b02              LDR      r3,[sp,#8]            ;2417
0000f6  9904              LDR      r1,[sp,#0x10]         ;2417
0000f8  f7fffffe          BL       I2C_TransferConfig
0000fc  8d60              LDRH     r0,[r4,#0x2a]         ;2420
0000fe  8d21              LDRH     r1,[r4,#0x28]         ;2420
000100  1a40              SUBS     r0,r0,r1              ;2420
000102  8560              STRH     r0,[r4,#0x2a]         ;2420
000104  bf00              NOP                            ;2423
000106  2100              MOVS     r1,#0                 ;2423
000108  2040              MOVS     r0,#0x40              ;2423
00010a  5501              STRB     r1,[r0,r4]            ;2423
00010c  bf00              NOP                            ;2423
00010e  6820              LDR      r0,[r4,#0]            ;2426
000110  6800              LDR      r0,[r0,#0]            ;2426
000112  e000              B        |L29.278|
                  |L29.276|
000114  e00a              B        |L29.300|
                  |L29.278|
000116  2101              MOVS     r1,#1                 ;2426
000118  03c9              LSLS     r1,r1,#15             ;2426
00011a  4308              ORRS     r0,r0,r1              ;2426
00011c  6821              LDR      r1,[r4,#0]            ;2426
00011e  6008              STR      r0,[r1,#0]            ;2426
000120  2111              MOVS     r1,#0x11              ;2432
000122  4620              MOV      r0,r4                 ;2432
000124  f7fffffe          BL       I2C_Enable_IRQ
000128  2000              MOVS     r0,#0                 ;2434
00012a  e77a              B        |L29.34|
                  |L29.300|
00012c  2002              MOVS     r0,#2                 ;2438
00012e  e778              B        |L29.34|
;;;2441   
                          ENDP

                  |L29.304|
                          DCD      0xffff0000
                  |L29.308|
                          DCD      I2C_Master_ISR_DMA
                  |L29.312|
                          DCD      I2C_DMAMasterReceiveCplt
                  |L29.316|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Mem_Read_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Read_IT PROC
;;;2124     */
;;;2125   HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  b5ff              PUSH     {r0-r7,lr}
;;;2126   {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  9e0f              LDR      r6,[sp,#0x3c]
00000a  9d0e              LDR      r5,[sp,#0x38]
;;;2127     uint32_t tickstart = 0U;
00000c  2000              MOVS     r0,#0
00000e  9004              STR      r0,[sp,#0x10]
;;;2128     uint32_t xfermode = 0U;
000010  9003              STR      r0,[sp,#0xc]
;;;2129   
;;;2130     /* Check the parameters */
;;;2131     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2132   
;;;2133     if(hi2c->State == HAL_I2C_STATE_READY)
000012  2041              MOVS     r0,#0x41
000014  5d00              LDRB     r0,[r0,r4]
000016  2820              CMP      r0,#0x20
000018  d16b              BNE      |L30.242|
;;;2134     {
;;;2135       if((pData == NULL) || (Size == 0U))
00001a  2d00              CMP      r5,#0
00001c  d001              BEQ      |L30.34|
00001e  2e00              CMP      r6,#0
000020  d102              BNE      |L30.40|
                  |L30.34|
;;;2136       {
;;;2137         return  HAL_ERROR;
000022  2001              MOVS     r0,#1
                  |L30.36|
;;;2138       }
;;;2139       
;;;2140       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
;;;2141       {
;;;2142         return HAL_BUSY;
;;;2143       }
;;;2144   
;;;2145       /* Process Locked */
;;;2146       __HAL_LOCK(hi2c);
;;;2147   
;;;2148       /* Init tickstart for timeout management*/
;;;2149       tickstart = HAL_GetTick();
;;;2150   
;;;2151       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;2152       hi2c->Mode        = HAL_I2C_MODE_MEM;
;;;2153       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;2154   
;;;2155       /* Prepare transfer parameters */
;;;2156       hi2c->pBuffPtr    = pData;
;;;2157       hi2c->XferCount   = Size;
;;;2158       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2159       hi2c->XferISR     = I2C_Master_ISR_IT;
;;;2160       
;;;2161       if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2162       {
;;;2163         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2164         xfermode = I2C_RELOAD_MODE;
;;;2165       }
;;;2166       else
;;;2167       {
;;;2168         hi2c->XferSize = hi2c->XferCount;
;;;2169         xfermode = I2C_AUTOEND_MODE;
;;;2170       }
;;;2171   
;;;2172       /* Send Slave Address and Memory Address */
;;;2173       if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;2174       {
;;;2175         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2176         {
;;;2177           /* Process Unlocked */
;;;2178           __HAL_UNLOCK(hi2c);
;;;2179           return HAL_ERROR;
;;;2180         }
;;;2181         else
;;;2182         {
;;;2183           /* Process Unlocked */
;;;2184           __HAL_UNLOCK(hi2c);
;;;2185           return HAL_TIMEOUT;
;;;2186         }
;;;2187       }
;;;2188   
;;;2189       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;2190       I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
;;;2191   
;;;2192       /* Process Unlocked */
;;;2193       __HAL_UNLOCK(hi2c);
;;;2194   
;;;2195       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2196                 to avoid the risk of I2C interrupt handle execution before current
;;;2197                 process unlock */
;;;2198   
;;;2199       /* Enable ERR, TC, STOP, NACK, RXI interrupt */
;;;2200       /* possible to enable all of these */
;;;2201       /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;2202       I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
;;;2203   
;;;2204       return HAL_OK;
;;;2205     }
;;;2206     else
;;;2207     {
;;;2208       return HAL_BUSY;
;;;2209     }
;;;2210   }
000024  b009              ADD      sp,sp,#0x24
000026  bdf0              POP      {r4-r7,pc}
                  |L30.40|
000028  6820              LDR      r0,[r4,#0]            ;2140
00002a  6980              LDR      r0,[r0,#0x18]         ;2140
00002c  2101              MOVS     r1,#1                 ;2140
00002e  03c9              LSLS     r1,r1,#15             ;2140
000030  4008              ANDS     r0,r0,r1              ;2140
000032  0bc0              LSRS     r0,r0,#15             ;2140
000034  2800              CMP      r0,#0                 ;2140
000036  d001              BEQ      |L30.60|
000038  2002              MOVS     r0,#2                 ;2142
00003a  e7f3              B        |L30.36|
                  |L30.60|
00003c  bf00              NOP                            ;2146
00003e  2040              MOVS     r0,#0x40              ;2146
000040  5d00              LDRB     r0,[r0,r4]            ;2146
000042  2801              CMP      r0,#1                 ;2146
000044  d101              BNE      |L30.74|
000046  2002              MOVS     r0,#2                 ;2146
000048  e7ec              B        |L30.36|
                  |L30.74|
00004a  2101              MOVS     r1,#1                 ;2146
00004c  2040              MOVS     r0,#0x40              ;2146
00004e  5501              STRB     r1,[r0,r4]            ;2146
000050  bf00              NOP                            ;2146
000052  f7fffffe          BL       HAL_GetTick
000056  9004              STR      r0,[sp,#0x10]         ;2149
000058  2122              MOVS     r1,#0x22              ;2151
00005a  2041              MOVS     r0,#0x41              ;2151
00005c  5501              STRB     r1,[r0,r4]            ;2151
00005e  2140              MOVS     r1,#0x40              ;2152
000060  2042              MOVS     r0,#0x42              ;2152
000062  5501              STRB     r1,[r0,r4]            ;2152
000064  2000              MOVS     r0,#0                 ;2153
000066  6460              STR      r0,[r4,#0x44]         ;2153
000068  6265              STR      r5,[r4,#0x24]         ;2156
00006a  8566              STRH     r6,[r4,#0x2a]         ;2157
00006c  4822              LDR      r0,|L30.248|
00006e  62e0              STR      r0,[r4,#0x2c]         ;2158
000070  4822              LDR      r0,|L30.252|
000072  6360              STR      r0,[r4,#0x34]         ;2159
000074  8d60              LDRH     r0,[r4,#0x2a]         ;2161
000076  28ff              CMP      r0,#0xff              ;2161
000078  d904              BLS      |L30.132|
00007a  20ff              MOVS     r0,#0xff              ;2163
00007c  8520              STRH     r0,[r4,#0x28]         ;2163
00007e  0488              LSLS     r0,r1,#18             ;2164
000080  9003              STR      r0,[sp,#0xc]          ;2164
000082  e004              B        |L30.142|
                  |L30.132|
000084  8d60              LDRH     r0,[r4,#0x2a]         ;2168
000086  8520              STRH     r0,[r4,#0x28]         ;2168
000088  2001              MOVS     r0,#1                 ;2169
00008a  0640              LSLS     r0,r0,#25             ;2169
00008c  9003              STR      r0,[sp,#0xc]          ;2169
                  |L30.142|
00008e  2119              MOVS     r1,#0x19              ;2173
000090  9804              LDR      r0,[sp,#0x10]         ;2173
000092  9100              STR      r1,[sp,#0]            ;2173
000094  9001              STR      r0,[sp,#4]            ;2173
000096  4639              MOV      r1,r7                 ;2173
000098  4620              MOV      r0,r4                 ;2173
00009a  9b08              LDR      r3,[sp,#0x20]         ;2173
00009c  9a07              LDR      r2,[sp,#0x1c]         ;2173
00009e  f7fffffe          BL       I2C_RequestMemoryRead
0000a2  2800              CMP      r0,#0                 ;2173
0000a4  d010              BEQ      |L30.200|
0000a6  6c60              LDR      r0,[r4,#0x44]         ;2175
0000a8  2804              CMP      r0,#4                 ;2175
0000aa  d106              BNE      |L30.186|
0000ac  bf00              NOP                            ;2178
0000ae  2100              MOVS     r1,#0                 ;2178
0000b0  2040              MOVS     r0,#0x40              ;2178
0000b2  5501              STRB     r1,[r0,r4]            ;2178
0000b4  bf00              NOP                            ;2178
0000b6  2001              MOVS     r0,#1                 ;2179
0000b8  e7b4              B        |L30.36|
                  |L30.186|
0000ba  bf00              NOP                            ;2184
0000bc  2100              MOVS     r1,#0                 ;2184
0000be  2040              MOVS     r0,#0x40              ;2184
0000c0  5501              STRB     r1,[r0,r4]            ;2184
0000c2  bf00              NOP                            ;2184
0000c4  2003              MOVS     r0,#3                 ;2185
0000c6  e7ad              B        |L30.36|
                  |L30.200|
0000c8  2009              MOVS     r0,#9                 ;2190
0000ca  0280              LSLS     r0,r0,#10             ;2190
0000cc  9000              STR      r0,[sp,#0]            ;2190
0000ce  8d20              LDRH     r0,[r4,#0x28]         ;2190
0000d0  b2c2              UXTB     r2,r0                 ;2190
0000d2  4639              MOV      r1,r7                 ;2190
0000d4  4620              MOV      r0,r4                 ;2190
0000d6  9b03              LDR      r3,[sp,#0xc]          ;2190
0000d8  f7fffffe          BL       I2C_TransferConfig
0000dc  bf00              NOP                            ;2193
0000de  2100              MOVS     r1,#0                 ;2193
0000e0  2040              MOVS     r0,#0x40              ;2193
0000e2  5501              STRB     r1,[r0,r4]            ;2193
0000e4  bf00              NOP                            ;2193
0000e6  2102              MOVS     r1,#2                 ;2202
0000e8  4620              MOV      r0,r4                 ;2202
0000ea  f7fffffe          BL       I2C_Enable_IRQ
0000ee  2000              MOVS     r0,#0                 ;2204
0000f0  e798              B        |L30.36|
                  |L30.242|
0000f2  2002              MOVS     r0,#2                 ;2208
0000f4  e796              B        |L30.36|
;;;2211   /**
                          ENDP

0000f6  0000              DCW      0x0000
                  |L30.248|
                          DCD      0xffff0000
                  |L30.252|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_Mem_Write||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write PROC
;;;1730     */
;;;1731   HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1732   {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
000006  9f0c              LDR      r7,[sp,#0x30]
000008  9e0e              LDR      r6,[sp,#0x38]
;;;1733     uint32_t tickstart = 0U;
00000a  2500              MOVS     r5,#0
;;;1734   
;;;1735     /* Check the parameters */
;;;1736     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;1737   
;;;1738     if(hi2c->State == HAL_I2C_STATE_READY)
00000c  2041              MOVS     r0,#0x41
00000e  5d00              LDRB     r0,[r0,r4]
000010  2820              CMP      r0,#0x20
000012  d170              BNE      |L31.246|
;;;1739     {
;;;1740       if((pData == NULL) || (Size == 0U))
000014  2f00              CMP      r7,#0
000016  d002              BEQ      |L31.30|
000018  980d              LDR      r0,[sp,#0x34]
00001a  2800              CMP      r0,#0
00001c  d102              BNE      |L31.36|
                  |L31.30|
;;;1741       {
;;;1742         return  HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L31.32|
;;;1743       }
;;;1744   
;;;1745       /* Process Locked */
;;;1746       __HAL_LOCK(hi2c);
;;;1747   
;;;1748       /* Init tickstart for timeout management*/
;;;1749       tickstart = HAL_GetTick();
;;;1750   
;;;1751       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
;;;1752       {
;;;1753         return HAL_TIMEOUT;
;;;1754       }
;;;1755   
;;;1756       hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;1757       hi2c->Mode      = HAL_I2C_MODE_MEM;
;;;1758       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1759   
;;;1760       /* Prepare transfer parameters */
;;;1761       hi2c->pBuffPtr  = pData;
;;;1762       hi2c->XferCount = Size;
;;;1763       hi2c->XferISR   = NULL;
;;;1764   
;;;1765       /* Send Slave Address and Memory Address */
;;;1766       if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
;;;1767       {
;;;1768         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1769         {
;;;1770           /* Process Unlocked */
;;;1771           __HAL_UNLOCK(hi2c);
;;;1772           return HAL_ERROR;
;;;1773         }
;;;1774         else
;;;1775         {
;;;1776           /* Process Unlocked */
;;;1777           __HAL_UNLOCK(hi2c);
;;;1778           return HAL_TIMEOUT;
;;;1779         }
;;;1780       }
;;;1781   
;;;1782       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
;;;1783       if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1784       {
;;;1785         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1786         I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
;;;1787       }
;;;1788       else
;;;1789       {
;;;1790         hi2c->XferSize = hi2c->XferCount;
;;;1791         I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
;;;1792       }
;;;1793   
;;;1794       do
;;;1795       {
;;;1796         /* Wait until TXIS flag is set */
;;;1797         if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1798         {
;;;1799           if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1800           {
;;;1801             return HAL_ERROR;
;;;1802           }
;;;1803           else
;;;1804           {
;;;1805             return HAL_TIMEOUT;
;;;1806           }
;;;1807         }
;;;1808   
;;;1809         /* Write data to TXDR */
;;;1810         hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
;;;1811         hi2c->XferCount--;
;;;1812         hi2c->XferSize--;
;;;1813   
;;;1814         if((hi2c->XferSize == 0U) && (hi2c->XferCount!=0U))
;;;1815         {
;;;1816           /* Wait until TCR flag is set */
;;;1817           if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
;;;1818           {
;;;1819             return HAL_TIMEOUT;
;;;1820           }
;;;1821   
;;;1822           if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;1823           {
;;;1824             hi2c->XferSize = MAX_NBYTE_SIZE;
;;;1825             I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
;;;1826           }
;;;1827           else
;;;1828           {
;;;1829             hi2c->XferSize = hi2c->XferCount;
;;;1830             I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
;;;1831           }
;;;1832         }
;;;1833   
;;;1834       }while(hi2c->XferCount > 0U);
;;;1835   
;;;1836       /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
;;;1837       /* Wait until STOPF flag is reset */ 
;;;1838       if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1839       {
;;;1840         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1841         {
;;;1842           return HAL_ERROR;
;;;1843         }
;;;1844         else
;;;1845         {
;;;1846           return HAL_TIMEOUT;
;;;1847         }
;;;1848       }
;;;1849   
;;;1850       /* Clear STOP Flag */
;;;1851       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;1852   
;;;1853       /* Clear Configuration Register 2 */
;;;1854       I2C_RESET_CR2(hi2c);
;;;1855   
;;;1856       hi2c->State = HAL_I2C_STATE_READY;
;;;1857       hi2c->Mode  = HAL_I2C_MODE_NONE;
;;;1858   
;;;1859       /* Process Unlocked */
;;;1860       __HAL_UNLOCK(hi2c);
;;;1861   
;;;1862       return HAL_OK;
;;;1863     }
;;;1864     else
;;;1865     {
;;;1866       return HAL_BUSY;
;;;1867     }
;;;1868   }
000020  b007              ADD      sp,sp,#0x1c
000022  bdf0              POP      {r4-r7,pc}
                  |L31.36|
000024  bf00              NOP                            ;1746
000026  2040              MOVS     r0,#0x40              ;1746
000028  5d00              LDRB     r0,[r0,r4]            ;1746
00002a  2801              CMP      r0,#1                 ;1746
00002c  d101              BNE      |L31.50|
00002e  2002              MOVS     r0,#2                 ;1746
000030  e7f6              B        |L31.32|
                  |L31.50|
000032  2101              MOVS     r1,#1                 ;1746
000034  2040              MOVS     r0,#0x40              ;1746
000036  5501              STRB     r1,[r0,r4]            ;1746
000038  bf00              NOP                            ;1746
00003a  f7fffffe          BL       HAL_GetTick
00003e  4605              MOV      r5,r0                 ;1749
000040  2319              MOVS     r3,#0x19              ;1751
000042  2201              MOVS     r2,#1                 ;1751
000044  03d1              LSLS     r1,r2,#15             ;1751
000046  4620              MOV      r0,r4                 ;1751
000048  9500              STR      r5,[sp,#0]            ;1751
00004a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00004e  2800              CMP      r0,#0                 ;1751
000050  d001              BEQ      |L31.86|
000052  2003              MOVS     r0,#3                 ;1753
000054  e7e4              B        |L31.32|
                  |L31.86|
000056  2121              MOVS     r1,#0x21              ;1756
000058  2041              MOVS     r0,#0x41              ;1756
00005a  5501              STRB     r1,[r0,r4]            ;1756
00005c  2140              MOVS     r1,#0x40              ;1757
00005e  2042              MOVS     r0,#0x42              ;1757
000060  5501              STRB     r1,[r0,r4]            ;1757
000062  2000              MOVS     r0,#0                 ;1758
000064  6460              STR      r0,[r4,#0x44]         ;1758
000066  6267              STR      r7,[r4,#0x24]         ;1761
000068  980d              LDR      r0,[sp,#0x34]         ;1762
00006a  8560              STRH     r0,[r4,#0x2a]         ;1762
00006c  2000              MOVS     r0,#0                 ;1763
00006e  6360              STR      r0,[r4,#0x34]         ;1763
000070  9600              STR      r6,[sp,#0]            ;1766
000072  9501              STR      r5,[sp,#4]            ;1766
000074  4620              MOV      r0,r4                 ;1766
000076  a904              ADD      r1,sp,#0x10           ;1766
000078  c90e              LDM      r1,{r1-r3}            ;1766
00007a  f7fffffe          BL       I2C_RequestMemoryWrite
00007e  2800              CMP      r0,#0                 ;1766
000080  d010              BEQ      |L31.164|
000082  6c60              LDR      r0,[r4,#0x44]         ;1768
000084  2804              CMP      r0,#4                 ;1768
000086  d106              BNE      |L31.150|
000088  bf00              NOP                            ;1771
00008a  2100              MOVS     r1,#0                 ;1771
00008c  2040              MOVS     r0,#0x40              ;1771
00008e  5501              STRB     r1,[r0,r4]            ;1771
000090  bf00              NOP                            ;1771
000092  2001              MOVS     r0,#1                 ;1772
000094  e7c4              B        |L31.32|
                  |L31.150|
000096  bf00              NOP                            ;1777
000098  2100              MOVS     r1,#0                 ;1777
00009a  2040              MOVS     r0,#0x40              ;1777
00009c  5501              STRB     r1,[r0,r4]            ;1777
00009e  bf00              NOP                            ;1777
0000a0  2003              MOVS     r0,#3                 ;1778
0000a2  e7bd              B        |L31.32|
                  |L31.164|
0000a4  8d60              LDRH     r0,[r4,#0x2a]         ;1783
0000a6  28ff              CMP      r0,#0xff              ;1783
0000a8  d90c              BLS      |L31.196|
0000aa  20ff              MOVS     r0,#0xff              ;1785
0000ac  8520              STRH     r0,[r4,#0x28]         ;1785
0000ae  2000              MOVS     r0,#0                 ;1786
0000b0  9000              STR      r0,[sp,#0]            ;1786
0000b2  8d20              LDRH     r0,[r4,#0x28]         ;1786
0000b4  b2c2              UXTB     r2,r0                 ;1786
0000b6  2301              MOVS     r3,#1                 ;1786
0000b8  061b              LSLS     r3,r3,#24             ;1786
0000ba  4620              MOV      r0,r4                 ;1786
0000bc  9904              LDR      r1,[sp,#0x10]         ;1786
0000be  f7fffffe          BL       I2C_TransferConfig
0000c2  e00b              B        |L31.220|
                  |L31.196|
0000c4  8d60              LDRH     r0,[r4,#0x2a]         ;1790
0000c6  8520              STRH     r0,[r4,#0x28]         ;1790
0000c8  2000              MOVS     r0,#0                 ;1791
0000ca  9000              STR      r0,[sp,#0]            ;1791
0000cc  8d20              LDRH     r0,[r4,#0x28]         ;1791
0000ce  b2c2              UXTB     r2,r0                 ;1791
0000d0  2301              MOVS     r3,#1                 ;1791
0000d2  065b              LSLS     r3,r3,#25             ;1791
0000d4  4620              MOV      r0,r4                 ;1791
0000d6  9904              LDR      r1,[sp,#0x10]         ;1791
0000d8  f7fffffe          BL       I2C_TransferConfig
                  |L31.220|
0000dc  bf00              NOP                            ;1794
                  |L31.222|
0000de  462a              MOV      r2,r5                 ;1797
0000e0  4631              MOV      r1,r6                 ;1797
0000e2  4620              MOV      r0,r4                 ;1797
0000e4  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
0000e8  2800              CMP      r0,#0                 ;1797
0000ea  d007              BEQ      |L31.252|
0000ec  6c60              LDR      r0,[r4,#0x44]         ;1799
0000ee  2804              CMP      r0,#4                 ;1799
0000f0  d102              BNE      |L31.248|
0000f2  2001              MOVS     r0,#1                 ;1801
0000f4  e794              B        |L31.32|
                  |L31.246|
0000f6  e060              B        |L31.442|
                  |L31.248|
0000f8  2003              MOVS     r0,#3                 ;1805
0000fa  e791              B        |L31.32|
                  |L31.252|
0000fc  6a61              LDR      r1,[r4,#0x24]         ;1810
0000fe  1c48              ADDS     r0,r1,#1              ;1810
000100  6260              STR      r0,[r4,#0x24]         ;1810
000102  7808              LDRB     r0,[r1,#0]            ;1810
000104  6821              LDR      r1,[r4,#0]            ;1810
000106  6288              STR      r0,[r1,#0x28]         ;1810
000108  8d60              LDRH     r0,[r4,#0x2a]         ;1811
00010a  1e40              SUBS     r0,r0,#1              ;1811
00010c  8560              STRH     r0,[r4,#0x2a]         ;1811
00010e  8d20              LDRH     r0,[r4,#0x28]         ;1812
000110  1e40              SUBS     r0,r0,#1              ;1812
000112  8520              STRH     r0,[r4,#0x28]         ;1812
000114  8d20              LDRH     r0,[r4,#0x28]         ;1814
000116  2800              CMP      r0,#0                 ;1814
000118  d129              BNE      |L31.366|
00011a  8d60              LDRH     r0,[r4,#0x2a]         ;1814
00011c  2800              CMP      r0,#0                 ;1814
00011e  d026              BEQ      |L31.366|
000120  4633              MOV      r3,r6                 ;1817
000122  2200              MOVS     r2,#0                 ;1817
000124  2180              MOVS     r1,#0x80              ;1817
000126  4620              MOV      r0,r4                 ;1817
000128  9500              STR      r5,[sp,#0]            ;1817
00012a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00012e  2800              CMP      r0,#0                 ;1817
000130  d001              BEQ      |L31.310|
000132  2003              MOVS     r0,#3                 ;1819
000134  e774              B        |L31.32|
                  |L31.310|
000136  8d60              LDRH     r0,[r4,#0x2a]         ;1822
000138  28ff              CMP      r0,#0xff              ;1822
00013a  d90c              BLS      |L31.342|
00013c  20ff              MOVS     r0,#0xff              ;1824
00013e  8520              STRH     r0,[r4,#0x28]         ;1824
000140  2000              MOVS     r0,#0                 ;1825
000142  9000              STR      r0,[sp,#0]            ;1825
000144  8d20              LDRH     r0,[r4,#0x28]         ;1825
000146  b2c2              UXTB     r2,r0                 ;1825
000148  2301              MOVS     r3,#1                 ;1825
00014a  061b              LSLS     r3,r3,#24             ;1825
00014c  4620              MOV      r0,r4                 ;1825
00014e  9904              LDR      r1,[sp,#0x10]         ;1825
000150  f7fffffe          BL       I2C_TransferConfig
000154  e00b              B        |L31.366|
                  |L31.342|
000156  8d60              LDRH     r0,[r4,#0x2a]         ;1829
000158  8520              STRH     r0,[r4,#0x28]         ;1829
00015a  2000              MOVS     r0,#0                 ;1830
00015c  9000              STR      r0,[sp,#0]            ;1830
00015e  8d20              LDRH     r0,[r4,#0x28]         ;1830
000160  b2c2              UXTB     r2,r0                 ;1830
000162  2301              MOVS     r3,#1                 ;1830
000164  065b              LSLS     r3,r3,#25             ;1830
000166  4620              MOV      r0,r4                 ;1830
000168  9904              LDR      r1,[sp,#0x10]         ;1830
00016a  f7fffffe          BL       I2C_TransferConfig
                  |L31.366|
00016e  8d60              LDRH     r0,[r4,#0x2a]         ;1834
000170  2800              CMP      r0,#0                 ;1834
000172  d1b4              BNE      |L31.222|
000174  462a              MOV      r2,r5                 ;1838
000176  4631              MOV      r1,r6                 ;1838
000178  4620              MOV      r0,r4                 ;1838
00017a  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
00017e  2800              CMP      r0,#0                 ;1838
000180  d006              BEQ      |L31.400|
000182  6c60              LDR      r0,[r4,#0x44]         ;1840
000184  2804              CMP      r0,#4                 ;1840
000186  d101              BNE      |L31.396|
000188  2001              MOVS     r0,#1                 ;1842
00018a  e749              B        |L31.32|
                  |L31.396|
00018c  2003              MOVS     r0,#3                 ;1846
00018e  e747              B        |L31.32|
                  |L31.400|
000190  2020              MOVS     r0,#0x20              ;1851
000192  6821              LDR      r1,[r4,#0]            ;1851
000194  61c8              STR      r0,[r1,#0x1c]         ;1851
000196  6820              LDR      r0,[r4,#0]            ;1854
000198  6840              LDR      r0,[r0,#4]            ;1854
00019a  4909              LDR      r1,|L31.448|
00019c  4008              ANDS     r0,r0,r1              ;1854
00019e  6821              LDR      r1,[r4,#0]            ;1854
0001a0  6048              STR      r0,[r1,#4]            ;1854
0001a2  2120              MOVS     r1,#0x20              ;1856
0001a4  2041              MOVS     r0,#0x41              ;1856
0001a6  5501              STRB     r1,[r0,r4]            ;1856
0001a8  2100              MOVS     r1,#0                 ;1857
0001aa  2042              MOVS     r0,#0x42              ;1857
0001ac  5501              STRB     r1,[r0,r4]            ;1857
0001ae  bf00              NOP                            ;1860
0001b0  2040              MOVS     r0,#0x40              ;1860
0001b2  5501              STRB     r1,[r0,r4]            ;1860
0001b4  bf00              NOP                            ;1860
0001b6  2000              MOVS     r0,#0                 ;1862
0001b8  e732              B        |L31.32|
                  |L31.442|
0001ba  2002              MOVS     r0,#2                 ;1866
0001bc  e730              B        |L31.32|
;;;1869   
                          ENDP

0001be  0000              DCW      0x0000
                  |L31.448|
                          DCD      0xfe00e800

                          AREA ||i.HAL_I2C_Mem_Write_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_DMA PROC
;;;2222     */
;;;2223   HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  b5ff              PUSH     {r0-r7,lr}
;;;2224   {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
000006  9e0d              LDR      r6,[sp,#0x34]
000008  9d0c              LDR      r5,[sp,#0x30]
;;;2225     uint32_t tickstart = 0U;
00000a  2700              MOVS     r7,#0
;;;2226     uint32_t xfermode = 0U;
00000c  2000              MOVS     r0,#0
00000e  9002              STR      r0,[sp,#8]
;;;2227   
;;;2228     /* Check the parameters */
;;;2229     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2230   
;;;2231     if(hi2c->State == HAL_I2C_STATE_READY)
000010  2041              MOVS     r0,#0x41
000012  5d00              LDRB     r0,[r0,r4]
000014  2820              CMP      r0,#0x20
000016  d17c              BNE      |L32.274|
;;;2232     {
;;;2233       if((pData == NULL) || (Size == 0U))
000018  2d00              CMP      r5,#0
00001a  d001              BEQ      |L32.32|
00001c  2e00              CMP      r6,#0
00001e  d102              BNE      |L32.38|
                  |L32.32|
;;;2234       {
;;;2235         return  HAL_ERROR;
000020  2001              MOVS     r0,#1
                  |L32.34|
;;;2236       }
;;;2237   
;;;2238       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
;;;2239       {
;;;2240         return HAL_BUSY;
;;;2241       }
;;;2242   
;;;2243       /* Process Locked */
;;;2244       __HAL_LOCK(hi2c);
;;;2245   
;;;2246       /* Init tickstart for timeout management*/
;;;2247       tickstart = HAL_GetTick();
;;;2248   
;;;2249       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;2250       hi2c->Mode        = HAL_I2C_MODE_MEM;
;;;2251       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;2252   
;;;2253       /* Prepare transfer parameters */
;;;2254       hi2c->pBuffPtr    = pData;
;;;2255       hi2c->XferCount   = Size;
;;;2256       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2257       hi2c->XferISR     = I2C_Master_ISR_DMA;
;;;2258       
;;;2259       if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2260       {
;;;2261         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2262         xfermode = I2C_RELOAD_MODE;
;;;2263       }
;;;2264       else
;;;2265       {
;;;2266         hi2c->XferSize = hi2c->XferCount;
;;;2267         xfermode = I2C_AUTOEND_MODE;
;;;2268       }
;;;2269   
;;;2270       /* Send Slave Address and Memory Address */
;;;2271       if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;2272       {
;;;2273         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2274         {
;;;2275           /* Process Unlocked */
;;;2276           __HAL_UNLOCK(hi2c);
;;;2277           return HAL_ERROR;
;;;2278         }
;;;2279         else
;;;2280         {
;;;2281           /* Process Unlocked */
;;;2282           __HAL_UNLOCK(hi2c);
;;;2283           return HAL_TIMEOUT;
;;;2284         }
;;;2285       }
;;;2286   
;;;2287       /* Set the I2C DMA transfer complete callback */
;;;2288       hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
;;;2289   
;;;2290       /* Set the DMA error callback */
;;;2291       hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;2292   
;;;2293       /* Set the unused DMA callbacks to NULL */
;;;2294       hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;2295       hi2c->hdmatx->XferAbortCallback = NULL;
;;;2296   
;;;2297       /* Enable the DMA channel */
;;;2298       HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
;;;2299   
;;;2300       /* Send Slave Address */
;;;2301       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;2302       I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
;;;2303   
;;;2304       /* Update XferCount value */
;;;2305       hi2c->XferCount -= hi2c->XferSize;
;;;2306   
;;;2307       /* Process Unlocked */
;;;2308       __HAL_UNLOCK(hi2c);
;;;2309   
;;;2310       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2311                 to avoid the risk of I2C interrupt handle execution before current
;;;2312                 process unlock */
;;;2313       /* Enable ERR and NACK interrupts */
;;;2314       I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
;;;2315   
;;;2316       /* Enable DMA Request */
;;;2317       hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
;;;2318   
;;;2319       return HAL_OK;
;;;2320     }
;;;2321     else
;;;2322     {
;;;2323       return HAL_BUSY;
;;;2324     }
;;;2325   }
000022  b007              ADD      sp,sp,#0x1c
000024  bdf0              POP      {r4-r7,pc}
                  |L32.38|
000026  6820              LDR      r0,[r4,#0]            ;2238
000028  6980              LDR      r0,[r0,#0x18]         ;2238
00002a  2101              MOVS     r1,#1                 ;2238
00002c  03c9              LSLS     r1,r1,#15             ;2238
00002e  4008              ANDS     r0,r0,r1              ;2238
000030  0bc0              LSRS     r0,r0,#15             ;2238
000032  2800              CMP      r0,#0                 ;2238
000034  d001              BEQ      |L32.58|
000036  2002              MOVS     r0,#2                 ;2240
000038  e7f3              B        |L32.34|
                  |L32.58|
00003a  bf00              NOP                            ;2244
00003c  2040              MOVS     r0,#0x40              ;2244
00003e  5d00              LDRB     r0,[r0,r4]            ;2244
000040  2801              CMP      r0,#1                 ;2244
000042  d101              BNE      |L32.72|
000044  2002              MOVS     r0,#2                 ;2244
000046  e7ec              B        |L32.34|
                  |L32.72|
000048  2101              MOVS     r1,#1                 ;2244
00004a  2040              MOVS     r0,#0x40              ;2244
00004c  5501              STRB     r1,[r0,r4]            ;2244
00004e  bf00              NOP                            ;2244
000050  f7fffffe          BL       HAL_GetTick
000054  4607              MOV      r7,r0                 ;2247
000056  2121              MOVS     r1,#0x21              ;2249
000058  2041              MOVS     r0,#0x41              ;2249
00005a  5501              STRB     r1,[r0,r4]            ;2249
00005c  2140              MOVS     r1,#0x40              ;2250
00005e  2042              MOVS     r0,#0x42              ;2250
000060  5501              STRB     r1,[r0,r4]            ;2250
000062  2000              MOVS     r0,#0                 ;2251
000064  6460              STR      r0,[r4,#0x44]         ;2251
000066  6265              STR      r5,[r4,#0x24]         ;2254
000068  8566              STRH     r6,[r4,#0x2a]         ;2255
00006a  4831              LDR      r0,|L32.304|
00006c  62e0              STR      r0,[r4,#0x2c]         ;2256
00006e  4831              LDR      r0,|L32.308|
000070  6360              STR      r0,[r4,#0x34]         ;2257
000072  8d60              LDRH     r0,[r4,#0x2a]         ;2259
000074  28ff              CMP      r0,#0xff              ;2259
000076  d904              BLS      |L32.130|
000078  20ff              MOVS     r0,#0xff              ;2261
00007a  8520              STRH     r0,[r4,#0x28]         ;2261
00007c  0488              LSLS     r0,r1,#18             ;2262
00007e  9002              STR      r0,[sp,#8]            ;2262
000080  e004              B        |L32.140|
                  |L32.130|
000082  8d60              LDRH     r0,[r4,#0x2a]         ;2266
000084  8520              STRH     r0,[r4,#0x28]         ;2266
000086  2001              MOVS     r0,#1                 ;2267
000088  0640              LSLS     r0,r0,#25             ;2267
00008a  9002              STR      r0,[sp,#8]            ;2267
                  |L32.140|
00008c  2019              MOVS     r0,#0x19              ;2271
00008e  9701              STR      r7,[sp,#4]            ;2271
000090  9000              STR      r0,[sp,#0]            ;2271
000092  4620              MOV      r0,r4                 ;2271
000094  a904              ADD      r1,sp,#0x10           ;2271
000096  c90e              LDM      r1,{r1-r3}            ;2271
000098  f7fffffe          BL       I2C_RequestMemoryWrite
00009c  2800              CMP      r0,#0                 ;2271
00009e  d010              BEQ      |L32.194|
0000a0  6c60              LDR      r0,[r4,#0x44]         ;2273
0000a2  2804              CMP      r0,#4                 ;2273
0000a4  d106              BNE      |L32.180|
0000a6  bf00              NOP                            ;2276
0000a8  2100              MOVS     r1,#0                 ;2276
0000aa  2040              MOVS     r0,#0x40              ;2276
0000ac  5501              STRB     r1,[r0,r4]            ;2276
0000ae  bf00              NOP                            ;2276
0000b0  2001              MOVS     r0,#1                 ;2277
0000b2  e7b6              B        |L32.34|
                  |L32.180|
0000b4  bf00              NOP                            ;2282
0000b6  2100              MOVS     r1,#0                 ;2282
0000b8  2040              MOVS     r0,#0x40              ;2282
0000ba  5501              STRB     r1,[r0,r4]            ;2282
0000bc  bf00              NOP                            ;2282
0000be  2003              MOVS     r0,#3                 ;2283
0000c0  e7af              B        |L32.34|
                  |L32.194|
0000c2  481d              LDR      r0,|L32.312|
0000c4  6ba1              LDR      r1,[r4,#0x38]         ;2288
0000c6  6288              STR      r0,[r1,#0x28]         ;2288
0000c8  481c              LDR      r0,|L32.316|
0000ca  6ba1              LDR      r1,[r4,#0x38]         ;2291
0000cc  6308              STR      r0,[r1,#0x30]         ;2291
0000ce  2000              MOVS     r0,#0                 ;2294
0000d0  6ba1              LDR      r1,[r4,#0x38]         ;2294
0000d2  62c8              STR      r0,[r1,#0x2c]         ;2294
0000d4  6ba1              LDR      r1,[r4,#0x38]         ;2295
0000d6  6348              STR      r0,[r1,#0x34]         ;2295
0000d8  8d23              LDRH     r3,[r4,#0x28]         ;2298
0000da  6821              LDR      r1,[r4,#0]            ;2298
0000dc  460a              MOV      r2,r1                 ;2298
0000de  3228              ADDS     r2,r2,#0x28           ;2298
0000e0  4629              MOV      r1,r5                 ;2298
0000e2  6ba0              LDR      r0,[r4,#0x38]         ;2298
0000e4  f7fffffe          BL       HAL_DMA_Start_IT
0000e8  2000              MOVS     r0,#0                 ;2302
0000ea  9000              STR      r0,[sp,#0]            ;2302
0000ec  8d20              LDRH     r0,[r4,#0x28]         ;2302
0000ee  b2c2              UXTB     r2,r0                 ;2302
0000f0  4620              MOV      r0,r4                 ;2302
0000f2  9b02              LDR      r3,[sp,#8]            ;2302
0000f4  9904              LDR      r1,[sp,#0x10]         ;2302
0000f6  f7fffffe          BL       I2C_TransferConfig
0000fa  8d60              LDRH     r0,[r4,#0x2a]         ;2305
0000fc  8d21              LDRH     r1,[r4,#0x28]         ;2305
0000fe  1a40              SUBS     r0,r0,r1              ;2305
000100  8560              STRH     r0,[r4,#0x2a]         ;2305
000102  bf00              NOP                            ;2308
000104  2100              MOVS     r1,#0                 ;2308
000106  2040              MOVS     r0,#0x40              ;2308
000108  5501              STRB     r1,[r0,r4]            ;2308
00010a  bf00              NOP                            ;2308
00010c  2111              MOVS     r1,#0x11              ;2314
00010e  4620              MOV      r0,r4                 ;2314
000110  e000              B        |L32.276|
                  |L32.274|
000112  e00a              B        |L32.298|
                  |L32.276|
000114  f7fffffe          BL       I2C_Enable_IRQ
000118  6820              LDR      r0,[r4,#0]            ;2317
00011a  6800              LDR      r0,[r0,#0]            ;2317
00011c  2101              MOVS     r1,#1                 ;2317
00011e  0389              LSLS     r1,r1,#14             ;2317
000120  4308              ORRS     r0,r0,r1              ;2317
000122  6821              LDR      r1,[r4,#0]            ;2317
000124  6008              STR      r0,[r1,#0]            ;2317
000126  2000              MOVS     r0,#0                 ;2319
000128  e77b              B        |L32.34|
                  |L32.298|
00012a  2002              MOVS     r0,#2                 ;2323
00012c  e779              B        |L32.34|
;;;2326   
                          ENDP

00012e  0000              DCW      0x0000
                  |L32.304|
                          DCD      0xffff0000
                  |L32.308|
                          DCD      I2C_Master_ISR_DMA
                  |L32.312|
                          DCD      I2C_DMAMasterTransmitCplt
                  |L32.316|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Mem_Write_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Mem_Write_IT PROC
;;;2025     */
;;;2026   HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
000000  b5ff              PUSH     {r0-r7,lr}
;;;2027   {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  9e0f              LDR      r6,[sp,#0x3c]
00000a  9d0e              LDR      r5,[sp,#0x38]
;;;2028     uint32_t tickstart = 0U;
00000c  2000              MOVS     r0,#0
00000e  9004              STR      r0,[sp,#0x10]
;;;2029     uint32_t xfermode = 0U;
000010  9003              STR      r0,[sp,#0xc]
;;;2030   
;;;2031     /* Check the parameters */
;;;2032     assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
;;;2033   
;;;2034     if(hi2c->State == HAL_I2C_STATE_READY)
000012  2041              MOVS     r0,#0x41
000014  5d00              LDRB     r0,[r0,r4]
000016  2820              CMP      r0,#0x20
000018  d16a              BNE      |L33.240|
;;;2035     {
;;;2036       if((pData == NULL) || (Size == 0U))
00001a  2d00              CMP      r5,#0
00001c  d001              BEQ      |L33.34|
00001e  2e00              CMP      r6,#0
000020  d102              BNE      |L33.40|
                  |L33.34|
;;;2037       {
;;;2038         return  HAL_ERROR;
000022  2001              MOVS     r0,#1
                  |L33.36|
;;;2039       }
;;;2040       
;;;2041       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
;;;2042       {
;;;2043         return HAL_BUSY;
;;;2044       }
;;;2045   
;;;2046       /* Process Locked */
;;;2047       __HAL_LOCK(hi2c);
;;;2048   
;;;2049       /* Init tickstart for timeout management*/
;;;2050       tickstart = HAL_GetTick();
;;;2051   
;;;2052       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;2053       hi2c->Mode        = HAL_I2C_MODE_MEM;
;;;2054       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;2055   
;;;2056       /* Prepare transfer parameters */
;;;2057       hi2c->pBuffPtr    = pData;
;;;2058       hi2c->XferCount   = Size;
;;;2059       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;2060       hi2c->XferISR     = I2C_Master_ISR_IT;
;;;2061       
;;;2062       if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;2063       {
;;;2064         hi2c->XferSize = MAX_NBYTE_SIZE;
;;;2065         xfermode = I2C_RELOAD_MODE;
;;;2066       }
;;;2067       else
;;;2068       {
;;;2069         hi2c->XferSize = hi2c->XferCount;
;;;2070         xfermode = I2C_AUTOEND_MODE;
;;;2071       }
;;;2072   
;;;2073       /* Send Slave Address and Memory Address */
;;;2074       if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
;;;2075       {
;;;2076         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;2077         {
;;;2078           /* Process Unlocked */
;;;2079           __HAL_UNLOCK(hi2c);
;;;2080           return HAL_ERROR;
;;;2081         }
;;;2082         else
;;;2083         {
;;;2084           /* Process Unlocked */
;;;2085           __HAL_UNLOCK(hi2c);
;;;2086           return HAL_TIMEOUT;
;;;2087         }
;;;2088       }
;;;2089   
;;;2090       /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
;;;2091       I2C_TransferConfig(hi2c,DevAddress, hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
;;;2092   
;;;2093       /* Process Unlocked */
;;;2094       __HAL_UNLOCK(hi2c); 
;;;2095   
;;;2096       /* Note : The I2C interrupts must be enabled after unlocking current process 
;;;2097                 to avoid the risk of I2C interrupt handle execution before current
;;;2098                 process unlock */
;;;2099   
;;;2100       /* Enable ERR, TC, STOP, NACK, TXI interrupt */
;;;2101       /* possible to enable all of these */
;;;2102       /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;2103       I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;2104   
;;;2105       return HAL_OK;
;;;2106     }
;;;2107     else
;;;2108     {
;;;2109       return HAL_BUSY;
;;;2110     }
;;;2111   }
000024  b009              ADD      sp,sp,#0x24
000026  bdf0              POP      {r4-r7,pc}
                  |L33.40|
000028  6820              LDR      r0,[r4,#0]            ;2041
00002a  6980              LDR      r0,[r0,#0x18]         ;2041
00002c  2101              MOVS     r1,#1                 ;2041
00002e  03c9              LSLS     r1,r1,#15             ;2041
000030  4008              ANDS     r0,r0,r1              ;2041
000032  0bc0              LSRS     r0,r0,#15             ;2041
000034  2800              CMP      r0,#0                 ;2041
000036  d001              BEQ      |L33.60|
000038  2002              MOVS     r0,#2                 ;2043
00003a  e7f3              B        |L33.36|
                  |L33.60|
00003c  bf00              NOP                            ;2047
00003e  2040              MOVS     r0,#0x40              ;2047
000040  5d00              LDRB     r0,[r0,r4]            ;2047
000042  2801              CMP      r0,#1                 ;2047
000044  d101              BNE      |L33.74|
000046  2002              MOVS     r0,#2                 ;2047
000048  e7ec              B        |L33.36|
                  |L33.74|
00004a  2101              MOVS     r1,#1                 ;2047
00004c  2040              MOVS     r0,#0x40              ;2047
00004e  5501              STRB     r1,[r0,r4]            ;2047
000050  bf00              NOP                            ;2047
000052  f7fffffe          BL       HAL_GetTick
000056  9004              STR      r0,[sp,#0x10]         ;2050
000058  2121              MOVS     r1,#0x21              ;2052
00005a  2041              MOVS     r0,#0x41              ;2052
00005c  5501              STRB     r1,[r0,r4]            ;2052
00005e  2140              MOVS     r1,#0x40              ;2053
000060  2042              MOVS     r0,#0x42              ;2053
000062  5501              STRB     r1,[r0,r4]            ;2053
000064  2000              MOVS     r0,#0                 ;2054
000066  6460              STR      r0,[r4,#0x44]         ;2054
000068  6265              STR      r5,[r4,#0x24]         ;2057
00006a  8566              STRH     r6,[r4,#0x2a]         ;2058
00006c  4821              LDR      r0,|L33.244|
00006e  62e0              STR      r0,[r4,#0x2c]         ;2059
000070  4821              LDR      r0,|L33.248|
000072  6360              STR      r0,[r4,#0x34]         ;2060
000074  8d60              LDRH     r0,[r4,#0x2a]         ;2062
000076  28ff              CMP      r0,#0xff              ;2062
000078  d904              BLS      |L33.132|
00007a  20ff              MOVS     r0,#0xff              ;2064
00007c  8520              STRH     r0,[r4,#0x28]         ;2064
00007e  0488              LSLS     r0,r1,#18             ;2065
000080  9003              STR      r0,[sp,#0xc]          ;2065
000082  e004              B        |L33.142|
                  |L33.132|
000084  8d60              LDRH     r0,[r4,#0x2a]         ;2069
000086  8520              STRH     r0,[r4,#0x28]         ;2069
000088  2001              MOVS     r0,#1                 ;2070
00008a  0640              LSLS     r0,r0,#25             ;2070
00008c  9003              STR      r0,[sp,#0xc]          ;2070
                  |L33.142|
00008e  2119              MOVS     r1,#0x19              ;2074
000090  9804              LDR      r0,[sp,#0x10]         ;2074
000092  9100              STR      r1,[sp,#0]            ;2074
000094  9001              STR      r0,[sp,#4]            ;2074
000096  4639              MOV      r1,r7                 ;2074
000098  4620              MOV      r0,r4                 ;2074
00009a  9b08              LDR      r3,[sp,#0x20]         ;2074
00009c  9a07              LDR      r2,[sp,#0x1c]         ;2074
00009e  f7fffffe          BL       I2C_RequestMemoryWrite
0000a2  2800              CMP      r0,#0                 ;2074
0000a4  d010              BEQ      |L33.200|
0000a6  6c60              LDR      r0,[r4,#0x44]         ;2076
0000a8  2804              CMP      r0,#4                 ;2076
0000aa  d106              BNE      |L33.186|
0000ac  bf00              NOP                            ;2079
0000ae  2100              MOVS     r1,#0                 ;2079
0000b0  2040              MOVS     r0,#0x40              ;2079
0000b2  5501              STRB     r1,[r0,r4]            ;2079
0000b4  bf00              NOP                            ;2079
0000b6  2001              MOVS     r0,#1                 ;2080
0000b8  e7b4              B        |L33.36|
                  |L33.186|
0000ba  bf00              NOP                            ;2085
0000bc  2100              MOVS     r1,#0                 ;2085
0000be  2040              MOVS     r0,#0x40              ;2085
0000c0  5501              STRB     r1,[r0,r4]            ;2085
0000c2  bf00              NOP                            ;2085
0000c4  2003              MOVS     r0,#3                 ;2086
0000c6  e7ad              B        |L33.36|
                  |L33.200|
0000c8  2000              MOVS     r0,#0                 ;2091
0000ca  9000              STR      r0,[sp,#0]            ;2091
0000cc  8d20              LDRH     r0,[r4,#0x28]         ;2091
0000ce  b2c2              UXTB     r2,r0                 ;2091
0000d0  4639              MOV      r1,r7                 ;2091
0000d2  4620              MOV      r0,r4                 ;2091
0000d4  9b03              LDR      r3,[sp,#0xc]          ;2091
0000d6  f7fffffe          BL       I2C_TransferConfig
0000da  bf00              NOP                            ;2094
0000dc  2100              MOVS     r1,#0                 ;2094
0000de  2040              MOVS     r0,#0x40              ;2094
0000e0  5501              STRB     r1,[r0,r4]            ;2094
0000e2  bf00              NOP                            ;2094
0000e4  2101              MOVS     r1,#1                 ;2103
0000e6  4620              MOV      r0,r4                 ;2103
0000e8  f7fffffe          BL       I2C_Enable_IRQ
0000ec  2000              MOVS     r0,#0                 ;2105
0000ee  e799              B        |L33.36|
                  |L33.240|
0000f0  2002              MOVS     r0,#2                 ;2109
0000f2  e797              B        |L33.36|
;;;2112   
                          ENDP

                  |L33.244|
                          DCD      0xffff0000
                  |L33.248|
                          DCD      I2C_Master_ISR_IT

                          AREA ||i.HAL_I2C_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspDeInit PROC
;;;542      */
;;;543    __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;544    {
;;;545      /* Prevent unused argument(s) compilation warning */
;;;546      UNUSED(hi2c);
;;;547    
;;;548      /* NOTE : This function should not be modified, when the callback is needed,
;;;549                the HAL_I2C_MspDeInit could be implemented in the user file
;;;550       */
;;;551    }
;;;552    
                          ENDP


                          AREA ||i.HAL_I2C_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_MspInit PROC
;;;526      */
;;;527    __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;528    {
;;;529      /* Prevent unused argument(s) compilation warning */
;;;530      UNUSED(hi2c);
;;;531    
;;;532      /* NOTE : This function should not be modified, when the callback is needed,
;;;533                the HAL_I2C_MspInit could be implemented in the user file
;;;534       */
;;;535    }
;;;536    
                          ENDP


                          AREA ||i.HAL_I2C_SlaveRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveRxCpltCallback PROC
;;;3077     */
;;;3078   __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3079   {
;;;3080     /* Prevent unused argument(s) compilation warning */
;;;3081     UNUSED(hi2c);
;;;3082   
;;;3083     /* NOTE : This function should not be modified, when the callback is needed,
;;;3084               the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
;;;3085      */
;;;3086   }
;;;3087   
                          ENDP


                          AREA ||i.HAL_I2C_SlaveTxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_I2C_SlaveTxCpltCallback PROC
;;;3061     */
;;;3062   __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
000000  4770              BX       lr
;;;3063   {
;;;3064     /* Prevent unused argument(s) compilation warning */
;;;3065     UNUSED(hi2c);
;;;3066   
;;;3067     /* NOTE : This function should not be modified, when the callback is needed,
;;;3068               the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
;;;3069      */
;;;3070   }
;;;3071   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Receive||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Slave_Receive PROC
;;;1013     */
;;;1014   HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1015   {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1016     uint32_t tickstart = 0U;
00000a  2500              MOVS     r5,#0
;;;1017   
;;;1018     if(hi2c->State == HAL_I2C_STATE_READY)
00000c  2041              MOVS     r0,#0x41
00000e  5d00              LDRB     r0,[r0,r4]
000010  2820              CMP      r0,#0x20
000012  d171              BNE      |L38.248|
;;;1019     {
;;;1020       if((pData == NULL) || (Size == 0U))
000014  2e00              CMP      r6,#0
000016  d001              BEQ      |L38.28|
000018  2f00              CMP      r7,#0
00001a  d102              BNE      |L38.34|
                  |L38.28|
;;;1021       {
;;;1022         return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L38.30|
;;;1023       }
;;;1024       /* Process Locked */
;;;1025       __HAL_LOCK(hi2c);
;;;1026   
;;;1027       /* Init tickstart for timeout management*/
;;;1028       tickstart = HAL_GetTick();
;;;1029   
;;;1030       hi2c->State     = HAL_I2C_STATE_BUSY_RX;
;;;1031       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;1032       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;1033   
;;;1034       /* Prepare transfer parameters */
;;;1035       hi2c->pBuffPtr  = pData;
;;;1036       hi2c->XferCount = Size;
;;;1037       hi2c->XferISR   = NULL;
;;;1038   
;;;1039       /* Enable Address Acknowledge */
;;;1040       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;1041   
;;;1042       /* Wait until ADDR flag is set */
;;;1043       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;1044       {
;;;1045         /* Disable Address Acknowledge */
;;;1046         hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1047         return HAL_TIMEOUT;
;;;1048       }
;;;1049   
;;;1050       /* Clear ADDR flag */
;;;1051       __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
;;;1052   
;;;1053       /* Wait until DIR flag is reset Receiver mode */
;;;1054       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)
;;;1055       {
;;;1056         /* Disable Address Acknowledge */
;;;1057         hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1058         return HAL_TIMEOUT;
;;;1059       }
;;;1060   
;;;1061       while(hi2c->XferCount > 0U)
;;;1062       {
;;;1063         /* Wait until RXNE flag is set */
;;;1064         if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1065         {
;;;1066           /* Disable Address Acknowledge */
;;;1067           hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1068   
;;;1069           /* Store Last receive data if any */
;;;1070           if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
;;;1071           {
;;;1072             /* Read data from RXDR */
;;;1073             (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
;;;1074             hi2c->XferCount--;
;;;1075           }
;;;1076   
;;;1077           if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
;;;1078           {
;;;1079             return HAL_TIMEOUT;
;;;1080           }
;;;1081           else
;;;1082           {
;;;1083             return HAL_ERROR;
;;;1084           }
;;;1085         }
;;;1086   
;;;1087         /* Read data from RXDR */
;;;1088         (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
;;;1089         hi2c->XferCount--;
;;;1090       }
;;;1091   
;;;1092       /* Wait until STOP flag is set */
;;;1093       if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;1094       {
;;;1095         /* Disable Address Acknowledge */
;;;1096         hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1097   
;;;1098         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;1099         {
;;;1100           return HAL_ERROR;
;;;1101         }
;;;1102         else
;;;1103         {
;;;1104           return HAL_TIMEOUT;
;;;1105         }
;;;1106       }
;;;1107   
;;;1108       /* Clear STOP flag */
;;;1109       __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
;;;1110   
;;;1111       /* Wait until BUSY flag is reset */
;;;1112       if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
;;;1113       {
;;;1114         /* Disable Address Acknowledge */
;;;1115         hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1116         return HAL_TIMEOUT;
;;;1117       }
;;;1118   
;;;1119       /* Disable Address Acknowledge */
;;;1120       hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;1121   
;;;1122       hi2c->State = HAL_I2C_STATE_READY;
;;;1123       hi2c->Mode  = HAL_I2C_MODE_NONE;
;;;1124   
;;;1125       /* Process Unlocked */
;;;1126       __HAL_UNLOCK(hi2c);
;;;1127   
;;;1128       return HAL_OK;
;;;1129     }
;;;1130     else
;;;1131     {
;;;1132       return HAL_BUSY;
;;;1133     }
;;;1134   }
00001e  b005              ADD      sp,sp,#0x14
000020  bdf0              POP      {r4-r7,pc}
                  |L38.34|
000022  bf00              NOP                            ;1025
000024  2040              MOVS     r0,#0x40              ;1025
000026  5d00              LDRB     r0,[r0,r4]            ;1025
000028  2801              CMP      r0,#1                 ;1025
00002a  d101              BNE      |L38.48|
00002c  2002              MOVS     r0,#2                 ;1025
00002e  e7f6              B        |L38.30|
                  |L38.48|
000030  2101              MOVS     r1,#1                 ;1025
000032  2040              MOVS     r0,#0x40              ;1025
000034  5501              STRB     r1,[r0,r4]            ;1025
000036  bf00              NOP                            ;1025
000038  f7fffffe          BL       HAL_GetTick
00003c  4605              MOV      r5,r0                 ;1028
00003e  2122              MOVS     r1,#0x22              ;1030
000040  2041              MOVS     r0,#0x41              ;1030
000042  5501              STRB     r1,[r0,r4]            ;1030
000044  2120              MOVS     r1,#0x20              ;1031
000046  2042              MOVS     r0,#0x42              ;1031
000048  5501              STRB     r1,[r0,r4]            ;1031
00004a  2000              MOVS     r0,#0                 ;1032
00004c  6460              STR      r0,[r4,#0x44]         ;1032
00004e  6266              STR      r6,[r4,#0x24]         ;1035
000050  8567              STRH     r7,[r4,#0x2a]         ;1036
000052  6360              STR      r0,[r4,#0x34]         ;1037
000054  6820              LDR      r0,[r4,#0]            ;1040
000056  6840              LDR      r0,[r0,#4]            ;1040
000058  0289              LSLS     r1,r1,#10             ;1040
00005a  4388              BICS     r0,r0,r1              ;1040
00005c  6821              LDR      r1,[r4,#0]            ;1040
00005e  6048              STR      r0,[r1,#4]            ;1040
000060  9500              STR      r5,[sp,#0]            ;1043
000062  2200              MOVS     r2,#0                 ;1043
000064  2108              MOVS     r1,#8                 ;1043
000066  4620              MOV      r0,r4                 ;1043
000068  9b04              LDR      r3,[sp,#0x10]         ;1043
00006a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00006e  2800              CMP      r0,#0                 ;1043
000070  d008              BEQ      |L38.132|
000072  6820              LDR      r0,[r4,#0]            ;1046
000074  6840              LDR      r0,[r0,#4]            ;1046
000076  2101              MOVS     r1,#1                 ;1046
000078  03c9              LSLS     r1,r1,#15             ;1046
00007a  4308              ORRS     r0,r0,r1              ;1046
00007c  6821              LDR      r1,[r4,#0]            ;1046
00007e  6048              STR      r0,[r1,#4]            ;1046
000080  2003              MOVS     r0,#3                 ;1047
000082  e7cc              B        |L38.30|
                  |L38.132|
000084  2008              MOVS     r0,#8                 ;1051
000086  6821              LDR      r1,[r4,#0]            ;1051
000088  61c8              STR      r0,[r1,#0x1c]         ;1051
00008a  9500              STR      r5,[sp,#0]            ;1054
00008c  2201              MOVS     r2,#1                 ;1054
00008e  0341              LSLS     r1,r0,#13             ;1054
000090  4620              MOV      r0,r4                 ;1054
000092  9b04              LDR      r3,[sp,#0x10]         ;1054
000094  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000098  2800              CMP      r0,#0                 ;1054
00009a  d008              BEQ      |L38.174|
00009c  6820              LDR      r0,[r4,#0]            ;1057
00009e  6840              LDR      r0,[r0,#4]            ;1057
0000a0  2101              MOVS     r1,#1                 ;1057
0000a2  03c9              LSLS     r1,r1,#15             ;1057
0000a4  4308              ORRS     r0,r0,r1              ;1057
0000a6  6821              LDR      r1,[r4,#0]            ;1057
0000a8  6048              STR      r0,[r1,#4]            ;1057
0000aa  2003              MOVS     r0,#3                 ;1058
0000ac  e7b7              B        |L38.30|
                  |L38.174|
0000ae  e030              B        |L38.274|
                  |L38.176|
0000b0  462a              MOV      r2,r5                 ;1064
0000b2  4620              MOV      r0,r4                 ;1064
0000b4  9904              LDR      r1,[sp,#0x10]         ;1064
0000b6  f7fffffe          BL       I2C_WaitOnRXNEFlagUntilTimeout
0000ba  2800              CMP      r0,#0                 ;1064
0000bc  d01f              BEQ      |L38.254|
0000be  6820              LDR      r0,[r4,#0]            ;1067
0000c0  6840              LDR      r0,[r0,#4]            ;1067
0000c2  2101              MOVS     r1,#1                 ;1067
0000c4  03c9              LSLS     r1,r1,#15             ;1067
0000c6  4308              ORRS     r0,r0,r1              ;1067
0000c8  6821              LDR      r1,[r4,#0]            ;1067
0000ca  6048              STR      r0,[r1,#4]            ;1067
0000cc  6820              LDR      r0,[r4,#0]            ;1070
0000ce  6980              LDR      r0,[r0,#0x18]         ;1070
0000d0  2104              MOVS     r1,#4                 ;1070
0000d2  4008              ANDS     r0,r0,r1              ;1070
0000d4  0880              LSRS     r0,r0,#2              ;1070
0000d6  2800              CMP      r0,#0                 ;1070
0000d8  d009              BEQ      |L38.238|
0000da  6820              LDR      r0,[r4,#0]            ;1073
0000dc  6a40              LDR      r0,[r0,#0x24]         ;1073
0000de  b2c1              UXTB     r1,r0                 ;1073
0000e0  6a62              LDR      r2,[r4,#0x24]         ;1073
0000e2  1c50              ADDS     r0,r2,#1              ;1073
0000e4  6260              STR      r0,[r4,#0x24]         ;1073
0000e6  7011              STRB     r1,[r2,#0]            ;1073
0000e8  8d60              LDRH     r0,[r4,#0x2a]         ;1074
0000ea  1e40              SUBS     r0,r0,#1              ;1074
0000ec  8560              STRH     r0,[r4,#0x2a]         ;1074
                  |L38.238|
0000ee  6c60              LDR      r0,[r4,#0x44]         ;1077
0000f0  2820              CMP      r0,#0x20              ;1077
0000f2  d102              BNE      |L38.250|
0000f4  2003              MOVS     r0,#3                 ;1079
0000f6  e792              B        |L38.30|
                  |L38.248|
0000f8  e04b              B        |L38.402|
                  |L38.250|
0000fa  2001              MOVS     r0,#1                 ;1083
0000fc  e78f              B        |L38.30|
                  |L38.254|
0000fe  6820              LDR      r0,[r4,#0]            ;1088
000100  6a40              LDR      r0,[r0,#0x24]         ;1088
000102  b2c1              UXTB     r1,r0                 ;1088
000104  6a62              LDR      r2,[r4,#0x24]         ;1088
000106  1c50              ADDS     r0,r2,#1              ;1088
000108  6260              STR      r0,[r4,#0x24]         ;1088
00010a  7011              STRB     r1,[r2,#0]            ;1088
00010c  8d60              LDRH     r0,[r4,#0x2a]         ;1089
00010e  1e40              SUBS     r0,r0,#1              ;1089
000110  8560              STRH     r0,[r4,#0x2a]         ;1089
                  |L38.274|
000112  8d60              LDRH     r0,[r4,#0x2a]         ;1061
000114  2800              CMP      r0,#0                 ;1061
000116  d1cb              BNE      |L38.176|
000118  462a              MOV      r2,r5                 ;1093
00011a  4620              MOV      r0,r4                 ;1093
00011c  9904              LDR      r1,[sp,#0x10]         ;1093
00011e  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
000122  2800              CMP      r0,#0                 ;1093
000124  d00d              BEQ      |L38.322|
000126  6820              LDR      r0,[r4,#0]            ;1096
000128  6840              LDR      r0,[r0,#4]            ;1096
00012a  2101              MOVS     r1,#1                 ;1096
00012c  03c9              LSLS     r1,r1,#15             ;1096
00012e  4308              ORRS     r0,r0,r1              ;1096
000130  6821              LDR      r1,[r4,#0]            ;1096
000132  6048              STR      r0,[r1,#4]            ;1096
000134  6c60              LDR      r0,[r4,#0x44]         ;1098
000136  2804              CMP      r0,#4                 ;1098
000138  d101              BNE      |L38.318|
00013a  2001              MOVS     r0,#1                 ;1100
00013c  e76f              B        |L38.30|
                  |L38.318|
00013e  2003              MOVS     r0,#3                 ;1104
000140  e76d              B        |L38.30|
                  |L38.322|
000142  2020              MOVS     r0,#0x20              ;1109
000144  6821              LDR      r1,[r4,#0]            ;1109
000146  61c8              STR      r0,[r1,#0x1c]         ;1109
000148  9500              STR      r5,[sp,#0]            ;1112
00014a  2201              MOVS     r2,#1                 ;1112
00014c  0281              LSLS     r1,r0,#10             ;1112
00014e  4620              MOV      r0,r4                 ;1112
000150  9b04              LDR      r3,[sp,#0x10]         ;1112
000152  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000156  2800              CMP      r0,#0                 ;1112
000158  d008              BEQ      |L38.364|
00015a  6820              LDR      r0,[r4,#0]            ;1115
00015c  6840              LDR      r0,[r0,#4]            ;1115
00015e  2101              MOVS     r1,#1                 ;1115
000160  03c9              LSLS     r1,r1,#15             ;1115
000162  4308              ORRS     r0,r0,r1              ;1115
000164  6821              LDR      r1,[r4,#0]            ;1115
000166  6048              STR      r0,[r1,#4]            ;1115
000168  2003              MOVS     r0,#3                 ;1116
00016a  e758              B        |L38.30|
                  |L38.364|
00016c  6820              LDR      r0,[r4,#0]            ;1120
00016e  6840              LDR      r0,[r0,#4]            ;1120
000170  2101              MOVS     r1,#1                 ;1120
000172  03c9              LSLS     r1,r1,#15             ;1120
000174  4308              ORRS     r0,r0,r1              ;1120
000176  6821              LDR      r1,[r4,#0]            ;1120
000178  6048              STR      r0,[r1,#4]            ;1120
00017a  2120              MOVS     r1,#0x20              ;1122
00017c  2041              MOVS     r0,#0x41              ;1122
00017e  5501              STRB     r1,[r0,r4]            ;1122
000180  2100              MOVS     r1,#0                 ;1123
000182  2042              MOVS     r0,#0x42              ;1123
000184  5501              STRB     r1,[r0,r4]            ;1123
000186  bf00              NOP                            ;1126
000188  2040              MOVS     r0,#0x40              ;1126
00018a  5501              STRB     r1,[r0,r4]            ;1126
00018c  bf00              NOP                            ;1126
00018e  2000              MOVS     r0,#0                 ;1128
000190  e745              B        |L38.30|
                  |L38.402|
000192  2002              MOVS     r0,#2                 ;1132
000194  e743              B        |L38.30|
;;;1135   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_DMA PROC
;;;1660     */
;;;1661   HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1662   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1663     if(hi2c->State == HAL_I2C_STATE_READY)
000008  2041              MOVS     r0,#0x41
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2820              CMP      r0,#0x20
00000e  d14c              BNE      |L39.170|
;;;1664     {
;;;1665       if((pData == NULL) || (Size == 0U)) 
000010  2d00              CMP      r5,#0
000012  d001              BEQ      |L39.24|
000014  2e00              CMP      r6,#0
000016  d101              BNE      |L39.28|
                  |L39.24|
;;;1666       {
;;;1667         return  HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L39.26|
;;;1668       }
;;;1669       /* Process Locked */
;;;1670       __HAL_LOCK(hi2c);
;;;1671   
;;;1672       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1673       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1674       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1675   
;;;1676       /* Prepare transfer parameters */
;;;1677       hi2c->pBuffPtr    = pData;
;;;1678       hi2c->XferCount   = Size;
;;;1679       hi2c->XferSize    = hi2c->XferCount;
;;;1680       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1681       hi2c->XferISR     = I2C_Slave_ISR_DMA;
;;;1682   
;;;1683       /* Set the I2C DMA transfer complete callback */
;;;1684       hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
;;;1685   
;;;1686       /* Set the DMA error callback */
;;;1687       hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
;;;1688   
;;;1689       /* Set the unused DMA callbacks to NULL */
;;;1690       hi2c->hdmarx->XferHalfCpltCallback = NULL;
;;;1691       hi2c->hdmarx->XferAbortCallback = NULL;
;;;1692   
;;;1693       /* Enable the DMA channel */
;;;1694       HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
;;;1695   
;;;1696       /* Enable Address Acknowledge */
;;;1697       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;1698   
;;;1699       /* Process Unlocked */
;;;1700       __HAL_UNLOCK(hi2c);
;;;1701   
;;;1702       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1703                 to avoid the risk of I2C interrupt handle execution before current
;;;1704                 process unlock */
;;;1705       /* Enable ERR, STOP, NACK, ADDR interrupts */
;;;1706       I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
;;;1707   
;;;1708       /* Enable DMA Request */
;;;1709       hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
;;;1710   
;;;1711       return HAL_OK;
;;;1712     }
;;;1713     else
;;;1714     {
;;;1715       return HAL_BUSY;
;;;1716     }
;;;1717   }
00001a  bd70              POP      {r4-r6,pc}
                  |L39.28|
00001c  bf00              NOP                            ;1670
00001e  2040              MOVS     r0,#0x40              ;1670
000020  5d00              LDRB     r0,[r0,r4]            ;1670
000022  2801              CMP      r0,#1                 ;1670
000024  d101              BNE      |L39.42|
000026  2002              MOVS     r0,#2                 ;1670
000028  e7f7              B        |L39.26|
                  |L39.42|
00002a  2101              MOVS     r1,#1                 ;1670
00002c  2040              MOVS     r0,#0x40              ;1670
00002e  5501              STRB     r1,[r0,r4]            ;1670
000030  bf00              NOP                            ;1670
000032  2122              MOVS     r1,#0x22              ;1672
000034  2041              MOVS     r0,#0x41              ;1672
000036  5501              STRB     r1,[r0,r4]            ;1672
000038  2120              MOVS     r1,#0x20              ;1673
00003a  2042              MOVS     r0,#0x42              ;1673
00003c  5501              STRB     r1,[r0,r4]            ;1673
00003e  2000              MOVS     r0,#0                 ;1674
000040  6460              STR      r0,[r4,#0x44]         ;1674
000042  6265              STR      r5,[r4,#0x24]         ;1677
000044  8566              STRH     r6,[r4,#0x2a]         ;1678
000046  8d60              LDRH     r0,[r4,#0x2a]         ;1679
000048  8520              STRH     r0,[r4,#0x28]         ;1679
00004a  4819              LDR      r0,|L39.176|
00004c  62e0              STR      r0,[r4,#0x2c]         ;1680
00004e  4819              LDR      r0,|L39.180|
000050  6360              STR      r0,[r4,#0x34]         ;1681
000052  4819              LDR      r0,|L39.184|
000054  6be1              LDR      r1,[r4,#0x3c]         ;1684
000056  6288              STR      r0,[r1,#0x28]         ;1684
000058  4818              LDR      r0,|L39.188|
00005a  6be1              LDR      r1,[r4,#0x3c]         ;1687
00005c  6308              STR      r0,[r1,#0x30]         ;1687
00005e  2000              MOVS     r0,#0                 ;1690
000060  6be1              LDR      r1,[r4,#0x3c]         ;1690
000062  62c8              STR      r0,[r1,#0x2c]         ;1690
000064  6be1              LDR      r1,[r4,#0x3c]         ;1691
000066  6348              STR      r0,[r1,#0x34]         ;1691
000068  8d23              LDRH     r3,[r4,#0x28]         ;1694
00006a  6822              LDR      r2,[r4,#0]            ;1694
00006c  4611              MOV      r1,r2                 ;1694
00006e  3124              ADDS     r1,r1,#0x24           ;1694
000070  462a              MOV      r2,r5                 ;1694
000072  6be0              LDR      r0,[r4,#0x3c]         ;1694
000074  f7fffffe          BL       HAL_DMA_Start_IT
000078  6820              LDR      r0,[r4,#0]            ;1697
00007a  6840              LDR      r0,[r0,#4]            ;1697
00007c  2101              MOVS     r1,#1                 ;1697
00007e  03c9              LSLS     r1,r1,#15             ;1697
000080  4388              BICS     r0,r0,r1              ;1697
000082  6821              LDR      r1,[r4,#0]            ;1697
000084  6048              STR      r0,[r1,#4]            ;1697
000086  bf00              NOP                            ;1700
000088  2100              MOVS     r1,#0                 ;1700
00008a  2040              MOVS     r0,#0x40              ;1700
00008c  5501              STRB     r1,[r0,r4]            ;1700
00008e  bf00              NOP                            ;1700
000090  2104              MOVS     r1,#4                 ;1706
000092  4620              MOV      r0,r4                 ;1706
000094  f7fffffe          BL       I2C_Enable_IRQ
000098  6820              LDR      r0,[r4,#0]            ;1709
00009a  6800              LDR      r0,[r0,#0]            ;1709
00009c  2101              MOVS     r1,#1                 ;1709
00009e  03c9              LSLS     r1,r1,#15             ;1709
0000a0  4308              ORRS     r0,r0,r1              ;1709
0000a2  6821              LDR      r1,[r4,#0]            ;1709
0000a4  6008              STR      r0,[r1,#0]            ;1709
0000a6  2000              MOVS     r0,#0                 ;1711
0000a8  e7b7              B        |L39.26|
                  |L39.170|
0000aa  2002              MOVS     r0,#2                 ;1715
0000ac  e7b5              B        |L39.26|
;;;1718   /**
                          ENDP

0000ae  0000              DCW      0x0000
                  |L39.176|
                          DCD      0xffff0000
                  |L39.180|
                          DCD      I2C_Slave_ISR_DMA
                  |L39.184|
                          DCD      I2C_DMASlaveReceiveCplt
                  |L39.188|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Receive_IT PROC
;;;1330     */
;;;1331   HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1332   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1333     if(hi2c->State == HAL_I2C_STATE_READY)
000008  2041              MOVS     r0,#0x41
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2820              CMP      r0,#0x20
00000e  d12b              BNE      |L40.104|
;;;1334     {
;;;1335       /* Process Locked */
;;;1336       __HAL_LOCK(hi2c);
000010  bf00              NOP      
000012  2040              MOVS     r0,#0x40
000014  5d00              LDRB     r0,[r0,r4]
000016  2801              CMP      r0,#1
000018  d101              BNE      |L40.30|
00001a  2002              MOVS     r0,#2
                  |L40.28|
;;;1337   
;;;1338       hi2c->State       = HAL_I2C_STATE_BUSY_RX;
;;;1339       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1340       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1341   
;;;1342       /* Enable Address Acknowledge */
;;;1343       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;1344   
;;;1345       /* Prepare transfer parameters */
;;;1346       hi2c->pBuffPtr    = pData;
;;;1347       hi2c->XferCount   = Size;
;;;1348       hi2c->XferSize    = hi2c->XferCount;
;;;1349       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1350       hi2c->XferISR     = I2C_Slave_ISR_IT;
;;;1351   
;;;1352       /* Process Unlocked */
;;;1353       __HAL_UNLOCK(hi2c);
;;;1354   
;;;1355       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1356                 to avoid the risk of I2C interrupt handle execution before current
;;;1357                 process unlock */
;;;1358   
;;;1359       /* Enable ERR, TC, STOP, NACK, RXI interrupt */
;;;1360       /* possible to enable all of these */
;;;1361       /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;1362       I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
;;;1363   
;;;1364       return HAL_OK;
;;;1365     }
;;;1366     else
;;;1367     {
;;;1368       return HAL_BUSY;
;;;1369     }
;;;1370   }
00001c  bd70              POP      {r4-r6,pc}
                  |L40.30|
00001e  2101              MOVS     r1,#1                 ;1336
000020  2040              MOVS     r0,#0x40              ;1336
000022  5501              STRB     r1,[r0,r4]            ;1336
000024  bf00              NOP                            ;1336
000026  2122              MOVS     r1,#0x22              ;1338
000028  2041              MOVS     r0,#0x41              ;1338
00002a  5501              STRB     r1,[r0,r4]            ;1338
00002c  2120              MOVS     r1,#0x20              ;1339
00002e  2042              MOVS     r0,#0x42              ;1339
000030  5501              STRB     r1,[r0,r4]            ;1339
000032  2000              MOVS     r0,#0                 ;1340
000034  6460              STR      r0,[r4,#0x44]         ;1340
000036  6820              LDR      r0,[r4,#0]            ;1343
000038  6840              LDR      r0,[r0,#4]            ;1343
00003a  0289              LSLS     r1,r1,#10             ;1343
00003c  4388              BICS     r0,r0,r1              ;1343
00003e  6821              LDR      r1,[r4,#0]            ;1343
000040  6048              STR      r0,[r1,#4]            ;1343
000042  6265              STR      r5,[r4,#0x24]         ;1346
000044  8566              STRH     r6,[r4,#0x2a]         ;1347
000046  8d60              LDRH     r0,[r4,#0x2a]         ;1348
000048  8520              STRH     r0,[r4,#0x28]         ;1348
00004a  4808              LDR      r0,|L40.108|
00004c  62e0              STR      r0,[r4,#0x2c]         ;1349
00004e  4808              LDR      r0,|L40.112|
000050  6360              STR      r0,[r4,#0x34]         ;1350
000052  bf00              NOP                            ;1353
000054  2100              MOVS     r1,#0                 ;1353
000056  2040              MOVS     r0,#0x40              ;1353
000058  5501              STRB     r1,[r0,r4]            ;1353
00005a  bf00              NOP                            ;1353
00005c  2106              MOVS     r1,#6                 ;1362
00005e  4620              MOV      r0,r4                 ;1362
000060  f7fffffe          BL       I2C_Enable_IRQ
000064  2000              MOVS     r0,#0                 ;1364
000066  e7d9              B        |L40.28|
                  |L40.104|
000068  2002              MOVS     r0,#2                 ;1368
00006a  e7d7              B        |L40.28|
;;;1371   
                          ENDP

                  |L40.108|
                          DCD      0xffff0000
                  |L40.112|
                          DCD      I2C_Slave_ISR_IT

                          AREA ||i.HAL_I2C_Slave_Sequential_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Sequential_Receive_IT PROC
;;;2789     */
;;;2790   HAL_StatusTypeDef HAL_I2C_Slave_Sequential_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2791   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;2792     /* Check the parameters */
;;;2793     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;2794   
;;;2795     if((hi2c->State & HAL_I2C_STATE_LISTEN) == HAL_I2C_STATE_LISTEN)
00000a  2041              MOVS     r0,#0x41
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2128              MOVS     r1,#0x28
000010  4008              ANDS     r0,r0,r1
000012  2828              CMP      r0,#0x28
000014  d146              BNE      |L41.164|
;;;2796     {
;;;2797       if((pData == NULL) || (Size == 0U))
000016  2d00              CMP      r5,#0
000018  d001              BEQ      |L41.30|
00001a  2e00              CMP      r6,#0
00001c  d101              BNE      |L41.34|
                  |L41.30|
;;;2798       {
;;;2799         return  HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L41.32|
;;;2800       }
;;;2801   
;;;2802       /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
;;;2803       I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
;;;2804   
;;;2805       /* Process Locked */
;;;2806       __HAL_LOCK(hi2c);
;;;2807       
;;;2808       /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
;;;2809       /* and then toggle the HAL slave TX state to RX state */
;;;2810       if(hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
;;;2811       {
;;;2812         /* Disable associated Interrupts */
;;;2813         I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
;;;2814       }
;;;2815       
;;;2816       hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
;;;2817       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;2818       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2819   
;;;2820       /* Enable Address Acknowledge */
;;;2821       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;2822   
;;;2823       /* Prepare transfer parameters */
;;;2824       hi2c->pBuffPtr    = pData;
;;;2825       hi2c->XferCount   = Size;
;;;2826       hi2c->XferSize    = hi2c->XferCount;
;;;2827       hi2c->XferOptions = XferOptions;
;;;2828       hi2c->XferISR     = I2C_Slave_ISR_IT;
;;;2829   
;;;2830       if(I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
;;;2831       {
;;;2832         /* Clear ADDR flag after prepare the transfer parameters */
;;;2833         /* This action will generate an acknowledge to the Master */
;;;2834         __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
;;;2835       }
;;;2836   
;;;2837       /* Process Unlocked */
;;;2838       __HAL_UNLOCK(hi2c);
;;;2839   
;;;2840       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2841       to avoid the risk of I2C interrupt handle execution before current
;;;2842       process unlock */
;;;2843       /* REnable ADDR interrupt */
;;;2844       I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
;;;2845   
;;;2846       return HAL_OK;
;;;2847     }
;;;2848     else
;;;2849     {
;;;2850       return HAL_ERROR;
;;;2851     }
;;;2852   }
000020  bdf8              POP      {r3-r7,pc}
                  |L41.34|
000022  2106              MOVS     r1,#6                 ;2803
000024  4620              MOV      r0,r4                 ;2803
000026  f7fffffe          BL       I2C_Disable_IRQ
00002a  bf00              NOP                            ;2806
00002c  2040              MOVS     r0,#0x40              ;2806
00002e  5d00              LDRB     r0,[r0,r4]            ;2806
000030  2801              CMP      r0,#1                 ;2806
000032  d101              BNE      |L41.56|
000034  2002              MOVS     r0,#2                 ;2806
000036  e7f3              B        |L41.32|
                  |L41.56|
000038  2101              MOVS     r1,#1                 ;2806
00003a  2040              MOVS     r0,#0x40              ;2806
00003c  5501              STRB     r1,[r0,r4]            ;2806
00003e  bf00              NOP                            ;2806
000040  2041              MOVS     r0,#0x41              ;2810
000042  5d00              LDRB     r0,[r0,r4]            ;2810
000044  2829              CMP      r0,#0x29              ;2810
000046  d102              BNE      |L41.78|
000048  4620              MOV      r0,r4                 ;2813
00004a  f7fffffe          BL       I2C_Disable_IRQ
                  |L41.78|
00004e  212a              MOVS     r1,#0x2a              ;2816
000050  2041              MOVS     r0,#0x41              ;2816
000052  5501              STRB     r1,[r0,r4]            ;2816
000054  2120              MOVS     r1,#0x20              ;2817
000056  2042              MOVS     r0,#0x42              ;2817
000058  5501              STRB     r1,[r0,r4]            ;2817
00005a  2000              MOVS     r0,#0                 ;2818
00005c  6460              STR      r0,[r4,#0x44]         ;2818
00005e  6820              LDR      r0,[r4,#0]            ;2821
000060  6840              LDR      r0,[r0,#4]            ;2821
000062  0289              LSLS     r1,r1,#10             ;2821
000064  4388              BICS     r0,r0,r1              ;2821
000066  6821              LDR      r1,[r4,#0]            ;2821
000068  6048              STR      r0,[r1,#4]            ;2821
00006a  6265              STR      r5,[r4,#0x24]         ;2824
00006c  8566              STRH     r6,[r4,#0x2a]         ;2825
00006e  8d60              LDRH     r0,[r4,#0x2a]         ;2826
000070  8520              STRH     r0,[r4,#0x28]         ;2826
000072  62e7              STR      r7,[r4,#0x2c]         ;2827
000074  480c              LDR      r0,|L41.168|
000076  6360              STR      r0,[r4,#0x34]         ;2828
000078  6820              LDR      r0,[r4,#0]            ;2830
00007a  6980              LDR      r0,[r0,#0x18]         ;2830
00007c  2101              MOVS     r1,#1                 ;2830
00007e  0409              LSLS     r1,r1,#16             ;2830
000080  4008              ANDS     r0,r0,r1              ;2830
000082  0c00              LSRS     r0,r0,#16             ;2830
000084  2800              CMP      r0,#0                 ;2830
000086  d102              BNE      |L41.142|
000088  2008              MOVS     r0,#8                 ;2834
00008a  6821              LDR      r1,[r4,#0]            ;2834
00008c  61c8              STR      r0,[r1,#0x1c]         ;2834
                  |L41.142|
00008e  bf00              NOP                            ;2838
000090  2100              MOVS     r1,#0                 ;2838
000092  2040              MOVS     r0,#0x40              ;2838
000094  5501              STRB     r1,[r0,r4]            ;2838
000096  bf00              NOP                            ;2838
000098  2106              MOVS     r1,#6                 ;2844
00009a  4620              MOV      r0,r4                 ;2844
00009c  f7fffffe          BL       I2C_Enable_IRQ
0000a0  2000              MOVS     r0,#0                 ;2846
0000a2  e7bd              B        |L41.32|
                  |L41.164|
0000a4  2001              MOVS     r0,#1                 ;2850
0000a6  e7bb              B        |L41.32|
;;;2853   
                          ENDP

                  |L41.168|
                          DCD      I2C_Slave_ISR_IT

                          AREA ||i.HAL_I2C_Slave_Sequential_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Sequential_Transmit_IT PROC
;;;2715     */
;;;2716   HAL_StatusTypeDef HAL_I2C_Slave_Sequential_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2717   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;2718     /* Check the parameters */
;;;2719     assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
;;;2720   
;;;2721     if((hi2c->State & HAL_I2C_STATE_LISTEN) == HAL_I2C_STATE_LISTEN)
00000a  2041              MOVS     r0,#0x41
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2128              MOVS     r1,#0x28
000010  4008              ANDS     r0,r0,r1
000012  2828              CMP      r0,#0x28
000014  d147              BNE      |L42.166|
;;;2722     {
;;;2723       if((pData == NULL) || (Size == 0U))
000016  2d00              CMP      r5,#0
000018  d001              BEQ      |L42.30|
00001a  2e00              CMP      r6,#0
00001c  d101              BNE      |L42.34|
                  |L42.30|
;;;2724       {
;;;2725         return  HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L42.32|
;;;2726       }
;;;2727   
;;;2728       /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
;;;2729       I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
;;;2730   
;;;2731       /* Process Locked */
;;;2732       __HAL_LOCK(hi2c);
;;;2733       
;;;2734       /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
;;;2735       /* and then toggle the HAL slave RX state to TX state */
;;;2736       if(hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
;;;2737       {
;;;2738         /* Disable associated Interrupts */
;;;2739         I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
;;;2740       }
;;;2741   
;;;2742       hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
;;;2743       hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;2744       hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;2745   
;;;2746       /* Enable Address Acknowledge */
;;;2747       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;2748   
;;;2749       /* Prepare transfer parameters */
;;;2750       hi2c->pBuffPtr    = pData;
;;;2751       hi2c->XferCount   = Size;
;;;2752       hi2c->XferSize    = hi2c->XferCount;
;;;2753       hi2c->XferOptions = XferOptions;
;;;2754       hi2c->XferISR     = I2C_Slave_ISR_IT;
;;;2755   
;;;2756       if(I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
;;;2757       {
;;;2758         /* Clear ADDR flag after prepare the transfer parameters */
;;;2759         /* This action will generate an acknowledge to the Master */
;;;2760         __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
;;;2761       }
;;;2762   
;;;2763       /* Process Unlocked */
;;;2764       __HAL_UNLOCK(hi2c);
;;;2765   
;;;2766       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;2767       to avoid the risk of I2C interrupt handle execution before current
;;;2768       process unlock */
;;;2769       /* REnable ADDR interrupt */
;;;2770       I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
;;;2771   
;;;2772       return HAL_OK;
;;;2773     }
;;;2774     else
;;;2775     {
;;;2776       return HAL_ERROR;
;;;2777     }
;;;2778   }
000020  bdf8              POP      {r3-r7,pc}
                  |L42.34|
000022  2105              MOVS     r1,#5                 ;2729
000024  4620              MOV      r0,r4                 ;2729
000026  f7fffffe          BL       I2C_Disable_IRQ
00002a  bf00              NOP                            ;2732
00002c  2040              MOVS     r0,#0x40              ;2732
00002e  5d00              LDRB     r0,[r0,r4]            ;2732
000030  2801              CMP      r0,#1                 ;2732
000032  d101              BNE      |L42.56|
000034  2002              MOVS     r0,#2                 ;2732
000036  e7f3              B        |L42.32|
                  |L42.56|
000038  2101              MOVS     r1,#1                 ;2732
00003a  2040              MOVS     r0,#0x40              ;2732
00003c  5501              STRB     r1,[r0,r4]            ;2732
00003e  bf00              NOP                            ;2732
000040  2041              MOVS     r0,#0x41              ;2736
000042  5d00              LDRB     r0,[r0,r4]            ;2736
000044  282a              CMP      r0,#0x2a              ;2736
000046  d103              BNE      |L42.80|
000048  2102              MOVS     r1,#2                 ;2739
00004a  4620              MOV      r0,r4                 ;2739
00004c  f7fffffe          BL       I2C_Disable_IRQ
                  |L42.80|
000050  2129              MOVS     r1,#0x29              ;2742
000052  2041              MOVS     r0,#0x41              ;2742
000054  5501              STRB     r1,[r0,r4]            ;2742
000056  2120              MOVS     r1,#0x20              ;2743
000058  2042              MOVS     r0,#0x42              ;2743
00005a  5501              STRB     r1,[r0,r4]            ;2743
00005c  2000              MOVS     r0,#0                 ;2744
00005e  6460              STR      r0,[r4,#0x44]         ;2744
000060  6820              LDR      r0,[r4,#0]            ;2747
000062  6840              LDR      r0,[r0,#4]            ;2747
000064  0289              LSLS     r1,r1,#10             ;2747
000066  4388              BICS     r0,r0,r1              ;2747
000068  6821              LDR      r1,[r4,#0]            ;2747
00006a  6048              STR      r0,[r1,#4]            ;2747
00006c  6265              STR      r5,[r4,#0x24]         ;2750
00006e  8566              STRH     r6,[r4,#0x2a]         ;2751
000070  8d60              LDRH     r0,[r4,#0x2a]         ;2752
000072  8520              STRH     r0,[r4,#0x28]         ;2752
000074  62e7              STR      r7,[r4,#0x2c]         ;2753
000076  480d              LDR      r0,|L42.172|
000078  6360              STR      r0,[r4,#0x34]         ;2754
00007a  6820              LDR      r0,[r4,#0]            ;2756
00007c  6980              LDR      r0,[r0,#0x18]         ;2756
00007e  2101              MOVS     r1,#1                 ;2756
000080  0409              LSLS     r1,r1,#16             ;2756
000082  4008              ANDS     r0,r0,r1              ;2756
000084  0c00              LSRS     r0,r0,#16             ;2756
000086  2800              CMP      r0,#0                 ;2756
000088  d002              BEQ      |L42.144|
00008a  2008              MOVS     r0,#8                 ;2760
00008c  6821              LDR      r1,[r4,#0]            ;2760
00008e  61c8              STR      r0,[r1,#0x1c]         ;2760
                  |L42.144|
000090  bf00              NOP                            ;2764
000092  2100              MOVS     r1,#0                 ;2764
000094  2040              MOVS     r0,#0x40              ;2764
000096  5501              STRB     r1,[r0,r4]            ;2764
000098  bf00              NOP                            ;2764
00009a  2105              MOVS     r1,#5                 ;2770
00009c  4620              MOV      r0,r4                 ;2770
00009e  f7fffffe          BL       I2C_Enable_IRQ
0000a2  2000              MOVS     r0,#0                 ;2772
0000a4  e7bc              B        |L42.32|
                  |L42.166|
0000a6  2001              MOVS     r0,#1                 ;2776
0000a8  e7ba              B        |L42.32|
;;;2779   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L42.172|
                          DCD      I2C_Slave_ISR_IT

                          AREA ||i.HAL_I2C_Slave_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_I2C_Slave_Transmit PROC
;;;873      */
;;;874    HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;875    {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;876      uint32_t tickstart = 0U;
00000a  2500              MOVS     r5,#0
;;;877    
;;;878      if(hi2c->State == HAL_I2C_STATE_READY)
00000c  2041              MOVS     r0,#0x41
00000e  5d00              LDRB     r0,[r0,r4]
000010  2820              CMP      r0,#0x20
000012  d179              BNE      |L43.264|
;;;879      {
;;;880        if((pData == NULL) || (Size == 0U))
000014  2e00              CMP      r6,#0
000016  d001              BEQ      |L43.28|
000018  2f00              CMP      r7,#0
00001a  d102              BNE      |L43.34|
                  |L43.28|
;;;881        {
;;;882          return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L43.30|
;;;883        }
;;;884        /* Process Locked */
;;;885        __HAL_LOCK(hi2c);
;;;886    
;;;887        /* Init tickstart for timeout management*/
;;;888        tickstart = HAL_GetTick();
;;;889    
;;;890        hi2c->State     = HAL_I2C_STATE_BUSY_TX;
;;;891        hi2c->Mode      = HAL_I2C_MODE_SLAVE;
;;;892        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;893    
;;;894        /* Prepare transfer parameters */
;;;895        hi2c->pBuffPtr  = pData;
;;;896        hi2c->XferCount = Size;
;;;897        hi2c->XferISR   = NULL;
;;;898    
;;;899        /* Enable Address Acknowledge */
;;;900        hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;901    
;;;902        /* Wait until ADDR flag is set */
;;;903        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;904        {
;;;905          /* Disable Address Acknowledge */
;;;906          hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;907          return HAL_TIMEOUT;
;;;908        }
;;;909    
;;;910        /* Clear ADDR flag */
;;;911        __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
;;;912    
;;;913        /* If 10bit addressing mode is selected */
;;;914        if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
;;;915        {
;;;916          /* Wait until ADDR flag is set */
;;;917          if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
;;;918          {
;;;919            /* Disable Address Acknowledge */
;;;920            hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;921            return HAL_TIMEOUT;
;;;922          }
;;;923    
;;;924          /* Clear ADDR flag */
;;;925          __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
;;;926        }
;;;927    
;;;928        /* Wait until DIR flag is set Transmitter mode */
;;;929        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)
;;;930        {
;;;931          /* Disable Address Acknowledge */
;;;932          hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;933          return HAL_TIMEOUT;
;;;934        }
;;;935    
;;;936        while(hi2c->XferCount > 0U)
;;;937        {
;;;938          /* Wait until TXIS flag is set */
;;;939          if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;940          {
;;;941            /* Disable Address Acknowledge */
;;;942            hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;943    
;;;944            if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;945            {
;;;946              return HAL_ERROR;
;;;947            }
;;;948            else
;;;949            {
;;;950              return HAL_TIMEOUT;
;;;951            }
;;;952          }
;;;953    
;;;954          /* Write data to TXDR */
;;;955          hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
;;;956          hi2c->XferCount--;
;;;957        }
;;;958    
;;;959        /* Wait until STOP flag is set */
;;;960        if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
;;;961        {
;;;962          /* Disable Address Acknowledge */
;;;963          hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;964    
;;;965          if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;966          {
;;;967            /* Normal use case for Transmitter mode */
;;;968            /* A NACK is generated to confirm the end of transfer */
;;;969            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;970          }
;;;971          else
;;;972          {
;;;973            return HAL_TIMEOUT;
;;;974          }
;;;975        }
;;;976    
;;;977        /* Clear STOP flag */
;;;978        __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
;;;979    
;;;980        /* Wait until BUSY flag is reset */ 
;;;981        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
;;;982        {
;;;983          /* Disable Address Acknowledge */
;;;984          hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;985          return HAL_TIMEOUT;
;;;986        }
;;;987    
;;;988        /* Disable Address Acknowledge */
;;;989        hi2c->Instance->CR2 |= I2C_CR2_NACK;
;;;990    
;;;991        hi2c->State = HAL_I2C_STATE_READY;
;;;992        hi2c->Mode  = HAL_I2C_MODE_NONE;
;;;993    
;;;994        /* Process Unlocked */
;;;995        __HAL_UNLOCK(hi2c);
;;;996    
;;;997        return HAL_OK;
;;;998      }
;;;999      else
;;;1000     {
;;;1001       return HAL_BUSY;
;;;1002     }
;;;1003   }
00001e  b005              ADD      sp,sp,#0x14
000020  bdf0              POP      {r4-r7,pc}
                  |L43.34|
000022  bf00              NOP                            ;885
000024  2040              MOVS     r0,#0x40              ;885
000026  5d00              LDRB     r0,[r0,r4]            ;885
000028  2801              CMP      r0,#1                 ;885
00002a  d101              BNE      |L43.48|
00002c  2002              MOVS     r0,#2                 ;885
00002e  e7f6              B        |L43.30|
                  |L43.48|
000030  2101              MOVS     r1,#1                 ;885
000032  2040              MOVS     r0,#0x40              ;885
000034  5501              STRB     r1,[r0,r4]            ;885
000036  bf00              NOP                            ;885
000038  f7fffffe          BL       HAL_GetTick
00003c  4605              MOV      r5,r0                 ;888
00003e  2121              MOVS     r1,#0x21              ;890
000040  2041              MOVS     r0,#0x41              ;890
000042  5501              STRB     r1,[r0,r4]            ;890
000044  2120              MOVS     r1,#0x20              ;891
000046  2042              MOVS     r0,#0x42              ;891
000048  5501              STRB     r1,[r0,r4]            ;891
00004a  2000              MOVS     r0,#0                 ;892
00004c  6460              STR      r0,[r4,#0x44]         ;892
00004e  6266              STR      r6,[r4,#0x24]         ;895
000050  8567              STRH     r7,[r4,#0x2a]         ;896
000052  6360              STR      r0,[r4,#0x34]         ;897
000054  6820              LDR      r0,[r4,#0]            ;900
000056  6840              LDR      r0,[r0,#4]            ;900
000058  0289              LSLS     r1,r1,#10             ;900
00005a  4388              BICS     r0,r0,r1              ;900
00005c  6821              LDR      r1,[r4,#0]            ;900
00005e  6048              STR      r0,[r1,#4]            ;900
000060  9500              STR      r5,[sp,#0]            ;903
000062  2200              MOVS     r2,#0                 ;903
000064  2108              MOVS     r1,#8                 ;903
000066  4620              MOV      r0,r4                 ;903
000068  9b04              LDR      r3,[sp,#0x10]         ;903
00006a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00006e  2800              CMP      r0,#0                 ;903
000070  d008              BEQ      |L43.132|
000072  6820              LDR      r0,[r4,#0]            ;906
000074  6840              LDR      r0,[r0,#4]            ;906
000076  2101              MOVS     r1,#1                 ;906
000078  03c9              LSLS     r1,r1,#15             ;906
00007a  4308              ORRS     r0,r0,r1              ;906
00007c  6821              LDR      r1,[r4,#0]            ;906
00007e  6048              STR      r0,[r1,#4]            ;906
000080  2003              MOVS     r0,#3                 ;907
000082  e7cc              B        |L43.30|
                  |L43.132|
000084  2008              MOVS     r0,#8                 ;911
000086  6821              LDR      r1,[r4,#0]            ;911
000088  61c8              STR      r0,[r1,#0x1c]         ;911
00008a  68e0              LDR      r0,[r4,#0xc]          ;914
00008c  2802              CMP      r0,#2                 ;914
00008e  d114              BNE      |L43.186|
000090  9500              STR      r5,[sp,#0]            ;917
000092  2200              MOVS     r2,#0                 ;917
000094  2108              MOVS     r1,#8                 ;917
000096  4620              MOV      r0,r4                 ;917
000098  9b04              LDR      r3,[sp,#0x10]         ;917
00009a  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
00009e  2800              CMP      r0,#0                 ;917
0000a0  d008              BEQ      |L43.180|
0000a2  6820              LDR      r0,[r4,#0]            ;920
0000a4  6840              LDR      r0,[r0,#4]            ;920
0000a6  2101              MOVS     r1,#1                 ;920
0000a8  03c9              LSLS     r1,r1,#15             ;920
0000aa  4308              ORRS     r0,r0,r1              ;920
0000ac  6821              LDR      r1,[r4,#0]            ;920
0000ae  6048              STR      r0,[r1,#4]            ;920
0000b0  2003              MOVS     r0,#3                 ;921
0000b2  e7b4              B        |L43.30|
                  |L43.180|
0000b4  2008              MOVS     r0,#8                 ;925
0000b6  6821              LDR      r1,[r4,#0]            ;925
0000b8  61c8              STR      r0,[r1,#0x1c]         ;925
                  |L43.186|
0000ba  9500              STR      r5,[sp,#0]            ;929
0000bc  2200              MOVS     r2,#0                 ;929
0000be  2101              MOVS     r1,#1                 ;929
0000c0  0409              LSLS     r1,r1,#16             ;929
0000c2  4620              MOV      r0,r4                 ;929
0000c4  9b04              LDR      r3,[sp,#0x10]         ;929
0000c6  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
0000ca  2800              CMP      r0,#0                 ;929
0000cc  d008              BEQ      |L43.224|
0000ce  6820              LDR      r0,[r4,#0]            ;932
0000d0  6840              LDR      r0,[r0,#4]            ;932
0000d2  2101              MOVS     r1,#1                 ;932
0000d4  03c9              LSLS     r1,r1,#15             ;932
0000d6  4308              ORRS     r0,r0,r1              ;932
0000d8  6821              LDR      r1,[r4,#0]            ;932
0000da  6048              STR      r0,[r1,#4]            ;932
0000dc  2003              MOVS     r0,#3                 ;933
0000de  e79e              B        |L43.30|
                  |L43.224|
0000e0  e01e              B        |L43.288|
                  |L43.226|
0000e2  462a              MOV      r2,r5                 ;939
0000e4  4620              MOV      r0,r4                 ;939
0000e6  9904              LDR      r1,[sp,#0x10]         ;939
0000e8  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
0000ec  2800              CMP      r0,#0                 ;939
0000ee  d00e              BEQ      |L43.270|
0000f0  6820              LDR      r0,[r4,#0]            ;942
0000f2  6840              LDR      r0,[r0,#4]            ;942
0000f4  2101              MOVS     r1,#1                 ;942
0000f6  03c9              LSLS     r1,r1,#15             ;942
0000f8  4308              ORRS     r0,r0,r1              ;942
0000fa  6821              LDR      r1,[r4,#0]            ;942
0000fc  6048              STR      r0,[r1,#4]            ;942
0000fe  6c60              LDR      r0,[r4,#0x44]         ;944
000100  2804              CMP      r0,#4                 ;944
000102  d102              BNE      |L43.266|
000104  2001              MOVS     r0,#1                 ;946
000106  e78a              B        |L43.30|
                  |L43.264|
000108  e04b              B        |L43.418|
                  |L43.266|
00010a  2003              MOVS     r0,#3                 ;950
00010c  e787              B        |L43.30|
                  |L43.270|
00010e  6a61              LDR      r1,[r4,#0x24]         ;955
000110  1c48              ADDS     r0,r1,#1              ;955
000112  6260              STR      r0,[r4,#0x24]         ;955
000114  7808              LDRB     r0,[r1,#0]            ;955
000116  6821              LDR      r1,[r4,#0]            ;955
000118  6288              STR      r0,[r1,#0x28]         ;955
00011a  8d60              LDRH     r0,[r4,#0x2a]         ;956
00011c  1e40              SUBS     r0,r0,#1              ;956
00011e  8560              STRH     r0,[r4,#0x2a]         ;956
                  |L43.288|
000120  8d60              LDRH     r0,[r4,#0x2a]         ;936
000122  2800              CMP      r0,#0                 ;936
000124  d1dd              BNE      |L43.226|
000126  462a              MOV      r2,r5                 ;960
000128  4620              MOV      r0,r4                 ;960
00012a  9904              LDR      r1,[sp,#0x10]         ;960
00012c  f7fffffe          BL       I2C_WaitOnSTOPFlagUntilTimeout
000130  2800              CMP      r0,#0                 ;960
000132  d00e              BEQ      |L43.338|
000134  6820              LDR      r0,[r4,#0]            ;963
000136  6840              LDR      r0,[r0,#4]            ;963
000138  2101              MOVS     r1,#1                 ;963
00013a  03c9              LSLS     r1,r1,#15             ;963
00013c  4308              ORRS     r0,r0,r1              ;963
00013e  6821              LDR      r1,[r4,#0]            ;963
000140  6048              STR      r0,[r1,#4]            ;963
000142  6c60              LDR      r0,[r4,#0x44]         ;965
000144  2804              CMP      r0,#4                 ;965
000146  d102              BNE      |L43.334|
000148  2000              MOVS     r0,#0                 ;969
00014a  6460              STR      r0,[r4,#0x44]         ;969
00014c  e001              B        |L43.338|
                  |L43.334|
00014e  2003              MOVS     r0,#3                 ;973
000150  e765              B        |L43.30|
                  |L43.338|
000152  2020              MOVS     r0,#0x20              ;978
000154  6821              LDR      r1,[r4,#0]            ;978
000156  61c8              STR      r0,[r1,#0x1c]         ;978
000158  9500              STR      r5,[sp,#0]            ;981
00015a  2201              MOVS     r2,#1                 ;981
00015c  0281              LSLS     r1,r0,#10             ;981
00015e  4620              MOV      r0,r4                 ;981
000160  9b04              LDR      r3,[sp,#0x10]         ;981
000162  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000166  2800              CMP      r0,#0                 ;981
000168  d008              BEQ      |L43.380|
00016a  6820              LDR      r0,[r4,#0]            ;984
00016c  6840              LDR      r0,[r0,#4]            ;984
00016e  2101              MOVS     r1,#1                 ;984
000170  03c9              LSLS     r1,r1,#15             ;984
000172  4308              ORRS     r0,r0,r1              ;984
000174  6821              LDR      r1,[r4,#0]            ;984
000176  6048              STR      r0,[r1,#4]            ;984
000178  2003              MOVS     r0,#3                 ;985
00017a  e750              B        |L43.30|
                  |L43.380|
00017c  6820              LDR      r0,[r4,#0]            ;989
00017e  6840              LDR      r0,[r0,#4]            ;989
000180  2101              MOVS     r1,#1                 ;989
000182  03c9              LSLS     r1,r1,#15             ;989
000184  4308              ORRS     r0,r0,r1              ;989
000186  6821              LDR      r1,[r4,#0]            ;989
000188  6048              STR      r0,[r1,#4]            ;989
00018a  2120              MOVS     r1,#0x20              ;991
00018c  2041              MOVS     r0,#0x41              ;991
00018e  5501              STRB     r1,[r0,r4]            ;991
000190  2100              MOVS     r1,#0                 ;992
000192  2042              MOVS     r0,#0x42              ;992
000194  5501              STRB     r1,[r0,r4]            ;992
000196  bf00              NOP                            ;995
000198  2040              MOVS     r0,#0x40              ;995
00019a  5501              STRB     r1,[r0,r4]            ;995
00019c  bf00              NOP                            ;995
00019e  2000              MOVS     r0,#0                 ;997
0001a0  e73d              B        |L43.30|
                  |L43.418|
0001a2  2002              MOVS     r0,#2                 ;1001
0001a4  e73b              B        |L43.30|
;;;1004   
                          ENDP


                          AREA ||i.HAL_I2C_Slave_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_DMA PROC
;;;1594     */
;;;1595   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1596   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1597     if(hi2c->State == HAL_I2C_STATE_READY)
000008  2041              MOVS     r0,#0x41
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2820              CMP      r0,#0x20
00000e  d14c              BNE      |L44.170|
;;;1598     {
;;;1599       if((pData == NULL) || (Size == 0U))
000010  2d00              CMP      r5,#0
000012  d001              BEQ      |L44.24|
000014  2e00              CMP      r6,#0
000016  d101              BNE      |L44.28|
                  |L44.24|
;;;1600       {
;;;1601         return  HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L44.26|
;;;1602       }   
;;;1603       /* Process Locked */
;;;1604       __HAL_LOCK(hi2c);
;;;1605   
;;;1606       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1607       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1608       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1609   
;;;1610       /* Prepare transfer parameters */
;;;1611       hi2c->pBuffPtr    = pData;
;;;1612       hi2c->XferCount   = Size;
;;;1613       hi2c->XferSize    = hi2c->XferCount;
;;;1614       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1615       hi2c->XferISR     = I2C_Slave_ISR_DMA;
;;;1616   
;;;1617       /* Set the I2C DMA transfer complete callback */
;;;1618       hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
;;;1619   
;;;1620       /* Set the DMA error callback */
;;;1621       hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
;;;1622   
;;;1623       /* Set the unused DMA callbacks to NULL */
;;;1624       hi2c->hdmatx->XferHalfCpltCallback = NULL;
;;;1625       hi2c->hdmatx->XferAbortCallback = NULL;
;;;1626   
;;;1627       /* Enable the DMA channel */
;;;1628       HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
;;;1629   
;;;1630       /* Enable Address Acknowledge */
;;;1631       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;1632   
;;;1633       /* Process Unlocked */
;;;1634       __HAL_UNLOCK(hi2c);
;;;1635   
;;;1636       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1637                 to avoid the risk of I2C interrupt handle execution before current
;;;1638                 process unlock */
;;;1639       /* Enable ERR, STOP, NACK, ADDR interrupts */
;;;1640       I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
;;;1641   
;;;1642       /* Enable DMA Request */
;;;1643       hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN; 
;;;1644   
;;;1645       return HAL_OK;
;;;1646     }
;;;1647     else
;;;1648     {
;;;1649       return HAL_BUSY;
;;;1650     }
;;;1651   }
00001a  bd70              POP      {r4-r6,pc}
                  |L44.28|
00001c  bf00              NOP                            ;1604
00001e  2040              MOVS     r0,#0x40              ;1604
000020  5d00              LDRB     r0,[r0,r4]            ;1604
000022  2801              CMP      r0,#1                 ;1604
000024  d101              BNE      |L44.42|
000026  2002              MOVS     r0,#2                 ;1604
000028  e7f7              B        |L44.26|
                  |L44.42|
00002a  2101              MOVS     r1,#1                 ;1604
00002c  2040              MOVS     r0,#0x40              ;1604
00002e  5501              STRB     r1,[r0,r4]            ;1604
000030  bf00              NOP                            ;1604
000032  2121              MOVS     r1,#0x21              ;1606
000034  2041              MOVS     r0,#0x41              ;1606
000036  5501              STRB     r1,[r0,r4]            ;1606
000038  2120              MOVS     r1,#0x20              ;1607
00003a  2042              MOVS     r0,#0x42              ;1607
00003c  5501              STRB     r1,[r0,r4]            ;1607
00003e  2000              MOVS     r0,#0                 ;1608
000040  6460              STR      r0,[r4,#0x44]         ;1608
000042  6265              STR      r5,[r4,#0x24]         ;1611
000044  8566              STRH     r6,[r4,#0x2a]         ;1612
000046  8d60              LDRH     r0,[r4,#0x2a]         ;1613
000048  8520              STRH     r0,[r4,#0x28]         ;1613
00004a  4819              LDR      r0,|L44.176|
00004c  62e0              STR      r0,[r4,#0x2c]         ;1614
00004e  4819              LDR      r0,|L44.180|
000050  6360              STR      r0,[r4,#0x34]         ;1615
000052  4819              LDR      r0,|L44.184|
000054  6ba1              LDR      r1,[r4,#0x38]         ;1618
000056  6288              STR      r0,[r1,#0x28]         ;1618
000058  4818              LDR      r0,|L44.188|
00005a  6ba1              LDR      r1,[r4,#0x38]         ;1621
00005c  6308              STR      r0,[r1,#0x30]         ;1621
00005e  2000              MOVS     r0,#0                 ;1624
000060  6ba1              LDR      r1,[r4,#0x38]         ;1624
000062  62c8              STR      r0,[r1,#0x2c]         ;1624
000064  6ba1              LDR      r1,[r4,#0x38]         ;1625
000066  6348              STR      r0,[r1,#0x34]         ;1625
000068  8d23              LDRH     r3,[r4,#0x28]         ;1628
00006a  6821              LDR      r1,[r4,#0]            ;1628
00006c  460a              MOV      r2,r1                 ;1628
00006e  3228              ADDS     r2,r2,#0x28           ;1628
000070  4629              MOV      r1,r5                 ;1628
000072  6ba0              LDR      r0,[r4,#0x38]         ;1628
000074  f7fffffe          BL       HAL_DMA_Start_IT
000078  6820              LDR      r0,[r4,#0]            ;1631
00007a  6840              LDR      r0,[r0,#4]            ;1631
00007c  2101              MOVS     r1,#1                 ;1631
00007e  03c9              LSLS     r1,r1,#15             ;1631
000080  4388              BICS     r0,r0,r1              ;1631
000082  6821              LDR      r1,[r4,#0]            ;1631
000084  6048              STR      r0,[r1,#4]            ;1631
000086  bf00              NOP                            ;1634
000088  2100              MOVS     r1,#0                 ;1634
00008a  2040              MOVS     r0,#0x40              ;1634
00008c  5501              STRB     r1,[r0,r4]            ;1634
00008e  bf00              NOP                            ;1634
000090  2104              MOVS     r1,#4                 ;1640
000092  4620              MOV      r0,r4                 ;1640
000094  f7fffffe          BL       I2C_Enable_IRQ
000098  6820              LDR      r0,[r4,#0]            ;1643
00009a  6800              LDR      r0,[r0,#0]            ;1643
00009c  2101              MOVS     r1,#1                 ;1643
00009e  0389              LSLS     r1,r1,#14             ;1643
0000a0  4308              ORRS     r0,r0,r1              ;1643
0000a2  6821              LDR      r1,[r4,#0]            ;1643
0000a4  6008              STR      r0,[r1,#0]            ;1643
0000a6  2000              MOVS     r0,#0                 ;1645
0000a8  e7b7              B        |L44.26|
                  |L44.170|
0000aa  2002              MOVS     r0,#2                 ;1649
0000ac  e7b5              B        |L44.26|
;;;1652   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L44.176|
                          DCD      0xffff0000
                  |L44.180|
                          DCD      I2C_Slave_ISR_DMA
                  |L44.184|
                          DCD      I2C_DMASlaveTransmitCplt
                  |L44.188|
                          DCD      I2C_DMAError

                          AREA ||i.HAL_I2C_Slave_Transmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_I2C_Slave_Transmit_IT PROC
;;;1281     */
;;;1282   HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1283   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1284     if(hi2c->State == HAL_I2C_STATE_READY)
000008  2041              MOVS     r0,#0x41
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2820              CMP      r0,#0x20
00000e  d12b              BNE      |L45.104|
;;;1285     {
;;;1286       /* Process Locked */
;;;1287       __HAL_LOCK(hi2c);
000010  bf00              NOP      
000012  2040              MOVS     r0,#0x40
000014  5d00              LDRB     r0,[r0,r4]
000016  2801              CMP      r0,#1
000018  d101              BNE      |L45.30|
00001a  2002              MOVS     r0,#2
                  |L45.28|
;;;1288   
;;;1289       hi2c->State       = HAL_I2C_STATE_BUSY_TX;
;;;1290       hi2c->Mode        = HAL_I2C_MODE_SLAVE;
;;;1291       hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
;;;1292   
;;;1293       /* Enable Address Acknowledge */
;;;1294       hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
;;;1295   
;;;1296       /* Prepare transfer parameters */
;;;1297       hi2c->pBuffPtr    = pData;
;;;1298       hi2c->XferCount   = Size;
;;;1299       hi2c->XferSize    = hi2c->XferCount;
;;;1300       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
;;;1301       hi2c->XferISR     = I2C_Slave_ISR_IT;
;;;1302   
;;;1303       /* Process Unlocked */
;;;1304       __HAL_UNLOCK(hi2c);
;;;1305   
;;;1306       /* Note : The I2C interrupts must be enabled after unlocking current process
;;;1307                 to avoid the risk of I2C interrupt handle execution before current
;;;1308                 process unlock */
;;;1309   
;;;1310       /* Enable ERR, TC, STOP, NACK, TXI interrupt */
;;;1311       /* possible to enable all of these */
;;;1312       /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
;;;1313       I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
;;;1314   
;;;1315       return HAL_OK;
;;;1316     }
;;;1317     else
;;;1318     {
;;;1319       return HAL_BUSY;
;;;1320     }
;;;1321   }
00001c  bd70              POP      {r4-r6,pc}
                  |L45.30|
00001e  2101              MOVS     r1,#1                 ;1287
000020  2040              MOVS     r0,#0x40              ;1287
000022  5501              STRB     r1,[r0,r4]            ;1287
000024  bf00              NOP                            ;1287
000026  2121              MOVS     r1,#0x21              ;1289
000028  2041              MOVS     r0,#0x41              ;1289
00002a  5501              STRB     r1,[r0,r4]            ;1289
00002c  2120              MOVS     r1,#0x20              ;1290
00002e  2042              MOVS     r0,#0x42              ;1290
000030  5501              STRB     r1,[r0,r4]            ;1290
000032  2000              MOVS     r0,#0                 ;1291
000034  6460              STR      r0,[r4,#0x44]         ;1291
000036  6820              LDR      r0,[r4,#0]            ;1294
000038  6840              LDR      r0,[r0,#4]            ;1294
00003a  0289              LSLS     r1,r1,#10             ;1294
00003c  4388              BICS     r0,r0,r1              ;1294
00003e  6821              LDR      r1,[r4,#0]            ;1294
000040  6048              STR      r0,[r1,#4]            ;1294
000042  6265              STR      r5,[r4,#0x24]         ;1297
000044  8566              STRH     r6,[r4,#0x2a]         ;1298
000046  8d60              LDRH     r0,[r4,#0x2a]         ;1299
000048  8520              STRH     r0,[r4,#0x28]         ;1299
00004a  4808              LDR      r0,|L45.108|
00004c  62e0              STR      r0,[r4,#0x2c]         ;1300
00004e  4808              LDR      r0,|L45.112|
000050  6360              STR      r0,[r4,#0x34]         ;1301
000052  bf00              NOP                            ;1304
000054  2100              MOVS     r1,#0                 ;1304
000056  2040              MOVS     r0,#0x40              ;1304
000058  5501              STRB     r1,[r0,r4]            ;1304
00005a  bf00              NOP                            ;1304
00005c  2105              MOVS     r1,#5                 ;1313
00005e  4620              MOV      r0,r4                 ;1313
000060  f7fffffe          BL       I2C_Enable_IRQ
000064  2000              MOVS     r0,#0                 ;1315
000066  e7d9              B        |L45.28|
                  |L45.104|
000068  2002              MOVS     r0,#2                 ;1319
00006a  e7d7              B        |L45.28|
;;;1322   
                          ENDP

                  |L45.108|
                          DCD      0xffff0000
                  |L45.112|
                          DCD      I2C_Slave_ISR_IT

                          AREA ||i.I2C_DMAAbort||, CODE, READONLY, ALIGN=1

                  I2C_DMAAbort PROC
;;;4434     */
;;;4435   static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4436   {
000002  4605              MOV      r5,r0
;;;4437     I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a6c              LDR      r4,[r5,#0x24]
;;;4438   
;;;4439     /* Disable Acknowledge */
;;;4440     hi2c->Instance->CR2 |= I2C_CR2_NACK;
000006  6820              LDR      r0,[r4,#0]
000008  6840              LDR      r0,[r0,#4]
00000a  2101              MOVS     r1,#1
00000c  03c9              LSLS     r1,r1,#15
00000e  4308              ORRS     r0,r0,r1
000010  6821              LDR      r1,[r4,#0]
000012  6048              STR      r0,[r1,#4]
;;;4441   
;;;4442     /* Reset AbortCpltCallback */
;;;4443     hi2c->hdmatx->XferAbortCallback = NULL;
000014  2000              MOVS     r0,#0
000016  6ba1              LDR      r1,[r4,#0x38]
000018  6348              STR      r0,[r1,#0x34]
;;;4444     hi2c->hdmarx->XferAbortCallback = NULL;
00001a  6be1              LDR      r1,[r4,#0x3c]
00001c  6348              STR      r0,[r1,#0x34]
;;;4445   
;;;4446     /* Check if come from abort from user */
;;;4447     if(hi2c->State == HAL_I2C_STATE_ABORT)
00001e  2041              MOVS     r0,#0x41
000020  5d00              LDRB     r0,[r0,r4]
000022  2860              CMP      r0,#0x60
000024  d106              BNE      |L46.52|
;;;4448     {
;;;4449       hi2c->State = HAL_I2C_STATE_READY;
000026  2120              MOVS     r1,#0x20
000028  2041              MOVS     r0,#0x41
00002a  5501              STRB     r1,[r0,r4]
;;;4450       
;;;4451       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4452       HAL_I2C_AbortCpltCallback(hi2c);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       HAL_I2C_AbortCpltCallback
000032  e002              B        |L46.58|
                  |L46.52|
;;;4453     }
;;;4454     else
;;;4455     {
;;;4456       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4457       HAL_I2C_ErrorCallback(hi2c);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L46.58|
;;;4458     }
;;;4459   }
00003a  bd70              POP      {r4-r6,pc}
;;;4460   
                          ENDP


                          AREA ||i.I2C_DMAError||, CODE, READONLY, ALIGN=1

                  I2C_DMAError PROC
;;;4417     */
;;;4418   static void I2C_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4419   {
000002  4605              MOV      r5,r0
;;;4420     I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a6c              LDR      r4,[r5,#0x24]
;;;4421   
;;;4422     /* Disable Acknowledge */
;;;4423     hi2c->Instance->CR2 |= I2C_CR2_NACK;
000006  6820              LDR      r0,[r4,#0]
000008  6840              LDR      r0,[r0,#4]
00000a  2101              MOVS     r1,#1
00000c  03c9              LSLS     r1,r1,#15
00000e  4308              ORRS     r0,r0,r1
000010  6821              LDR      r1,[r4,#0]
000012  6048              STR      r0,[r1,#4]
;;;4424   
;;;4425     /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4426     I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
000014  2110              MOVS     r1,#0x10
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       I2C_ITError
;;;4427   }
00001c  bd70              POP      {r4-r6,pc}
;;;4428   
                          ENDP


                          AREA ||i.I2C_DMAMasterReceiveCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMAMasterReceiveCplt PROC
;;;4360     */
;;;4361   static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4362   {
000002  4605              MOV      r5,r0
;;;4363     I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6a6c              LDR      r4,[r5,#0x24]
;;;4364   
;;;4365     /* Disable DMA Request */
;;;4366     hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
000006  6820              LDR      r0,[r4,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  2101              MOVS     r1,#1
00000c  03c9              LSLS     r1,r1,#15
00000e  4388              BICS     r0,r0,r1
000010  6821              LDR      r1,[r4,#0]
000012  6008              STR      r0,[r1,#0]
;;;4367   
;;;4368     /* If last transfer, enable STOP interrupt */
;;;4369     if(hi2c->XferCount == 0U)
000014  8d60              LDRH     r0,[r4,#0x2a]
000016  2800              CMP      r0,#0
000018  d104              BNE      |L48.36|
;;;4370     {
;;;4371       /* Enable STOP interrupt */
;;;4372       I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
00001a  2112              MOVS     r1,#0x12
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       I2C_Enable_IRQ
000022  e017              B        |L48.84|
                  |L48.36|
;;;4373     }
;;;4374     /* else prepare a new DMA transfer and enable TCReload interrupt */
;;;4375     else
;;;4376     {
;;;4377       /* Update Buffer pointer */
;;;4378       hi2c->pBuffPtr += hi2c->XferSize;
000024  8d21              LDRH     r1,[r4,#0x28]
000026  6a60              LDR      r0,[r4,#0x24]
000028  1840              ADDS     r0,r0,r1
00002a  6260              STR      r0,[r4,#0x24]
;;;4379   
;;;4380       /* Set the XferSize to transfer */
;;;4381       if(hi2c->XferCount > MAX_NBYTE_SIZE)
00002c  8d60              LDRH     r0,[r4,#0x2a]
00002e  28ff              CMP      r0,#0xff
000030  d902              BLS      |L48.56|
;;;4382       {
;;;4383         hi2c->XferSize = MAX_NBYTE_SIZE;
000032  20ff              MOVS     r0,#0xff
000034  8520              STRH     r0,[r4,#0x28]
000036  e001              B        |L48.60|
                  |L48.56|
;;;4384       }
;;;4385       else
;;;4386       {
;;;4387         hi2c->XferSize = hi2c->XferCount;
000038  8d60              LDRH     r0,[r4,#0x2a]
00003a  8520              STRH     r0,[r4,#0x28]
                  |L48.60|
;;;4388       }
;;;4389   
;;;4390       /* Enable the DMA channel */
;;;4391       HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
00003c  8d23              LDRH     r3,[r4,#0x28]
00003e  6826              LDR      r6,[r4,#0]
000040  4631              MOV      r1,r6
000042  3124              ADDS     r1,r1,#0x24
000044  6a62              LDR      r2,[r4,#0x24]
000046  6be0              LDR      r0,[r4,#0x3c]
000048  f7fffffe          BL       HAL_DMA_Start_IT
;;;4392   
;;;4393       /* Enable TC interrupts */
;;;4394       I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
00004c  2112              MOVS     r1,#0x12
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       I2C_Enable_IRQ
                  |L48.84|
;;;4395     }
;;;4396   }
000054  bd70              POP      {r4-r6,pc}
;;;4397   
                          ENDP


                          AREA ||i.I2C_DMAMasterTransmitCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMAMasterTransmitCplt PROC
;;;4303     */
;;;4304   static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4305   {
000002  4605              MOV      r5,r0
;;;4306     I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6a6c              LDR      r4,[r5,#0x24]
;;;4307   
;;;4308     /* Disable DMA Request */
;;;4309     hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
000006  6820              LDR      r0,[r4,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  2101              MOVS     r1,#1
00000c  0389              LSLS     r1,r1,#14
00000e  4388              BICS     r0,r0,r1
000010  6821              LDR      r1,[r4,#0]
000012  6008              STR      r0,[r1,#0]
;;;4310   
;;;4311     /* If last transfer, enable STOP interrupt */
;;;4312     if(hi2c->XferCount == 0U)
000014  8d60              LDRH     r0,[r4,#0x2a]
000016  2800              CMP      r0,#0
000018  d104              BNE      |L49.36|
;;;4313     {
;;;4314       /* Enable STOP interrupt */
;;;4315       I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
00001a  2112              MOVS     r1,#0x12
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       I2C_Enable_IRQ
000022  e017              B        |L49.84|
                  |L49.36|
;;;4316     }
;;;4317     /* else prepare a new DMA transfer and enable TCReload interrupt */
;;;4318     else
;;;4319     {
;;;4320       /* Update Buffer pointer */
;;;4321       hi2c->pBuffPtr += hi2c->XferSize;
000024  8d21              LDRH     r1,[r4,#0x28]
000026  6a60              LDR      r0,[r4,#0x24]
000028  1840              ADDS     r0,r0,r1
00002a  6260              STR      r0,[r4,#0x24]
;;;4322   
;;;4323       /* Set the XferSize to transfer */
;;;4324       if(hi2c->XferCount > MAX_NBYTE_SIZE)
00002c  8d60              LDRH     r0,[r4,#0x2a]
00002e  28ff              CMP      r0,#0xff
000030  d902              BLS      |L49.56|
;;;4325       {
;;;4326         hi2c->XferSize = MAX_NBYTE_SIZE;
000032  20ff              MOVS     r0,#0xff
000034  8520              STRH     r0,[r4,#0x28]
000036  e001              B        |L49.60|
                  |L49.56|
;;;4327       }
;;;4328       else
;;;4329       {
;;;4330         hi2c->XferSize = hi2c->XferCount;
000038  8d60              LDRH     r0,[r4,#0x2a]
00003a  8520              STRH     r0,[r4,#0x28]
                  |L49.60|
;;;4331       }
;;;4332   
;;;4333       /* Enable the DMA channel */
;;;4334       HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
00003c  8d23              LDRH     r3,[r4,#0x28]
00003e  6826              LDR      r6,[r4,#0]
000040  4632              MOV      r2,r6
000042  3228              ADDS     r2,r2,#0x28
000044  6a61              LDR      r1,[r4,#0x24]
000046  6ba0              LDR      r0,[r4,#0x38]
000048  f7fffffe          BL       HAL_DMA_Start_IT
;;;4335   
;;;4336       /* Enable TC interrupts */
;;;4337       I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
00004c  2112              MOVS     r1,#0x12
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       I2C_Enable_IRQ
                  |L49.84|
;;;4338     }
;;;4339   }
000054  bd70              POP      {r4-r6,pc}
;;;4340   
                          ENDP


                          AREA ||i.I2C_DMASlaveReceiveCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMASlaveReceiveCplt PROC
;;;4402     */
;;;4403   static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)
000000  4770              BX       lr
;;;4404   {
;;;4405     /* Prevent unused argument(s) compilation warning */
;;;4406     UNUSED(hdma);
;;;4407   
;;;4408     /* No specific action, Master fully manage the generation of STOP condition */
;;;4409     /* Mean that this generation can arrive at any time, at the end or during DMA process */
;;;4410     /* So STOP condition should be manage through Interrupt treatment */
;;;4411   }
;;;4412   
                          ENDP


                          AREA ||i.I2C_DMASlaveTransmitCplt||, CODE, READONLY, ALIGN=1

                  I2C_DMASlaveTransmitCplt PROC
;;;4345     */
;;;4346   static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)
000000  4770              BX       lr
;;;4347   {
;;;4348     /* Prevent unused argument(s) compilation warning */
;;;4349     UNUSED(hdma);
;;;4350   
;;;4351     /* No specific action, Master fully manage the generation of STOP condition */
;;;4352     /* Mean that this generation can arrive at any time, at the end or during DMA process */
;;;4353     /* So STOP condition should be manage through Interrupt treatment */
;;;4354   }
;;;4355   
                          ENDP


                          AREA ||i.I2C_Disable_IRQ||, CODE, READONLY, ALIGN=1

                  I2C_Disable_IRQ PROC
;;;4791     */
;;;4792   static HAL_StatusTypeDef I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
000000  b510              PUSH     {r4,lr}
;;;4793   {
000002  4603              MOV      r3,r0
000004  460a              MOV      r2,r1
;;;4794     uint32_t tmpisr = 0U;
000006  2100              MOVS     r1,#0
;;;4795   
;;;4796     if((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
000008  07d0              LSLS     r0,r2,#31
00000a  0fc0              LSRS     r0,r0,#31
00000c  2800              CMP      r0,#0
00000e  d009              BEQ      |L52.36|
;;;4797     {
;;;4798       /* Disable TC and TXI interrupts */
;;;4799       tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
000010  2042              MOVS     r0,#0x42
000012  4301              ORRS     r1,r1,r0
;;;4800   
;;;4801       if((hi2c->State & HAL_I2C_STATE_LISTEN) != HAL_I2C_STATE_LISTEN)
000014  2041              MOVS     r0,#0x41
000016  5cc0              LDRB     r0,[r0,r3]
000018  2428              MOVS     r4,#0x28
00001a  4020              ANDS     r0,r0,r4
00001c  2828              CMP      r0,#0x28
00001e  d001              BEQ      |L52.36|
;;;4802       {
;;;4803         /* Disable NACK and STOP interrupts */
;;;4804         tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
000020  20b0              MOVS     r0,#0xb0
000022  4301              ORRS     r1,r1,r0
                  |L52.36|
;;;4805       }
;;;4806     }
;;;4807   
;;;4808     if((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
000024  2002              MOVS     r0,#2
000026  4010              ANDS     r0,r0,r2
000028  2802              CMP      r0,#2
00002a  d109              BNE      |L52.64|
;;;4809     {
;;;4810       /* Disable TC and RXI interrupts */
;;;4811       tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
00002c  2044              MOVS     r0,#0x44
00002e  4301              ORRS     r1,r1,r0
;;;4812   
;;;4813       if((hi2c->State & HAL_I2C_STATE_LISTEN) != HAL_I2C_STATE_LISTEN)
000030  2041              MOVS     r0,#0x41
000032  5cc0              LDRB     r0,[r0,r3]
000034  2428              MOVS     r4,#0x28
000036  4020              ANDS     r0,r0,r4
000038  2828              CMP      r0,#0x28
00003a  d001              BEQ      |L52.64|
;;;4814       {
;;;4815         /* Disable NACK and STOP interrupts */
;;;4816         tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
00003c  20b0              MOVS     r0,#0xb0
00003e  4301              ORRS     r1,r1,r0
                  |L52.64|
;;;4817       }
;;;4818     }
;;;4819   
;;;4820     if((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
000040  2004              MOVS     r0,#4
000042  4010              ANDS     r0,r0,r2
000044  2804              CMP      r0,#4
000046  d101              BNE      |L52.76|
;;;4821     {
;;;4822       /* Disable ADDR, NACK and STOP interrupts */
;;;4823       tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
000048  20b8              MOVS     r0,#0xb8
00004a  4301              ORRS     r1,r1,r0
                  |L52.76|
;;;4824     }
;;;4825   
;;;4826     if((InterruptRequest & I2C_XFER_ERROR_IT) == I2C_XFER_ERROR_IT)
00004c  2011              MOVS     r0,#0x11
00004e  4010              ANDS     r0,r0,r2
000050  2811              CMP      r0,#0x11
000052  d101              BNE      |L52.88|
;;;4827     {
;;;4828       /* Enable ERR and NACK interrupts */
;;;4829       tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
000054  2090              MOVS     r0,#0x90
000056  4301              ORRS     r1,r1,r0
                  |L52.88|
;;;4830     }
;;;4831   
;;;4832     if((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
000058  2012              MOVS     r0,#0x12
00005a  4010              ANDS     r0,r0,r2
00005c  2812              CMP      r0,#0x12
00005e  d101              BNE      |L52.100|
;;;4833     {
;;;4834       /* Enable STOP interrupts */
;;;4835       tmpisr |= I2C_IT_STOPI;
000060  2020              MOVS     r0,#0x20
000062  4301              ORRS     r1,r1,r0
                  |L52.100|
;;;4836     }
;;;4837     
;;;4838     if((InterruptRequest & I2C_XFER_RELOAD_IT) == I2C_XFER_RELOAD_IT)
000064  2012              MOVS     r0,#0x12
000066  4010              ANDS     r0,r0,r2
000068  2812              CMP      r0,#0x12
00006a  d101              BNE      |L52.112|
;;;4839     {
;;;4840       /* Enable TC interrupts */
;;;4841       tmpisr |= I2C_IT_TCI;
00006c  2040              MOVS     r0,#0x40
00006e  4301              ORRS     r1,r1,r0
                  |L52.112|
;;;4842     }
;;;4843   
;;;4844     /* Disable interrupts only at the end */
;;;4845     /* to avoid a breaking situation like at "t" time */
;;;4846     /* all disable interrupts request are not done */
;;;4847     __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
000070  6818              LDR      r0,[r3,#0]
000072  6800              LDR      r0,[r0,#0]
000074  4388              BICS     r0,r0,r1
000076  681c              LDR      r4,[r3,#0]
000078  6020              STR      r0,[r4,#0]
;;;4848   
;;;4849     return HAL_OK;
00007a  2000              MOVS     r0,#0
;;;4850   }
00007c  bd10              POP      {r4,pc}
;;;4851   
                          ENDP


                          AREA ||i.I2C_Enable_IRQ||, CODE, READONLY, ALIGN=2

                  I2C_Enable_IRQ PROC
;;;4718     */
;;;4719   static HAL_StatusTypeDef I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
000000  b510              PUSH     {r4,lr}
;;;4720   {
000002  4603              MOV      r3,r0
;;;4721     uint32_t tmpisr = 0U;
000004  2200              MOVS     r2,#0
;;;4722   
;;;4723     if((hi2c->XferISR == I2C_Master_ISR_DMA) || \
000006  4c20              LDR      r4,|L53.136|
000008  6b58              LDR      r0,[r3,#0x34]
00000a  42a0              CMP      r0,r4
00000c  d003              BEQ      |L53.22|
;;;4724        (hi2c->XferISR == I2C_Slave_ISR_DMA))
00000e  4c1f              LDR      r4,|L53.140|
000010  6b58              LDR      r0,[r3,#0x34]
000012  42a0              CMP      r0,r4
000014  d118              BNE      |L53.72|
                  |L53.22|
;;;4725     {
;;;4726       if((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
000016  2004              MOVS     r0,#4
000018  4008              ANDS     r0,r0,r1
00001a  2804              CMP      r0,#4
00001c  d101              BNE      |L53.34|
;;;4727       {
;;;4728         /* Enable ERR, STOP, NACK and ADDR interrupts */
;;;4729         tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
00001e  20b8              MOVS     r0,#0xb8
000020  4302              ORRS     r2,r2,r0
                  |L53.34|
;;;4730       }
;;;4731   
;;;4732       if((InterruptRequest & I2C_XFER_ERROR_IT) == I2C_XFER_ERROR_IT)
000022  2011              MOVS     r0,#0x11
000024  4008              ANDS     r0,r0,r1
000026  2811              CMP      r0,#0x11
000028  d101              BNE      |L53.46|
;;;4733       {
;;;4734         /* Enable ERR and NACK interrupts */
;;;4735         tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
00002a  2090              MOVS     r0,#0x90
00002c  4302              ORRS     r2,r2,r0
                  |L53.46|
;;;4736       }
;;;4737   
;;;4738       if((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
00002e  2012              MOVS     r0,#0x12
000030  4008              ANDS     r0,r0,r1
000032  2812              CMP      r0,#0x12
000034  d101              BNE      |L53.58|
;;;4739       {
;;;4740         /* Enable STOP interrupts */
;;;4741         tmpisr |= I2C_IT_STOPI;
000036  2020              MOVS     r0,#0x20
000038  4302              ORRS     r2,r2,r0
                  |L53.58|
;;;4742       }
;;;4743       
;;;4744       if((InterruptRequest & I2C_XFER_RELOAD_IT) == I2C_XFER_RELOAD_IT)
00003a  2012              MOVS     r0,#0x12
00003c  4008              ANDS     r0,r0,r1
00003e  2812              CMP      r0,#0x12
000040  d11a              BNE      |L53.120|
;;;4745       {
;;;4746         /* Enable TC interrupts */
;;;4747         tmpisr |= I2C_IT_TCI;
000042  2040              MOVS     r0,#0x40
000044  4302              ORRS     r2,r2,r0
000046  e017              B        |L53.120|
                  |L53.72|
;;;4748       }
;;;4749     }
;;;4750     else
;;;4751     {
;;;4752       if((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
000048  2004              MOVS     r0,#4
00004a  4008              ANDS     r0,r0,r1
00004c  2804              CMP      r0,#4
00004e  d101              BNE      |L53.84|
;;;4753       {
;;;4754         /* Enable ERR, STOP, NACK, and ADDR interrupts */
;;;4755         tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
000050  20b8              MOVS     r0,#0xb8
000052  4302              ORRS     r2,r2,r0
                  |L53.84|
;;;4756       }
;;;4757   
;;;4758       if((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
000054  07c8              LSLS     r0,r1,#31
000056  0fc0              LSRS     r0,r0,#31
000058  2800              CMP      r0,#0
00005a  d001              BEQ      |L53.96|
;;;4759       {
;;;4760         /* Enable ERR, TC, STOP, NACK and RXI interrupts */
;;;4761         tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
00005c  20f2              MOVS     r0,#0xf2
00005e  4302              ORRS     r2,r2,r0
                  |L53.96|
;;;4762       }
;;;4763   
;;;4764       if((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
000060  2002              MOVS     r0,#2
000062  4008              ANDS     r0,r0,r1
000064  2802              CMP      r0,#2
000066  d101              BNE      |L53.108|
;;;4765       {
;;;4766         /* Enable ERR, TC, STOP, NACK and TXI interrupts */
;;;4767         tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
000068  20f4              MOVS     r0,#0xf4
00006a  4302              ORRS     r2,r2,r0
                  |L53.108|
;;;4768       }
;;;4769   
;;;4770       if((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
00006c  2012              MOVS     r0,#0x12
00006e  4008              ANDS     r0,r0,r1
000070  2812              CMP      r0,#0x12
000072  d101              BNE      |L53.120|
;;;4771       {
;;;4772         /* Enable STOP interrupts */
;;;4773         tmpisr |= I2C_IT_STOPI;
000074  2020              MOVS     r0,#0x20
000076  4302              ORRS     r2,r2,r0
                  |L53.120|
;;;4774       }
;;;4775     }
;;;4776     
;;;4777     /* Enable interrupts only at the end */
;;;4778     /* to avoid the risk of I2C interrupt handle execution before */
;;;4779     /* all interrupts requested done */
;;;4780     __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
000078  6818              LDR      r0,[r3,#0]
00007a  6800              LDR      r0,[r0,#0]
00007c  4310              ORRS     r0,r0,r2
00007e  681c              LDR      r4,[r3,#0]
000080  6020              STR      r0,[r4,#0]
;;;4781   
;;;4782     return HAL_OK;
000082  2000              MOVS     r0,#0
;;;4783   }
000084  bd10              POP      {r4,pc}
;;;4784   
                          ENDP

000086  0000              DCW      0x0000
                  |L53.136|
                          DCD      I2C_Master_ISR_DMA
                  |L53.140|
                          DCD      I2C_Slave_ISR_DMA

                          AREA ||i.I2C_Flush_TXDR||, CODE, READONLY, ALIGN=1

                  I2C_Flush_TXDR PROC
;;;4282     */
;;;4283   static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
000000  6801              LDR      r1,[r0,#0]
;;;4284   {
;;;4285     /* If a pending TXIS flag is set */
;;;4286     /* Write a dummy data in TXDR to clear it */
;;;4287     if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
000002  6989              LDR      r1,[r1,#0x18]
000004  2202              MOVS     r2,#2
000006  4011              ANDS     r1,r1,r2
000008  0849              LSRS     r1,r1,#1
00000a  2900              CMP      r1,#0
00000c  d002              BEQ      |L54.20|
;;;4288     {
;;;4289        hi2c->Instance->TXDR = 0x00U;
00000e  2100              MOVS     r1,#0
000010  6802              LDR      r2,[r0,#0]
000012  6291              STR      r1,[r2,#0x28]
                  |L54.20|
;;;4290     }
;;;4291   
;;;4292     /* Flush TX register if not empty */
;;;4293     if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
000014  6801              LDR      r1,[r0,#0]
000016  6989              LDR      r1,[r1,#0x18]
000018  07c9              LSLS     r1,r1,#31
00001a  0fc9              LSRS     r1,r1,#31
00001c  2201              MOVS     r2,#1
00001e  4051              EORS     r1,r1,r2
000020  4051              EORS     r1,r1,r2
000022  2900              CMP      r1,#0
000024  d104              BNE      |L54.48|
;;;4294     {
;;;4295       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
000026  6801              LDR      r1,[r0,#0]
000028  6989              LDR      r1,[r1,#0x18]
00002a  4311              ORRS     r1,r1,r2
00002c  6802              LDR      r2,[r0,#0]
00002e  6191              STR      r1,[r2,#0x18]
                  |L54.48|
;;;4296     }
;;;4297   }
000030  4770              BX       lr
;;;4298   
                          ENDP


                          AREA ||i.I2C_ITAddrCplt||, CODE, READONLY, ALIGN=1

                  I2C_ITAddrCplt PROC
;;;3766     */
;;;3767   static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3768   {
000002  4604              MOV      r4,r0
;;;3769     uint8_t transferdirection = 0U;
000004  2700              MOVS     r7,#0
;;;3770     uint16_t slaveaddrcode = 0U;
000006  2500              MOVS     r5,#0
;;;3771     uint16_t ownadd1code = 0U;
000008  2600              MOVS     r6,#0
;;;3772     uint16_t ownadd2code = 0U;
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;3773   
;;;3774     /* Prevent unused argument(s) compilation warning */
;;;3775     UNUSED(ITFlags);
;;;3776   
;;;3777     /* In case of Listen state, need to inform upper layer of address match code event */
;;;3778     if((hi2c->State & HAL_I2C_STATE_LISTEN) == HAL_I2C_STATE_LISTEN)
00000e  2041              MOVS     r0,#0x41
000010  5d00              LDRB     r0,[r0,r4]
000012  2128              MOVS     r1,#0x28
000014  4008              ANDS     r0,r0,r1
000016  2828              CMP      r0,#0x28
000018  d154              BNE      |L55.196|
;;;3779     {
;;;3780       transferdirection = I2C_GET_DIR(hi2c);
00001a  6820              LDR      r0,[r4,#0]
00001c  6980              LDR      r0,[r0,#0x18]
00001e  2101              MOVS     r1,#1
000020  0409              LSLS     r1,r1,#16
000022  4008              ANDS     r0,r0,r1
000024  0c07              LSRS     r7,r0,#16
;;;3781       slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
000026  6820              LDR      r0,[r4,#0]
000028  6980              LDR      r0,[r0,#0x18]
00002a  217f              MOVS     r1,#0x7f
00002c  0449              LSLS     r1,r1,#17
00002e  4008              ANDS     r0,r0,r1
000030  0c05              LSRS     r5,r0,#16
;;;3782       ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
000032  6820              LDR      r0,[r4,#0]
000034  6880              LDR      r0,[r0,#8]
000036  0586              LSLS     r6,r0,#22
000038  0db6              LSRS     r6,r6,#22
;;;3783       ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
00003a  6820              LDR      r0,[r4,#0]
00003c  68c0              LDR      r0,[r0,#0xc]
00003e  21fe              MOVS     r1,#0xfe
000040  4008              ANDS     r0,r0,r1
000042  9000              STR      r0,[sp,#0]
;;;3784   
;;;3785       /* If 10bits addressing mode is selected */
;;;3786       if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
000044  68e0              LDR      r0,[r4,#0xc]
000046  2802              CMP      r0,#2
000048  d12d              BNE      |L55.166|
;;;3787       {
;;;3788         if((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
00004a  2006              MOVS     r0,#6
00004c  4028              ANDS     r0,r0,r5
00004e  11f1              ASRS     r1,r6,#7
000050  2206              MOVS     r2,#6
000052  4011              ANDS     r1,r1,r2
000054  4288              CMP      r0,r1
000056  d116              BNE      |L55.134|
;;;3789         {
;;;3790           slaveaddrcode = ownadd1code;
000058  4635              MOV      r5,r6
;;;3791           hi2c->AddrEventCount++;
00005a  6ca0              LDR      r0,[r4,#0x48]
00005c  1c40              ADDS     r0,r0,#1
00005e  64a0              STR      r0,[r4,#0x48]
;;;3792           if(hi2c->AddrEventCount == 2U)
000060  6ca0              LDR      r0,[r4,#0x48]
000062  2802              CMP      r0,#2
000064  d136              BNE      |L55.212|
;;;3793           {
;;;3794             /* Reset Address Event counter */
;;;3795             hi2c->AddrEventCount = 0U;
000066  2000              MOVS     r0,#0
000068  64a0              STR      r0,[r4,#0x48]
;;;3796   
;;;3797             /* Clear ADDR flag */
;;;3798             __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
00006a  2008              MOVS     r0,#8
00006c  6821              LDR      r1,[r4,#0]
00006e  61c8              STR      r0,[r1,#0x1c]
;;;3799   
;;;3800             /* Process Unlocked */
;;;3801             __HAL_UNLOCK(hi2c);
000070  bf00              NOP      
000072  2100              MOVS     r1,#0
000074  2040              MOVS     r0,#0x40
000076  5501              STRB     r1,[r0,r4]
000078  bf00              NOP      
;;;3802   
;;;3803             /* Call Slave Addr callback */
;;;3804             HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
00007a  462a              MOV      r2,r5
00007c  4639              MOV      r1,r7
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       HAL_I2C_AddrCallback
000084  e026              B        |L55.212|
                  |L55.134|
;;;3805           }
;;;3806         }
;;;3807         else
;;;3808         {
;;;3809           slaveaddrcode = ownadd2code;
000086  9d00              LDR      r5,[sp,#0]
;;;3810   
;;;3811           /* Disable ADDR Interrupts */
;;;3812           I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
000088  2104              MOVS     r1,#4
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       I2C_Disable_IRQ
;;;3813   
;;;3814           /* Process Unlocked */
;;;3815           __HAL_UNLOCK(hi2c);
000090  bf00              NOP      
000092  2100              MOVS     r1,#0
000094  2040              MOVS     r0,#0x40
000096  5501              STRB     r1,[r0,r4]
000098  bf00              NOP      
;;;3816   
;;;3817           /* Call Slave Addr callback */
;;;3818           HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
00009a  462a              MOV      r2,r5
00009c  4639              MOV      r1,r7
00009e  4620              MOV      r0,r4
0000a0  f7fffffe          BL       HAL_I2C_AddrCallback
0000a4  e016              B        |L55.212|
                  |L55.166|
;;;3819         }
;;;3820       }
;;;3821       /* else 7 bits addressing mode is selected */
;;;3822       else
;;;3823       {
;;;3824         /* Disable ADDR Interrupts */
;;;3825         I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
0000a6  2104              MOVS     r1,#4
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       I2C_Disable_IRQ
;;;3826   
;;;3827         /* Process Unlocked */
;;;3828         __HAL_UNLOCK(hi2c);
0000ae  bf00              NOP      
0000b0  2100              MOVS     r1,#0
0000b2  2040              MOVS     r0,#0x40
0000b4  5501              STRB     r1,[r0,r4]
0000b6  bf00              NOP      
;;;3829   
;;;3830         /* Call Slave Addr callback */
;;;3831         HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
0000b8  462a              MOV      r2,r5
0000ba  4639              MOV      r1,r7
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       HAL_I2C_AddrCallback
0000c2  e007              B        |L55.212|
                  |L55.196|
;;;3832       }
;;;3833     }
;;;3834     /* Else clear address flag only */
;;;3835     else
;;;3836     {
;;;3837       /* Clear ADDR flag */
;;;3838       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
0000c4  2008              MOVS     r0,#8
0000c6  6821              LDR      r1,[r4,#0]
0000c8  61c8              STR      r0,[r1,#0x1c]
;;;3839   
;;;3840       /* Process Unlocked */
;;;3841       __HAL_UNLOCK(hi2c);
0000ca  bf00              NOP      
0000cc  2100              MOVS     r1,#0
0000ce  2040              MOVS     r0,#0x40
0000d0  5501              STRB     r1,[r0,r4]
0000d2  bf00              NOP      
                  |L55.212|
;;;3842     }
;;;3843   }
0000d4  bdf8              POP      {r3-r7,pc}
;;;3844   
                          ENDP


                          AREA ||i.I2C_ITError||, CODE, READONLY, ALIGN=2

                  I2C_ITError PROC
;;;4180     */
;;;4181   static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
000000  b570              PUSH     {r4-r6,lr}
;;;4182   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4183     /* Reset handle parameters */
;;;4184     hi2c->Mode          = HAL_I2C_MODE_NONE;
000006  2100              MOVS     r1,#0
000008  2042              MOVS     r0,#0x42
00000a  5501              STRB     r1,[r0,r4]
;;;4185     hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
00000c  483f              LDR      r0,|L56.268|
00000e  62e0              STR      r0,[r4,#0x2c]
;;;4186     hi2c->XferCount     = 0U;
000010  2000              MOVS     r0,#0
000012  8560              STRH     r0,[r4,#0x2a]
;;;4187   
;;;4188     /* Set new error code */
;;;4189     hi2c->ErrorCode |= ErrorCode;
000014  6c60              LDR      r0,[r4,#0x44]
000016  4328              ORRS     r0,r0,r5
000018  6460              STR      r0,[r4,#0x44]
;;;4190   
;;;4191     /* Disable Interrupts */
;;;4192     if((hi2c->State == HAL_I2C_STATE_LISTEN)         ||
00001a  2041              MOVS     r0,#0x41
00001c  5d00              LDRB     r0,[r0,r4]
00001e  2828              CMP      r0,#0x28
000020  d007              BEQ      |L56.50|
;;;4193        (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
000022  2041              MOVS     r0,#0x41
000024  5d00              LDRB     r0,[r0,r4]
000026  2829              CMP      r0,#0x29
000028  d003              BEQ      |L56.50|
;;;4194        (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN))
00002a  2041              MOVS     r0,#0x41
00002c  5d00              LDRB     r0,[r0,r4]
00002e  282a              CMP      r0,#0x2a
000030  d10b              BNE      |L56.74|
                  |L56.50|
;;;4195     {
;;;4196       /* Disable all interrupts, except interrupts related to LISTEN state */
;;;4197       I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
000032  2103              MOVS     r1,#3
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       I2C_Disable_IRQ
;;;4198   
;;;4199       /* keep HAL_I2C_STATE_LISTEN if set */
;;;4200       hi2c->State         = HAL_I2C_STATE_LISTEN;
00003a  2128              MOVS     r1,#0x28
00003c  2041              MOVS     r0,#0x41
00003e  5501              STRB     r1,[r0,r4]
;;;4201       hi2c->PreviousState = I2C_STATE_NONE;
000040  2000              MOVS     r0,#0
000042  6320              STR      r0,[r4,#0x30]
;;;4202       hi2c->XferISR       = I2C_Slave_ISR_IT;
000044  4832              LDR      r0,|L56.272|
000046  6360              STR      r0,[r4,#0x34]
000048  e00d              B        |L56.102|
                  |L56.74|
;;;4203     }
;;;4204     else
;;;4205     {
;;;4206       /* Disable all interrupts */
;;;4207       I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
00004a  2107              MOVS     r1,#7
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       I2C_Disable_IRQ
;;;4208       
;;;4209       /* If state is an abort treatment on goind, don't change state */
;;;4210       /* This change will be do later */
;;;4211       if(hi2c->State != HAL_I2C_STATE_ABORT)
000052  2041              MOVS     r0,#0x41
000054  5d00              LDRB     r0,[r0,r4]
000056  2860              CMP      r0,#0x60
000058  d002              BEQ      |L56.96|
;;;4212       {
;;;4213         /* Set HAL_I2C_STATE_READY */
;;;4214         hi2c->State         = HAL_I2C_STATE_READY;
00005a  2120              MOVS     r1,#0x20
00005c  2041              MOVS     r0,#0x41
00005e  5501              STRB     r1,[r0,r4]
                  |L56.96|
;;;4215       }
;;;4216       hi2c->PreviousState = I2C_STATE_NONE;
000060  2000              MOVS     r0,#0
000062  6320              STR      r0,[r4,#0x30]
;;;4217       hi2c->XferISR       = NULL;
000064  6360              STR      r0,[r4,#0x34]
                  |L56.102|
;;;4218     }
;;;4219   
;;;4220     /* Abort DMA TX transfer if any */
;;;4221     if((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
000066  6820              LDR      r0,[r4,#0]
000068  6800              LDR      r0,[r0,#0]
00006a  2101              MOVS     r1,#1
00006c  0389              LSLS     r1,r1,#14
00006e  4008              ANDS     r0,r0,r1
000070  4288              CMP      r0,r1
000072  d115              BNE      |L56.160|
;;;4222     {
;;;4223       hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
000074  6820              LDR      r0,[r4,#0]
000076  6800              LDR      r0,[r0,#0]
000078  4388              BICS     r0,r0,r1
00007a  6821              LDR      r1,[r4,#0]
00007c  6008              STR      r0,[r1,#0]
;;;4224   
;;;4225       /* Set the I2C DMA Abort callback :
;;;4226          will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4227       hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
00007e  4825              LDR      r0,|L56.276|
000080  6ba1              LDR      r1,[r4,#0x38]
000082  6348              STR      r0,[r1,#0x34]
;;;4228   
;;;4229       /* Process Unlocked */
;;;4230       __HAL_UNLOCK(hi2c);
000084  bf00              NOP      
000086  2100              MOVS     r1,#0
000088  2040              MOVS     r0,#0x40
00008a  5501              STRB     r1,[r0,r4]
00008c  bf00              NOP      
;;;4231   
;;;4232       /* Abort DMA TX */
;;;4233       if(HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
00008e  6ba0              LDR      r0,[r4,#0x38]
000090  f7fffffe          BL       HAL_DMA_Abort_IT
000094  2800              CMP      r0,#0
000096  d038              BEQ      |L56.266|
;;;4234       {
;;;4235         /* Call Directly XferAbortCallback function in case of error */
;;;4236         hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
000098  6ba0              LDR      r0,[r4,#0x38]
00009a  6b41              LDR      r1,[r0,#0x34]
00009c  4788              BLX      r1
00009e  e034              B        |L56.266|
                  |L56.160|
;;;4237       }
;;;4238     }
;;;4239     /* Abort DMA RX transfer if any */
;;;4240     else if((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6800              LDR      r0,[r0,#0]
0000a4  2101              MOVS     r1,#1
0000a6  03c9              LSLS     r1,r1,#15
0000a8  4008              ANDS     r0,r0,r1
0000aa  4288              CMP      r0,r1
0000ac  d115              BNE      |L56.218|
;;;4241     {
;;;4242       hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
0000ae  6820              LDR      r0,[r4,#0]
0000b0  6800              LDR      r0,[r0,#0]
0000b2  4388              BICS     r0,r0,r1
0000b4  6821              LDR      r1,[r4,#0]
0000b6  6008              STR      r0,[r1,#0]
;;;4243   
;;;4244       /* Set the I2C DMA Abort callback :
;;;4245          will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
;;;4246       hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
0000b8  4816              LDR      r0,|L56.276|
0000ba  6be1              LDR      r1,[r4,#0x3c]
0000bc  6348              STR      r0,[r1,#0x34]
;;;4247   
;;;4248       /* Process Unlocked */
;;;4249       __HAL_UNLOCK(hi2c);
0000be  bf00              NOP      
0000c0  2100              MOVS     r1,#0
0000c2  2040              MOVS     r0,#0x40
0000c4  5501              STRB     r1,[r0,r4]
0000c6  bf00              NOP      
;;;4250   
;;;4251       /* Abort DMA RX */
;;;4252       if(HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
0000c8  6be0              LDR      r0,[r4,#0x3c]
0000ca  f7fffffe          BL       HAL_DMA_Abort_IT
0000ce  2800              CMP      r0,#0
0000d0  d01b              BEQ      |L56.266|
;;;4253       {
;;;4254         /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
;;;4255         hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
0000d2  6be0              LDR      r0,[r4,#0x3c]
0000d4  6b41              LDR      r1,[r0,#0x34]
0000d6  4788              BLX      r1
0000d8  e017              B        |L56.266|
                  |L56.218|
;;;4256       }
;;;4257     }
;;;4258     else if(hi2c->State == HAL_I2C_STATE_ABORT)
0000da  2041              MOVS     r0,#0x41
0000dc  5d00              LDRB     r0,[r0,r4]
0000de  2860              CMP      r0,#0x60
0000e0  d10b              BNE      |L56.250|
;;;4259     {
;;;4260       hi2c->State = HAL_I2C_STATE_READY;
0000e2  2120              MOVS     r1,#0x20
0000e4  2041              MOVS     r0,#0x41
0000e6  5501              STRB     r1,[r0,r4]
;;;4261       
;;;4262       /* Process Unlocked */
;;;4263       __HAL_UNLOCK(hi2c);
0000e8  bf00              NOP      
0000ea  2100              MOVS     r1,#0
0000ec  2040              MOVS     r0,#0x40
0000ee  5501              STRB     r1,[r0,r4]
0000f0  bf00              NOP      
;;;4264   
;;;4265       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4266       HAL_I2C_AbortCpltCallback(hi2c);
0000f2  4620              MOV      r0,r4
0000f4  f7fffffe          BL       HAL_I2C_AbortCpltCallback
0000f8  e007              B        |L56.266|
                  |L56.250|
;;;4267     }
;;;4268     else
;;;4269     {
;;;4270       /* Process Unlocked */
;;;4271       __HAL_UNLOCK(hi2c);
0000fa  bf00              NOP      
0000fc  2100              MOVS     r1,#0
0000fe  2040              MOVS     r0,#0x40
000100  5501              STRB     r1,[r0,r4]
000102  bf00              NOP      
;;;4272   
;;;4273       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4274       HAL_I2C_ErrorCallback(hi2c);
000104  4620              MOV      r0,r4
000106  f7fffffe          BL       HAL_I2C_ErrorCallback
                  |L56.266|
;;;4275     }
;;;4276   }
00010a  bd70              POP      {r4-r6,pc}
;;;4277   
                          ENDP

                  |L56.268|
                          DCD      0xffff0000
                  |L56.272|
                          DCD      I2C_Slave_ISR_IT
                  |L56.276|
                          DCD      I2C_DMAAbort

                          AREA ||i.I2C_ITListenCplt||, CODE, READONLY, ALIGN=2

                  I2C_ITListenCplt PROC
;;;4136     */
;;;4137   static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
000000  b570              PUSH     {r4-r6,lr}
;;;4138   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4139     /* Reset handle parameters */
;;;4140     hi2c->XferOptions = I2C_NO_OPTION_FRAME;
000006  481a              LDR      r0,|L57.112|
000008  62e0              STR      r0,[r4,#0x2c]
;;;4141     hi2c->PreviousState = I2C_STATE_NONE;
00000a  2000              MOVS     r0,#0
00000c  6320              STR      r0,[r4,#0x30]
;;;4142     hi2c->State = HAL_I2C_STATE_READY;
00000e  2120              MOVS     r1,#0x20
000010  2041              MOVS     r0,#0x41
000012  5501              STRB     r1,[r0,r4]
;;;4143     hi2c->Mode = HAL_I2C_MODE_NONE;
000014  2100              MOVS     r1,#0
000016  2042              MOVS     r0,#0x42
000018  5501              STRB     r1,[r0,r4]
;;;4144     hi2c->XferISR = NULL;
00001a  2000              MOVS     r0,#0
00001c  6360              STR      r0,[r4,#0x34]
;;;4145   
;;;4146     /* Store Last receive data if any */
;;;4147     if(((ITFlags & I2C_FLAG_RXNE) != RESET))
00001e  2004              MOVS     r0,#4
000020  4028              ANDS     r0,r0,r5
000022  2800              CMP      r0,#0
000024  d013              BEQ      |L57.78|
;;;4148     {
;;;4149       /* Read data from RXDR */
;;;4150       (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
000026  6820              LDR      r0,[r4,#0]
000028  6a40              LDR      r0,[r0,#0x24]
00002a  b2c1              UXTB     r1,r0
00002c  6a62              LDR      r2,[r4,#0x24]
00002e  1c50              ADDS     r0,r2,#1
000030  6260              STR      r0,[r4,#0x24]
000032  7011              STRB     r1,[r2,#0]
;;;4151   
;;;4152       if((hi2c->XferSize > 0U))
000034  8d20              LDRH     r0,[r4,#0x28]
000036  2800              CMP      r0,#0
000038  d009              BEQ      |L57.78|
;;;4153       {
;;;4154         hi2c->XferSize--;
00003a  8d20              LDRH     r0,[r4,#0x28]
00003c  1e40              SUBS     r0,r0,#1
00003e  8520              STRH     r0,[r4,#0x28]
;;;4155         hi2c->XferCount--;
000040  8d60              LDRH     r0,[r4,#0x2a]
000042  1e40              SUBS     r0,r0,#1
000044  8560              STRH     r0,[r4,#0x2a]
;;;4156   
;;;4157         /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;4158         hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
000046  6c60              LDR      r0,[r4,#0x44]
000048  2104              MOVS     r1,#4
00004a  4308              ORRS     r0,r0,r1
00004c  6460              STR      r0,[r4,#0x44]
                  |L57.78|
;;;4159       }
;;;4160     }
;;;4161   
;;;4162     /* Disable all Interrupts*/
;;;4163     I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
00004e  2107              MOVS     r1,#7
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       I2C_Disable_IRQ
;;;4164   
;;;4165     /* Clear NACK Flag */
;;;4166     __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
000056  2010              MOVS     r0,#0x10
000058  6821              LDR      r1,[r4,#0]
00005a  61c8              STR      r0,[r1,#0x1c]
;;;4167   
;;;4168     /* Process Unlocked */
;;;4169     __HAL_UNLOCK(hi2c);
00005c  bf00              NOP      
00005e  2100              MOVS     r1,#0
000060  2040              MOVS     r0,#0x40
000062  5501              STRB     r1,[r0,r4]
000064  bf00              NOP      
;;;4170   
;;;4171     /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;4172     HAL_I2C_ListenCpltCallback(hi2c);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       HAL_I2C_ListenCpltCallback
;;;4173   }
00006c  bd70              POP      {r4-r6,pc}
;;;4174   
                          ENDP

00006e  0000              DCW      0x0000
                  |L57.112|
                          DCD      0xffff0000

                          AREA ||i.I2C_ITMasterCplt||, CODE, READONLY, ALIGN=2

                  I2C_ITMasterCplt PROC
;;;3938     */
;;;3939   static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
000000  b570              PUSH     {r4-r6,lr}
;;;3940   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3941     /* Clear STOP Flag */
;;;3942     __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
000006  2020              MOVS     r0,#0x20
000008  6821              LDR      r1,[r4,#0]
00000a  61c8              STR      r0,[r1,#0x1c]
;;;3943   
;;;3944     /* Clear Configuration Register 2 */
;;;3945     I2C_RESET_CR2(hi2c);
00000c  6820              LDR      r0,[r4,#0]
00000e  6840              LDR      r0,[r0,#4]
000010  4934              LDR      r1,|L58.228|
000012  4008              ANDS     r0,r0,r1
000014  6821              LDR      r1,[r4,#0]
000016  6048              STR      r0,[r1,#4]
;;;3946   
;;;3947     /* Reset handle parameters */
;;;3948     hi2c->PreviousState = I2C_STATE_NONE;
000018  2000              MOVS     r0,#0
00001a  6320              STR      r0,[r4,#0x30]
;;;3949     hi2c->XferISR       = NULL;
00001c  6360              STR      r0,[r4,#0x34]
;;;3950     hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
00001e  4832              LDR      r0,|L58.232|
000020  62e0              STR      r0,[r4,#0x2c]
;;;3951   
;;;3952     if((ITFlags & I2C_FLAG_AF) != RESET)
000022  2010              MOVS     r0,#0x10
000024  4028              ANDS     r0,r0,r5
000026  2800              CMP      r0,#0
000028  d006              BEQ      |L58.56|
;;;3953     {
;;;3954       /* Clear NACK Flag */
;;;3955       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
00002a  2010              MOVS     r0,#0x10
00002c  6821              LDR      r1,[r4,#0]
00002e  61c8              STR      r0,[r1,#0x1c]
;;;3956   
;;;3957       /* Set acknowledge error code */
;;;3958       hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
000030  6c60              LDR      r0,[r4,#0x44]
000032  2104              MOVS     r1,#4
000034  4308              ORRS     r0,r0,r1
000036  6460              STR      r0,[r4,#0x44]
                  |L58.56|
;;;3959     }
;;;3960   
;;;3961     /* Flush TX register */
;;;3962     I2C_Flush_TXDR(hi2c);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       I2C_Flush_TXDR
;;;3963   
;;;3964     /* Disable Interrupts */
;;;3965     I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT| I2C_XFER_RX_IT);
00003e  2103              MOVS     r1,#3
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       I2C_Disable_IRQ
;;;3966   
;;;3967     /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;3968     if((hi2c->ErrorCode != HAL_I2C_ERROR_NONE) || (hi2c->State == HAL_I2C_STATE_ABORT))
000046  6c60              LDR      r0,[r4,#0x44]
000048  2800              CMP      r0,#0
00004a  d103              BNE      |L58.84|
00004c  2041              MOVS     r0,#0x41
00004e  5d00              LDRB     r0,[r0,r4]
000050  2860              CMP      r0,#0x60
000052  d104              BNE      |L58.94|
                  |L58.84|
;;;3969     {
;;;3970       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;3971       I2C_ITError(hi2c, hi2c->ErrorCode);
000054  6c61              LDR      r1,[r4,#0x44]
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       I2C_ITError
00005c  e040              B        |L58.224|
                  |L58.94|
;;;3972     }
;;;3973     /* hi2c->State == HAL_I2C_STATE_BUSY_TX */
;;;3974     else if(hi2c->State == HAL_I2C_STATE_BUSY_TX)
00005e  2041              MOVS     r0,#0x41
000060  5d00              LDRB     r0,[r0,r4]
000062  2821              CMP      r0,#0x21
000064  d11c              BNE      |L58.160|
;;;3975     {
;;;3976       hi2c->State = HAL_I2C_STATE_READY;
000066  2120              MOVS     r1,#0x20
000068  2041              MOVS     r0,#0x41
00006a  5501              STRB     r1,[r0,r4]
;;;3977   
;;;3978       if (hi2c->Mode == HAL_I2C_MODE_MEM)
00006c  2042              MOVS     r0,#0x42
00006e  5d00              LDRB     r0,[r0,r4]
000070  2840              CMP      r0,#0x40
000072  d10a              BNE      |L58.138|
;;;3979       {
;;;3980         hi2c->Mode = HAL_I2C_MODE_NONE;
000074  2100              MOVS     r1,#0
000076  2042              MOVS     r0,#0x42
000078  5501              STRB     r1,[r0,r4]
;;;3981   
;;;3982         /* Process Unlocked */
;;;3983         __HAL_UNLOCK(hi2c);
00007a  bf00              NOP      
00007c  2040              MOVS     r0,#0x40
00007e  5501              STRB     r1,[r0,r4]
000080  bf00              NOP      
;;;3984   
;;;3985         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;3986         HAL_I2C_MemTxCpltCallback(hi2c);
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       HAL_I2C_MemTxCpltCallback
000088  e02a              B        |L58.224|
                  |L58.138|
;;;3987       }
;;;3988       else
;;;3989       {
;;;3990         hi2c->Mode = HAL_I2C_MODE_NONE;
00008a  2100              MOVS     r1,#0
00008c  2042              MOVS     r0,#0x42
00008e  5501              STRB     r1,[r0,r4]
;;;3991   
;;;3992         /* Process Unlocked */
;;;3993         __HAL_UNLOCK(hi2c);
000090  bf00              NOP      
000092  2040              MOVS     r0,#0x40
000094  5501              STRB     r1,[r0,r4]
000096  bf00              NOP      
;;;3994   
;;;3995         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;3996         HAL_I2C_MasterTxCpltCallback(hi2c);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
00009e  e01f              B        |L58.224|
                  |L58.160|
;;;3997       }
;;;3998     }
;;;3999     /* hi2c->State == HAL_I2C_STATE_BUSY_RX */
;;;4000     else if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
0000a0  2041              MOVS     r0,#0x41
0000a2  5d00              LDRB     r0,[r0,r4]
0000a4  2822              CMP      r0,#0x22
0000a6  d11b              BNE      |L58.224|
;;;4001     {
;;;4002       hi2c->State = HAL_I2C_STATE_READY;
0000a8  2120              MOVS     r1,#0x20
0000aa  2041              MOVS     r0,#0x41
0000ac  5501              STRB     r1,[r0,r4]
;;;4003   
;;;4004       if (hi2c->Mode == HAL_I2C_MODE_MEM)
0000ae  2042              MOVS     r0,#0x42
0000b0  5d00              LDRB     r0,[r0,r4]
0000b2  2840              CMP      r0,#0x40
0000b4  d10a              BNE      |L58.204|
;;;4005       {
;;;4006         hi2c->Mode = HAL_I2C_MODE_NONE;
0000b6  2100              MOVS     r1,#0
0000b8  2042              MOVS     r0,#0x42
0000ba  5501              STRB     r1,[r0,r4]
;;;4007   
;;;4008         /* Process Unlocked */
;;;4009         __HAL_UNLOCK(hi2c);
0000bc  bf00              NOP      
0000be  2040              MOVS     r0,#0x40
0000c0  5501              STRB     r1,[r0,r4]
0000c2  bf00              NOP      
;;;4010   
;;;4011         HAL_I2C_MemRxCpltCallback(hi2c);
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       HAL_I2C_MemRxCpltCallback
0000ca  e009              B        |L58.224|
                  |L58.204|
;;;4012       }
;;;4013       else
;;;4014       {
;;;4015         hi2c->Mode = HAL_I2C_MODE_NONE;
0000cc  2100              MOVS     r1,#0
0000ce  2042              MOVS     r0,#0x42
0000d0  5501              STRB     r1,[r0,r4]
;;;4016   
;;;4017         /* Process Unlocked */
;;;4018         __HAL_UNLOCK(hi2c);
0000d2  bf00              NOP      
0000d4  2040              MOVS     r0,#0x40
0000d6  5501              STRB     r1,[r0,r4]
0000d8  bf00              NOP      
;;;4019   
;;;4020         HAL_I2C_MasterRxCpltCallback(hi2c);
0000da  4620              MOV      r0,r4
0000dc  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
                  |L58.224|
;;;4021       }
;;;4022     }
;;;4023   }
0000e0  bd70              POP      {r4-r6,pc}
;;;4024   
                          ENDP

0000e2  0000              DCW      0x0000
                  |L58.228|
                          DCD      0xfe00e800
                  |L58.232|
                          DCD      0xffff0000

                          AREA ||i.I2C_ITMasterSequentialCplt||, CODE, READONLY, ALIGN=1

                  I2C_ITMasterSequentialCplt PROC
;;;3849     */
;;;3850   static void I2C_ITMasterSequentialCplt(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;3851   {
000002  4604              MOV      r4,r0
;;;3852     /* Reset I2C handle mode */
;;;3853     hi2c->Mode = HAL_I2C_MODE_NONE;
000004  2100              MOVS     r1,#0
000006  2042              MOVS     r0,#0x42
000008  5501              STRB     r1,[r0,r4]
;;;3854   
;;;3855     /* No Generate Stop, to permit restart mode */
;;;3856     /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */
;;;3857     if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
00000a  2041              MOVS     r0,#0x41
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2821              CMP      r0,#0x21
000010  d113              BNE      |L59.58|
;;;3858     {
;;;3859       hi2c->State         = HAL_I2C_STATE_READY;
000012  2120              MOVS     r1,#0x20
000014  2041              MOVS     r0,#0x41
000016  5501              STRB     r1,[r0,r4]
;;;3860       hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
000018  2011              MOVS     r0,#0x11
00001a  6320              STR      r0,[r4,#0x30]
;;;3861       hi2c->XferISR       = NULL;
00001c  2000              MOVS     r0,#0
00001e  6360              STR      r0,[r4,#0x34]
;;;3862   
;;;3863       /* Disable Interrupts */
;;;3864       I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
000020  2101              MOVS     r1,#1
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       I2C_Disable_IRQ
;;;3865   
;;;3866       /* Process Unlocked */
;;;3867       __HAL_UNLOCK(hi2c);
000028  bf00              NOP      
00002a  2100              MOVS     r1,#0
00002c  2040              MOVS     r0,#0x40
00002e  5501              STRB     r1,[r0,r4]
000030  bf00              NOP      
;;;3868   
;;;3869       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;3870       HAL_I2C_MasterTxCpltCallback(hi2c);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_I2C_MasterTxCpltCallback
000038  e012              B        |L59.96|
                  |L59.58|
;;;3871     }
;;;3872     /* hi2c->State == HAL_I2C_STATE_BUSY_RX */
;;;3873     else
;;;3874     {
;;;3875       hi2c->State         = HAL_I2C_STATE_READY;
00003a  2120              MOVS     r1,#0x20
00003c  2041              MOVS     r0,#0x41
00003e  5501              STRB     r1,[r0,r4]
;;;3876       hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
000040  2012              MOVS     r0,#0x12
000042  6320              STR      r0,[r4,#0x30]
;;;3877       hi2c->XferISR       = NULL;
000044  2000              MOVS     r0,#0
000046  6360              STR      r0,[r4,#0x34]
;;;3878   
;;;3879       /* Disable Interrupts */
;;;3880       I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
000048  2102              MOVS     r1,#2
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       I2C_Disable_IRQ
;;;3881   
;;;3882       /* Process Unlocked */
;;;3883       __HAL_UNLOCK(hi2c);
000050  bf00              NOP      
000052  2100              MOVS     r1,#0
000054  2040              MOVS     r0,#0x40
000056  5501              STRB     r1,[r0,r4]
000058  bf00              NOP      
;;;3884   
;;;3885       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;3886       HAL_I2C_MasterRxCpltCallback(hi2c);
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       HAL_I2C_MasterRxCpltCallback
                  |L59.96|
;;;3887     }
;;;3888   }
000060  bd10              POP      {r4,pc}
;;;3889   
                          ENDP


                          AREA ||i.I2C_ITSlaveCplt||, CODE, READONLY, ALIGN=2

                  I2C_ITSlaveCplt PROC
;;;4030     */
;;;4031   static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
000000  b570              PUSH     {r4-r6,lr}
;;;4032   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4033     /* Clear STOP Flag */
;;;4034     __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
000006  2020              MOVS     r0,#0x20
000008  6821              LDR      r1,[r4,#0]
00000a  61c8              STR      r0,[r1,#0x1c]
;;;4035   
;;;4036     /* Clear ADDR flag */
;;;4037     __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
00000c  2008              MOVS     r0,#8
00000e  6821              LDR      r1,[r4,#0]
000010  61c8              STR      r0,[r1,#0x1c]
;;;4038   
;;;4039     /* Disable all interrupts */
;;;4040     I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT | I2C_XFER_RX_IT);
000012  2107              MOVS     r1,#7
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       I2C_Disable_IRQ
;;;4041   
;;;4042     /* Disable Address Acknowledge */
;;;4043     hi2c->Instance->CR2 |= I2C_CR2_NACK;
00001a  6820              LDR      r0,[r4,#0]
00001c  6840              LDR      r0,[r0,#4]
00001e  2101              MOVS     r1,#1
000020  03c9              LSLS     r1,r1,#15
000022  4308              ORRS     r0,r0,r1
000024  6821              LDR      r1,[r4,#0]
000026  6048              STR      r0,[r1,#4]
;;;4044   
;;;4045     /* Clear Configuration Register 2 */
;;;4046     I2C_RESET_CR2(hi2c);
000028  6820              LDR      r0,[r4,#0]
00002a  6840              LDR      r0,[r0,#4]
00002c  4941              LDR      r1,|L60.308|
00002e  4008              ANDS     r0,r0,r1
000030  6821              LDR      r1,[r4,#0]
000032  6048              STR      r0,[r1,#4]
;;;4047   
;;;4048     /* Flush TX register */
;;;4049     I2C_Flush_TXDR(hi2c);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       I2C_Flush_TXDR
;;;4050   
;;;4051     /* If a DMA is ongoing, Update handle size context */
;;;4052     if(((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN) ||
00003a  6820              LDR      r0,[r4,#0]
00003c  6800              LDR      r0,[r0,#0]
00003e  2101              MOVS     r1,#1
000040  0389              LSLS     r1,r1,#14
000042  4008              ANDS     r0,r0,r1
000044  4288              CMP      r0,r1
000046  d005              BEQ      |L60.84|
;;;4053        ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN))
000048  6820              LDR      r0,[r4,#0]
00004a  6800              LDR      r0,[r0,#0]
00004c  0049              LSLS     r1,r1,#1
00004e  4008              ANDS     r0,r0,r1
000050  4288              CMP      r0,r1
000052  d10b              BNE      |L60.108|
                  |L60.84|
;;;4054     {
;;;4055       hi2c->XferCount = I2C_GET_DMA_REMAIN_DATA(hi2c);
000054  2041              MOVS     r0,#0x41
000056  5d00              LDRB     r0,[r0,r4]
000058  2821              CMP      r0,#0x21
00005a  d103              BNE      |L60.100|
00005c  6ba0              LDR      r0,[r4,#0x38]
00005e  6800              LDR      r0,[r0,#0]
000060  6840              LDR      r0,[r0,#4]
000062  e002              B        |L60.106|
                  |L60.100|
000064  6be0              LDR      r0,[r4,#0x3c]
000066  6800              LDR      r0,[r0,#0]
000068  6840              LDR      r0,[r0,#4]
                  |L60.106|
00006a  8560              STRH     r0,[r4,#0x2a]
                  |L60.108|
;;;4056     }
;;;4057   
;;;4058     /* All data are not transferred, so set error code accordingly */
;;;4059     if(hi2c->XferCount != 0U)
00006c  8d60              LDRH     r0,[r4,#0x2a]
00006e  2800              CMP      r0,#0
000070  d003              BEQ      |L60.122|
;;;4060     {
;;;4061       /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;4062       hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
000072  6c60              LDR      r0,[r4,#0x44]
000074  2104              MOVS     r1,#4
000076  4308              ORRS     r0,r0,r1
000078  6460              STR      r0,[r4,#0x44]
                  |L60.122|
;;;4063     }
;;;4064   
;;;4065     /* Store Last receive data if any */
;;;4066     if(((ITFlags & I2C_FLAG_RXNE) != RESET))
00007a  2004              MOVS     r0,#4
00007c  4028              ANDS     r0,r0,r5
00007e  2800              CMP      r0,#0
000080  d013              BEQ      |L60.170|
;;;4067     {
;;;4068       /* Read data from RXDR */
;;;4069       (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
000082  6820              LDR      r0,[r4,#0]
000084  6a40              LDR      r0,[r0,#0x24]
000086  b2c1              UXTB     r1,r0
000088  6a62              LDR      r2,[r4,#0x24]
00008a  1c50              ADDS     r0,r2,#1
00008c  6260              STR      r0,[r4,#0x24]
00008e  7011              STRB     r1,[r2,#0]
;;;4070   
;;;4071       if((hi2c->XferSize > 0U))
000090  8d20              LDRH     r0,[r4,#0x28]
000092  2800              CMP      r0,#0
000094  d009              BEQ      |L60.170|
;;;4072       {
;;;4073         hi2c->XferSize--;
000096  8d20              LDRH     r0,[r4,#0x28]
000098  1e40              SUBS     r0,r0,#1
00009a  8520              STRH     r0,[r4,#0x28]
;;;4074         hi2c->XferCount--;
00009c  8d60              LDRH     r0,[r4,#0x2a]
00009e  1e40              SUBS     r0,r0,#1
0000a0  8560              STRH     r0,[r4,#0x2a]
;;;4075   
;;;4076         /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;4077         hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
0000a2  6c60              LDR      r0,[r4,#0x44]
0000a4  2104              MOVS     r1,#4
0000a6  4308              ORRS     r0,r0,r1
0000a8  6460              STR      r0,[r4,#0x44]
                  |L60.170|
;;;4078       }
;;;4079     }
;;;4080   
;;;4081     hi2c->PreviousState = I2C_STATE_NONE;
0000aa  2000              MOVS     r0,#0
0000ac  6320              STR      r0,[r4,#0x30]
;;;4082     hi2c->Mode = HAL_I2C_MODE_NONE;
0000ae  2100              MOVS     r1,#0
0000b0  2042              MOVS     r0,#0x42
0000b2  5501              STRB     r1,[r0,r4]
;;;4083     hi2c->XferISR = NULL;
0000b4  2000              MOVS     r0,#0
0000b6  6360              STR      r0,[r4,#0x34]
;;;4084   
;;;4085     if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
0000b8  6c60              LDR      r0,[r4,#0x44]
0000ba  2800              CMP      r0,#0
0000bc  d00c              BEQ      |L60.216|
;;;4086     {
;;;4087       /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4088       I2C_ITError(hi2c, hi2c->ErrorCode);
0000be  6c61              LDR      r1,[r4,#0x44]
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       I2C_ITError
;;;4089   
;;;4090       /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;4091       if(hi2c->State == HAL_I2C_STATE_LISTEN)
0000c6  2041              MOVS     r0,#0x41
0000c8  5d00              LDRB     r0,[r0,r4]
0000ca  2828              CMP      r0,#0x28
0000cc  d131              BNE      |L60.306|
;;;4092       {
;;;4093         /* Call I2C Listen complete process */
;;;4094         I2C_ITListenCplt(hi2c, ITFlags);
0000ce  4629              MOV      r1,r5
0000d0  4620              MOV      r0,r4
0000d2  f7fffffe          BL       I2C_ITListenCplt
0000d6  e02c              B        |L60.306|
                  |L60.216|
;;;4095       }
;;;4096     }
;;;4097     else if(hi2c->XferOptions != I2C_NO_OPTION_FRAME)
0000d8  6ae0              LDR      r0,[r4,#0x2c]
0000da  4917              LDR      r1,|L60.312|
0000dc  4288              CMP      r0,r1
0000de  d00d              BEQ      |L60.252|
;;;4098     {
;;;4099       hi2c->XferOptions = I2C_NO_OPTION_FRAME;
0000e0  4608              MOV      r0,r1
0000e2  62e0              STR      r0,[r4,#0x2c]
;;;4100       hi2c->State = HAL_I2C_STATE_READY;
0000e4  2120              MOVS     r1,#0x20
0000e6  2041              MOVS     r0,#0x41
0000e8  5501              STRB     r1,[r0,r4]
;;;4101   
;;;4102       /* Process Unlocked */
;;;4103       __HAL_UNLOCK(hi2c);
0000ea  bf00              NOP      
0000ec  2100              MOVS     r1,#0
0000ee  2040              MOVS     r0,#0x40
0000f0  5501              STRB     r1,[r0,r4]
0000f2  bf00              NOP      
;;;4104   
;;;4105       /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
;;;4106       HAL_I2C_ListenCpltCallback(hi2c);
0000f4  4620              MOV      r0,r4
0000f6  f7fffffe          BL       HAL_I2C_ListenCpltCallback
0000fa  e01a              B        |L60.306|
                  |L60.252|
;;;4107     }
;;;4108     /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;4109     else if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
0000fc  2041              MOVS     r0,#0x41
0000fe  5d00              LDRB     r0,[r0,r4]
000100  2822              CMP      r0,#0x22
000102  d10b              BNE      |L60.284|
;;;4110     {
;;;4111       hi2c->State = HAL_I2C_STATE_READY;
000104  2120              MOVS     r1,#0x20
000106  2041              MOVS     r0,#0x41
000108  5501              STRB     r1,[r0,r4]
;;;4112   
;;;4113       /* Process Unlocked */
;;;4114       __HAL_UNLOCK(hi2c);
00010a  bf00              NOP      
00010c  2100              MOVS     r1,#0
00010e  2040              MOVS     r0,#0x40
000110  5501              STRB     r1,[r0,r4]
000112  bf00              NOP      
;;;4115   
;;;4116       /* Call the Slave Rx Complete callback */
;;;4117       HAL_I2C_SlaveRxCpltCallback(hi2c);
000114  4620              MOV      r0,r4
000116  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
00011a  e00a              B        |L60.306|
                  |L60.284|
;;;4118     }
;;;4119     else
;;;4120     {
;;;4121       hi2c->State = HAL_I2C_STATE_READY;
00011c  2120              MOVS     r1,#0x20
00011e  2041              MOVS     r0,#0x41
000120  5501              STRB     r1,[r0,r4]
;;;4122   
;;;4123       /* Process Unlocked */
;;;4124       __HAL_UNLOCK(hi2c);
000122  bf00              NOP      
000124  2100              MOVS     r1,#0
000126  2040              MOVS     r0,#0x40
000128  5501              STRB     r1,[r0,r4]
00012a  bf00              NOP      
;;;4125   
;;;4126       /* Call the Slave Tx Complete callback */
;;;4127       HAL_I2C_SlaveTxCpltCallback(hi2c);
00012c  4620              MOV      r0,r4
00012e  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
                  |L60.306|
;;;4128     }
;;;4129   }
000132  bd70              POP      {r4-r6,pc}
;;;4130   
                          ENDP

                  |L60.308|
                          DCD      0xfe00e800
                  |L60.312|
                          DCD      0xffff0000

                          AREA ||i.I2C_ITSlaveSequentialCplt||, CODE, READONLY, ALIGN=1

                  I2C_ITSlaveSequentialCplt PROC
;;;3894     */
;;;3895   static void I2C_ITSlaveSequentialCplt(I2C_HandleTypeDef *hi2c)
000000  b510              PUSH     {r4,lr}
;;;3896   {
000002  4604              MOV      r4,r0
;;;3897     /* Reset I2C handle mode */
;;;3898     hi2c->Mode = HAL_I2C_MODE_NONE;
000004  2100              MOVS     r1,#0
000006  2042              MOVS     r0,#0x42
000008  5501              STRB     r1,[r0,r4]
;;;3899   
;;;3900     if(hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
00000a  2041              MOVS     r0,#0x41
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2829              CMP      r0,#0x29
000010  d111              BNE      |L61.54|
;;;3901     {
;;;3902       /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
;;;3903       hi2c->State         = HAL_I2C_STATE_LISTEN;
000012  2128              MOVS     r1,#0x28
000014  2041              MOVS     r0,#0x41
000016  5501              STRB     r1,[r0,r4]
;;;3904       hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
000018  2021              MOVS     r0,#0x21
00001a  6320              STR      r0,[r4,#0x30]
;;;3905   
;;;3906       /* Disable Interrupts */
;;;3907       I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
00001c  2101              MOVS     r1,#1
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       I2C_Disable_IRQ
;;;3908   
;;;3909       /* Process Unlocked */
;;;3910       __HAL_UNLOCK(hi2c);
000024  bf00              NOP      
000026  2100              MOVS     r1,#0
000028  2040              MOVS     r0,#0x40
00002a  5501              STRB     r1,[r0,r4]
00002c  bf00              NOP      
;;;3911   
;;;3912       /* Call the Tx complete callback to inform upper layer of the end of transmit process */
;;;3913       HAL_I2C_SlaveTxCpltCallback(hi2c);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_I2C_SlaveTxCpltCallback
000034  e014              B        |L61.96|
                  |L61.54|
;;;3914     }
;;;3915   
;;;3916     else if(hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
000036  2041              MOVS     r0,#0x41
000038  5d00              LDRB     r0,[r0,r4]
00003a  282a              CMP      r0,#0x2a
00003c  d110              BNE      |L61.96|
;;;3917     {
;;;3918       /* Remove HAL_I2C_STATE_SLAVE_BUSY_RX, keep only HAL_I2C_STATE_LISTEN */
;;;3919       hi2c->State         = HAL_I2C_STATE_LISTEN;
00003e  2128              MOVS     r1,#0x28
000040  2041              MOVS     r0,#0x41
000042  5501              STRB     r1,[r0,r4]
;;;3920       hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
000044  2022              MOVS     r0,#0x22
000046  6320              STR      r0,[r4,#0x30]
;;;3921   
;;;3922       /* Disable Interrupts */
;;;3923       I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
000048  2102              MOVS     r1,#2
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       I2C_Disable_IRQ
;;;3924   
;;;3925       /* Process Unlocked */
;;;3926       __HAL_UNLOCK(hi2c);
000050  bf00              NOP      
000052  2100              MOVS     r1,#0
000054  2040              MOVS     r0,#0x40
000056  5501              STRB     r1,[r0,r4]
000058  bf00              NOP      
;;;3927   
;;;3928       /* Call the Rx complete callback to inform upper layer of the end of receive process */
;;;3929       HAL_I2C_SlaveRxCpltCallback(hi2c);
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       HAL_I2C_SlaveRxCpltCallback
                  |L61.96|
;;;3930     }
;;;3931   }
000060  bd10              POP      {r4,pc}
;;;3932   
                          ENDP


                          AREA ||i.I2C_IsAcknowledgeFailed||, CODE, READONLY, ALIGN=2

                  I2C_IsAcknowledgeFailed PROC
;;;4622     */
;;;4623   static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;4624   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;4625     if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
000008  6820              LDR      r0,[r4,#0]
00000a  6980              LDR      r0,[r0,#0x18]
00000c  2110              MOVS     r1,#0x10
00000e  4008              ANDS     r0,r0,r1
000010  0900              LSRS     r0,r0,#4
000012  2800              CMP      r0,#0
000014  d03a              BEQ      |L62.140|
;;;4626     {
;;;4627       /* Wait until STOP Flag is reset */
;;;4628       /* AutoEnd should be initiate after AF */
;;;4629       while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
000016  e015              B        |L62.68|
                  |L62.24|
;;;4630       {
;;;4631         /* Check for the Timeout */
;;;4632         if(Timeout != HAL_MAX_DELAY)
000018  1c68              ADDS     r0,r5,#1
00001a  2800              CMP      r0,#0
00001c  d012              BEQ      |L62.68|
;;;4633         {
;;;4634         if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
00001e  2d00              CMP      r5,#0
000020  d004              BEQ      |L62.44|
000022  f7fffffe          BL       HAL_GetTick
000026  1b80              SUBS     r0,r0,r6
000028  42a8              CMP      r0,r5
00002a  d90b              BLS      |L62.68|
                  |L62.44|
;;;4635           {
;;;4636             hi2c->State= HAL_I2C_STATE_READY;
00002c  2120              MOVS     r1,#0x20
00002e  2041              MOVS     r0,#0x41
000030  5501              STRB     r1,[r0,r4]
;;;4637             hi2c->Mode = HAL_I2C_MODE_NONE;
000032  2100              MOVS     r1,#0
000034  2042              MOVS     r0,#0x42
000036  5501              STRB     r1,[r0,r4]
;;;4638   
;;;4639             /* Process Unlocked */
;;;4640             __HAL_UNLOCK(hi2c);
000038  bf00              NOP      
00003a  2040              MOVS     r0,#0x40
00003c  5501              STRB     r1,[r0,r4]
00003e  bf00              NOP      
;;;4641             return HAL_TIMEOUT;
000040  2003              MOVS     r0,#3
                  |L62.66|
;;;4642           }
;;;4643         }
;;;4644       }
;;;4645   
;;;4646       /* Clear NACKF Flag */
;;;4647       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;4648   
;;;4649       /* Clear STOP Flag */
;;;4650       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;4651   
;;;4652       /* Flush TX register */
;;;4653       I2C_Flush_TXDR(hi2c);
;;;4654   
;;;4655       /* Clear Configuration Register 2 */
;;;4656       I2C_RESET_CR2(hi2c);
;;;4657   
;;;4658       hi2c->ErrorCode = HAL_I2C_ERROR_AF;
;;;4659       hi2c->State= HAL_I2C_STATE_READY;
;;;4660       hi2c->Mode = HAL_I2C_MODE_NONE;
;;;4661   
;;;4662       /* Process Unlocked */
;;;4663       __HAL_UNLOCK(hi2c);
;;;4664   
;;;4665       return HAL_ERROR;
;;;4666     }
;;;4667     return HAL_OK;
;;;4668   }
000042  bd70              POP      {r4-r6,pc}
                  |L62.68|
000044  6820              LDR      r0,[r4,#0]            ;4629
000046  6980              LDR      r0,[r0,#0x18]         ;4629
000048  2120              MOVS     r1,#0x20              ;4629
00004a  4008              ANDS     r0,r0,r1              ;4629
00004c  0940              LSRS     r0,r0,#5              ;4629
00004e  2800              CMP      r0,#0                 ;4629
000050  d0e2              BEQ      |L62.24|
000052  2010              MOVS     r0,#0x10              ;4647
000054  6821              LDR      r1,[r4,#0]            ;4647
000056  61c8              STR      r0,[r1,#0x1c]         ;4647
000058  2020              MOVS     r0,#0x20              ;4650
00005a  6821              LDR      r1,[r4,#0]            ;4650
00005c  61c8              STR      r0,[r1,#0x1c]         ;4650
00005e  4620              MOV      r0,r4                 ;4653
000060  f7fffffe          BL       I2C_Flush_TXDR
000064  6820              LDR      r0,[r4,#0]            ;4656
000066  6840              LDR      r0,[r0,#4]            ;4656
000068  4909              LDR      r1,|L62.144|
00006a  4008              ANDS     r0,r0,r1              ;4656
00006c  6821              LDR      r1,[r4,#0]            ;4656
00006e  6048              STR      r0,[r1,#4]            ;4656
000070  2004              MOVS     r0,#4                 ;4658
000072  6460              STR      r0,[r4,#0x44]         ;4658
000074  2120              MOVS     r1,#0x20              ;4659
000076  2041              MOVS     r0,#0x41              ;4659
000078  5501              STRB     r1,[r0,r4]            ;4659
00007a  2100              MOVS     r1,#0                 ;4660
00007c  2042              MOVS     r0,#0x42              ;4660
00007e  5501              STRB     r1,[r0,r4]            ;4660
000080  bf00              NOP                            ;4663
000082  2040              MOVS     r0,#0x40              ;4663
000084  5501              STRB     r1,[r0,r4]            ;4663
000086  bf00              NOP                            ;4663
000088  2001              MOVS     r0,#1                 ;4665
00008a  e7da              B        |L62.66|
                  |L62.140|
00008c  2000              MOVS     r0,#0                 ;4667
00008e  e7d8              B        |L62.66|
;;;4669   
                          ENDP

                  |L62.144|
                          DCD      0xfe00e800

                          AREA ||i.I2C_Master_ISR_DMA||, CODE, READONLY, ALIGN=1

                  I2C_Master_ISR_DMA PROC
;;;3494     */
;;;3495   static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources) 
000000  b5fe              PUSH     {r1-r7,lr}
;;;3496   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3497     uint16_t devaddress = 0U;
000008  2700              MOVS     r7,#0
;;;3498     uint32_t xfermode = 0U;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;3499   
;;;3500     /* Process Locked */
;;;3501     __HAL_LOCK(hi2c);
00000e  bf00              NOP      
000010  2040              MOVS     r0,#0x40
000012  5d00              LDRB     r0,[r0,r4]
000014  2801              CMP      r0,#1
000016  d101              BNE      |L63.28|
000018  2002              MOVS     r0,#2
                  |L63.26|
;;;3502   
;;;3503     if(((ITFlags & I2C_FLAG_AF) != RESET) && ((ITSources & I2C_IT_NACKI) != RESET))
;;;3504     {
;;;3505       /* Clear NACK Flag */
;;;3506       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;3507   
;;;3508       /* Set corresponding Error Code */
;;;3509       hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
;;;3510       
;;;3511       /* No need to generate STOP, it is automatically done */
;;;3512       /* But enable STOP interrupt, to treat it */
;;;3513       /* Error callback will be send during stop flag treatment */
;;;3514       I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
;;;3515   
;;;3516       /* Flush TX register */
;;;3517       I2C_Flush_TXDR(hi2c);
;;;3518     }
;;;3519     else if(((ITFlags & I2C_FLAG_TCR) != RESET) && ((ITSources & I2C_IT_TCI) != RESET))
;;;3520     {
;;;3521       /* Disable TC interrupt */
;;;3522       __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
;;;3523       
;;;3524       if(hi2c->XferCount != 0U)
;;;3525       {
;;;3526         /* Recover Slave address */
;;;3527         devaddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
;;;3528         
;;;3529         /* Prepare the new XferSize to transfer */
;;;3530         if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;3531         {
;;;3532           hi2c->XferSize = MAX_NBYTE_SIZE;
;;;3533           xfermode = I2C_RELOAD_MODE;
;;;3534         }
;;;3535         else
;;;3536         {
;;;3537           hi2c->XferSize = hi2c->XferCount;
;;;3538           xfermode = I2C_AUTOEND_MODE;
;;;3539         }
;;;3540   
;;;3541         /* Set the new XferSize in Nbytes register */
;;;3542         I2C_TransferConfig(hi2c, devaddress, hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
;;;3543   
;;;3544         /* Update XferCount value */
;;;3545         hi2c->XferCount -= hi2c->XferSize;
;;;3546   
;;;3547         /* Enable DMA Request */
;;;3548         if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
;;;3549         {
;;;3550           hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
;;;3551         }
;;;3552         else
;;;3553         {
;;;3554           hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
;;;3555         }
;;;3556       }
;;;3557       else
;;;3558       {
;;;3559         /* Wrong size Status regarding TCR flag event */
;;;3560         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;3561         I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
;;;3562       }
;;;3563     }
;;;3564     else if(((ITFlags & I2C_FLAG_STOPF) != RESET) && ((ITSources & I2C_IT_STOPI) != RESET))
;;;3565     {
;;;3566       /* Call I2C Master complete process */
;;;3567       I2C_ITMasterCplt(hi2c, ITFlags);
;;;3568     }
;;;3569   
;;;3570     /* Process Unlocked */
;;;3571     __HAL_UNLOCK(hi2c);
;;;3572   
;;;3573     return HAL_OK;
;;;3574   }
00001a  bdfe              POP      {r1-r7,pc}
                  |L63.28|
00001c  2101              MOVS     r1,#1                 ;3501
00001e  2040              MOVS     r0,#0x40              ;3501
000020  5501              STRB     r1,[r0,r4]            ;3501
000022  bf00              NOP                            ;3501
000024  2010              MOVS     r0,#0x10              ;3503
000026  4028              ANDS     r0,r0,r5              ;3503
000028  2800              CMP      r0,#0                 ;3503
00002a  d012              BEQ      |L63.82|
00002c  2010              MOVS     r0,#0x10              ;3503
00002e  4030              ANDS     r0,r0,r6              ;3503
000030  2800              CMP      r0,#0                 ;3503
000032  d00e              BEQ      |L63.82|
000034  2010              MOVS     r0,#0x10              ;3506
000036  6821              LDR      r1,[r4,#0]            ;3506
000038  61c8              STR      r0,[r1,#0x1c]         ;3506
00003a  6c60              LDR      r0,[r4,#0x44]         ;3509
00003c  2104              MOVS     r1,#4                 ;3509
00003e  4308              ORRS     r0,r0,r1              ;3509
000040  6460              STR      r0,[r4,#0x44]         ;3509
000042  2112              MOVS     r1,#0x12              ;3514
000044  4620              MOV      r0,r4                 ;3514
000046  f7fffffe          BL       I2C_Enable_IRQ
00004a  4620              MOV      r0,r4                 ;3517
00004c  f7fffffe          BL       I2C_Flush_TXDR
000050  e054              B        |L63.252|
                  |L63.82|
000052  2080              MOVS     r0,#0x80              ;3519
000054  4028              ANDS     r0,r0,r5              ;3519
000056  2800              CMP      r0,#0                 ;3519
000058  d044              BEQ      |L63.228|
00005a  2040              MOVS     r0,#0x40              ;3519
00005c  4030              ANDS     r0,r0,r6              ;3519
00005e  2800              CMP      r0,#0                 ;3519
000060  d040              BEQ      |L63.228|
000062  6820              LDR      r0,[r4,#0]            ;3522
000064  6800              LDR      r0,[r0,#0]            ;3522
000066  2140              MOVS     r1,#0x40              ;3522
000068  4388              BICS     r0,r0,r1              ;3522
00006a  6821              LDR      r1,[r4,#0]            ;3522
00006c  6008              STR      r0,[r1,#0]            ;3522
00006e  8d60              LDRH     r0,[r4,#0x2a]         ;3524
000070  2800              CMP      r0,#0                 ;3524
000072  d032              BEQ      |L63.218|
000074  6820              LDR      r0,[r4,#0]            ;3527
000076  6840              LDR      r0,[r0,#4]            ;3527
000078  0587              LSLS     r7,r0,#22             ;3527
00007a  0dbf              LSRS     r7,r7,#22             ;3527
00007c  8d60              LDRH     r0,[r4,#0x2a]         ;3530
00007e  28ff              CMP      r0,#0xff              ;3530
000080  d905              BLS      |L63.142|
000082  20ff              MOVS     r0,#0xff              ;3532
000084  8520              STRH     r0,[r4,#0x28]         ;3532
000086  2001              MOVS     r0,#1                 ;3533
000088  0600              LSLS     r0,r0,#24             ;3533
00008a  9001              STR      r0,[sp,#4]            ;3533
00008c  e004              B        |L63.152|
                  |L63.142|
00008e  8d60              LDRH     r0,[r4,#0x2a]         ;3537
000090  8520              STRH     r0,[r4,#0x28]         ;3537
000092  2001              MOVS     r0,#1                 ;3538
000094  0640              LSLS     r0,r0,#25             ;3538
000096  9001              STR      r0,[sp,#4]            ;3538
                  |L63.152|
000098  2000              MOVS     r0,#0                 ;3542
00009a  9000              STR      r0,[sp,#0]            ;3542
00009c  8d20              LDRH     r0,[r4,#0x28]         ;3542
00009e  b2c2              UXTB     r2,r0                 ;3542
0000a0  4639              MOV      r1,r7                 ;3542
0000a2  4620              MOV      r0,r4                 ;3542
0000a4  9b01              LDR      r3,[sp,#4]            ;3542
0000a6  f7fffffe          BL       I2C_TransferConfig
0000aa  8d60              LDRH     r0,[r4,#0x2a]         ;3545
0000ac  8d21              LDRH     r1,[r4,#0x28]         ;3545
0000ae  1a40              SUBS     r0,r0,r1              ;3545
0000b0  8560              STRH     r0,[r4,#0x2a]         ;3545
0000b2  2041              MOVS     r0,#0x41              ;3548
0000b4  5d00              LDRB     r0,[r0,r4]            ;3548
0000b6  2822              CMP      r0,#0x22              ;3548
0000b8  d107              BNE      |L63.202|
0000ba  6820              LDR      r0,[r4,#0]            ;3550
0000bc  6800              LDR      r0,[r0,#0]            ;3550
0000be  2101              MOVS     r1,#1                 ;3550
0000c0  03c9              LSLS     r1,r1,#15             ;3550
0000c2  4308              ORRS     r0,r0,r1              ;3550
0000c4  6821              LDR      r1,[r4,#0]            ;3550
0000c6  6008              STR      r0,[r1,#0]            ;3550
0000c8  e018              B        |L63.252|
                  |L63.202|
0000ca  6820              LDR      r0,[r4,#0]            ;3554
0000cc  6800              LDR      r0,[r0,#0]            ;3554
0000ce  2101              MOVS     r1,#1                 ;3554
0000d0  0389              LSLS     r1,r1,#14             ;3554
0000d2  4308              ORRS     r0,r0,r1              ;3554
0000d4  6821              LDR      r1,[r4,#0]            ;3554
0000d6  6008              STR      r0,[r1,#0]            ;3554
0000d8  e010              B        |L63.252|
                  |L63.218|
0000da  2140              MOVS     r1,#0x40              ;3561
0000dc  4620              MOV      r0,r4                 ;3561
0000de  f7fffffe          BL       I2C_ITError
0000e2  e00b              B        |L63.252|
                  |L63.228|
0000e4  2020              MOVS     r0,#0x20              ;3564
0000e6  4028              ANDS     r0,r0,r5              ;3564
0000e8  2800              CMP      r0,#0                 ;3564
0000ea  d007              BEQ      |L63.252|
0000ec  2020              MOVS     r0,#0x20              ;3564
0000ee  4030              ANDS     r0,r0,r6              ;3564
0000f0  2800              CMP      r0,#0                 ;3564
0000f2  d003              BEQ      |L63.252|
0000f4  4629              MOV      r1,r5                 ;3567
0000f6  4620              MOV      r0,r4                 ;3567
0000f8  f7fffffe          BL       I2C_ITMasterCplt
                  |L63.252|
0000fc  bf00              NOP                            ;3571
0000fe  2100              MOVS     r1,#0                 ;3571
000100  2040              MOVS     r0,#0x40              ;3571
000102  5501              STRB     r1,[r0,r4]            ;3571
000104  bf00              NOP                            ;3571
000106  2000              MOVS     r0,#0                 ;3573
000108  e787              B        |L63.26|
;;;3575   
                          ENDP


                          AREA ||i.I2C_Master_ISR_IT||, CODE, READONLY, ALIGN=2

                  I2C_Master_ISR_IT PROC
;;;3260     */
;;;3261   static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources) 
000000  b5f8              PUSH     {r3-r7,lr}
;;;3262   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3263     uint16_t devaddress = 0U;
000008  2700              MOVS     r7,#0
;;;3264   
;;;3265     /* Process Locked */
;;;3266     __HAL_LOCK(hi2c);
00000a  bf00              NOP      
00000c  2040              MOVS     r0,#0x40
00000e  5d00              LDRB     r0,[r0,r4]
000010  2801              CMP      r0,#1
000012  d101              BNE      |L64.24|
000014  2002              MOVS     r0,#2
                  |L64.22|
;;;3267   
;;;3268     if(((ITFlags & I2C_FLAG_AF) != RESET) && ((ITSources & I2C_IT_NACKI) != RESET))
;;;3269     {
;;;3270       /* Clear NACK Flag */
;;;3271       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;3272   
;;;3273       /* Set corresponding Error Code */
;;;3274       /* No need to generate STOP, it is automatically done */
;;;3275       /* Error callback will be send during stop flag treatment */
;;;3276       hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
;;;3277   
;;;3278       /* Flush TX register */
;;;3279       I2C_Flush_TXDR(hi2c);
;;;3280     }
;;;3281     else if(((ITFlags & I2C_FLAG_RXNE) != RESET) && ((ITSources & I2C_IT_RXI) != RESET))
;;;3282     {
;;;3283       /* Read data from RXDR */
;;;3284       (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
;;;3285       hi2c->XferSize--;
;;;3286       hi2c->XferCount--;
;;;3287     }
;;;3288     else if(((ITFlags & I2C_FLAG_TXIS) != RESET) && ((ITSources & I2C_IT_TXI) != RESET))
;;;3289     {
;;;3290       /* Write data to TXDR */
;;;3291       hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
;;;3292       hi2c->XferSize--;
;;;3293       hi2c->XferCount--;
;;;3294     }
;;;3295     else if(((ITFlags & I2C_FLAG_TCR) != RESET) && ((ITSources & I2C_IT_TCI) != RESET))
;;;3296     {
;;;3297       if((hi2c->XferSize == 0U) && (hi2c->XferCount != 0U))
;;;3298       {
;;;3299         devaddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
;;;3300         
;;;3301         if(hi2c->XferCount > MAX_NBYTE_SIZE)
;;;3302         {
;;;3303           hi2c->XferSize = MAX_NBYTE_SIZE;
;;;3304           I2C_TransferConfig(hi2c, devaddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
;;;3305         }
;;;3306         else
;;;3307         {
;;;3308           hi2c->XferSize = hi2c->XferCount;
;;;3309           if(hi2c->XferOptions != I2C_NO_OPTION_FRAME)
;;;3310           {
;;;3311             I2C_TransferConfig(hi2c, devaddress, hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
;;;3312           }
;;;3313           else
;;;3314           {
;;;3315             I2C_TransferConfig(hi2c, devaddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
;;;3316           }
;;;3317         }
;;;3318       }
;;;3319       else
;;;3320       {
;;;3321         /* Call TxCpltCallback() if no stop mode is set */
;;;3322         if(I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
;;;3323         {
;;;3324           /* Call I2C Master Sequential complete process */
;;;3325           I2C_ITMasterSequentialCplt(hi2c);
;;;3326         }
;;;3327         else
;;;3328         {
;;;3329           /* Wrong size Status regarding TCR flag event */
;;;3330           /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;3331           I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
;;;3332         }
;;;3333       }
;;;3334     }
;;;3335     else if(((ITFlags & I2C_FLAG_TC) != RESET) && ((ITSources & I2C_IT_TCI) != RESET))
;;;3336     {
;;;3337       if(hi2c->XferCount == 0U)
;;;3338       {
;;;3339         if(I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
;;;3340         {
;;;3341           /* Generate a stop condition in case of no transfer option */
;;;3342           if(hi2c->XferOptions == I2C_NO_OPTION_FRAME)
;;;3343           {
;;;3344             /* Generate Stop */
;;;3345             hi2c->Instance->CR2 |= I2C_CR2_STOP;
;;;3346           }
;;;3347           else
;;;3348           {
;;;3349             /* Call I2C Master Sequential complete process */
;;;3350             I2C_ITMasterSequentialCplt(hi2c);
;;;3351           }
;;;3352         }
;;;3353       }
;;;3354       else
;;;3355       {
;;;3356         /* Wrong size Status regarding TC flag event */
;;;3357         /* Call the corresponding callback to inform upper layer of End of Transfer */
;;;3358         I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
;;;3359       }
;;;3360     }
;;;3361   
;;;3362     if(((ITFlags & I2C_FLAG_STOPF) != RESET) && ((ITSources & I2C_IT_STOPI) != RESET))
;;;3363     {
;;;3364       /* Call I2C Master complete process */
;;;3365       I2C_ITMasterCplt(hi2c, ITFlags);
;;;3366     }
;;;3367   
;;;3368     /* Process Unlocked */
;;;3369     __HAL_UNLOCK(hi2c);
;;;3370   
;;;3371     return HAL_OK;
;;;3372   }
000016  bdf8              POP      {r3-r7,pc}
                  |L64.24|
000018  2101              MOVS     r1,#1                 ;3266
00001a  2040              MOVS     r0,#0x40              ;3266
00001c  5501              STRB     r1,[r0,r4]            ;3266
00001e  bf00              NOP                            ;3266
000020  2010              MOVS     r0,#0x10              ;3268
000022  4028              ANDS     r0,r0,r5              ;3268
000024  2800              CMP      r0,#0                 ;3268
000026  d00e              BEQ      |L64.70|
000028  2010              MOVS     r0,#0x10              ;3268
00002a  4030              ANDS     r0,r0,r6              ;3268
00002c  2800              CMP      r0,#0                 ;3268
00002e  d00a              BEQ      |L64.70|
000030  2010              MOVS     r0,#0x10              ;3271
000032  6821              LDR      r1,[r4,#0]            ;3271
000034  61c8              STR      r0,[r1,#0x1c]         ;3271
000036  6c60              LDR      r0,[r4,#0x44]         ;3276
000038  2104              MOVS     r1,#4                 ;3276
00003a  4308              ORRS     r0,r0,r1              ;3276
00003c  6460              STR      r0,[r4,#0x44]         ;3276
00003e  4620              MOV      r0,r4                 ;3279
000040  f7fffffe          BL       I2C_Flush_TXDR
000044  e09d              B        |L64.386|
                  |L64.70|
000046  2004              MOVS     r0,#4                 ;3281
000048  4028              ANDS     r0,r0,r5              ;3281
00004a  2800              CMP      r0,#0                 ;3281
00004c  d011              BEQ      |L64.114|
00004e  2004              MOVS     r0,#4                 ;3281
000050  4030              ANDS     r0,r0,r6              ;3281
000052  2800              CMP      r0,#0                 ;3281
000054  d00d              BEQ      |L64.114|
000056  6820              LDR      r0,[r4,#0]            ;3284
000058  6a40              LDR      r0,[r0,#0x24]         ;3284
00005a  b2c1              UXTB     r1,r0                 ;3284
00005c  6a62              LDR      r2,[r4,#0x24]         ;3284
00005e  1c50              ADDS     r0,r2,#1              ;3284
000060  6260              STR      r0,[r4,#0x24]         ;3284
000062  7011              STRB     r1,[r2,#0]            ;3284
000064  8d20              LDRH     r0,[r4,#0x28]         ;3285
000066  1e40              SUBS     r0,r0,#1              ;3285
000068  8520              STRH     r0,[r4,#0x28]         ;3285
00006a  8d60              LDRH     r0,[r4,#0x2a]         ;3286
00006c  1e40              SUBS     r0,r0,#1              ;3286
00006e  8560              STRH     r0,[r4,#0x2a]         ;3286
000070  e087              B        |L64.386|
                  |L64.114|
000072  2002              MOVS     r0,#2                 ;3288
000074  4028              ANDS     r0,r0,r5              ;3288
000076  2800              CMP      r0,#0                 ;3288
000078  d010              BEQ      |L64.156|
00007a  2002              MOVS     r0,#2                 ;3288
00007c  4030              ANDS     r0,r0,r6              ;3288
00007e  2800              CMP      r0,#0                 ;3288
000080  d00c              BEQ      |L64.156|
000082  6a61              LDR      r1,[r4,#0x24]         ;3291
000084  1c48              ADDS     r0,r1,#1              ;3291
000086  6260              STR      r0,[r4,#0x24]         ;3291
000088  7808              LDRB     r0,[r1,#0]            ;3291
00008a  6821              LDR      r1,[r4,#0]            ;3291
00008c  6288              STR      r0,[r1,#0x28]         ;3291
00008e  8d20              LDRH     r0,[r4,#0x28]         ;3292
000090  1e40              SUBS     r0,r0,#1              ;3292
000092  8520              STRH     r0,[r4,#0x28]         ;3292
000094  8d60              LDRH     r0,[r4,#0x2a]         ;3293
000096  1e40              SUBS     r0,r0,#1              ;3293
000098  8560              STRH     r0,[r4,#0x2a]         ;3293
00009a  e072              B        |L64.386|
                  |L64.156|
00009c  2080              MOVS     r0,#0x80              ;3295
00009e  4028              ANDS     r0,r0,r5              ;3295
0000a0  2800              CMP      r0,#0                 ;3295
0000a2  d048              BEQ      |L64.310|
0000a4  2040              MOVS     r0,#0x40              ;3295
0000a6  4030              ANDS     r0,r0,r6              ;3295
0000a8  2800              CMP      r0,#0                 ;3295
0000aa  d044              BEQ      |L64.310|
0000ac  8d20              LDRH     r0,[r4,#0x28]         ;3297
0000ae  2800              CMP      r0,#0                 ;3297
0000b0  d131              BNE      |L64.278|
0000b2  8d60              LDRH     r0,[r4,#0x2a]         ;3297
0000b4  2800              CMP      r0,#0                 ;3297
0000b6  d02e              BEQ      |L64.278|
0000b8  6820              LDR      r0,[r4,#0]            ;3299
0000ba  6840              LDR      r0,[r0,#4]            ;3299
0000bc  0587              LSLS     r7,r0,#22             ;3299
0000be  0dbf              LSRS     r7,r7,#22             ;3299
0000c0  8d60              LDRH     r0,[r4,#0x2a]         ;3301
0000c2  28ff              CMP      r0,#0xff              ;3301
0000c4  d90c              BLS      |L64.224|
0000c6  20ff              MOVS     r0,#0xff              ;3303
0000c8  8520              STRH     r0,[r4,#0x28]         ;3303
0000ca  2000              MOVS     r0,#0                 ;3304
0000cc  9000              STR      r0,[sp,#0]            ;3304
0000ce  8d20              LDRH     r0,[r4,#0x28]         ;3304
0000d0  b2c2              UXTB     r2,r0                 ;3304
0000d2  2301              MOVS     r3,#1                 ;3304
0000d4  061b              LSLS     r3,r3,#24             ;3304
0000d6  4639              MOV      r1,r7                 ;3304
0000d8  4620              MOV      r0,r4                 ;3304
0000da  f7fffffe          BL       I2C_TransferConfig
0000de  e050              B        |L64.386|
                  |L64.224|
0000e0  8d60              LDRH     r0,[r4,#0x2a]         ;3308
0000e2  8520              STRH     r0,[r4,#0x28]         ;3308
0000e4  6ae0              LDR      r0,[r4,#0x2c]         ;3309
0000e6  4930              LDR      r1,|L64.424|
0000e8  4288              CMP      r0,r1                 ;3309
0000ea  d009              BEQ      |L64.256|
0000ec  2000              MOVS     r0,#0                 ;3311
0000ee  9000              STR      r0,[sp,#0]            ;3311
0000f0  6ae3              LDR      r3,[r4,#0x2c]         ;3311
0000f2  8d20              LDRH     r0,[r4,#0x28]         ;3311
0000f4  b2c2              UXTB     r2,r0                 ;3311
0000f6  4639              MOV      r1,r7                 ;3311
0000f8  4620              MOV      r0,r4                 ;3311
0000fa  f7fffffe          BL       I2C_TransferConfig
0000fe  e040              B        |L64.386|
                  |L64.256|
000100  2000              MOVS     r0,#0                 ;3315
000102  9000              STR      r0,[sp,#0]            ;3315
000104  8d20              LDRH     r0,[r4,#0x28]         ;3315
000106  b2c2              UXTB     r2,r0                 ;3315
000108  2301              MOVS     r3,#1                 ;3315
00010a  065b              LSLS     r3,r3,#25             ;3315
00010c  4639              MOV      r1,r7                 ;3315
00010e  4620              MOV      r0,r4                 ;3315
000110  f7fffffe          BL       I2C_TransferConfig
000114  e035              B        |L64.386|
                  |L64.278|
000116  6820              LDR      r0,[r4,#0]            ;3322
000118  6840              LDR      r0,[r0,#4]            ;3322
00011a  2101              MOVS     r1,#1                 ;3322
00011c  0649              LSLS     r1,r1,#25             ;3322
00011e  4008              ANDS     r0,r0,r1              ;3322
000120  4288              CMP      r0,r1                 ;3322
000122  d003              BEQ      |L64.300|
000124  4620              MOV      r0,r4                 ;3325
000126  f7fffffe          BL       I2C_ITMasterSequentialCplt
00012a  e02a              B        |L64.386|
                  |L64.300|
00012c  2140              MOVS     r1,#0x40              ;3331
00012e  4620              MOV      r0,r4                 ;3331
000130  f7fffffe          BL       I2C_ITError
000134  e025              B        |L64.386|
                  |L64.310|
000136  2040              MOVS     r0,#0x40              ;3335
000138  4028              ANDS     r0,r0,r5              ;3335
00013a  2800              CMP      r0,#0                 ;3335
00013c  d021              BEQ      |L64.386|
00013e  2040              MOVS     r0,#0x40              ;3335
000140  4030              ANDS     r0,r0,r6              ;3335
000142  2800              CMP      r0,#0                 ;3335
000144  d01d              BEQ      |L64.386|
000146  8d60              LDRH     r0,[r4,#0x2a]         ;3337
000148  2800              CMP      r0,#0                 ;3337
00014a  d116              BNE      |L64.378|
00014c  6820              LDR      r0,[r4,#0]            ;3339
00014e  6840              LDR      r0,[r0,#4]            ;3339
000150  2101              MOVS     r1,#1                 ;3339
000152  0649              LSLS     r1,r1,#25             ;3339
000154  4008              ANDS     r0,r0,r1              ;3339
000156  4288              CMP      r0,r1                 ;3339
000158  d013              BEQ      |L64.386|
00015a  6ae0              LDR      r0,[r4,#0x2c]         ;3342
00015c  4912              LDR      r1,|L64.424|
00015e  4288              CMP      r0,r1                 ;3342
000160  d107              BNE      |L64.370|
000162  6820              LDR      r0,[r4,#0]            ;3345
000164  6840              LDR      r0,[r0,#4]            ;3345
000166  2101              MOVS     r1,#1                 ;3345
000168  0389              LSLS     r1,r1,#14             ;3345
00016a  4308              ORRS     r0,r0,r1              ;3345
00016c  6821              LDR      r1,[r4,#0]            ;3345
00016e  6048              STR      r0,[r1,#4]            ;3345
000170  e007              B        |L64.386|
                  |L64.370|
000172  4620              MOV      r0,r4                 ;3350
000174  f7fffffe          BL       I2C_ITMasterSequentialCplt
000178  e003              B        |L64.386|
                  |L64.378|
00017a  2140              MOVS     r1,#0x40              ;3358
00017c  4620              MOV      r0,r4                 ;3358
00017e  f7fffffe          BL       I2C_ITError
                  |L64.386|
000182  2020              MOVS     r0,#0x20              ;3362
000184  4028              ANDS     r0,r0,r5              ;3362
000186  2800              CMP      r0,#0                 ;3362
000188  d007              BEQ      |L64.410|
00018a  2020              MOVS     r0,#0x20              ;3362
00018c  4030              ANDS     r0,r0,r6              ;3362
00018e  2800              CMP      r0,#0                 ;3362
000190  d003              BEQ      |L64.410|
000192  4629              MOV      r1,r5                 ;3365
000194  4620              MOV      r0,r4                 ;3365
000196  f7fffffe          BL       I2C_ITMasterCplt
                  |L64.410|
00019a  bf00              NOP                            ;3369
00019c  2100              MOVS     r1,#0                 ;3369
00019e  2040              MOVS     r0,#0x40              ;3369
0001a0  5501              STRB     r1,[r0,r4]            ;3369
0001a2  bf00              NOP                            ;3369
0001a4  2000              MOVS     r0,#0                 ;3371
0001a6  e736              B        |L64.22|
;;;3373   
                          ENDP

                  |L64.424|
                          DCD      0xffff0000

                          AREA ||i.I2C_RequestMemoryRead||, CODE, READONLY, ALIGN=1

                  I2C_RequestMemoryRead PROC
;;;3705     */
;;;3706   static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
000000  b5ff              PUSH     {r0-r7,lr}
;;;3707   {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
00000a  9f0a              LDR      r7,[sp,#0x28]
;;;3708     I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
00000c  2001              MOVS     r0,#1
00000e  0340              LSLS     r0,r0,#13
000010  b2f2              UXTB     r2,r6
000012  2300              MOVS     r3,#0
000014  9000              STR      r0,[sp,#0]
000016  4620              MOV      r0,r4
000018  9902              LDR      r1,[sp,#8]
00001a  f7fffffe          BL       I2C_TransferConfig
;;;3709   
;;;3710     /* Wait until TXIS flag is set */
;;;3711     if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
00001e  4639              MOV      r1,r7
000020  4620              MOV      r0,r4
000022  9a0b              LDR      r2,[sp,#0x2c]
000024  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
000028  2800              CMP      r0,#0
00002a  d007              BEQ      |L65.60|
;;;3712     {
;;;3713       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
00002c  6c60              LDR      r0,[r4,#0x44]
00002e  2804              CMP      r0,#4
000030  d102              BNE      |L65.56|
;;;3714       {
;;;3715         return HAL_ERROR;
000032  2001              MOVS     r0,#1
                  |L65.52|
;;;3716       }
;;;3717       else
;;;3718       {
;;;3719         return HAL_TIMEOUT;
;;;3720       }
;;;3721     }
;;;3722   
;;;3723     /* If Memory address size is 8Bit */
;;;3724     if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;3725     {
;;;3726       /* Send Memory Address */
;;;3727       hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
;;;3728     }
;;;3729     /* If Memory address size is 16Bit */
;;;3730     else
;;;3731     {
;;;3732       /* Send MSB of Memory Address */
;;;3733       hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
;;;3734   
;;;3735       /* Wait until TXIS flag is set */
;;;3736       if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;3737       {
;;;3738         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3739         {
;;;3740           return HAL_ERROR;
;;;3741         }
;;;3742         else
;;;3743         {
;;;3744           return HAL_TIMEOUT;
;;;3745         }
;;;3746       }
;;;3747       
;;;3748       /* Send LSB of Memory Address */
;;;3749       hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
;;;3750     }
;;;3751   
;;;3752     /* Wait until TC flag is set */
;;;3753     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
;;;3754     {
;;;3755       return HAL_TIMEOUT;
;;;3756     }
;;;3757     
;;;3758     return HAL_OK;
;;;3759   }
000034  b005              ADD      sp,sp,#0x14
000036  bdf0              POP      {r4-r7,pc}
                  |L65.56|
000038  2003              MOVS     r0,#3                 ;3719
00003a  e7fb              B        |L65.52|
                  |L65.60|
00003c  2e01              CMP      r6,#1                 ;3724
00003e  d103              BNE      |L65.72|
000040  b2e8              UXTB     r0,r5                 ;3727
000042  6821              LDR      r1,[r4,#0]            ;3727
000044  6288              STR      r0,[r1,#0x28]         ;3727
000046  e016              B        |L65.118|
                  |L65.72|
000048  20ff              MOVS     r0,#0xff              ;3733
00004a  0200              LSLS     r0,r0,#8              ;3733
00004c  4028              ANDS     r0,r0,r5              ;3733
00004e  1200              ASRS     r0,r0,#8              ;3733
000050  6821              LDR      r1,[r4,#0]            ;3733
000052  6288              STR      r0,[r1,#0x28]         ;3733
000054  4639              MOV      r1,r7                 ;3736
000056  4620              MOV      r0,r4                 ;3736
000058  9a0b              LDR      r2,[sp,#0x2c]         ;3736
00005a  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
00005e  2800              CMP      r0,#0                 ;3736
000060  d006              BEQ      |L65.112|
000062  6c60              LDR      r0,[r4,#0x44]         ;3738
000064  2804              CMP      r0,#4                 ;3738
000066  d101              BNE      |L65.108|
000068  2001              MOVS     r0,#1                 ;3740
00006a  e7e3              B        |L65.52|
                  |L65.108|
00006c  2003              MOVS     r0,#3                 ;3744
00006e  e7e1              B        |L65.52|
                  |L65.112|
000070  b2e8              UXTB     r0,r5                 ;3749
000072  6821              LDR      r1,[r4,#0]            ;3749
000074  6288              STR      r0,[r1,#0x28]         ;3749
                  |L65.118|
000076  980b              LDR      r0,[sp,#0x2c]         ;3753
000078  463b              MOV      r3,r7                 ;3753
00007a  2200              MOVS     r2,#0                 ;3753
00007c  2140              MOVS     r1,#0x40              ;3753
00007e  9000              STR      r0,[sp,#0]            ;3753
000080  4620              MOV      r0,r4                 ;3753
000082  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000086  2800              CMP      r0,#0                 ;3753
000088  d001              BEQ      |L65.142|
00008a  2003              MOVS     r0,#3                 ;3755
00008c  e7d2              B        |L65.52|
                  |L65.142|
00008e  2000              MOVS     r0,#0                 ;3758
000090  e7d0              B        |L65.52|
;;;3760   
                          ENDP


                          AREA ||i.I2C_RequestMemoryWrite||, CODE, READONLY, ALIGN=1

                  I2C_RequestMemoryWrite PROC
;;;3638     */
;;;3639   static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
000000  b5ff              PUSH     {r0-r7,lr}
;;;3640   {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
00000a  9f0a              LDR      r7,[sp,#0x28]
;;;3641     I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
00000c  2001              MOVS     r0,#1
00000e  0340              LSLS     r0,r0,#13
000010  b2f2              UXTB     r2,r6
000012  02c3              LSLS     r3,r0,#11
000014  9000              STR      r0,[sp,#0]
000016  4620              MOV      r0,r4
000018  9902              LDR      r1,[sp,#8]
00001a  f7fffffe          BL       I2C_TransferConfig
;;;3642   
;;;3643     /* Wait until TXIS flag is set */
;;;3644     if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
00001e  4639              MOV      r1,r7
000020  4620              MOV      r0,r4
000022  9a0b              LDR      r2,[sp,#0x2c]
000024  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
000028  2800              CMP      r0,#0
00002a  d007              BEQ      |L66.60|
;;;3645     {
;;;3646       if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
00002c  6c60              LDR      r0,[r4,#0x44]
00002e  2804              CMP      r0,#4
000030  d102              BNE      |L66.56|
;;;3647       {
;;;3648         return HAL_ERROR;
000032  2001              MOVS     r0,#1
                  |L66.52|
;;;3649       }
;;;3650       else
;;;3651       {
;;;3652         return HAL_TIMEOUT;
;;;3653       }
;;;3654     }
;;;3655   
;;;3656     /* If Memory address size is 8Bit */
;;;3657     if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
;;;3658     {
;;;3659       /* Send Memory Address */
;;;3660       hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
;;;3661     }
;;;3662     /* If Memory address size is 16Bit */
;;;3663     else
;;;3664     {
;;;3665       /* Send MSB of Memory Address */
;;;3666       hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
;;;3667   
;;;3668       /* Wait until TXIS flag is set */
;;;3669       if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
;;;3670       {
;;;3671         if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
;;;3672         {
;;;3673           return HAL_ERROR;
;;;3674         }
;;;3675         else
;;;3676         {
;;;3677           return HAL_TIMEOUT;
;;;3678         }
;;;3679       }
;;;3680       
;;;3681       /* Send LSB of Memory Address */
;;;3682       hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
;;;3683     }
;;;3684   
;;;3685     /* Wait until TCR flag is set */
;;;3686     if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
;;;3687     {
;;;3688       return HAL_TIMEOUT;
;;;3689     }
;;;3690   
;;;3691   return HAL_OK;
;;;3692   }
000034  b005              ADD      sp,sp,#0x14
000036  bdf0              POP      {r4-r7,pc}
                  |L66.56|
000038  2003              MOVS     r0,#3                 ;3652
00003a  e7fb              B        |L66.52|
                  |L66.60|
00003c  2e01              CMP      r6,#1                 ;3657
00003e  d103              BNE      |L66.72|
000040  b2e8              UXTB     r0,r5                 ;3660
000042  6821              LDR      r1,[r4,#0]            ;3660
000044  6288              STR      r0,[r1,#0x28]         ;3660
000046  e016              B        |L66.118|
                  |L66.72|
000048  20ff              MOVS     r0,#0xff              ;3666
00004a  0200              LSLS     r0,r0,#8              ;3666
00004c  4028              ANDS     r0,r0,r5              ;3666
00004e  1200              ASRS     r0,r0,#8              ;3666
000050  6821              LDR      r1,[r4,#0]            ;3666
000052  6288              STR      r0,[r1,#0x28]         ;3666
000054  4639              MOV      r1,r7                 ;3669
000056  4620              MOV      r0,r4                 ;3669
000058  9a0b              LDR      r2,[sp,#0x2c]         ;3669
00005a  f7fffffe          BL       I2C_WaitOnTXISFlagUntilTimeout
00005e  2800              CMP      r0,#0                 ;3669
000060  d006              BEQ      |L66.112|
000062  6c60              LDR      r0,[r4,#0x44]         ;3671
000064  2804              CMP      r0,#4                 ;3671
000066  d101              BNE      |L66.108|
000068  2001              MOVS     r0,#1                 ;3673
00006a  e7e3              B        |L66.52|
                  |L66.108|
00006c  2003              MOVS     r0,#3                 ;3677
00006e  e7e1              B        |L66.52|
                  |L66.112|
000070  b2e8              UXTB     r0,r5                 ;3682
000072  6821              LDR      r1,[r4,#0]            ;3682
000074  6288              STR      r0,[r1,#0x28]         ;3682
                  |L66.118|
000076  980b              LDR      r0,[sp,#0x2c]         ;3686
000078  463b              MOV      r3,r7                 ;3686
00007a  2200              MOVS     r2,#0                 ;3686
00007c  2180              MOVS     r1,#0x80              ;3686
00007e  9000              STR      r0,[sp,#0]            ;3686
000080  4620              MOV      r0,r4                 ;3686
000082  f7fffffe          BL       I2C_WaitOnFlagUntilTimeout
000086  2800              CMP      r0,#0                 ;3686
000088  d001              BEQ      |L66.142|
00008a  2003              MOVS     r0,#3                 ;3688
00008c  e7d2              B        |L66.52|
                  |L66.142|
00008e  2000              MOVS     r0,#0                 ;3691
000090  e7d0              B        |L66.52|
;;;3693   
                          ENDP


                          AREA ||i.I2C_Slave_ISR_DMA||, CODE, READONLY, ALIGN=1

                  I2C_Slave_ISR_DMA PROC
;;;3583     */
;;;3584   static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources) 
000000  b570              PUSH     {r4-r6,lr}
;;;3585   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3586     /* Process locked */
;;;3587     __HAL_LOCK(hi2c);
000008  bf00              NOP      
00000a  2040              MOVS     r0,#0x40
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L67.22|
000012  2002              MOVS     r0,#2
                  |L67.20|
;;;3588     
;;;3589     if(((ITFlags & I2C_FLAG_AF) != RESET) && ((ITSources & I2C_IT_NACKI) != RESET))
;;;3590     {
;;;3591       /* Check that I2C transfer finished */
;;;3592       /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
;;;3593       /* Mean XferCount == 0 */
;;;3594       /* So clear Flag NACKF only */
;;;3595       if(I2C_GET_DMA_REMAIN_DATA(hi2c) == 0U)
;;;3596       {
;;;3597         /* Clear NACK Flag */
;;;3598         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;3599       }
;;;3600       else
;;;3601       {
;;;3602         /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
;;;3603         /* Clear NACK Flag */
;;;3604         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;3605         
;;;3606         /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;3607         hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
;;;3608       }
;;;3609     }
;;;3610     else if(((ITFlags & I2C_FLAG_ADDR) != RESET) && ((ITSources & I2C_IT_ADDRI) != RESET))
;;;3611     {
;;;3612       /* Clear ADDR flag */
;;;3613       __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
;;;3614     }
;;;3615     else if(((ITFlags & I2C_FLAG_STOPF) != RESET) && ((ITSources & I2C_IT_STOPI) != RESET))
;;;3616     {
;;;3617       /* Call I2C Slave complete process */
;;;3618       I2C_ITSlaveCplt(hi2c, ITFlags);
;;;3619     }
;;;3620   
;;;3621     /* Process Unlocked */
;;;3622     __HAL_UNLOCK(hi2c);
;;;3623   
;;;3624     return HAL_OK;
;;;3625   }
000014  bd70              POP      {r4-r6,pc}
                  |L67.22|
000016  2101              MOVS     r1,#1                 ;3587
000018  2040              MOVS     r0,#0x40              ;3587
00001a  5501              STRB     r1,[r0,r4]            ;3587
00001c  bf00              NOP                            ;3587
00001e  2010              MOVS     r0,#0x10              ;3589
000020  4028              ANDS     r0,r0,r5              ;3589
000022  2800              CMP      r0,#0                 ;3589
000024  d01c              BEQ      |L67.96|
000026  2010              MOVS     r0,#0x10              ;3589
000028  4030              ANDS     r0,r0,r6              ;3589
00002a  2800              CMP      r0,#0                 ;3589
00002c  d018              BEQ      |L67.96|
00002e  2041              MOVS     r0,#0x41              ;3595
000030  5d00              LDRB     r0,[r0,r4]            ;3595
000032  2821              CMP      r0,#0x21              ;3595
000034  d103              BNE      |L67.62|
000036  6ba0              LDR      r0,[r4,#0x38]         ;3595
000038  6800              LDR      r0,[r0,#0]            ;3595
00003a  6840              LDR      r0,[r0,#4]            ;3595
00003c  e002              B        |L67.68|
                  |L67.62|
00003e  6be0              LDR      r0,[r4,#0x3c]         ;3595
000040  6800              LDR      r0,[r0,#0]            ;3595
000042  6840              LDR      r0,[r0,#4]            ;3595
                  |L67.68|
000044  2800              CMP      r0,#0                 ;3595
000046  d103              BNE      |L67.80|
000048  2010              MOVS     r0,#0x10              ;3598
00004a  6821              LDR      r1,[r4,#0]            ;3598
00004c  61c8              STR      r0,[r1,#0x1c]         ;3598
00004e  e01f              B        |L67.144|
                  |L67.80|
000050  2010              MOVS     r0,#0x10              ;3604
000052  6821              LDR      r1,[r4,#0]            ;3604
000054  61c8              STR      r0,[r1,#0x1c]         ;3604
000056  6c60              LDR      r0,[r4,#0x44]         ;3607
000058  2104              MOVS     r1,#4                 ;3607
00005a  4308              ORRS     r0,r0,r1              ;3607
00005c  6460              STR      r0,[r4,#0x44]         ;3607
00005e  e017              B        |L67.144|
                  |L67.96|
000060  2008              MOVS     r0,#8                 ;3610
000062  4028              ANDS     r0,r0,r5              ;3610
000064  2800              CMP      r0,#0                 ;3610
000066  d007              BEQ      |L67.120|
000068  2008              MOVS     r0,#8                 ;3610
00006a  4030              ANDS     r0,r0,r6              ;3610
00006c  2800              CMP      r0,#0                 ;3610
00006e  d003              BEQ      |L67.120|
000070  2008              MOVS     r0,#8                 ;3613
000072  6821              LDR      r1,[r4,#0]            ;3613
000074  61c8              STR      r0,[r1,#0x1c]         ;3613
000076  e00b              B        |L67.144|
                  |L67.120|
000078  2020              MOVS     r0,#0x20              ;3615
00007a  4028              ANDS     r0,r0,r5              ;3615
00007c  2800              CMP      r0,#0                 ;3615
00007e  d007              BEQ      |L67.144|
000080  2020              MOVS     r0,#0x20              ;3615
000082  4030              ANDS     r0,r0,r6              ;3615
000084  2800              CMP      r0,#0                 ;3615
000086  d003              BEQ      |L67.144|
000088  4629              MOV      r1,r5                 ;3618
00008a  4620              MOV      r0,r4                 ;3618
00008c  f7fffffe          BL       I2C_ITSlaveCplt
                  |L67.144|
000090  bf00              NOP                            ;3622
000092  2100              MOVS     r1,#0                 ;3622
000094  2040              MOVS     r0,#0x40              ;3622
000096  5501              STRB     r1,[r0,r4]            ;3622
000098  bf00              NOP                            ;3622
00009a  2000              MOVS     r0,#0                 ;3624
00009c  e7ba              B        |L67.20|
;;;3626   
                          ENDP


                          AREA ||i.I2C_Slave_ISR_IT||, CODE, READONLY, ALIGN=2

                  I2C_Slave_ISR_IT PROC
;;;3381     */
;;;3382   static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags, uint32_t ITSources) 
000000  b570              PUSH     {r4-r6,lr}
;;;3383   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3384     /* Process locked */
;;;3385     __HAL_LOCK(hi2c);
000008  bf00              NOP      
00000a  2040              MOVS     r0,#0x40
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L68.22|
000012  2002              MOVS     r0,#2
                  |L68.20|
;;;3386     
;;;3387     if(((ITFlags & I2C_FLAG_AF) != RESET) && ((ITSources & I2C_IT_NACKI) != RESET))
;;;3388     {
;;;3389       /* Check that I2C transfer finished */
;;;3390       /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
;;;3391       /* Mean XferCount == 0*/
;;;3392       /* So clear Flag NACKF only */
;;;3393       if(hi2c->XferCount == 0U)
;;;3394       {
;;;3395         if(((hi2c->XferOptions == I2C_FIRST_AND_LAST_FRAME) || (hi2c->XferOptions == I2C_LAST_FRAME)) && \
;;;3396           (hi2c->State == HAL_I2C_STATE_LISTEN))
;;;3397         {
;;;3398           /* Call I2C Listen complete process */
;;;3399           I2C_ITListenCplt(hi2c, ITFlags);
;;;3400         }
;;;3401         else if((hi2c->XferOptions != I2C_NO_OPTION_FRAME) && (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN))
;;;3402         {
;;;3403           /* Clear NACK Flag */
;;;3404           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;3405   
;;;3406           /* Flush TX register */
;;;3407           I2C_Flush_TXDR(hi2c);
;;;3408   
;;;3409           /* Last Byte is Transmitted */
;;;3410           /* Call I2C Slave Sequential complete process */
;;;3411           I2C_ITSlaveSequentialCplt(hi2c);
;;;3412         }
;;;3413         else
;;;3414         {
;;;3415           /* Clear NACK Flag */
;;;3416           __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;3417         }
;;;3418       }
;;;3419       else
;;;3420       {
;;;3421         /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
;;;3422         /* Clear NACK Flag */
;;;3423         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
;;;3424   
;;;3425         /* Set ErrorCode corresponding to a Non-Acknowledge */
;;;3426         hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
;;;3427       }
;;;3428     }
;;;3429     else if(((ITFlags & I2C_FLAG_RXNE) != RESET) && ((ITSources & I2C_IT_RXI) != RESET))
;;;3430     {
;;;3431       if(hi2c->XferCount > 0U)
;;;3432       {
;;;3433         /* Read data from RXDR */
;;;3434         (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
;;;3435         hi2c->XferSize--;
;;;3436         hi2c->XferCount--;
;;;3437       }
;;;3438   
;;;3439       if((hi2c->XferCount == 0U) && \
;;;3440          (hi2c->XferOptions != I2C_NO_OPTION_FRAME))
;;;3441       {
;;;3442         /* Call I2C Slave Sequential complete process */
;;;3443         I2C_ITSlaveSequentialCplt(hi2c);
;;;3444      }
;;;3445     }
;;;3446     else if(((ITFlags & I2C_FLAG_ADDR) != RESET) && ((ITSources & I2C_IT_ADDRI) != RESET))
;;;3447     {
;;;3448       I2C_ITAddrCplt(hi2c, ITFlags);
;;;3449     }
;;;3450     else if(((ITFlags & I2C_FLAG_TXIS) != RESET) && ((ITSources & I2C_IT_TXI) != RESET))
;;;3451     {
;;;3452       /* Write data to TXDR only if XferCount not reach "0" */
;;;3453       /* A TXIS flag can be set, during STOP treatment      */
;;;3454       /* Check if all Datas have already been sent */
;;;3455       /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
;;;3456       if(hi2c->XferCount > 0U)
;;;3457       {
;;;3458         /* Write data to TXDR */
;;;3459         hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
;;;3460         hi2c->XferCount--;
;;;3461         hi2c->XferSize--;
;;;3462       }
;;;3463       else
;;;3464       {
;;;3465         if((hi2c->XferOptions == I2C_NEXT_FRAME) || (hi2c->XferOptions == I2C_FIRST_FRAME))
;;;3466         {
;;;3467           /* Last Byte is Transmitted */
;;;3468           /* Call I2C Slave Sequential complete process */
;;;3469           I2C_ITSlaveSequentialCplt(hi2c);
;;;3470         }
;;;3471       }
;;;3472     }
;;;3473   
;;;3474     /* Check if STOPF is set */
;;;3475     if(((ITFlags & I2C_FLAG_STOPF) != RESET) && ((ITSources & I2C_IT_STOPI) != RESET))
;;;3476     {
;;;3477       /* Call I2C Slave complete process */
;;;3478       I2C_ITSlaveCplt(hi2c, ITFlags);
;;;3479     }
;;;3480   
;;;3481     /* Process Unlocked */
;;;3482     __HAL_UNLOCK(hi2c);
;;;3483   
;;;3484     return HAL_OK;
;;;3485   }
000014  bd70              POP      {r4-r6,pc}
                  |L68.22|
000016  2101              MOVS     r1,#1                 ;3385
000018  2040              MOVS     r0,#0x40              ;3385
00001a  5501              STRB     r1,[r0,r4]            ;3385
00001c  bf00              NOP                            ;3385
00001e  2010              MOVS     r0,#0x10              ;3387
000020  4028              ANDS     r0,r0,r5              ;3387
000022  2800              CMP      r0,#0                 ;3387
000024  d034              BEQ      |L68.144|
000026  2010              MOVS     r0,#0x10              ;3387
000028  4030              ANDS     r0,r0,r6              ;3387
00002a  2800              CMP      r0,#0                 ;3387
00002c  d030              BEQ      |L68.144|
00002e  8d60              LDRH     r0,[r4,#0x2a]         ;3393
000030  2800              CMP      r0,#0                 ;3393
000032  d125              BNE      |L68.128|
000034  6ae0              LDR      r0,[r4,#0x2c]         ;3395
000036  0649              LSLS     r1,r1,#25             ;3395
000038  4288              CMP      r0,r1                 ;3395
00003a  d002              BEQ      |L68.66|
00003c  6ae0              LDR      r0,[r4,#0x2c]         ;3395
00003e  4288              CMP      r0,r1                 ;3395
000040  d108              BNE      |L68.84|
                  |L68.66|
000042  2041              MOVS     r0,#0x41              ;3396
000044  5d00              LDRB     r0,[r0,r4]            ;3396
000046  2828              CMP      r0,#0x28              ;3396
000048  d104              BNE      |L68.84|
00004a  4629              MOV      r1,r5                 ;3399
00004c  4620              MOV      r0,r4                 ;3399
00004e  f7fffffe          BL       I2C_ITListenCplt
000052  e070              B        |L68.310|
                  |L68.84|
000054  6ae0              LDR      r0,[r4,#0x2c]         ;3401
000056  4941              LDR      r1,|L68.348|
000058  4288              CMP      r0,r1                 ;3401
00005a  d00d              BEQ      |L68.120|
00005c  2041              MOVS     r0,#0x41              ;3401
00005e  5d00              LDRB     r0,[r0,r4]            ;3401
000060  2829              CMP      r0,#0x29              ;3401
000062  d109              BNE      |L68.120|
000064  2010              MOVS     r0,#0x10              ;3404
000066  6821              LDR      r1,[r4,#0]            ;3404
000068  61c8              STR      r0,[r1,#0x1c]         ;3404
00006a  4620              MOV      r0,r4                 ;3407
00006c  f7fffffe          BL       I2C_Flush_TXDR
000070  4620              MOV      r0,r4                 ;3411
000072  f7fffffe          BL       I2C_ITSlaveSequentialCplt
000076  e05e              B        |L68.310|
                  |L68.120|
000078  2010              MOVS     r0,#0x10              ;3416
00007a  6821              LDR      r1,[r4,#0]            ;3416
00007c  61c8              STR      r0,[r1,#0x1c]         ;3416
00007e  e05a              B        |L68.310|
                  |L68.128|
000080  2010              MOVS     r0,#0x10              ;3423
000082  6821              LDR      r1,[r4,#0]            ;3423
000084  61c8              STR      r0,[r1,#0x1c]         ;3423
000086  6c60              LDR      r0,[r4,#0x44]         ;3426
000088  2104              MOVS     r1,#4                 ;3426
00008a  4308              ORRS     r0,r0,r1              ;3426
00008c  6460              STR      r0,[r4,#0x44]         ;3426
00008e  e052              B        |L68.310|
                  |L68.144|
000090  2004              MOVS     r0,#4                 ;3429
000092  4028              ANDS     r0,r0,r5              ;3429
000094  2800              CMP      r0,#0                 ;3429
000096  d01e              BEQ      |L68.214|
000098  2004              MOVS     r0,#4                 ;3429
00009a  4030              ANDS     r0,r0,r6              ;3429
00009c  2800              CMP      r0,#0                 ;3429
00009e  d01a              BEQ      |L68.214|
0000a0  8d60              LDRH     r0,[r4,#0x2a]         ;3431
0000a2  2800              CMP      r0,#0                 ;3431
0000a4  d00c              BEQ      |L68.192|
0000a6  6820              LDR      r0,[r4,#0]            ;3434
0000a8  6a40              LDR      r0,[r0,#0x24]         ;3434
0000aa  b2c1              UXTB     r1,r0                 ;3434
0000ac  6a62              LDR      r2,[r4,#0x24]         ;3434
0000ae  1c50              ADDS     r0,r2,#1              ;3434
0000b0  6260              STR      r0,[r4,#0x24]         ;3434
0000b2  7011              STRB     r1,[r2,#0]            ;3434
0000b4  8d20              LDRH     r0,[r4,#0x28]         ;3435
0000b6  1e40              SUBS     r0,r0,#1              ;3435
0000b8  8520              STRH     r0,[r4,#0x28]         ;3435
0000ba  8d60              LDRH     r0,[r4,#0x2a]         ;3436
0000bc  1e40              SUBS     r0,r0,#1              ;3436
0000be  8560              STRH     r0,[r4,#0x2a]         ;3436
                  |L68.192|
0000c0  8d60              LDRH     r0,[r4,#0x2a]         ;3439
0000c2  2800              CMP      r0,#0                 ;3439
0000c4  d137              BNE      |L68.310|
0000c6  6ae0              LDR      r0,[r4,#0x2c]         ;3440
0000c8  4924              LDR      r1,|L68.348|
0000ca  4288              CMP      r0,r1                 ;3440
0000cc  d033              BEQ      |L68.310|
0000ce  4620              MOV      r0,r4                 ;3443
0000d0  f7fffffe          BL       I2C_ITSlaveSequentialCplt
0000d4  e02f              B        |L68.310|
                  |L68.214|
0000d6  2008              MOVS     r0,#8                 ;3446
0000d8  4028              ANDS     r0,r0,r5              ;3446
0000da  2800              CMP      r0,#0                 ;3446
0000dc  d008              BEQ      |L68.240|
0000de  2008              MOVS     r0,#8                 ;3446
0000e0  4030              ANDS     r0,r0,r6              ;3446
0000e2  2800              CMP      r0,#0                 ;3446
0000e4  d004              BEQ      |L68.240|
0000e6  4629              MOV      r1,r5                 ;3448
0000e8  4620              MOV      r0,r4                 ;3448
0000ea  f7fffffe          BL       I2C_ITAddrCplt
0000ee  e022              B        |L68.310|
                  |L68.240|
0000f0  2002              MOVS     r0,#2                 ;3450
0000f2  4028              ANDS     r0,r0,r5              ;3450
0000f4  2800              CMP      r0,#0                 ;3450
0000f6  d01e              BEQ      |L68.310|
0000f8  2002              MOVS     r0,#2                 ;3450
0000fa  4030              ANDS     r0,r0,r6              ;3450
0000fc  2800              CMP      r0,#0                 ;3450
0000fe  d01a              BEQ      |L68.310|
000100  8d60              LDRH     r0,[r4,#0x2a]         ;3456
000102  2800              CMP      r0,#0                 ;3456
000104  d00c              BEQ      |L68.288|
000106  6a61              LDR      r1,[r4,#0x24]         ;3459
000108  1c48              ADDS     r0,r1,#1              ;3459
00010a  6260              STR      r0,[r4,#0x24]         ;3459
00010c  7808              LDRB     r0,[r1,#0]            ;3459
00010e  6821              LDR      r1,[r4,#0]            ;3459
000110  6288              STR      r0,[r1,#0x28]         ;3459
000112  8d60              LDRH     r0,[r4,#0x2a]         ;3460
000114  1e40              SUBS     r0,r0,#1              ;3460
000116  8560              STRH     r0,[r4,#0x2a]         ;3460
000118  8d20              LDRH     r0,[r4,#0x28]         ;3461
00011a  1e40              SUBS     r0,r0,#1              ;3461
00011c  8520              STRH     r0,[r4,#0x28]         ;3461
00011e  e00a              B        |L68.310|
                  |L68.288|
000120  6ae0              LDR      r0,[r4,#0x2c]         ;3465
000122  2101              MOVS     r1,#1                 ;3465
000124  0609              LSLS     r1,r1,#24             ;3465
000126  4288              CMP      r0,r1                 ;3465
000128  d002              BEQ      |L68.304|
00012a  6ae0              LDR      r0,[r4,#0x2c]         ;3465
00012c  2800              CMP      r0,#0                 ;3465
00012e  d102              BNE      |L68.310|
                  |L68.304|
000130  4620              MOV      r0,r4                 ;3469
000132  f7fffffe          BL       I2C_ITSlaveSequentialCplt
                  |L68.310|
000136  2020              MOVS     r0,#0x20              ;3475
000138  4028              ANDS     r0,r0,r5              ;3475
00013a  2800              CMP      r0,#0                 ;3475
00013c  d007              BEQ      |L68.334|
00013e  2020              MOVS     r0,#0x20              ;3475
000140  4030              ANDS     r0,r0,r6              ;3475
000142  2800              CMP      r0,#0                 ;3475
000144  d003              BEQ      |L68.334|
000146  4629              MOV      r1,r5                 ;3478
000148  4620              MOV      r0,r4                 ;3478
00014a  f7fffffe          BL       I2C_ITSlaveCplt
                  |L68.334|
00014e  bf00              NOP                            ;3482
000150  2100              MOVS     r1,#0                 ;3482
000152  2040              MOVS     r0,#0x40              ;3482
000154  5501              STRB     r1,[r0,r4]            ;3482
000156  bf00              NOP                            ;3482
000158  2000              MOVS     r0,#0                 ;3484
00015a  e75b              B        |L68.20|
;;;3486   
                          ENDP

                  |L68.348|
                          DCD      0xffff0000

                          AREA ||i.I2C_TransferConfig||, CODE, READONLY, ALIGN=2

                  I2C_TransferConfig PROC
;;;4688     */
;;;4689   static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c,  uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
000000  b5f0              PUSH     {r4-r7,lr}
;;;4690   {
000002  460c              MOV      r4,r1
;;;4691     uint32_t tmpreg = 0U;
000004  2100              MOVS     r1,#0
;;;4692   
;;;4693     /* Check the parameters */
;;;4694     assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
;;;4695     assert_param(IS_TRANSFER_MODE(Mode));
;;;4696     assert_param(IS_TRANSFER_REQUEST(Request));
;;;4697   
;;;4698     /* Get the CR2 register value */
;;;4699     tmpreg = hi2c->Instance->CR2;
000006  6805              LDR      r5,[r0,#0]
000008  6869              LDR      r1,[r5,#4]
;;;4700   
;;;4701     /* clear tmpreg specific bits */
;;;4702     tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
00000a  4d08              LDR      r5,|L69.44|
00000c  4029              ANDS     r1,r1,r5
;;;4703   
;;;4704     /* update tmpreg */
;;;4705     tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
00000e  05a5              LSLS     r5,r4,#22
000010  0dad              LSRS     r5,r5,#22
000012  0416              LSLS     r6,r2,#16
000014  27ff              MOVS     r7,#0xff
000016  043f              LSLS     r7,r7,#16
000018  403e              ANDS     r6,r6,r7
00001a  4335              ORRS     r5,r5,r6
00001c  431d              ORRS     r5,r5,r3
00001e  9e05              LDR      r6,[sp,#0x14]
000020  4335              ORRS     r5,r5,r6
000022  4329              ORRS     r1,r1,r5
;;;4706               (uint32_t)Mode | (uint32_t)Request);
;;;4707   
;;;4708     /* update CR2 register */
;;;4709     hi2c->Instance->CR2 = tmpreg;
000024  6805              LDR      r5,[r0,#0]
000026  6069              STR      r1,[r5,#4]
;;;4710   }
000028  bdf0              POP      {r4-r7,pc}
;;;4711   
                          ENDP

00002a  0000              DCW      0x0000
                  |L69.44|
                          DCD      0xfc009800

                          AREA ||i.I2C_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnFlagUntilTimeout PROC
;;;4470     */
;;;4471   static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;4472   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
000008  461d              MOV      r5,r3
;;;4473     while(__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
00000a  e016              B        |L70.58|
                  |L70.12|
;;;4474     {
;;;4475       /* Check for the Timeout */
;;;4476       if(Timeout != HAL_MAX_DELAY)
00000c  1c68              ADDS     r0,r5,#1
00000e  2800              CMP      r0,#0
000010  d013              BEQ      |L70.58|
;;;4477       {
;;;4478         if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
000012  2d00              CMP      r5,#0
000014  d005              BEQ      |L70.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  9906              LDR      r1,[sp,#0x18]
00001c  1a40              SUBS     r0,r0,r1
00001e  42a8              CMP      r0,r5
000020  d90b              BLS      |L70.58|
                  |L70.34|
;;;4479         {
;;;4480           hi2c->State= HAL_I2C_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  2041              MOVS     r0,#0x41
000026  5501              STRB     r1,[r0,r4]
;;;4481           hi2c->Mode = HAL_I2C_MODE_NONE;
000028  2100              MOVS     r1,#0
00002a  2042              MOVS     r0,#0x42
00002c  5501              STRB     r1,[r0,r4]
;;;4482   
;;;4483           /* Process Unlocked */
;;;4484           __HAL_UNLOCK(hi2c);
00002e  bf00              NOP      
000030  2040              MOVS     r0,#0x40
000032  5501              STRB     r1,[r0,r4]
000034  bf00              NOP      
;;;4485           return HAL_TIMEOUT;
000036  2003              MOVS     r0,#3
                  |L70.56|
;;;4486         }
;;;4487       }
;;;4488     }
;;;4489     return HAL_OK;
;;;4490   }
000038  bdf8              POP      {r3-r7,pc}
                  |L70.58|
00003a  6820              LDR      r0,[r4,#0]            ;4473
00003c  6980              LDR      r0,[r0,#0x18]         ;4473
00003e  4030              ANDS     r0,r0,r6              ;4473
000040  42b0              CMP      r0,r6                 ;4473
000042  d101              BNE      |L70.72|
000044  2001              MOVS     r0,#1                 ;4473
000046  e000              B        |L70.74|
                  |L70.72|
000048  2000              MOVS     r0,#0                 ;4473
                  |L70.74|
00004a  42b8              CMP      r0,r7                 ;4473
00004c  d0de              BEQ      |L70.12|
00004e  2000              MOVS     r0,#0                 ;4489
000050  e7f2              B        |L70.56|
;;;4491   
                          ENDP


                          AREA ||i.I2C_WaitOnRXNEFlagUntilTimeout||, CODE, READONLY, ALIGN=2

                  I2C_WaitOnRXNEFlagUntilTimeout PROC
;;;4570     */
;;;4571   static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;4572   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;4573     while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
000008  e03a              B        |L71.128|
                  |L71.10|
;;;4574     {
;;;4575       /* Check if a NACK is detected */
;;;4576       if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       I2C_IsAcknowledgeFailed
000014  2800              CMP      r0,#0
000016  d001              BEQ      |L71.28|
;;;4577       {
;;;4578         return HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L71.26|
;;;4579       }
;;;4580   
;;;4581       /* Check if a STOPF is detected */
;;;4582       if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
;;;4583       {
;;;4584         /* Clear STOP Flag */
;;;4585         __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
;;;4586   
;;;4587         /* Clear Configuration Register 2 */
;;;4588         I2C_RESET_CR2(hi2c);
;;;4589   
;;;4590         hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
;;;4591         hi2c->State= HAL_I2C_STATE_READY;
;;;4592         hi2c->Mode = HAL_I2C_MODE_NONE;
;;;4593   
;;;4594         /* Process Unlocked */
;;;4595         __HAL_UNLOCK(hi2c);
;;;4596   
;;;4597         return HAL_ERROR;
;;;4598       }
;;;4599   
;;;4600       /* Check for the Timeout */
;;;4601       if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
;;;4602       {
;;;4603         hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;4604         hi2c->State= HAL_I2C_STATE_READY;
;;;4605   
;;;4606         /* Process Unlocked */
;;;4607         __HAL_UNLOCK(hi2c);
;;;4608   
;;;4609         return HAL_TIMEOUT;
;;;4610       }
;;;4611     }
;;;4612     return HAL_OK;
;;;4613   }
00001a  bd70              POP      {r4-r6,pc}
                  |L71.28|
00001c  6820              LDR      r0,[r4,#0]            ;4582
00001e  6980              LDR      r0,[r0,#0x18]         ;4582
000020  2120              MOVS     r1,#0x20              ;4582
000022  4008              ANDS     r0,r0,r1              ;4582
000024  0940              LSRS     r0,r0,#5              ;4582
000026  2800              CMP      r0,#0                 ;4582
000028  d016              BEQ      |L71.88|
00002a  2020              MOVS     r0,#0x20              ;4585
00002c  6821              LDR      r1,[r4,#0]            ;4585
00002e  61c8              STR      r0,[r1,#0x1c]         ;4585
000030  6820              LDR      r0,[r4,#0]            ;4588
000032  6840              LDR      r0,[r0,#4]            ;4588
000034  4917              LDR      r1,|L71.148|
000036  4008              ANDS     r0,r0,r1              ;4588
000038  6821              LDR      r1,[r4,#0]            ;4588
00003a  6048              STR      r0,[r1,#4]            ;4588
00003c  2000              MOVS     r0,#0                 ;4590
00003e  6460              STR      r0,[r4,#0x44]         ;4590
000040  2120              MOVS     r1,#0x20              ;4591
000042  2041              MOVS     r0,#0x41              ;4591
000044  5501              STRB     r1,[r0,r4]            ;4591
000046  2100              MOVS     r1,#0                 ;4592
000048  2042              MOVS     r0,#0x42              ;4592
00004a  5501              STRB     r1,[r0,r4]            ;4592
00004c  bf00              NOP                            ;4595
00004e  2040              MOVS     r0,#0x40              ;4595
000050  5501              STRB     r1,[r0,r4]            ;4595
000052  bf00              NOP                            ;4595
000054  2001              MOVS     r0,#1                 ;4597
000056  e7e0              B        |L71.26|
                  |L71.88|
000058  2d00              CMP      r5,#0                 ;4601
00005a  d004              BEQ      |L71.102|
00005c  f7fffffe          BL       HAL_GetTick
000060  1b80              SUBS     r0,r0,r6              ;4601
000062  42a8              CMP      r0,r5                 ;4601
000064  d90c              BLS      |L71.128|
                  |L71.102|
000066  6c60              LDR      r0,[r4,#0x44]         ;4603
000068  2120              MOVS     r1,#0x20              ;4603
00006a  4308              ORRS     r0,r0,r1              ;4603
00006c  6460              STR      r0,[r4,#0x44]         ;4603
00006e  2041              MOVS     r0,#0x41              ;4604
000070  5501              STRB     r1,[r0,r4]            ;4604
000072  bf00              NOP                            ;4607
000074  2100              MOVS     r1,#0                 ;4607
000076  2040              MOVS     r0,#0x40              ;4607
000078  5501              STRB     r1,[r0,r4]            ;4607
00007a  bf00              NOP                            ;4607
00007c  2003              MOVS     r0,#3                 ;4609
00007e  e7cc              B        |L71.26|
                  |L71.128|
000080  6820              LDR      r0,[r4,#0]            ;4573
000082  6980              LDR      r0,[r0,#0x18]         ;4573
000084  2104              MOVS     r1,#4                 ;4573
000086  4008              ANDS     r0,r0,r1              ;4573
000088  0880              LSRS     r0,r0,#2              ;4573
00008a  2800              CMP      r0,#0                 ;4573
00008c  d0bd              BEQ      |L71.10|
00008e  2000              MOVS     r0,#0                 ;4612
000090  e7c3              B        |L71.26|
;;;4614   
                          ENDP

000092  0000              DCW      0x0000
                  |L71.148|
                          DCD      0xfe00e800

                          AREA ||i.I2C_WaitOnSTOPFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnSTOPFlagUntilTimeout PROC
;;;4536     */
;;;4537   static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;4538   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;4539     while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
000008  e01e              B        |L72.72|
                  |L72.10|
;;;4540     {
;;;4541       /* Check if a NACK is detected */
;;;4542       if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       I2C_IsAcknowledgeFailed
000014  2800              CMP      r0,#0
000016  d001              BEQ      |L72.28|
;;;4543       {
;;;4544         return HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L72.26|
;;;4545       }
;;;4546   
;;;4547       /* Check for the Timeout */
;;;4548       if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
;;;4549       {
;;;4550         hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;4551         hi2c->State= HAL_I2C_STATE_READY;
;;;4552         hi2c->Mode = HAL_I2C_MODE_NONE;
;;;4553   
;;;4554         /* Process Unlocked */
;;;4555         __HAL_UNLOCK(hi2c);
;;;4556   
;;;4557         return HAL_TIMEOUT;
;;;4558       }
;;;4559     }
;;;4560     return HAL_OK;
;;;4561   }
00001a  bd70              POP      {r4-r6,pc}
                  |L72.28|
00001c  2d00              CMP      r5,#0                 ;4548
00001e  d004              BEQ      |L72.42|
000020  f7fffffe          BL       HAL_GetTick
000024  1b80              SUBS     r0,r0,r6              ;4548
000026  42a8              CMP      r0,r5                 ;4548
000028  d90e              BLS      |L72.72|
                  |L72.42|
00002a  6c60              LDR      r0,[r4,#0x44]         ;4550
00002c  2120              MOVS     r1,#0x20              ;4550
00002e  4308              ORRS     r0,r0,r1              ;4550
000030  6460              STR      r0,[r4,#0x44]         ;4550
000032  2041              MOVS     r0,#0x41              ;4551
000034  5501              STRB     r1,[r0,r4]            ;4551
000036  2100              MOVS     r1,#0                 ;4552
000038  2042              MOVS     r0,#0x42              ;4552
00003a  5501              STRB     r1,[r0,r4]            ;4552
00003c  bf00              NOP                            ;4555
00003e  2040              MOVS     r0,#0x40              ;4555
000040  5501              STRB     r1,[r0,r4]            ;4555
000042  bf00              NOP                            ;4555
000044  2003              MOVS     r0,#3                 ;4557
000046  e7e8              B        |L72.26|
                  |L72.72|
000048  6820              LDR      r0,[r4,#0]            ;4539
00004a  6980              LDR      r0,[r0,#0x18]         ;4539
00004c  2120              MOVS     r1,#0x20              ;4539
00004e  4008              ANDS     r0,r0,r1              ;4539
000050  0940              LSRS     r0,r0,#5              ;4539
000052  2800              CMP      r0,#0                 ;4539
000054  d0d9              BEQ      |L72.10|
000056  2000              MOVS     r0,#0                 ;4560
000058  e7df              B        |L72.26|
;;;4562   
                          ENDP


                          AREA ||i.I2C_WaitOnTXISFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  I2C_WaitOnTXISFlagUntilTimeout PROC
;;;4499     */
;;;4500   static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
000000  b570              PUSH     {r4-r6,lr}
;;;4501   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;4502     while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
000008  e021              B        |L73.78|
                  |L73.10|
;;;4503     {
;;;4504       /* Check if a NACK is detected */
;;;4505       if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       I2C_IsAcknowledgeFailed
000014  2800              CMP      r0,#0
000016  d001              BEQ      |L73.28|
;;;4506       {
;;;4507         return HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L73.26|
;;;4508       }
;;;4509   
;;;4510       /* Check for the Timeout */
;;;4511       if(Timeout != HAL_MAX_DELAY)
;;;4512       {
;;;4513         if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
;;;4514         {
;;;4515           hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
;;;4516           hi2c->State= HAL_I2C_STATE_READY;
;;;4517           hi2c->Mode = HAL_I2C_MODE_NONE;
;;;4518   
;;;4519           /* Process Unlocked */
;;;4520           __HAL_UNLOCK(hi2c);
;;;4521   
;;;4522           return HAL_TIMEOUT;
;;;4523         }
;;;4524       }
;;;4525     }
;;;4526     return HAL_OK;
;;;4527   }
00001a  bd70              POP      {r4-r6,pc}
                  |L73.28|
00001c  1c68              ADDS     r0,r5,#1              ;4511
00001e  2800              CMP      r0,#0                 ;4511
000020  d015              BEQ      |L73.78|
000022  2d00              CMP      r5,#0                 ;4513
000024  d004              BEQ      |L73.48|
000026  f7fffffe          BL       HAL_GetTick
00002a  1b80              SUBS     r0,r0,r6              ;4513
00002c  42a8              CMP      r0,r5                 ;4513
00002e  d90e              BLS      |L73.78|
                  |L73.48|
000030  6c60              LDR      r0,[r4,#0x44]         ;4515
000032  2120              MOVS     r1,#0x20              ;4515
000034  4308              ORRS     r0,r0,r1              ;4515
000036  6460              STR      r0,[r4,#0x44]         ;4515
000038  2041              MOVS     r0,#0x41              ;4516
00003a  5501              STRB     r1,[r0,r4]            ;4516
00003c  2100              MOVS     r1,#0                 ;4517
00003e  2042              MOVS     r0,#0x42              ;4517
000040  5501              STRB     r1,[r0,r4]            ;4517
000042  bf00              NOP                            ;4520
000044  2040              MOVS     r0,#0x40              ;4520
000046  5501              STRB     r1,[r0,r4]            ;4520
000048  bf00              NOP                            ;4520
00004a  2003              MOVS     r0,#3                 ;4522
00004c  e7e5              B        |L73.26|
                  |L73.78|
00004e  6820              LDR      r0,[r4,#0]            ;4502
000050  6980              LDR      r0,[r0,#0x18]         ;4502
000052  2102              MOVS     r1,#2                 ;4502
000054  4008              ANDS     r0,r0,r1              ;4502
000056  0840              LSRS     r0,r0,#1              ;4502
000058  2800              CMP      r0,#0                 ;4502
00005a  d0d6              BEQ      |L73.10|
00005c  2000              MOVS     r0,#0                 ;4526
00005e  e7dc              B        |L73.26|
;;;4528   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\stm32f03xx_HAL\\Src\\stm32f0xx_hal_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f0xx_hal_i2c_c_0eb271f4____REV16|
#line 388 "..\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f0xx_hal_i2c_c_0eb271f4____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f0xx_hal_i2c_c_0eb271f4____REVSH|
#line 402
|__asm___19_stm32f0xx_hal_i2c_c_0eb271f4____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
