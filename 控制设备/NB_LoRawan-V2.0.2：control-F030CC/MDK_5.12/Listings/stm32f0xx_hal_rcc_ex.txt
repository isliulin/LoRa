; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f0xx_hal_rcc_ex.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f0xx_hal_rcc_ex.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS\Device\ST\STM32F0xx\Include -I..\CMSIS\Include -I..\stm32f03xx_HAL\Inc -I..\USER -I..\HAL\inc -I..\HAL\system -I..\Lib\LoRawan-node\misc -I..\Lib\LoRawan-node\crypto -I..\Lib\LoRawan-node\mac -I..\Lib\LoRawan-node\radio -I..\Lib\LoRawan-node\radio\sx1276 -I..\Lib -IE:\NBI项目\NBI_LoRa\LoRa版本备份\NB_LoRawan-V2.0.2：control-F030CC\MDK_5.12\RTE -ID:\mysaftware\keil_5.12\ARM\PACK\Keil\STM32F0xx_DFP\1.5.0\Device\Include -ID:\mysaftware\keil_5.12\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=518 -DSTM32F030xC -DUSE_HAL_DRIVER -DSTM32F030xC -DUSE_MODEM_LORA -DUSE_BAND_433 --omf_browse=.\objects\stm32f0xx_hal_rcc_ex.crf ..\stm32f03xx_HAL\Src\stm32f0xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;285      */
;;;286    void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  4909              LDR      r1,|L1.40|
;;;287    {
;;;288      /* Set all possible values for the extended clock type parameter------------*/
;;;289      /* Common part first */
;;;290      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_I2C1   | RCC_PERIPHCLK_RTC;  
000002  6001              STR      r1,[r0,#0]
;;;291      /* Get the RTC configuration --------------------------------------------*/
;;;292      PeriphClkInit->RTCClockSelection = __HAL_RCC_GET_RTC_SOURCE();
000004  4909              LDR      r1,|L1.44|
000006  6a09              LDR      r1,[r1,#0x20]
000008  2203              MOVS     r2,#3
00000a  0212              LSLS     r2,r2,#8
00000c  4011              ANDS     r1,r1,r2
00000e  6041              STR      r1,[r0,#4]
;;;293      /* Get the USART1 clock configuration --------------------------------------------*/
;;;294      PeriphClkInit->Usart1ClockSelection = __HAL_RCC_GET_USART1_SOURCE();
000010  4906              LDR      r1,|L1.44|
000012  6b09              LDR      r1,[r1,#0x30]
000014  0789              LSLS     r1,r1,#30
000016  0f89              LSRS     r1,r1,#30
000018  6081              STR      r1,[r0,#8]
;;;295      /* Get the I2C1 clock source -----------------------------------------------*/
;;;296      PeriphClkInit->I2c1ClockSelection = __HAL_RCC_GET_I2C1_SOURCE();
00001a  4904              LDR      r1,|L1.44|
00001c  6b09              LDR      r1,[r1,#0x30]
00001e  2210              MOVS     r2,#0x10
000020  4011              ANDS     r1,r1,r2
000022  60c1              STR      r1,[r0,#0xc]
;;;297    
;;;298    #if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
;;;299     || defined(STM32F091xC) || defined(STM32F098xx)
;;;300      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USART2;
;;;301      /* Get the USART2 clock source ---------------------------------------------*/
;;;302      PeriphClkInit->Usart2ClockSelection = __HAL_RCC_GET_USART2_SOURCE();
;;;303    #endif /* STM32F071xB || STM32F072xB || STM32F078xx || */
;;;304           /* STM32F091xC || STM32F098xx */
;;;305    
;;;306    #if defined(STM32F091xC) || defined(STM32F098xx)
;;;307      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USART3;
;;;308      /* Get the USART3 clock source ---------------------------------------------*/
;;;309      PeriphClkInit->Usart3ClockSelection = __HAL_RCC_GET_USART3_SOURCE();
;;;310    #endif /* STM32F091xC || STM32F098xx */
;;;311    
;;;312    #if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F070x6)
;;;313      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USB;
;;;314      /* Get the USB clock source ---------------------------------------------*/
;;;315      PeriphClkInit->UsbClockSelection = __HAL_RCC_GET_USB_SOURCE();
;;;316    #endif /* STM32F042x6 || STM32F048xx || STM32F072xB || STM32F078xx || STM32F070xB || STM32F070x6 */
;;;317    
;;;318    #if defined(STM32F042x6) || defined(STM32F048xx)\
;;;319     || defined(STM32F051x8) || defined(STM32F058xx)\
;;;320     || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
;;;321     || defined(STM32F091xC) || defined(STM32F098xx)
;;;322      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_CEC;
;;;323      /* Get the CEC clock source ------------------------------------------------*/
;;;324      PeriphClkInit->CecClockSelection = __HAL_RCC_GET_CEC_SOURCE();
;;;325    #endif /* STM32F042x6 || STM32F048xx ||                */
;;;326           /* STM32F051x8 || STM32F058xx ||                */
;;;327           /* STM32F071xB || STM32F072xB || STM32F078xx || */
;;;328           /* STM32F091xC || STM32F098xx */
;;;329    
;;;330    }
000024  4770              BX       lr
;;;331    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x00010021
                  |L1.44|
                          DCD      0x40021000

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;385      */
;;;386    uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  b570              PUSH     {r4-r6,lr}
;;;387    {
000002  4605              MOV      r5,r0
;;;388      /* frequency == 0 : means that no available frequency for the peripheral */
;;;389      uint32_t frequency = 0U;
000004  2600              MOVS     r6,#0
;;;390      
;;;391      uint32_t srcclk = 0U;
000006  2400              MOVS     r4,#0
;;;392    #if defined(USB)
;;;393      uint32_t pllmull = 0U, pllsource = 0U, predivfactor = 0U;
;;;394    #endif /* USB */
;;;395    
;;;396      /* Check the parameters */
;;;397      assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
;;;398      
;;;399      switch (PeriphClk)
000008  2d01              CMP      r5,#1
00000a  d030              BEQ      |L2.110|
00000c  2d20              CMP      r5,#0x20
00000e  d052              BEQ      |L2.182|
000010  2001              MOVS     r0,#1
000012  0400              LSLS     r0,r0,#16
000014  1a28              SUBS     r0,r5,r0
000016  d163              BNE      |L2.224|
;;;400      {
;;;401      case RCC_PERIPHCLK_RTC:
;;;402        {
;;;403          /* Get the current RTC source */
;;;404          srcclk = __HAL_RCC_GET_RTC_SOURCE();
000018  4833              LDR      r0,|L2.232|
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  2103              MOVS     r1,#3
00001e  0209              LSLS     r1,r1,#8
000020  4008              ANDS     r0,r0,r1
000022  4604              MOV      r4,r0
;;;405    
;;;406          /* Check if LSE is ready and if RTC clock selection is LSE */
;;;407          if ((srcclk == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
000024  20ff              MOVS     r0,#0xff
000026  3001              ADDS     r0,#1
000028  4284              CMP      r4,r0
00002a  d107              BNE      |L2.60|
00002c  482e              LDR      r0,|L2.232|
00002e  6a00              LDR      r0,[r0,#0x20]
000030  2102              MOVS     r1,#2
000032  4008              ANDS     r0,r0,r1
000034  2800              CMP      r0,#0
000036  d001              BEQ      |L2.60|
;;;408          {
;;;409            frequency = LSE_VALUE;
000038  038e              LSLS     r6,r1,#14
00003a  e017              B        |L2.108|
                  |L2.60|
;;;410          }
;;;411          /* Check if LSI is ready and if RTC clock selection is LSI */
;;;412          else if ((srcclk == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
00003c  2001              MOVS     r0,#1
00003e  0240              LSLS     r0,r0,#9
000040  4284              CMP      r4,r0
000042  d107              BNE      |L2.84|
000044  4828              LDR      r0,|L2.232|
000046  6a40              LDR      r0,[r0,#0x24]
000048  2102              MOVS     r1,#2
00004a  4008              ANDS     r0,r0,r1
00004c  2800              CMP      r0,#0
00004e  d001              BEQ      |L2.84|
;;;413          {
;;;414            frequency = LSI_VALUE;
000050  4e26              LDR      r6,|L2.236|
000052  e00b              B        |L2.108|
                  |L2.84|
;;;415          }
;;;416          /* Check if HSE is ready  and if RTC clock selection is HSI_DIV32*/
;;;417          else if ((srcclk == RCC_RTCCLKSOURCE_HSE_DIV32) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
000054  2003              MOVS     r0,#3
000056  0200              LSLS     r0,r0,#8
000058  4284              CMP      r4,r0
00005a  d107              BNE      |L2.108|
00005c  4822              LDR      r0,|L2.232|
00005e  6800              LDR      r0,[r0,#0]
000060  2101              MOVS     r1,#1
000062  0449              LSLS     r1,r1,#17
000064  4008              ANDS     r0,r0,r1
000066  2800              CMP      r0,#0
000068  d000              BEQ      |L2.108|
;;;418          {
;;;419            frequency = HSE_VALUE / 32U;
00006a  4e21              LDR      r6,|L2.240|
                  |L2.108|
;;;420          }
;;;421          break;
00006c  e039              B        |L2.226|
                  |L2.110|
;;;422        }
;;;423      case RCC_PERIPHCLK_USART1:
;;;424        {
;;;425          /* Get the current USART1 source */
;;;426          srcclk = __HAL_RCC_GET_USART1_SOURCE();
00006e  481e              LDR      r0,|L2.232|
000070  6b00              LDR      r0,[r0,#0x30]
000072  0784              LSLS     r4,r0,#30
000074  0fa4              LSRS     r4,r4,#30
;;;427    
;;;428          /* Check if USART1 clock selection is PCLK1 */
;;;429          if (srcclk == RCC_USART1CLKSOURCE_PCLK1)
000076  2c00              CMP      r4,#0
000078  d103              BNE      |L2.130|
;;;430          {
;;;431            frequency = HAL_RCC_GetPCLK1Freq();
00007a  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00007e  4606              MOV      r6,r0
000080  e018              B        |L2.180|
                  |L2.130|
;;;432          }
;;;433          /* Check if HSI is ready and if USART1 clock selection is HSI */
;;;434          else if ((srcclk == RCC_USART1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
000082  2c03              CMP      r4,#3
000084  d107              BNE      |L2.150|
000086  4818              LDR      r0,|L2.232|
000088  6800              LDR      r0,[r0,#0]
00008a  2102              MOVS     r1,#2
00008c  4008              ANDS     r0,r0,r1
00008e  2800              CMP      r0,#0
000090  d001              BEQ      |L2.150|
;;;435          {
;;;436            frequency = HSI_VALUE;
000092  4e18              LDR      r6,|L2.244|
000094  e00e              B        |L2.180|
                  |L2.150|
;;;437          }
;;;438          /* Check if USART1 clock selection is SYSCLK */
;;;439          else if (srcclk == RCC_USART1CLKSOURCE_SYSCLK)
000096  2c01              CMP      r4,#1
000098  d103              BNE      |L2.162|
;;;440          {
;;;441            frequency = HAL_RCC_GetSysClockFreq();
00009a  f7fffffe          BL       HAL_RCC_GetSysClockFreq
00009e  4606              MOV      r6,r0
0000a0  e008              B        |L2.180|
                  |L2.162|
;;;442          }
;;;443          /* Check if LSE is ready  and if USART1 clock selection is LSE */
;;;444          else if ((srcclk == RCC_USART1CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
0000a2  2c02              CMP      r4,#2
0000a4  d106              BNE      |L2.180|
0000a6  4810              LDR      r0,|L2.232|
0000a8  6a00              LDR      r0,[r0,#0x20]
0000aa  2102              MOVS     r1,#2
0000ac  4008              ANDS     r0,r0,r1
0000ae  2800              CMP      r0,#0
0000b0  d000              BEQ      |L2.180|
;;;445          {
;;;446            frequency = LSE_VALUE;
0000b2  038e              LSLS     r6,r1,#14
                  |L2.180|
;;;447          }
;;;448          break;
0000b4  e015              B        |L2.226|
                  |L2.182|
;;;449        }
;;;450    #if defined(RCC_CFGR3_USART2SW)
;;;451      case RCC_PERIPHCLK_USART2:
;;;452        {
;;;453          /* Get the current USART2 source */
;;;454          srcclk = __HAL_RCC_GET_USART2_SOURCE();
;;;455    
;;;456          /* Check if USART2 clock selection is PCLK1 */
;;;457          if (srcclk == RCC_USART2CLKSOURCE_PCLK1)
;;;458          {
;;;459            frequency = HAL_RCC_GetPCLK1Freq();
;;;460          }
;;;461          /* Check if HSI is ready and if USART2 clock selection is HSI */
;;;462          else if ((srcclk == RCC_USART2CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
;;;463          {
;;;464            frequency = HSI_VALUE;
;;;465          }
;;;466          /* Check if USART2 clock selection is SYSCLK */
;;;467          else if (srcclk == RCC_USART2CLKSOURCE_SYSCLK)
;;;468          {
;;;469            frequency = HAL_RCC_GetSysClockFreq();
;;;470          }
;;;471          /* Check if LSE is ready  and if USART2 clock selection is LSE */
;;;472          else if ((srcclk == RCC_USART2CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
;;;473          {
;;;474            frequency = LSE_VALUE;
;;;475          }
;;;476          break;
;;;477        }
;;;478    #endif /* RCC_CFGR3_USART2SW */
;;;479    #if defined(RCC_CFGR3_USART3SW)
;;;480      case RCC_PERIPHCLK_USART3:
;;;481        {
;;;482          /* Get the current USART3 source */
;;;483          srcclk = __HAL_RCC_GET_USART3_SOURCE();
;;;484    
;;;485          /* Check if USART3 clock selection is PCLK1 */
;;;486          if (srcclk == RCC_USART3CLKSOURCE_PCLK1)
;;;487          {
;;;488            frequency = HAL_RCC_GetPCLK1Freq();
;;;489          }
;;;490          /* Check if HSI is ready and if USART3 clock selection is HSI */
;;;491          else if ((srcclk == RCC_USART3CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
;;;492          {
;;;493            frequency = HSI_VALUE;
;;;494          }
;;;495          /* Check if USART3 clock selection is SYSCLK */
;;;496          else if (srcclk == RCC_USART3CLKSOURCE_SYSCLK)
;;;497          {
;;;498            frequency = HAL_RCC_GetSysClockFreq();
;;;499          }
;;;500          /* Check if LSE is ready  and if USART3 clock selection is LSE */
;;;501          else if ((srcclk == RCC_USART3CLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
;;;502          {
;;;503            frequency = LSE_VALUE;
;;;504          }
;;;505          break;
;;;506        }
;;;507    #endif /* RCC_CFGR3_USART3SW */
;;;508      case RCC_PERIPHCLK_I2C1:
;;;509        {
;;;510          /* Get the current I2C1 source */
;;;511          srcclk = __HAL_RCC_GET_I2C1_SOURCE();
0000b6  480c              LDR      r0,|L2.232|
0000b8  6b00              LDR      r0,[r0,#0x30]
0000ba  2110              MOVS     r1,#0x10
0000bc  4008              ANDS     r0,r0,r1
0000be  4604              MOV      r4,r0
;;;512    
;;;513          /* Check if HSI is ready and if I2C1 clock selection is HSI */
;;;514          if ((srcclk == RCC_I2C1CLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
0000c0  2c00              CMP      r4,#0
0000c2  d107              BNE      |L2.212|
0000c4  4808              LDR      r0,|L2.232|
0000c6  6800              LDR      r0,[r0,#0]
0000c8  2102              MOVS     r1,#2
0000ca  4008              ANDS     r0,r0,r1
0000cc  2800              CMP      r0,#0
0000ce  d001              BEQ      |L2.212|
;;;515          {
;;;516            frequency = HSI_VALUE;
0000d0  4e08              LDR      r6,|L2.244|
0000d2  e004              B        |L2.222|
                  |L2.212|
;;;517          }
;;;518          /* Check if I2C1 clock selection is SYSCLK */
;;;519          else if (srcclk == RCC_I2C1CLKSOURCE_SYSCLK)
0000d4  2c10              CMP      r4,#0x10
0000d6  d102              BNE      |L2.222|
;;;520          {
;;;521            frequency = HAL_RCC_GetSysClockFreq();
0000d8  f7fffffe          BL       HAL_RCC_GetSysClockFreq
0000dc  4606              MOV      r6,r0
                  |L2.222|
;;;522          }
;;;523          break;
0000de  e000              B        |L2.226|
                  |L2.224|
;;;524        }
;;;525    #if defined(USB)
;;;526      case RCC_PERIPHCLK_USB:
;;;527        {
;;;528          /* Get the current USB source */
;;;529          srcclk = __HAL_RCC_GET_USB_SOURCE();
;;;530    
;;;531          /* Check if PLL is ready and if USB clock selection is PLL */
;;;532          if ((srcclk == RCC_USBCLKSOURCE_PLL) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY)))
;;;533          {
;;;534            /* Get PLL clock source and multiplication factor ----------------------*/
;;;535            pllmull      = RCC->CFGR & RCC_CFGR_PLLMUL;
;;;536            pllsource    = RCC->CFGR & RCC_CFGR_PLLSRC;
;;;537            pllmull      = (pllmull >> RCC_CFGR_PLLMUL_BITNUMBER) + 2U;
;;;538            predivfactor = (RCC->CFGR2 & RCC_CFGR2_PREDIV) + 1U;
;;;539    
;;;540            if (pllsource == RCC_CFGR_PLLSRC_HSE_PREDIV)
;;;541            {
;;;542              /* HSE used as PLL clock source : frequency = HSE/PREDIV * PLLMUL */
;;;543              frequency = (HSE_VALUE/predivfactor) * pllmull;
;;;544            }
;;;545    #if defined(RCC_CR2_HSI48ON)
;;;546            else if (pllsource == RCC_CFGR_PLLSRC_HSI48_PREDIV)
;;;547            {
;;;548              /* HSI48 used as PLL clock source : frequency = HSI48/PREDIV * PLLMUL */
;;;549              frequency = (HSI48_VALUE / predivfactor) * pllmull;
;;;550            }
;;;551    #endif /* RCC_CR2_HSI48ON */
;;;552            else
;;;553            {
;;;554    #if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F078xx) || defined(STM32F072xB) || defined(STM32F070xB)
;;;555              /* HSI used as PLL clock source : frequency = HSI/PREDIV * PLLMUL */
;;;556              frequency = (HSI_VALUE / predivfactor) * pllmull;
;;;557    #else
;;;558              /* HSI used as PLL clock source : frequency = HSI/2U * PLLMUL */
;;;559              frequency = (HSI_VALUE >> 1U) * pllmull;
;;;560    #endif /* STM32F042x6 || STM32F048xx || STM32F072xB || STM32F078xx || STM32F070xB */
;;;561            }
;;;562          }
;;;563    #if defined(RCC_CR2_HSI48ON)
;;;564          /* Check if HSI48 is ready and if USB clock selection is HSI48 */
;;;565          else if ((srcclk == RCC_USBCLKSOURCE_HSI48) && (HAL_IS_BIT_SET(RCC->CR2, RCC_CR2_HSI48RDY)))
;;;566          {
;;;567            frequency = HSI48_VALUE;
;;;568          }
;;;569    #endif /* RCC_CR2_HSI48ON */
;;;570          break;
;;;571        }
;;;572    #endif /* USB */
;;;573    #if defined(CEC)
;;;574      case RCC_PERIPHCLK_CEC:
;;;575        {
;;;576          /* Get the current CEC source */
;;;577          srcclk = __HAL_RCC_GET_CEC_SOURCE();
;;;578    
;;;579          /* Check if HSI is ready and if CEC clock selection is HSI */
;;;580          if ((srcclk == RCC_CECCLKSOURCE_HSI) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)))
;;;581          {
;;;582            frequency = HSI_VALUE;
;;;583          }
;;;584          /* Check if LSE is ready  and if CEC clock selection is LSE */
;;;585          else if ((srcclk == RCC_CECCLKSOURCE_LSE) && (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)))
;;;586          {
;;;587            frequency = LSE_VALUE;
;;;588          }
;;;589          break;
;;;590        }
;;;591    #endif /* CEC */
;;;592      default: 
;;;593        {
;;;594          break;
0000e0  bf00              NOP      
                  |L2.226|
0000e2  bf00              NOP                            ;421
;;;595        }
;;;596      }
;;;597      return(frequency);
0000e4  4630              MOV      r0,r6
;;;598    }
0000e6  bd70              POP      {r4-r6,pc}
;;;599    
                          ENDP

                  |L2.232|
                          DCD      0x40021000
                  |L2.236|
                          DCD      0x00009c40
                  |L2.240|
                          DCD      0x0003d090
                  |L2.244|
                          DCD      0x007a1200

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;119      */
;;;120    HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  b5f8              PUSH     {r3-r7,lr}
;;;121    {
000002  4604              MOV      r4,r0
;;;122      uint32_t tickstart = 0U;
000004  2600              MOVS     r6,#0
;;;123      uint32_t temp_reg = 0U;
000006  2500              MOVS     r5,#0
;;;124    
;;;125      /* Check the parameters */
;;;126      assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;127      
;;;128      /*---------------------------- RTC configuration -------------------------------*/
;;;129      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
000008  2101              MOVS     r1,#1
00000a  0409              LSLS     r1,r1,#16
00000c  6820              LDR      r0,[r4,#0]
00000e  4008              ANDS     r0,r0,r1
000010  4288              CMP      r0,r1
000012  d17a              BNE      |L3.266|
;;;130      {
;;;131        /* check for RTC Parameters used to output RTCCLK */
;;;132        assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;133        
;;;134        FlagStatus       pwrclkchanged = RESET;
000014  2700              MOVS     r7,#0
;;;135    
;;;136        /* As soon as function is called to change RTC clock source, activation of the 
;;;137           power domain is done. */
;;;138        /* Requires to enable write access to Backup Domain of necessary */
;;;139        if(__HAL_RCC_PWR_IS_CLK_DISABLED())
000016  484b              LDR      r0,|L3.324|
000018  69c0              LDR      r0,[r0,#0x1c]
00001a  0309              LSLS     r1,r1,#12
00001c  4008              ANDS     r0,r0,r1
00001e  2800              CMP      r0,#0
000020  d10d              BNE      |L3.62|
;;;140        {
;;;141        __HAL_RCC_PWR_CLK_ENABLE();
000022  bf00              NOP      
000024  4847              LDR      r0,|L3.324|
000026  69c0              LDR      r0,[r0,#0x1c]
000028  4308              ORRS     r0,r0,r1
00002a  4946              LDR      r1,|L3.324|
00002c  61c8              STR      r0,[r1,#0x1c]
00002e  4608              MOV      r0,r1
000030  69c0              LDR      r0,[r0,#0x1c]
000032  0409              LSLS     r1,r1,#16
000034  4008              ANDS     r0,r0,r1
000036  9000              STR      r0,[sp,#0]
000038  bf00              NOP      
00003a  bf00              NOP      
;;;142          pwrclkchanged = SET;
00003c  2701              MOVS     r7,#1
                  |L3.62|
;;;143        }
;;;144        
;;;145        if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
00003e  4842              LDR      r0,|L3.328|
000040  6800              LDR      r0,[r0,#0]
000042  21ff              MOVS     r1,#0xff
000044  3101              ADDS     r1,#1
000046  4008              ANDS     r0,r0,r1
000048  2800              CMP      r0,#0
00004a  d116              BNE      |L3.122|
;;;146        {
;;;147          /* Enable write access to Backup domain */
;;;148          SET_BIT(PWR->CR, PWR_CR_DBP);
00004c  483e              LDR      r0,|L3.328|
00004e  6800              LDR      r0,[r0,#0]
000050  4308              ORRS     r0,r0,r1
000052  493d              LDR      r1,|L3.328|
000054  6008              STR      r0,[r1,#0]
;;;149          
;;;150          /* Wait for Backup domain Write protection disable */
;;;151          tickstart = HAL_GetTick();
000056  f7fffffe          BL       HAL_GetTick
00005a  4606              MOV      r6,r0
;;;152          
;;;153          while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
00005c  e006              B        |L3.108|
                  |L3.94|
;;;154          {
;;;155            if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
00005e  f7fffffe          BL       HAL_GetTick
000062  1b80              SUBS     r0,r0,r6
000064  2864              CMP      r0,#0x64
000066  d901              BLS      |L3.108|
;;;156            {
;;;157              return HAL_TIMEOUT;
000068  2003              MOVS     r0,#3
                  |L3.106|
;;;158            }
;;;159          }
;;;160        }
;;;161        
;;;162        /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
;;;163        temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
;;;164        if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
;;;165        {
;;;166          /* Store the content of BDCR register before the reset of Backup Domain */
;;;167          temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
;;;168          /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;169          __HAL_RCC_BACKUPRESET_FORCE();
;;;170          __HAL_RCC_BACKUPRESET_RELEASE();
;;;171          /* Restore the Content of BDCR register */
;;;172          RCC->BDCR = temp_reg;
;;;173          
;;;174          /* Wait for LSERDY if LSE was enabled */
;;;175          if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
;;;176          {
;;;177            /* Get Start Tick */
;;;178            tickstart = HAL_GetTick();
;;;179            
;;;180            /* Wait till LSE is ready */  
;;;181            while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;182            {
;;;183              if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
;;;184              {
;;;185                return HAL_TIMEOUT;
;;;186              }
;;;187            }
;;;188          }
;;;189        }
;;;190        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
;;;191    
;;;192        /* Require to disable power clock if necessary */
;;;193        if(pwrclkchanged == SET)
;;;194        {
;;;195          __HAL_RCC_PWR_CLK_DISABLE();
;;;196        }
;;;197      }
;;;198    
;;;199      /*------------------------------- USART1 Configuration ------------------------*/ 
;;;200      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
;;;201      {
;;;202        /* Check the parameters */
;;;203        assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
;;;204        
;;;205        /* Configure the USART1 clock source */
;;;206        __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
;;;207      }
;;;208      
;;;209    #if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
;;;210     || defined(STM32F091xC) || defined(STM32F098xx)
;;;211      /*----------------------------- USART2 Configuration --------------------------*/ 
;;;212      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
;;;213      {
;;;214        /* Check the parameters */
;;;215        assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
;;;216        
;;;217        /* Configure the USART2 clock source */
;;;218        __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
;;;219      }
;;;220    #endif /* STM32F071xB || STM32F072xB || STM32F078xx || */
;;;221           /* STM32F091xC || STM32F098xx */
;;;222    
;;;223    #if defined(STM32F091xC) || defined(STM32F098xx)
;;;224      /*----------------------------- USART3 Configuration --------------------------*/ 
;;;225      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
;;;226      {
;;;227        /* Check the parameters */
;;;228        assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
;;;229        
;;;230        /* Configure the USART3 clock source */
;;;231        __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
;;;232      }
;;;233    #endif /* STM32F091xC || STM32F098xx */  
;;;234    
;;;235      /*------------------------------ I2C1 Configuration ------------------------*/ 
;;;236      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
;;;237      {
;;;238        /* Check the parameters */
;;;239        assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
;;;240        
;;;241        /* Configure the I2C1 clock source */
;;;242        __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
;;;243      }
;;;244    
;;;245    #if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F070x6)
;;;246      /*------------------------------ USB Configuration ------------------------*/ 
;;;247      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
;;;248      {
;;;249        /* Check the parameters */
;;;250        assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
;;;251        
;;;252        /* Configure the USB clock source */
;;;253        __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
;;;254      }
;;;255    #endif /* STM32F042x6 || STM32F048xx || STM32F072xB || STM32F078xx || STM32F070xB || STM32F070x6 */
;;;256    
;;;257    #if defined(STM32F042x6) || defined(STM32F048xx)\
;;;258     || defined(STM32F051x8) || defined(STM32F058xx)\
;;;259     || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
;;;260     || defined(STM32F091xC) || defined(STM32F098xx)
;;;261      /*------------------------------ CEC clock Configuration -------------------*/ 
;;;262      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
;;;263      {
;;;264        /* Check the parameters */
;;;265        assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
;;;266        
;;;267        /* Configure the CEC clock source */
;;;268        __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
;;;269      }
;;;270    #endif /* STM32F042x6 || STM32F048xx ||                */
;;;271           /* STM32F051x8 || STM32F058xx ||                */
;;;272           /* STM32F071xB || STM32F072xB || STM32F078xx || */
;;;273           /* STM32F091xC || STM32F098xx */
;;;274      
;;;275      return HAL_OK;
;;;276    }
00006a  bdf8              POP      {r3-r7,pc}
                  |L3.108|
00006c  4836              LDR      r0,|L3.328|
00006e  6800              LDR      r0,[r0,#0]            ;153
000070  21ff              MOVS     r1,#0xff              ;153
000072  3101              ADDS     r1,#1                 ;153
000074  4008              ANDS     r0,r0,r1              ;153
000076  2800              CMP      r0,#0                 ;153
000078  d0f1              BEQ      |L3.94|
                  |L3.122|
00007a  4832              LDR      r0,|L3.324|
00007c  6a00              LDR      r0,[r0,#0x20]         ;163
00007e  2103              MOVS     r1,#3                 ;163
000080  0209              LSLS     r1,r1,#8              ;163
000082  4008              ANDS     r0,r0,r1              ;163
000084  4605              MOV      r5,r0                 ;163
000086  2d00              CMP      r5,#0                 ;164
000088  d02d              BEQ      |L3.230|
00008a  6860              LDR      r0,[r4,#4]            ;164
00008c  4008              ANDS     r0,r0,r1              ;164
00008e  42a8              CMP      r0,r5                 ;164
000090  d029              BEQ      |L3.230|
000092  482c              LDR      r0,|L3.324|
000094  6a00              LDR      r0,[r0,#0x20]         ;167
000096  4388              BICS     r0,r0,r1              ;167
000098  4605              MOV      r5,r0                 ;167
00009a  482a              LDR      r0,|L3.324|
00009c  6a00              LDR      r0,[r0,#0x20]         ;169
00009e  2101              MOVS     r1,#1                 ;169
0000a0  0409              LSLS     r1,r1,#16             ;169
0000a2  4308              ORRS     r0,r0,r1              ;169
0000a4  4927              LDR      r1,|L3.324|
0000a6  6208              STR      r0,[r1,#0x20]         ;169
0000a8  4608              MOV      r0,r1                 ;170
0000aa  6a00              LDR      r0,[r0,#0x20]         ;170
0000ac  2101              MOVS     r1,#1                 ;170
0000ae  0409              LSLS     r1,r1,#16             ;170
0000b0  4388              BICS     r0,r0,r1              ;170
0000b2  4924              LDR      r1,|L3.324|
0000b4  6208              STR      r0,[r1,#0x20]         ;170
0000b6  4608              MOV      r0,r1                 ;172
0000b8  6205              STR      r5,[r0,#0x20]         ;172
0000ba  07e8              LSLS     r0,r5,#31             ;175
0000bc  0fc0              LSRS     r0,r0,#31             ;175
0000be  2800              CMP      r0,#0                 ;175
0000c0  d011              BEQ      |L3.230|
0000c2  f7fffffe          BL       HAL_GetTick
0000c6  4606              MOV      r6,r0                 ;178
0000c8  e007              B        |L3.218|
                  |L3.202|
0000ca  f7fffffe          BL       HAL_GetTick
0000ce  1b80              SUBS     r0,r0,r6              ;183
0000d0  491e              LDR      r1,|L3.332|
0000d2  4288              CMP      r0,r1                 ;183
0000d4  d901              BLS      |L3.218|
0000d6  2003              MOVS     r0,#3                 ;185
0000d8  e7c7              B        |L3.106|
                  |L3.218|
0000da  481a              LDR      r0,|L3.324|
0000dc  6a00              LDR      r0,[r0,#0x20]         ;181
0000de  2102              MOVS     r1,#2                 ;181
0000e0  4008              ANDS     r0,r0,r1              ;181
0000e2  2800              CMP      r0,#0                 ;181
0000e4  d0f1              BEQ      |L3.202|
                  |L3.230|
0000e6  4817              LDR      r0,|L3.324|
0000e8  6a00              LDR      r0,[r0,#0x20]         ;190
0000ea  2103              MOVS     r1,#3                 ;190
0000ec  0209              LSLS     r1,r1,#8              ;190
0000ee  4388              BICS     r0,r0,r1              ;190
0000f0  6861              LDR      r1,[r4,#4]            ;190
0000f2  4308              ORRS     r0,r0,r1              ;190
0000f4  4913              LDR      r1,|L3.324|
0000f6  6208              STR      r0,[r1,#0x20]         ;190
0000f8  2f01              CMP      r7,#1                 ;193
0000fa  d105              BNE      |L3.264|
0000fc  4608              MOV      r0,r1                 ;195
0000fe  69c0              LDR      r0,[r0,#0x1c]         ;195
000100  0409              LSLS     r1,r1,#16             ;195
000102  4388              BICS     r0,r0,r1              ;195
000104  490f              LDR      r1,|L3.324|
000106  61c8              STR      r0,[r1,#0x1c]         ;195
                  |L3.264|
000108  bf00              NOP                            ;197
                  |L3.266|
00010a  7820              LDRB     r0,[r4,#0]            ;200
00010c  07c0              LSLS     r0,r0,#31             ;200
00010e  0fc0              LSRS     r0,r0,#31             ;200
000110  2800              CMP      r0,#0                 ;200
000112  d007              BEQ      |L3.292|
000114  480b              LDR      r0,|L3.324|
000116  6b00              LDR      r0,[r0,#0x30]         ;206
000118  0880              LSRS     r0,r0,#2              ;206
00011a  0080              LSLS     r0,r0,#2              ;206
00011c  68a1              LDR      r1,[r4,#8]            ;206
00011e  4308              ORRS     r0,r0,r1              ;206
000120  4908              LDR      r1,|L3.324|
000122  6308              STR      r0,[r1,#0x30]         ;206
                  |L3.292|
000124  2120              MOVS     r1,#0x20              ;236
000126  6820              LDR      r0,[r4,#0]            ;236
000128  4008              ANDS     r0,r0,r1              ;236
00012a  2820              CMP      r0,#0x20              ;236
00012c  d107              BNE      |L3.318|
00012e  4805              LDR      r0,|L3.324|
000130  6b00              LDR      r0,[r0,#0x30]         ;242
000132  2110              MOVS     r1,#0x10              ;242
000134  4388              BICS     r0,r0,r1              ;242
000136  68e1              LDR      r1,[r4,#0xc]          ;242
000138  4308              ORRS     r0,r0,r1              ;242
00013a  4902              LDR      r1,|L3.324|
00013c  6308              STR      r0,[r1,#0x30]         ;242
                  |L3.318|
00013e  2000              MOVS     r0,#0                 ;275
000140  e793              B        |L3.106|
;;;277    
                          ENDP

000142  0000              DCW      0x0000
                  |L3.324|
                          DCD      0x40021000
                  |L3.328|
                          DCD      0x40007000
                  |L3.332|
                          DCD      0x00001388

;*** Start embedded assembler ***

#line 1 "..\\stm32f03xx_HAL\\Src\\stm32f0xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f0xx_hal_rcc_ex_c_bed13b44____REV16|
#line 388 "..\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f0xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f0xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 402
|__asm___22_stm32f0xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
