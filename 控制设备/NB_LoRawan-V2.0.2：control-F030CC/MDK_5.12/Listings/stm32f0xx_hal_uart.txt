; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f0xx_hal_uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f0xx_hal_uart.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS\Device\ST\STM32F0xx\Include -I..\CMSIS\Include -I..\stm32f03xx_HAL\Inc -I..\USER -I..\HAL\inc -I..\HAL\system -I..\Lib\LoRawan-node\misc -I..\Lib\LoRawan-node\crypto -I..\Lib\LoRawan-node\mac -I..\Lib\LoRawan-node\radio -I..\Lib\LoRawan-node\radio\sx1276 -I..\Lib -IE:\NBI项目\NBI_LoRa\LoRa版本备份\NB_LoRawan-V2.0.2：control-F030CC\MDK_5.12\RTE -ID:\mysaftware\keil_5.12\ARM\PACK\Keil\STM32F0xx_DFP\1.5.0\Device\Include -ID:\mysaftware\keil_5.12\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=518 -DSTM32F030xC -DUSE_HAL_DRIVER -DSTM32F030xC -DUSE_MODEM_LORA -DUSE_BAND_433 --omf_browse=.\objects\stm32f0xx_hal_uart.crf ..\stm32f03xx_HAL\Src\stm32f0xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2028     */
;;;2029   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2030   {
;;;2031     /* Process Locked */
;;;2032     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  2068              MOVS     r0,#0x68
000006  5c40              LDRB     r0,[r0,r1]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L1.16|
00000c  2002              MOVS     r0,#2
                  |L1.14|
;;;2033     huart->gState = HAL_UART_STATE_BUSY;
;;;2034   
;;;2035     /* Clear TE and RE bits */
;;;2036     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
;;;2037     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2038     SET_BIT(huart->Instance->CR1, USART_CR1_RE);
;;;2039   
;;;2040     huart->gState = HAL_UART_STATE_READY;
;;;2041     /* Process Unlocked */
;;;2042     __HAL_UNLOCK(huart);
;;;2043   
;;;2044     return HAL_OK;
;;;2045   }
00000e  4770              BX       lr
                  |L1.16|
000010  2201              MOVS     r2,#1                 ;2032
000012  2068              MOVS     r0,#0x68              ;2032
000014  5442              STRB     r2,[r0,r1]            ;2032
000016  bf00              NOP                            ;2032
000018  2224              MOVS     r2,#0x24              ;2033
00001a  2069              MOVS     r0,#0x69              ;2033
00001c  5442              STRB     r2,[r0,r1]            ;2033
00001e  6808              LDR      r0,[r1,#0]            ;2036
000020  6800              LDR      r0,[r0,#0]            ;2036
000022  220c              MOVS     r2,#0xc               ;2036
000024  4390              BICS     r0,r0,r2              ;2036
000026  680a              LDR      r2,[r1,#0]            ;2036
000028  6010              STR      r0,[r2,#0]            ;2036
00002a  6808              LDR      r0,[r1,#0]            ;2038
00002c  6800              LDR      r0,[r0,#0]            ;2038
00002e  2204              MOVS     r2,#4                 ;2038
000030  4310              ORRS     r0,r0,r2              ;2038
000032  680a              LDR      r2,[r1,#0]            ;2038
000034  6010              STR      r0,[r2,#0]            ;2038
000036  2220              MOVS     r2,#0x20              ;2040
000038  2069              MOVS     r0,#0x69              ;2040
00003a  5442              STRB     r2,[r0,r1]            ;2040
00003c  bf00              NOP                            ;2042
00003e  2200              MOVS     r2,#0                 ;2042
000040  2068              MOVS     r0,#0x68              ;2042
000042  5442              STRB     r2,[r0,r1]            ;2042
000044  bf00              NOP                            ;2042
000046  2000              MOVS     r0,#0                 ;2044
000048  e7e1              B        |L1.14|
;;;2046   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2004     */
;;;2005   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2006   {
;;;2007     /* Process Locked */
;;;2008     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  2068              MOVS     r0,#0x68
000006  5c40              LDRB     r0,[r0,r1]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L2.16|
00000c  2002              MOVS     r0,#2
                  |L2.14|
;;;2009     huart->gState = HAL_UART_STATE_BUSY;
;;;2010   
;;;2011     /* Clear TE and RE bits */
;;;2012     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
;;;2013     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2014     SET_BIT(huart->Instance->CR1, USART_CR1_TE);
;;;2015   
;;;2016     huart->gState = HAL_UART_STATE_READY;
;;;2017   
;;;2018     /* Process Unlocked */
;;;2019     __HAL_UNLOCK(huart);
;;;2020   
;;;2021     return HAL_OK;
;;;2022   }
00000e  4770              BX       lr
                  |L2.16|
000010  2201              MOVS     r2,#1                 ;2008
000012  2068              MOVS     r0,#0x68              ;2008
000014  5442              STRB     r2,[r0,r1]            ;2008
000016  bf00              NOP                            ;2008
000018  2224              MOVS     r2,#0x24              ;2009
00001a  2069              MOVS     r0,#0x69              ;2009
00001c  5442              STRB     r2,[r0,r1]            ;2009
00001e  6808              LDR      r0,[r1,#0]            ;2012
000020  6800              LDR      r0,[r0,#0]            ;2012
000022  220c              MOVS     r2,#0xc               ;2012
000024  4390              BICS     r0,r0,r2              ;2012
000026  680a              LDR      r2,[r1,#0]            ;2012
000028  6010              STR      r0,[r2,#0]            ;2012
00002a  6808              LDR      r0,[r1,#0]            ;2014
00002c  6800              LDR      r0,[r0,#0]            ;2014
00002e  2208              MOVS     r2,#8                 ;2014
000030  4310              ORRS     r0,r0,r2              ;2014
000032  680a              LDR      r2,[r1,#0]            ;2014
000034  6010              STR      r0,[r2,#0]            ;2014
000036  2220              MOVS     r2,#0x20              ;2016
000038  2069              MOVS     r0,#0x69              ;2016
00003a  5442              STRB     r2,[r0,r1]            ;2016
00003c  bf00              NOP                            ;2019
00003e  2200              MOVS     r2,#0                 ;2019
000040  2068              MOVS     r0,#0x68              ;2019
000042  5442              STRB     r2,[r0,r1]            ;2019
000044  bf00              NOP                            ;2019
000046  2000              MOVS     r0,#0                 ;2021
000048  e7e1              B        |L2.14|
;;;2023   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;369      */
;;;370    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;371    {
000002  4604              MOV      r4,r0
;;;372      /* Check the UART handle allocation */
;;;373      if(huart == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L3.12|
;;;374      {
;;;375        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L3.10|
;;;376      }
;;;377    
;;;378      /* Check UART instance */
;;;379      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;380    
;;;381      if(huart->gState == HAL_UART_STATE_RESET)
;;;382      {
;;;383        /* Allocate lock resource and initialize it */
;;;384        huart->Lock = HAL_UNLOCKED;
;;;385    
;;;386        /* Init the low level hardware : GPIO, CLOCK */
;;;387        HAL_UART_MspInit(huart);
;;;388      }
;;;389    
;;;390      huart->gState = HAL_UART_STATE_BUSY;
;;;391    
;;;392      /* Disable the Peripheral */
;;;393      __HAL_UART_DISABLE(huart);
;;;394    
;;;395      /* Set the UART Communication parameters */
;;;396      if (UART_SetConfig(huart) == HAL_ERROR)
;;;397      {
;;;398        return HAL_ERROR;
;;;399      }
;;;400    
;;;401      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;402      {
;;;403        UART_AdvFeatureConfig(huart);
;;;404      }
;;;405    
;;;406      /* In half-duplex mode, the following bits must be kept cleared:
;;;407      - LINEN (if LIN is supported) and CLKEN bits in the USART_CR2 register,
;;;408      - SCEN (if Smartcard is supported), and IREN (if IrDA is supported)  bits in the USART_CR3 register. */
;;;409    #if defined (USART_CR2_LINEN)
;;;410      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;411    #else
;;;412      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;413    #endif
;;;414    #if defined (USART_CR3_SCEN)
;;;415    #if defined (USART_CR3_IREN)
;;;416      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;417    #else
;;;418      CLEAR_BIT(huart->Instance->CR3, USART_CR3_SCEN);
;;;419    #endif
;;;420    #else
;;;421    #if defined (USART_CR3_IREN)
;;;422      CLEAR_BIT(huart->Instance->CR3, USART_CR3_IREN);
;;;423    #endif
;;;424    #endif
;;;425    
;;;426      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;427      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;428    
;;;429      /* Enable the Peripheral */
;;;430      __HAL_UART_ENABLE(huart);
;;;431    
;;;432      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;433      return (UART_CheckIdleState(huart));
;;;434    }
00000a  bd10              POP      {r4,pc}
                  |L3.12|
00000c  2069              MOVS     r0,#0x69              ;381
00000e  5d00              LDRB     r0,[r0,r4]            ;381
000010  2800              CMP      r0,#0                 ;381
000012  d105              BNE      |L3.32|
000014  2100              MOVS     r1,#0                 ;384
000016  2068              MOVS     r0,#0x68              ;384
000018  5501              STRB     r1,[r0,r4]            ;384
00001a  4620              MOV      r0,r4                 ;387
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L3.32|
000020  2124              MOVS     r1,#0x24              ;390
000022  2069              MOVS     r0,#0x69              ;390
000024  5501              STRB     r1,[r0,r4]            ;390
000026  6820              LDR      r0,[r4,#0]            ;393
000028  6800              LDR      r0,[r0,#0]            ;393
00002a  0840              LSRS     r0,r0,#1              ;393
00002c  0040              LSLS     r0,r0,#1              ;393
00002e  6821              LDR      r1,[r4,#0]            ;393
000030  6008              STR      r0,[r1,#0]            ;393
000032  4620              MOV      r0,r4                 ;396
000034  f7fffffe          BL       UART_SetConfig
000038  2801              CMP      r0,#1                 ;396
00003a  d100              BNE      |L3.62|
00003c  e7e5              B        |L3.10|
                  |L3.62|
00003e  6a60              LDR      r0,[r4,#0x24]         ;401
000040  2800              CMP      r0,#0                 ;401
000042  d002              BEQ      |L3.74|
000044  4620              MOV      r0,r4                 ;403
000046  f7fffffe          BL       UART_AdvFeatureConfig
                  |L3.74|
00004a  6820              LDR      r0,[r4,#0]            ;412
00004c  6840              LDR      r0,[r0,#4]            ;412
00004e  2101              MOVS     r1,#1                 ;412
000050  02c9              LSLS     r1,r1,#11             ;412
000052  4388              BICS     r0,r0,r1              ;412
000054  6821              LDR      r1,[r4,#0]            ;412
000056  6048              STR      r0,[r1,#4]            ;412
000058  6820              LDR      r0,[r4,#0]            ;427
00005a  6880              LDR      r0,[r0,#8]            ;427
00005c  2108              MOVS     r1,#8                 ;427
00005e  4308              ORRS     r0,r0,r1              ;427
000060  6821              LDR      r1,[r4,#0]            ;427
000062  6088              STR      r0,[r1,#8]            ;427
000064  6820              LDR      r0,[r4,#0]            ;430
000066  6800              LDR      r0,[r0,#0]            ;430
000068  2101              MOVS     r1,#1                 ;430
00006a  4308              ORRS     r0,r0,r1              ;430
00006c  6821              LDR      r1,[r4,#0]            ;430
00006e  6008              STR      r0,[r1,#0]            ;430
000070  4620              MOV      r0,r4                 ;433
000072  f7fffffe          BL       UART_CheckIdleState
000076  e7c8              B        |L3.10|
;;;435    
                          ENDP


                          AREA ||i.HAL_MultiProcessor_DisableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_DisableMuteMode PROC
;;;1973     */
;;;1974   HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
000000  b500              PUSH     {lr}
;;;1975   {
000002  4603              MOV      r3,r0
;;;1976     /* Process Locked */
;;;1977     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  2068              MOVS     r0,#0x68
000008  5cc0              LDRB     r0,[r0,r3]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L4.18|
00000e  2002              MOVS     r0,#2
                  |L4.16|
;;;1978   
;;;1979     huart->gState = HAL_UART_STATE_BUSY;
;;;1980   
;;;1981      /* Disable USART mute mode by clearing the MME bit in the CR1 register */
;;;1982     CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1983   
;;;1984     huart->gState = HAL_UART_STATE_READY;
;;;1985   
;;;1986     return (UART_CheckIdleState(huart));
;;;1987   }
000010  bd00              POP      {pc}
                  |L4.18|
000012  2101              MOVS     r1,#1                 ;1977
000014  2068              MOVS     r0,#0x68              ;1977
000016  54c1              STRB     r1,[r0,r3]            ;1977
000018  bf00              NOP                            ;1977
00001a  2124              MOVS     r1,#0x24              ;1979
00001c  2069              MOVS     r0,#0x69              ;1979
00001e  54c1              STRB     r1,[r0,r3]            ;1979
000020  6818              LDR      r0,[r3,#0]            ;1982
000022  6800              LDR      r0,[r0,#0]            ;1982
000024  2101              MOVS     r1,#1                 ;1982
000026  0349              LSLS     r1,r1,#13             ;1982
000028  4388              BICS     r0,r0,r1              ;1982
00002a  6819              LDR      r1,[r3,#0]            ;1982
00002c  6008              STR      r0,[r1,#0]            ;1982
00002e  2120              MOVS     r1,#0x20              ;1984
000030  2069              MOVS     r0,#0x69              ;1984
000032  54c1              STRB     r1,[r0,r3]            ;1984
000034  4618              MOV      r0,r3                 ;1986
000036  f7fffffe          BL       UART_CheckIdleState
00003a  e7e9              B        |L4.16|
;;;1988   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnableMuteMode PROC
;;;1952     */
;;;1953   HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
000000  b500              PUSH     {lr}
;;;1954   {
000002  4603              MOV      r3,r0
;;;1955     /* Process Locked */
;;;1956     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  2068              MOVS     r0,#0x68
000008  5cc0              LDRB     r0,[r0,r3]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L5.18|
00000e  2002              MOVS     r0,#2
                  |L5.16|
;;;1957   
;;;1958     huart->gState = HAL_UART_STATE_BUSY;
;;;1959   
;;;1960     /* Enable USART mute mode by setting the MME bit in the CR1 register */
;;;1961     SET_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1962   
;;;1963     huart->gState = HAL_UART_STATE_READY;
;;;1964   
;;;1965     return (UART_CheckIdleState(huart));
;;;1966   }
000010  bd00              POP      {pc}
                  |L5.18|
000012  2101              MOVS     r1,#1                 ;1956
000014  2068              MOVS     r0,#0x68              ;1956
000016  54c1              STRB     r1,[r0,r3]            ;1956
000018  bf00              NOP                            ;1956
00001a  2124              MOVS     r1,#0x24              ;1958
00001c  2069              MOVS     r0,#0x69              ;1958
00001e  54c1              STRB     r1,[r0,r3]            ;1958
000020  6818              LDR      r0,[r3,#0]            ;1961
000022  6800              LDR      r0,[r0,#0]            ;1961
000024  2101              MOVS     r1,#1                 ;1961
000026  0349              LSLS     r1,r1,#13             ;1961
000028  4308              ORRS     r0,r0,r1              ;1961
00002a  6819              LDR      r1,[r3,#0]            ;1961
00002c  6008              STR      r0,[r1,#0]            ;1961
00002e  2120              MOVS     r1,#0x20              ;1963
000030  2069              MOVS     r0,#0x69              ;1963
000032  54c1              STRB     r1,[r0,r3]            ;1963
000034  4618              MOV      r0,r3                 ;1965
000036  f7fffffe          BL       UART_CheckIdleState
00003a  e7e9              B        |L5.16|
;;;1967   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1994     */
;;;1995   void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;1996   {
;;;1997     __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
000002  6989              LDR      r1,[r1,#0x18]
000004  2204              MOVS     r2,#4
000006  4311              ORRS     r1,r1,r2
000008  6802              LDR      r2,[r0,#0]
00000a  6191              STR      r1,[r2,#0x18]
;;;1998   }
00000c  4770              BX       lr
;;;1999   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;454      */
;;;455    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  b570              PUSH     {r4-r6,lr}
;;;456    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;457      /* Check the UART handle allocation */
;;;458      if(huart == NULL)
000008  2c00              CMP      r4,#0
00000a  d101              BNE      |L7.16|
;;;459      {
;;;460        return HAL_ERROR;
00000c  2001              MOVS     r0,#1
                  |L7.14|
;;;461      }
;;;462    
;;;463      /* Check the wake up method parameter */
;;;464      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;465    
;;;466      if(huart->gState == HAL_UART_STATE_RESET)
;;;467      {
;;;468        /* Allocate lock resource and initialize it */
;;;469        huart->Lock = HAL_UNLOCKED;
;;;470    
;;;471        /* Init the low level hardware : GPIO, CLOCK */
;;;472        HAL_UART_MspInit(huart);
;;;473      }
;;;474    
;;;475      huart->gState = HAL_UART_STATE_BUSY;
;;;476    
;;;477      /* Disable the Peripheral */
;;;478      __HAL_UART_DISABLE(huart);
;;;479    
;;;480      /* Set the UART Communication parameters */
;;;481      if (UART_SetConfig(huart) == HAL_ERROR)
;;;482      {
;;;483        return HAL_ERROR;
;;;484      }
;;;485    
;;;486      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;487      {
;;;488        UART_AdvFeatureConfig(huart);
;;;489      }
;;;490    
;;;491      /* In multiprocessor mode, the following bits must be kept cleared:
;;;492      - LINEN (if LIN is supported) and CLKEN bits in the USART_CR2 register,
;;;493      - SCEN (if Smartcard is supported), HDSEL and IREN (if IrDA is supported) bits in the USART_CR3 register. */
;;;494    #if defined (USART_CR2_LINEN)
;;;495      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;496    #else
;;;497      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;498    #endif
;;;499    #if defined (USART_CR3_SCEN)
;;;500    #if defined (USART_CR3_IREN)
;;;501      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;502    #else
;;;503      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL));
;;;504    #endif
;;;505    #else
;;;506    #if defined (USART_CR3_IREN)
;;;507      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN));
;;;508    #else
;;;509      CLEAR_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;510    #endif
;;;511    #endif
;;;512    
;;;513      if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
;;;514      {
;;;515        /* If address mark wake up method is chosen, set the USART address node */
;;;516        MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
;;;517      }
;;;518    
;;;519      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;520      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;521    
;;;522      /* Enable the Peripheral */
;;;523      __HAL_UART_ENABLE(huart);
;;;524    
;;;525      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;526      return (UART_CheckIdleState(huart));
;;;527    }
00000e  bd70              POP      {r4-r6,pc}
                  |L7.16|
000010  2069              MOVS     r0,#0x69              ;466
000012  5d00              LDRB     r0,[r0,r4]            ;466
000014  2800              CMP      r0,#0                 ;466
000016  d105              BNE      |L7.36|
000018  2100              MOVS     r1,#0                 ;469
00001a  2068              MOVS     r0,#0x68              ;469
00001c  5501              STRB     r1,[r0,r4]            ;469
00001e  4620              MOV      r0,r4                 ;472
000020  f7fffffe          BL       HAL_UART_MspInit
                  |L7.36|
000024  2124              MOVS     r1,#0x24              ;475
000026  2069              MOVS     r0,#0x69              ;475
000028  5501              STRB     r1,[r0,r4]            ;475
00002a  6820              LDR      r0,[r4,#0]            ;478
00002c  6800              LDR      r0,[r0,#0]            ;478
00002e  0840              LSRS     r0,r0,#1              ;478
000030  0040              LSLS     r0,r0,#1              ;478
000032  6821              LDR      r1,[r4,#0]            ;478
000034  6008              STR      r0,[r1,#0]            ;478
000036  4620              MOV      r0,r4                 ;481
000038  f7fffffe          BL       UART_SetConfig
00003c  2801              CMP      r0,#1                 ;481
00003e  d100              BNE      |L7.66|
000040  e7e5              B        |L7.14|
                  |L7.66|
000042  6a60              LDR      r0,[r4,#0x24]         ;486
000044  2800              CMP      r0,#0                 ;486
000046  d002              BEQ      |L7.78|
000048  4620              MOV      r0,r4                 ;488
00004a  f7fffffe          BL       UART_AdvFeatureConfig
                  |L7.78|
00004e  6820              LDR      r0,[r4,#0]            ;497
000050  6840              LDR      r0,[r0,#4]            ;497
000052  2101              MOVS     r1,#1                 ;497
000054  02c9              LSLS     r1,r1,#11             ;497
000056  4388              BICS     r0,r0,r1              ;497
000058  6821              LDR      r1,[r4,#0]            ;497
00005a  6048              STR      r0,[r1,#4]            ;497
00005c  6820              LDR      r0,[r4,#0]            ;509
00005e  6880              LDR      r0,[r0,#8]            ;509
000060  2108              MOVS     r1,#8                 ;509
000062  4388              BICS     r0,r0,r1              ;509
000064  6821              LDR      r1,[r4,#0]            ;509
000066  6088              STR      r0,[r1,#8]            ;509
000068  2001              MOVS     r0,#1                 ;513
00006a  02c0              LSLS     r0,r0,#11             ;513
00006c  4285              CMP      r5,r0                 ;513
00006e  d107              BNE      |L7.128|
000070  6820              LDR      r0,[r4,#0]            ;516
000072  6840              LDR      r0,[r0,#4]            ;516
000074  0200              LSLS     r0,r0,#8              ;516
000076  0a00              LSRS     r0,r0,#8              ;516
000078  0631              LSLS     r1,r6,#24             ;516
00007a  4308              ORRS     r0,r0,r1              ;516
00007c  6821              LDR      r1,[r4,#0]            ;516
00007e  6048              STR      r0,[r1,#4]            ;516
                  |L7.128|
000080  6820              LDR      r0,[r4,#0]            ;520
000082  6800              LDR      r0,[r0,#0]            ;520
000084  2101              MOVS     r1,#1                 ;520
000086  02c9              LSLS     r1,r1,#11             ;520
000088  4388              BICS     r0,r0,r1              ;520
00008a  4328              ORRS     r0,r0,r5              ;520
00008c  6821              LDR      r1,[r4,#0]            ;520
00008e  6008              STR      r0,[r1,#0]            ;520
000090  6820              LDR      r0,[r4,#0]            ;523
000092  6800              LDR      r0,[r0,#0]            ;523
000094  2101              MOVS     r1,#1                 ;523
000096  4308              ORRS     r0,r0,r1              ;523
000098  6821              LDR      r1,[r4,#0]            ;523
00009a  6008              STR      r0,[r1,#0]            ;523
00009c  4620              MOV      r0,r4                 ;526
00009e  f7fffffe          BL       UART_CheckIdleState
0000a2  e7b4              B        |L7.14|
;;;528    
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1245   */
;;;1246   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1247   {
000002  4604              MOV      r4,r0
;;;1248     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1249     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  21ff              MOVS     r1,#0xff
00000a  31e1              ADDS     r1,r1,#0xe1
00000c  4388              BICS     r0,r0,r1
00000e  6821              LDR      r1,[r4,#0]
000010  6008              STR      r0,[r1,#0]
;;;1250     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000012  6820              LDR      r0,[r4,#0]
000014  6880              LDR      r0,[r0,#8]
000016  0840              LSRS     r0,r0,#1
000018  0040              LSLS     r0,r0,#1
00001a  6821              LDR      r1,[r4,#0]
00001c  6088              STR      r0,[r1,#8]
;;;1251   
;;;1252     /* Disable the UART DMA Tx request if enabled */
;;;1253     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00001e  6820              LDR      r0,[r4,#0]
000020  6880              LDR      r0,[r0,#8]
000022  2180              MOVS     r1,#0x80
000024  4008              ANDS     r0,r0,r1
000026  2800              CMP      r0,#0
000028  d00d              BEQ      |L8.70|
;;;1254     {
;;;1255       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00002a  6820              LDR      r0,[r4,#0]
00002c  6880              LDR      r0,[r0,#8]
00002e  4388              BICS     r0,r0,r1
000030  6821              LDR      r1,[r4,#0]
000032  6088              STR      r0,[r1,#8]
;;;1256   
;;;1257       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1258       if(huart->hdmatx != NULL)
000034  6e20              LDR      r0,[r4,#0x60]
000036  2800              CMP      r0,#0
000038  d005              BEQ      |L8.70|
;;;1259       {
;;;1260         /* Set the UART DMA Abort callback to Null. 
;;;1261            No call back execution at end of DMA abort procedure */
;;;1262         huart->hdmatx->XferAbortCallback = NULL;
00003a  2000              MOVS     r0,#0
00003c  6e21              LDR      r1,[r4,#0x60]
00003e  6348              STR      r0,[r1,#0x34]
;;;1263   
;;;1264         HAL_DMA_Abort(huart->hdmatx);
000040  6e20              LDR      r0,[r4,#0x60]
000042  f7fffffe          BL       HAL_DMA_Abort
                  |L8.70|
;;;1265       }
;;;1266     }
;;;1267   
;;;1268     /* Disable the UART DMA Rx request if enabled */
;;;1269     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000046  6820              LDR      r0,[r4,#0]
000048  6880              LDR      r0,[r0,#8]
00004a  2140              MOVS     r1,#0x40
00004c  4008              ANDS     r0,r0,r1
00004e  2800              CMP      r0,#0
000050  d00d              BEQ      |L8.110|
;;;1270     {
;;;1271       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000052  6820              LDR      r0,[r4,#0]
000054  6880              LDR      r0,[r0,#8]
000056  4388              BICS     r0,r0,r1
000058  6821              LDR      r1,[r4,#0]
00005a  6088              STR      r0,[r1,#8]
;;;1272   
;;;1273       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1274       if(huart->hdmarx != NULL)
00005c  6e60              LDR      r0,[r4,#0x64]
00005e  2800              CMP      r0,#0
000060  d005              BEQ      |L8.110|
;;;1275       {
;;;1276         /* Set the UART DMA Abort callback to Null. 
;;;1277            No call back execution at end of DMA abort procedure */
;;;1278         huart->hdmarx->XferAbortCallback = NULL;
000062  2000              MOVS     r0,#0
000064  6e61              LDR      r1,[r4,#0x64]
000066  6348              STR      r0,[r1,#0x34]
;;;1279   
;;;1280         HAL_DMA_Abort(huart->hdmarx);
000068  6e60              LDR      r0,[r4,#0x64]
00006a  f7fffffe          BL       HAL_DMA_Abort
                  |L8.110|
;;;1281       }
;;;1282     }
;;;1283   
;;;1284     /* Reset Tx and Rx transfer counters */
;;;1285     huart->TxXferCount = 0U; 
00006e  2100              MOVS     r1,#0
000070  2052              MOVS     r0,#0x52
000072  5301              STRH     r1,[r0,r4]
;;;1286     huart->RxXferCount = 0U; 
000074  205a              MOVS     r0,#0x5a
000076  5301              STRH     r1,[r0,r4]
;;;1287   
;;;1288     /* Clear the Error flags in the ICR register */
;;;1289     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000078  200f              MOVS     r0,#0xf
00007a  6821              LDR      r1,[r4,#0]
00007c  6208              STR      r0,[r1,#0x20]
;;;1290   
;;;1291     /* Restore huart->gState and huart->RxState to Ready */
;;;1292     huart->gState  = HAL_UART_STATE_READY;
00007e  2120              MOVS     r1,#0x20
000080  2069              MOVS     r0,#0x69
000082  5501              STRB     r1,[r0,r4]
;;;1293     huart->RxState = HAL_UART_STATE_READY;
000084  206a              MOVS     r0,#0x6a
000086  5501              STRB     r1,[r0,r4]
;;;1294   
;;;1295     /* Reset Handle ErrorCode to No Error */
;;;1296     huart->ErrorCode = HAL_UART_ERROR_NONE;
000088  2000              MOVS     r0,#0
00008a  66e0              STR      r0,[r4,#0x6c]
;;;1297   
;;;1298     return HAL_OK;
;;;1299   }
00008c  bd10              POP      {r4,pc}
;;;1300   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;1884     */
;;;1885   __weak void HAL_UART_AbortCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1886   {
;;;1887     /* Prevent unused argument(s) compilation warning */
;;;1888     UNUSED(huart);
;;;1889   
;;;1890     /* NOTE : This function should not be modified, when the callback is needed,
;;;1891               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;1892      */
;;;1893   }
;;;1894   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1354   */
;;;1355   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1356   {
000002  4604              MOV      r4,r0
;;;1357     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1358     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  21ff              MOVS     r1,#0xff
00000a  3121              ADDS     r1,r1,#0x21
00000c  4388              BICS     r0,r0,r1
00000e  6821              LDR      r1,[r4,#0]
000010  6008              STR      r0,[r1,#0]
;;;1359     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000012  6820              LDR      r0,[r4,#0]
000014  6880              LDR      r0,[r0,#8]
000016  0840              LSRS     r0,r0,#1
000018  0040              LSLS     r0,r0,#1
00001a  6821              LDR      r1,[r4,#0]
00001c  6088              STR      r0,[r1,#8]
;;;1360   
;;;1361     /* Disable the UART DMA Rx request if enabled */
;;;1362     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00001e  6820              LDR      r0,[r4,#0]
000020  6880              LDR      r0,[r0,#8]
000022  2140              MOVS     r1,#0x40
000024  4008              ANDS     r0,r0,r1
000026  2800              CMP      r0,#0
000028  d00d              BEQ      |L10.70|
;;;1363     {
;;;1364       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00002a  6820              LDR      r0,[r4,#0]
00002c  6880              LDR      r0,[r0,#8]
00002e  4388              BICS     r0,r0,r1
000030  6821              LDR      r1,[r4,#0]
000032  6088              STR      r0,[r1,#8]
;;;1365   
;;;1366       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1367       if(huart->hdmarx != NULL)
000034  6e60              LDR      r0,[r4,#0x64]
000036  2800              CMP      r0,#0
000038  d005              BEQ      |L10.70|
;;;1368       {
;;;1369         /* Set the UART DMA Abort callback to Null. 
;;;1370            No call back execution at end of DMA abort procedure */
;;;1371         huart->hdmarx->XferAbortCallback = NULL;
00003a  2000              MOVS     r0,#0
00003c  6e61              LDR      r1,[r4,#0x64]
00003e  6348              STR      r0,[r1,#0x34]
;;;1372   
;;;1373         HAL_DMA_Abort(huart->hdmarx);
000040  6e60              LDR      r0,[r4,#0x64]
000042  f7fffffe          BL       HAL_DMA_Abort
                  |L10.70|
;;;1374       }
;;;1375     }
;;;1376   
;;;1377     /* Reset Rx transfer counter */
;;;1378     huart->RxXferCount = 0U; 
000046  2100              MOVS     r1,#0
000048  205a              MOVS     r0,#0x5a
00004a  5301              STRH     r1,[r0,r4]
;;;1379   
;;;1380     /* Clear the Error flags in the ICR register */
;;;1381     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
00004c  200f              MOVS     r0,#0xf
00004e  6821              LDR      r1,[r4,#0]
000050  6208              STR      r0,[r1,#0x20]
;;;1382   
;;;1383     /* Restore huart->RxState to Ready */
;;;1384     huart->RxState = HAL_UART_STATE_READY;
000052  2120              MOVS     r1,#0x20
000054  206a              MOVS     r0,#0x6a
000056  5501              STRB     r1,[r0,r4]
;;;1385   
;;;1386     return HAL_OK;
000058  2000              MOVS     r0,#0
;;;1387   }
00005a  bd10              POP      {r4,pc}
;;;1388   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;1914     */
;;;1915   __weak void HAL_UART_AbortReceiveCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1916   {
;;;1917     /* Prevent unused argument(s) compilation warning */
;;;1918     UNUSED(huart);
;;;1919   
;;;1920     /* NOTE : This function should not be modified, when the callback is needed,
;;;1921               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;1922      */
;;;1923   }
;;;1924   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;1592   */
;;;1593   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1594   {
000002  4604              MOV      r4,r0
;;;1595     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1596     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  21ff              MOVS     r1,#0xff
00000a  3121              ADDS     r1,r1,#0x21
00000c  4388              BICS     r0,r0,r1
00000e  6821              LDR      r1,[r4,#0]
000010  6008              STR      r0,[r1,#0]
;;;1597     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000012  6820              LDR      r0,[r4,#0]
000014  6880              LDR      r0,[r0,#8]
000016  0840              LSRS     r0,r0,#1
000018  0040              LSLS     r0,r0,#1
00001a  6821              LDR      r1,[r4,#0]
00001c  6088              STR      r0,[r1,#8]
;;;1598   
;;;1599     /* Disable the UART DMA Rx request if enabled */
;;;1600     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00001e  6820              LDR      r0,[r4,#0]
000020  6880              LDR      r0,[r0,#8]
000022  2140              MOVS     r1,#0x40
000024  4008              ANDS     r0,r0,r1
000026  2800              CMP      r0,#0
000028  d020              BEQ      |L12.108|
;;;1601     {
;;;1602       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00002a  6820              LDR      r0,[r4,#0]
00002c  6880              LDR      r0,[r0,#8]
00002e  4388              BICS     r0,r0,r1
000030  6821              LDR      r1,[r4,#0]
000032  6088              STR      r0,[r1,#8]
;;;1603   
;;;1604       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1605       if(huart->hdmarx != NULL)
000034  6e60              LDR      r0,[r4,#0x64]
000036  2800              CMP      r0,#0
000038  d00b              BEQ      |L12.82|
;;;1606       {
;;;1607         /* Set the UART DMA Abort callback : 
;;;1608            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1609         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
00003a  4813              LDR      r0,|L12.136|
00003c  6e61              LDR      r1,[r4,#0x64]
00003e  6348              STR      r0,[r1,#0x34]
;;;1610   
;;;1611         /* Abort DMA RX */
;;;1612         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
000040  6e60              LDR      r0,[r4,#0x64]
000042  f7fffffe          BL       HAL_DMA_Abort_IT
000046  2800              CMP      r0,#0
000048  d01c              BEQ      |L12.132|
;;;1613         {
;;;1614           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1615           huart->hdmarx->XferAbortCallback(huart->hdmarx);
00004a  6e60              LDR      r0,[r4,#0x64]
00004c  6b41              LDR      r1,[r0,#0x34]
00004e  4788              BLX      r1
000050  e018              B        |L12.132|
                  |L12.82|
;;;1616         }
;;;1617       }
;;;1618       else
;;;1619       {
;;;1620         /* Reset Rx transfer counter */
;;;1621         huart->RxXferCount = 0U; 
000052  2100              MOVS     r1,#0
000054  205a              MOVS     r0,#0x5a
000056  5301              STRH     r1,[r0,r4]
;;;1622   
;;;1623         /* Clear the Error flags in the ICR register */
;;;1624         __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000058  200f              MOVS     r0,#0xf
00005a  6821              LDR      r1,[r4,#0]
00005c  6208              STR      r0,[r1,#0x20]
;;;1625   
;;;1626         /* Restore huart->RxState to Ready */
;;;1627         huart->RxState = HAL_UART_STATE_READY;
00005e  2120              MOVS     r1,#0x20
000060  206a              MOVS     r0,#0x6a
000062  5501              STRB     r1,[r0,r4]
;;;1628   
;;;1629         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1630         HAL_UART_AbortReceiveCpltCallback(huart);
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
00006a  e00b              B        |L12.132|
                  |L12.108|
;;;1631       }
;;;1632     }
;;;1633     else
;;;1634     {
;;;1635       /* Reset Rx transfer counter */
;;;1636       huart->RxXferCount = 0U; 
00006c  2100              MOVS     r1,#0
00006e  205a              MOVS     r0,#0x5a
000070  5301              STRH     r1,[r0,r4]
;;;1637   
;;;1638       /* Clear the Error flags in the ICR register */
;;;1639       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
000072  200f              MOVS     r0,#0xf
000074  6821              LDR      r1,[r4,#0]
000076  6208              STR      r0,[r1,#0x20]
;;;1640   
;;;1641       /* Restore huart->RxState to Ready */
;;;1642       huart->RxState = HAL_UART_STATE_READY;
000078  2120              MOVS     r1,#0x20
00007a  206a              MOVS     r0,#0x6a
00007c  5501              STRB     r1,[r0,r4]
;;;1643   
;;;1644       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1645       HAL_UART_AbortReceiveCpltCallback(huart);
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L12.132|
;;;1646     }
;;;1647   
;;;1648     return HAL_OK;
000084  2000              MOVS     r0,#0
;;;1649   }
000086  bd10              POP      {r4,pc}
;;;1650   
                          ENDP

                  |L12.136|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1312   */
;;;1313   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1314   {
000002  4604              MOV      r4,r0
;;;1315     /* Disable TXEIE and TCIE interrupts */
;;;1316     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  21c0              MOVS     r1,#0xc0
00000a  4388              BICS     r0,r0,r1
00000c  6821              LDR      r1,[r4,#0]
00000e  6008              STR      r0,[r1,#0]
;;;1317   
;;;1318     /* Disable the UART DMA Tx request if enabled */
;;;1319     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000010  6820              LDR      r0,[r4,#0]
000012  6880              LDR      r0,[r0,#8]
000014  2180              MOVS     r1,#0x80
000016  4008              ANDS     r0,r0,r1
000018  2800              CMP      r0,#0
00001a  d00d              BEQ      |L13.56|
;;;1320     {
;;;1321       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001c  6820              LDR      r0,[r4,#0]
00001e  6880              LDR      r0,[r0,#8]
000020  4388              BICS     r0,r0,r1
000022  6821              LDR      r1,[r4,#0]
000024  6088              STR      r0,[r1,#8]
;;;1322   
;;;1323       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1324       if(huart->hdmatx != NULL)
000026  6e20              LDR      r0,[r4,#0x60]
000028  2800              CMP      r0,#0
00002a  d005              BEQ      |L13.56|
;;;1325       {
;;;1326         /* Set the UART DMA Abort callback to Null. 
;;;1327            No call back execution at end of DMA abort procedure */
;;;1328         huart->hdmatx->XferAbortCallback = NULL;
00002c  2000              MOVS     r0,#0
00002e  6e21              LDR      r1,[r4,#0x60]
000030  6348              STR      r0,[r1,#0x34]
;;;1329   
;;;1330         HAL_DMA_Abort(huart->hdmatx);
000032  6e20              LDR      r0,[r4,#0x60]
000034  f7fffffe          BL       HAL_DMA_Abort
                  |L13.56|
;;;1331       }
;;;1332     }
;;;1333   
;;;1334     /* Reset Tx transfer counter */
;;;1335     huart->TxXferCount = 0U; 
000038  2100              MOVS     r1,#0
00003a  2052              MOVS     r0,#0x52
00003c  5301              STRH     r1,[r0,r4]
;;;1336   
;;;1337     /* Restore huart->gState to Ready */
;;;1338     huart->gState = HAL_UART_STATE_READY;
00003e  2120              MOVS     r1,#0x20
000040  2069              MOVS     r0,#0x69
000042  5501              STRB     r1,[r0,r4]
;;;1339   
;;;1340     return HAL_OK;
000044  2000              MOVS     r0,#0
;;;1341   }
000046  bd10              POP      {r4,pc}
;;;1342   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;1899     */
;;;1900   __weak void HAL_UART_AbortTransmitCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1901   {
;;;1902     /* Prevent unused argument(s) compilation warning */
;;;1903     UNUSED(huart);
;;;1904   
;;;1905     /* NOTE : This function should not be modified, when the callback is needed,
;;;1906               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;1907      */
;;;1908   }
;;;1909   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;1527   */
;;;1528   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1529   {
000002  4604              MOV      r4,r0
;;;1530     /* Disable TXEIE and TCIE interrupts */
;;;1531     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  21c0              MOVS     r1,#0xc0
00000a  4388              BICS     r0,r0,r1
00000c  6821              LDR      r1,[r4,#0]
00000e  6008              STR      r0,[r1,#0]
;;;1532   
;;;1533     /* Disable the UART DMA Tx request if enabled */
;;;1534     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000010  6820              LDR      r0,[r4,#0]
000012  6880              LDR      r0,[r0,#8]
000014  2180              MOVS     r1,#0x80
000016  4008              ANDS     r0,r0,r1
000018  2800              CMP      r0,#0
00001a  d01d              BEQ      |L15.88|
;;;1535     {
;;;1536       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001c  6820              LDR      r0,[r4,#0]
00001e  6880              LDR      r0,[r0,#8]
000020  4388              BICS     r0,r0,r1
000022  6821              LDR      r1,[r4,#0]
000024  6088              STR      r0,[r1,#8]
;;;1537   
;;;1538       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1539       if(huart->hdmatx != NULL)
000026  6e20              LDR      r0,[r4,#0x60]
000028  2800              CMP      r0,#0
00002a  d00b              BEQ      |L15.68|
;;;1540       {
;;;1541         /* Set the UART DMA Abort callback : 
;;;1542            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1543         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
00002c  4810              LDR      r0,|L15.112|
00002e  6e21              LDR      r1,[r4,#0x60]
000030  6348              STR      r0,[r1,#0x34]
;;;1544   
;;;1545         /* Abort DMA TX */
;;;1546         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
000032  6e20              LDR      r0,[r4,#0x60]
000034  f7fffffe          BL       HAL_DMA_Abort_IT
000038  2800              CMP      r0,#0
00003a  d016              BEQ      |L15.106|
;;;1547         {
;;;1548           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;1549           huart->hdmatx->XferAbortCallback(huart->hdmatx);
00003c  6e20              LDR      r0,[r4,#0x60]
00003e  6b41              LDR      r1,[r0,#0x34]
000040  4788              BLX      r1
000042  e012              B        |L15.106|
                  |L15.68|
;;;1550         }
;;;1551       }
;;;1552       else
;;;1553       {
;;;1554         /* Reset Tx transfer counter */
;;;1555         huart->TxXferCount = 0U; 
000044  2100              MOVS     r1,#0
000046  2052              MOVS     r0,#0x52
000048  5301              STRH     r1,[r0,r4]
;;;1556   
;;;1557         /* Restore huart->gState to Ready */
;;;1558         huart->gState = HAL_UART_STATE_READY;
00004a  2120              MOVS     r1,#0x20
00004c  2069              MOVS     r0,#0x69
00004e  5501              STRB     r1,[r0,r4]
;;;1559   
;;;1560         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1561         HAL_UART_AbortTransmitCpltCallback(huart);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
000056  e008              B        |L15.106|
                  |L15.88|
;;;1562       }
;;;1563     }
;;;1564     else
;;;1565     {
;;;1566       /* Reset Tx transfer counter */
;;;1567       huart->TxXferCount = 0U; 
000058  2100              MOVS     r1,#0
00005a  2052              MOVS     r0,#0x52
00005c  5301              STRH     r1,[r0,r4]
;;;1568   
;;;1569       /* Restore huart->gState to Ready */
;;;1570       huart->gState = HAL_UART_STATE_READY;
00005e  2120              MOVS     r1,#0x20
000060  2069              MOVS     r0,#0x69
000062  5501              STRB     r1,[r0,r4]
;;;1571   
;;;1572       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1573       HAL_UART_AbortTransmitCpltCallback(huart);
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L15.106|
;;;1574     }
;;;1575   
;;;1576     return HAL_OK;
00006a  2000              MOVS     r0,#0
;;;1577   }
00006c  bd10              POP      {r4,pc}
;;;1578   
                          ENDP

00006e  0000              DCW      0x0000
                  |L15.112|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1402   */
;;;1403   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1404   {
000002  4604              MOV      r4,r0
;;;1405     uint32_t abortcplt = 1U;
000004  2501              MOVS     r5,#1
;;;1406     
;;;1407     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1408     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000006  6820              LDR      r0,[r4,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  21ff              MOVS     r1,#0xff
00000c  31e1              ADDS     r1,r1,#0xe1
00000e  4388              BICS     r0,r0,r1
000010  6821              LDR      r1,[r4,#0]
000012  6008              STR      r0,[r1,#0]
;;;1409     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000014  6820              LDR      r0,[r4,#0]
000016  6880              LDR      r0,[r0,#8]
000018  43a8              BICS     r0,r0,r5
00001a  6821              LDR      r1,[r4,#0]
00001c  6088              STR      r0,[r1,#8]
;;;1410   
;;;1411     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1412        before any call to DMA Abort functions */
;;;1413     /* DMA Tx Handle is valid */
;;;1414     if(huart->hdmatx != NULL)
00001e  6e20              LDR      r0,[r4,#0x60]
000020  2800              CMP      r0,#0
000022  d00c              BEQ      |L16.62|
;;;1415     {
;;;1416       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1417          Otherwise, set it to NULL */
;;;1418       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000024  6820              LDR      r0,[r4,#0]
000026  6880              LDR      r0,[r0,#8]
000028  2180              MOVS     r1,#0x80
00002a  4008              ANDS     r0,r0,r1
00002c  2800              CMP      r0,#0
00002e  d003              BEQ      |L16.56|
;;;1419       {
;;;1420         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
000030  482e              LDR      r0,|L16.236|
000032  6e21              LDR      r1,[r4,#0x60]
000034  6348              STR      r0,[r1,#0x34]
000036  e002              B        |L16.62|
                  |L16.56|
;;;1421       }
;;;1422       else
;;;1423       {
;;;1424         huart->hdmatx->XferAbortCallback = NULL;
000038  2000              MOVS     r0,#0
00003a  6e21              LDR      r1,[r4,#0x60]
00003c  6348              STR      r0,[r1,#0x34]
                  |L16.62|
;;;1425       }
;;;1426     }
;;;1427     /* DMA Rx Handle is valid */
;;;1428     if(huart->hdmarx != NULL)
00003e  6e60              LDR      r0,[r4,#0x64]
000040  2800              CMP      r0,#0
000042  d00c              BEQ      |L16.94|
;;;1429     {
;;;1430       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1431          Otherwise, set it to NULL */
;;;1432       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000044  6820              LDR      r0,[r4,#0]
000046  6880              LDR      r0,[r0,#8]
000048  2140              MOVS     r1,#0x40
00004a  4008              ANDS     r0,r0,r1
00004c  2800              CMP      r0,#0
00004e  d003              BEQ      |L16.88|
;;;1433       {
;;;1434         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
000050  4827              LDR      r0,|L16.240|
000052  6e61              LDR      r1,[r4,#0x64]
000054  6348              STR      r0,[r1,#0x34]
000056  e002              B        |L16.94|
                  |L16.88|
;;;1435       }
;;;1436       else
;;;1437       {
;;;1438         huart->hdmarx->XferAbortCallback = NULL;
000058  2000              MOVS     r0,#0
00005a  6e61              LDR      r1,[r4,#0x64]
00005c  6348              STR      r0,[r1,#0x34]
                  |L16.94|
;;;1439       }
;;;1440     }
;;;1441     
;;;1442     /* Disable the UART DMA Tx request if enabled */
;;;1443     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00005e  6820              LDR      r0,[r4,#0]
000060  6880              LDR      r0,[r0,#8]
000062  2180              MOVS     r1,#0x80
000064  4008              ANDS     r0,r0,r1
000066  2800              CMP      r0,#0
000068  d011              BEQ      |L16.142|
;;;1444     {
;;;1445       /* Disable DMA Tx at UART level */
;;;1446       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00006a  6820              LDR      r0,[r4,#0]
00006c  6880              LDR      r0,[r0,#8]
00006e  4388              BICS     r0,r0,r1
000070  6821              LDR      r1,[r4,#0]
000072  6088              STR      r0,[r1,#8]
;;;1447   
;;;1448       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1449       if(huart->hdmatx != NULL)
000074  6e20              LDR      r0,[r4,#0x60]
000076  2800              CMP      r0,#0
000078  d009              BEQ      |L16.142|
;;;1450       {
;;;1451         /* UART Tx DMA Abort callback has already been initialised : 
;;;1452            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1453   
;;;1454         /* Abort DMA TX */
;;;1455         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
00007a  6e20              LDR      r0,[r4,#0x60]
00007c  f7fffffe          BL       HAL_DMA_Abort_IT
000080  2800              CMP      r0,#0
000082  d003              BEQ      |L16.140|
;;;1456         {
;;;1457           huart->hdmatx->XferAbortCallback = NULL;
000084  2000              MOVS     r0,#0
000086  6e21              LDR      r1,[r4,#0x60]
000088  6348              STR      r0,[r1,#0x34]
00008a  e000              B        |L16.142|
                  |L16.140|
;;;1458         }
;;;1459         else
;;;1460         {
;;;1461           abortcplt = 0U;
00008c  2500              MOVS     r5,#0
                  |L16.142|
;;;1462         }
;;;1463       }
;;;1464     }
;;;1465   
;;;1466     /* Disable the UART DMA Rx request if enabled */
;;;1467     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00008e  6820              LDR      r0,[r4,#0]
000090  6880              LDR      r0,[r0,#8]
000092  2140              MOVS     r1,#0x40
000094  4008              ANDS     r0,r0,r1
000096  2800              CMP      r0,#0
000098  d012              BEQ      |L16.192|
;;;1468     {
;;;1469       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00009a  6820              LDR      r0,[r4,#0]
00009c  6880              LDR      r0,[r0,#8]
00009e  4388              BICS     r0,r0,r1
0000a0  6821              LDR      r1,[r4,#0]
0000a2  6088              STR      r0,[r1,#8]
;;;1470   
;;;1471       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1472       if(huart->hdmarx != NULL)
0000a4  6e60              LDR      r0,[r4,#0x64]
0000a6  2800              CMP      r0,#0
0000a8  d00a              BEQ      |L16.192|
;;;1473       {
;;;1474         /* UART Rx DMA Abort callback has already been initialised : 
;;;1475            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1476   
;;;1477         /* Abort DMA RX */
;;;1478         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
0000aa  6e60              LDR      r0,[r4,#0x64]
0000ac  f7fffffe          BL       HAL_DMA_Abort_IT
0000b0  2800              CMP      r0,#0
0000b2  d004              BEQ      |L16.190|
;;;1479         {
;;;1480           huart->hdmarx->XferAbortCallback = NULL;
0000b4  2000              MOVS     r0,#0
0000b6  6e61              LDR      r1,[r4,#0x64]
0000b8  6348              STR      r0,[r1,#0x34]
;;;1481           abortcplt = 1U;
0000ba  2501              MOVS     r5,#1
0000bc  e000              B        |L16.192|
                  |L16.190|
;;;1482         }
;;;1483         else
;;;1484         {
;;;1485           abortcplt = 0U;
0000be  2500              MOVS     r5,#0
                  |L16.192|
;;;1486         }
;;;1487       }
;;;1488     }
;;;1489   
;;;1490     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1491     if (abortcplt == 1U)
0000c0  2d01              CMP      r5,#1
0000c2  d111              BNE      |L16.232|
;;;1492     {
;;;1493       /* Reset Tx and Rx transfer counters */
;;;1494       huart->TxXferCount = 0U; 
0000c4  2100              MOVS     r1,#0
0000c6  2052              MOVS     r0,#0x52
0000c8  5301              STRH     r1,[r0,r4]
;;;1495       huart->RxXferCount = 0U;
0000ca  205a              MOVS     r0,#0x5a
0000cc  5301              STRH     r1,[r0,r4]
;;;1496   
;;;1497       /* Reset errorCode */
;;;1498       huart->ErrorCode = HAL_UART_ERROR_NONE;
0000ce  2000              MOVS     r0,#0
0000d0  66e0              STR      r0,[r4,#0x6c]
;;;1499   
;;;1500       /* Clear the Error flags in the ICR register */
;;;1501       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
0000d2  200f              MOVS     r0,#0xf
0000d4  6821              LDR      r1,[r4,#0]
0000d6  6208              STR      r0,[r1,#0x20]
;;;1502   
;;;1503       /* Restore huart->gState and huart->RxState to Ready */
;;;1504       huart->gState  = HAL_UART_STATE_READY;
0000d8  2120              MOVS     r1,#0x20
0000da  2069              MOVS     r0,#0x69
0000dc  5501              STRB     r1,[r0,r4]
;;;1505       huart->RxState = HAL_UART_STATE_READY;
0000de  206a              MOVS     r0,#0x6a
0000e0  5501              STRB     r1,[r0,r4]
;;;1506   
;;;1507       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1508       HAL_UART_AbortCpltCallback(huart);
0000e2  4620              MOV      r0,r4
0000e4  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L16.232|
;;;1509     }
;;;1510   
;;;1511     return HAL_OK;
0000e8  2000              MOVS     r0,#0
;;;1512   }
0000ea  bd70              POP      {r4-r6,pc}
;;;1513   
                          ENDP

                  |L16.236|
                          DCD      UART_DMATxAbortCallback
                  |L16.240|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1124     */
;;;1125   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1126   {
;;;1127     /* Process Locked */
;;;1128     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  2068              MOVS     r0,#0x68
000006  5c40              LDRB     r0,[r0,r1]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L17.16|
00000c  2002              MOVS     r0,#2
                  |L17.14|
;;;1129   
;;;1130     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
;;;1131         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
;;;1132     {
;;;1133       /* Disable the UART DMA Tx request */
;;;1134       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1135     }
;;;1136     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
;;;1137         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1138     {
;;;1139       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1140       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1141       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1142   
;;;1143       /* Disable the UART DMA Rx request */
;;;1144       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1145     }
;;;1146   
;;;1147     /* Process Unlocked */
;;;1148     __HAL_UNLOCK(huart);
;;;1149   
;;;1150     return HAL_OK;
;;;1151   }
00000e  4770              BX       lr
                  |L17.16|
000010  2201              MOVS     r2,#1                 ;1128
000012  2068              MOVS     r0,#0x68              ;1128
000014  5442              STRB     r2,[r0,r1]            ;1128
000016  bf00              NOP                            ;1128
000018  2069              MOVS     r0,#0x69              ;1130
00001a  5c40              LDRB     r0,[r0,r1]            ;1130
00001c  2821              CMP      r0,#0x21              ;1130
00001e  d10a              BNE      |L17.54|
000020  6808              LDR      r0,[r1,#0]            ;1131
000022  6880              LDR      r0,[r0,#8]            ;1131
000024  2280              MOVS     r2,#0x80              ;1131
000026  4010              ANDS     r0,r0,r2              ;1131
000028  2800              CMP      r0,#0                 ;1131
00002a  d004              BEQ      |L17.54|
00002c  6808              LDR      r0,[r1,#0]            ;1134
00002e  6880              LDR      r0,[r0,#8]            ;1134
000030  4390              BICS     r0,r0,r2              ;1134
000032  680a              LDR      r2,[r1,#0]            ;1134
000034  6090              STR      r0,[r2,#8]            ;1134
                  |L17.54|
000036  206a              MOVS     r0,#0x6a              ;1136
000038  5c40              LDRB     r0,[r0,r1]            ;1136
00003a  2822              CMP      r0,#0x22              ;1136
00003c  d117              BNE      |L17.110|
00003e  6808              LDR      r0,[r1,#0]            ;1137
000040  6880              LDR      r0,[r0,#8]            ;1137
000042  2240              MOVS     r2,#0x40              ;1137
000044  4010              ANDS     r0,r0,r2              ;1137
000046  2800              CMP      r0,#0                 ;1137
000048  d011              BEQ      |L17.110|
00004a  6808              LDR      r0,[r1,#0]            ;1140
00004c  6800              LDR      r0,[r0,#0]            ;1140
00004e  0092              LSLS     r2,r2,#2              ;1140
000050  4390              BICS     r0,r0,r2              ;1140
000052  680a              LDR      r2,[r1,#0]            ;1140
000054  6010              STR      r0,[r2,#0]            ;1140
000056  6808              LDR      r0,[r1,#0]            ;1141
000058  6880              LDR      r0,[r0,#8]            ;1141
00005a  0840              LSRS     r0,r0,#1              ;1141
00005c  0040              LSLS     r0,r0,#1              ;1141
00005e  680a              LDR      r2,[r1,#0]            ;1141
000060  6090              STR      r0,[r2,#8]            ;1141
000062  6808              LDR      r0,[r1,#0]            ;1144
000064  6880              LDR      r0,[r0,#8]            ;1144
000066  2240              MOVS     r2,#0x40              ;1144
000068  4390              BICS     r0,r0,r2              ;1144
00006a  680a              LDR      r2,[r1,#0]            ;1144
00006c  6090              STR      r0,[r2,#8]            ;1144
                  |L17.110|
00006e  bf00              NOP                            ;1148
000070  2200              MOVS     r2,#0                 ;1148
000072  2068              MOVS     r0,#0x68              ;1148
000074  5442              STRB     r2,[r0,r1]            ;1148
000076  bf00              NOP                            ;1148
000078  2000              MOVS     r0,#0                 ;1150
00007a  e7c8              B        |L17.14|
;;;1152   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1157     */
;;;1158   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1159   {
;;;1160     /* Process Locked */
;;;1161     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  2068              MOVS     r0,#0x68
000006  5c40              LDRB     r0,[r0,r1]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L18.16|
00000c  2002              MOVS     r0,#2
                  |L18.14|
;;;1162   
;;;1163     if(huart->gState == HAL_UART_STATE_BUSY_TX)
;;;1164     {
;;;1165       /* Enable the UART DMA Tx request */
;;;1166       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1167     }
;;;1168     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1169     {
;;;1170       /* Clear the Overrun flag before resuming the Rx transfer */
;;;1171       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
;;;1172   
;;;1173       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1174       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1175       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1176   
;;;1177       /* Enable the UART DMA Rx request */
;;;1178       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1179     }
;;;1180   
;;;1181     /* Process Unlocked */
;;;1182     __HAL_UNLOCK(huart);
;;;1183   
;;;1184     return HAL_OK;
;;;1185   }
00000e  4770              BX       lr
                  |L18.16|
000010  2201              MOVS     r2,#1                 ;1161
000012  2068              MOVS     r0,#0x68              ;1161
000014  5442              STRB     r2,[r0,r1]            ;1161
000016  bf00              NOP                            ;1161
000018  2069              MOVS     r0,#0x69              ;1163
00001a  5c40              LDRB     r0,[r0,r1]            ;1163
00001c  2821              CMP      r0,#0x21              ;1163
00001e  d105              BNE      |L18.44|
000020  6808              LDR      r0,[r1,#0]            ;1166
000022  6880              LDR      r0,[r0,#8]            ;1166
000024  2280              MOVS     r2,#0x80              ;1166
000026  4310              ORRS     r0,r0,r2              ;1166
000028  680a              LDR      r2,[r1,#0]            ;1166
00002a  6090              STR      r0,[r2,#8]            ;1166
                  |L18.44|
00002c  206a              MOVS     r0,#0x6a              ;1168
00002e  5c40              LDRB     r0,[r0,r1]            ;1168
000030  2822              CMP      r0,#0x22              ;1168
000032  d115              BNE      |L18.96|
000034  2008              MOVS     r0,#8                 ;1171
000036  680a              LDR      r2,[r1,#0]            ;1171
000038  6210              STR      r0,[r2,#0x20]         ;1171
00003a  6808              LDR      r0,[r1,#0]            ;1174
00003c  6800              LDR      r0,[r0,#0]            ;1174
00003e  22ff              MOVS     r2,#0xff              ;1174
000040  3201              ADDS     r2,#1                 ;1174
000042  4310              ORRS     r0,r0,r2              ;1174
000044  680a              LDR      r2,[r1,#0]            ;1174
000046  6010              STR      r0,[r2,#0]            ;1174
000048  6808              LDR      r0,[r1,#0]            ;1175
00004a  6880              LDR      r0,[r0,#8]            ;1175
00004c  2201              MOVS     r2,#1                 ;1175
00004e  4310              ORRS     r0,r0,r2              ;1175
000050  680a              LDR      r2,[r1,#0]            ;1175
000052  6090              STR      r0,[r2,#8]            ;1175
000054  6808              LDR      r0,[r1,#0]            ;1178
000056  6880              LDR      r0,[r0,#8]            ;1178
000058  2240              MOVS     r2,#0x40              ;1178
00005a  4310              ORRS     r0,r0,r2              ;1178
00005c  680a              LDR      r2,[r1,#0]            ;1178
00005e  6090              STR      r0,[r2,#8]            ;1178
                  |L18.96|
000060  bf00              NOP                            ;1182
000062  2200              MOVS     r2,#0                 ;1182
000064  2068              MOVS     r0,#0x68              ;1182
000066  5442              STRB     r2,[r0,r1]            ;1182
000068  bf00              NOP                            ;1182
00006a  2000              MOVS     r0,#0                 ;1184
00006c  e7cf              B        |L18.14|
;;;1186   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1191     */
;;;1192   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1193   {
000002  4604              MOV      r4,r0
;;;1194     /* The Lock is not implemented on this API to allow the user application
;;;1195        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
;;;1196        HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback: 
;;;1197        indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete  
;;;1198        interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of 
;;;1199        the stream and the corresponding call back is executed. */
;;;1200   
;;;1201     /* Stop UART DMA Tx request if ongoing */
;;;1202     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
000004  2069              MOVS     r0,#0x69
000006  5d00              LDRB     r0,[r0,r4]
000008  2821              CMP      r0,#0x21
00000a  d113              BNE      |L19.52|
;;;1203         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
00000c  6820              LDR      r0,[r4,#0]
00000e  6880              LDR      r0,[r0,#8]
000010  2180              MOVS     r1,#0x80
000012  4008              ANDS     r0,r0,r1
000014  2800              CMP      r0,#0
000016  d00d              BEQ      |L19.52|
;;;1204     {
;;;1205       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000018  6820              LDR      r0,[r4,#0]
00001a  6880              LDR      r0,[r0,#8]
00001c  4388              BICS     r0,r0,r1
00001e  6821              LDR      r1,[r4,#0]
000020  6088              STR      r0,[r1,#8]
;;;1206   
;;;1207       /* Abort the UART DMA Tx channel */
;;;1208       if(huart->hdmatx != NULL)
000022  6e20              LDR      r0,[r4,#0x60]
000024  2800              CMP      r0,#0
000026  d002              BEQ      |L19.46|
;;;1209       {
;;;1210         HAL_DMA_Abort(huart->hdmatx);
000028  6e20              LDR      r0,[r4,#0x60]
00002a  f7fffffe          BL       HAL_DMA_Abort
                  |L19.46|
;;;1211       }
;;;1212   
;;;1213       UART_EndTxTransfer(huart);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       UART_EndTxTransfer
                  |L19.52|
;;;1214     }
;;;1215   
;;;1216     /* Stop UART DMA Rx request if ongoing */
;;;1217     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
000034  206a              MOVS     r0,#0x6a
000036  5d00              LDRB     r0,[r0,r4]
000038  2822              CMP      r0,#0x22
00003a  d113              BNE      |L19.100|
;;;1218         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
00003c  6820              LDR      r0,[r4,#0]
00003e  6880              LDR      r0,[r0,#8]
000040  2140              MOVS     r1,#0x40
000042  4008              ANDS     r0,r0,r1
000044  2800              CMP      r0,#0
000046  d00d              BEQ      |L19.100|
;;;1219     {
;;;1220       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000048  6820              LDR      r0,[r4,#0]
00004a  6880              LDR      r0,[r0,#8]
00004c  4388              BICS     r0,r0,r1
00004e  6821              LDR      r1,[r4,#0]
000050  6088              STR      r0,[r1,#8]
;;;1221   
;;;1222       /* Abort the UART DMA Rx channel */
;;;1223       if(huart->hdmarx != NULL)
000052  6e60              LDR      r0,[r4,#0x64]
000054  2800              CMP      r0,#0
000056  d002              BEQ      |L19.94|
;;;1224       {
;;;1225         HAL_DMA_Abort(huart->hdmarx);
000058  6e60              LDR      r0,[r4,#0x64]
00005a  f7fffffe          BL       HAL_DMA_Abort
                  |L19.94|
;;;1226       }
;;;1227   
;;;1228       UART_EndRxTransfer(huart);
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       UART_EndRxTransfer
                  |L19.100|
;;;1229     }
;;;1230   
;;;1231     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;1232   }
000066  bd10              POP      {r4,pc}
;;;1233   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;534      */
;;;535    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;536    {
000002  4604              MOV      r4,r0
;;;537      /* Check the UART handle allocation */
;;;538      if(huart == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L20.12|
;;;539      {
;;;540        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L20.10|
;;;541      }
;;;542    
;;;543      /* Check the parameters */
;;;544      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;545    
;;;546      huart->gState = HAL_UART_STATE_BUSY;
;;;547    
;;;548      /* Disable the Peripheral */
;;;549      __HAL_UART_DISABLE(huart);
;;;550    
;;;551      huart->Instance->CR1 = 0x0U;
;;;552      huart->Instance->CR2 = 0x0U;
;;;553      huart->Instance->CR3 = 0x0U;
;;;554    
;;;555      /* DeInit the low level hardware */
;;;556      HAL_UART_MspDeInit(huart);
;;;557    
;;;558      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;559      huart->gState    = HAL_UART_STATE_RESET;
;;;560      huart->RxState   = HAL_UART_STATE_RESET;
;;;561    
;;;562      /* Process Unlock */
;;;563      __HAL_UNLOCK(huart);
;;;564    
;;;565      return HAL_OK;
;;;566    }
00000a  bd10              POP      {r4,pc}
                  |L20.12|
00000c  2124              MOVS     r1,#0x24              ;546
00000e  2069              MOVS     r0,#0x69              ;546
000010  5501              STRB     r1,[r0,r4]            ;546
000012  6820              LDR      r0,[r4,#0]            ;549
000014  6800              LDR      r0,[r0,#0]            ;549
000016  0840              LSRS     r0,r0,#1              ;549
000018  0040              LSLS     r0,r0,#1              ;549
00001a  6821              LDR      r1,[r4,#0]            ;549
00001c  6008              STR      r0,[r1,#0]            ;549
00001e  2000              MOVS     r0,#0                 ;551
000020  6821              LDR      r1,[r4,#0]            ;551
000022  6008              STR      r0,[r1,#0]            ;551
000024  6821              LDR      r1,[r4,#0]            ;552
000026  6048              STR      r0,[r1,#4]            ;552
000028  6821              LDR      r1,[r4,#0]            ;553
00002a  6088              STR      r0,[r1,#8]            ;553
00002c  4620              MOV      r0,r4                 ;556
00002e  f7fffffe          BL       HAL_UART_MspDeInit
000032  2000              MOVS     r0,#0                 ;558
000034  66e0              STR      r0,[r4,#0x6c]         ;558
000036  2100              MOVS     r1,#0                 ;559
000038  2069              MOVS     r0,#0x69              ;559
00003a  5501              STRB     r1,[r0,r4]            ;559
00003c  206a              MOVS     r0,#0x6a              ;560
00003e  5501              STRB     r1,[r0,r4]            ;560
000040  bf00              NOP                            ;563
000042  2068              MOVS     r0,#0x68              ;563
000044  5501              STRB     r1,[r0,r4]            ;563
000046  bf00              NOP                            ;563
000048  2000              MOVS     r0,#0                 ;565
00004a  e7de              B        |L20.10|
;;;567    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1869     */
;;;1870   __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1871   {
;;;1872     /* Prevent unused argument(s) compilation warning */
;;;1873     UNUSED(huart);
;;;1874   
;;;1875     /* NOTE : This function should not be modified, when the callback is needed,
;;;1876               the HAL_UART_ErrorCallback can be implemented in the user file.
;;;1877      */
;;;1878   }
;;;1879   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2087     */
;;;2088   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2089   {
;;;2090     return huart->ErrorCode;
000002  6ec8              LDR      r0,[r1,#0x6c]
;;;2091   }
000004  4770              BX       lr
;;;2092   /**
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;2072     */
;;;2073   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2074   {
;;;2075     uint32_t temp1= 0x00U, temp2 = 0x00U;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
;;;2076     temp1 = huart->gState;
000006  2069              MOVS     r0,#0x69
000008  5c42              LDRB     r2,[r0,r1]
;;;2077     temp2 = huart->RxState;
00000a  206a              MOVS     r0,#0x6a
00000c  5c43              LDRB     r3,[r0,r1]
;;;2078   
;;;2079     return (HAL_UART_StateTypeDef)(temp1 | temp2);
00000e  4610              MOV      r0,r2
000010  4318              ORRS     r0,r0,r3
;;;2080   }
000012  4770              BX       lr
;;;2081   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1655     */
;;;1656   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1657   {
000002  4604              MOV      r4,r0
;;;1658     uint32_t isrflags   = READ_REG(huart->Instance->ISR);
000004  6820              LDR      r0,[r4,#0]
000006  69c5              LDR      r5,[r0,#0x1c]
;;;1659     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
000008  6820              LDR      r0,[r4,#0]
00000a  6806              LDR      r6,[r0,#0]
;;;1660     uint32_t cr3its;
;;;1661     uint32_t errorflags;
;;;1662   
;;;1663     /* If no error occurs */
;;;1664     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
00000c  0728              LSLS     r0,r5,#28
00000e  0f00              LSRS     r0,r0,#28
000010  9000              STR      r0,[sp,#0]
;;;1665     if (errorflags == RESET)
000012  9800              LDR      r0,[sp,#0]
000014  2800              CMP      r0,#0
000016  d10b              BNE      |L24.48|
;;;1666     {
;;;1667       /* UART in mode Receiver ---------------------------------------------------*/
;;;1668       if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000018  2020              MOVS     r0,#0x20
00001a  4028              ANDS     r0,r0,r5
00001c  2800              CMP      r0,#0
00001e  d007              BEQ      |L24.48|
000020  2020              MOVS     r0,#0x20
000022  4030              ANDS     r0,r0,r6
000024  2800              CMP      r0,#0
000026  d003              BEQ      |L24.48|
;;;1669       {
;;;1670         UART_Receive_IT(huart);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       UART_Receive_IT
                  |L24.46|
;;;1671         return;
;;;1672       }
;;;1673     }  
;;;1674   
;;;1675     /* If some errors occur */
;;;1676     cr3its = READ_REG(huart->Instance->CR3);
;;;1677     if(   (errorflags != RESET)
;;;1678        && (   ((cr3its & USART_CR3_EIE) != RESET)
;;;1679            || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
;;;1680     {
;;;1681       /* UART parity error interrupt occurred -------------------------------------*/
;;;1682       if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
;;;1683       {
;;;1684         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
;;;1685   
;;;1686         huart->ErrorCode |= HAL_UART_ERROR_PE;
;;;1687       }
;;;1688   
;;;1689       /* UART frame error interrupt occurred --------------------------------------*/
;;;1690       if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;1691       {
;;;1692         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
;;;1693   
;;;1694         huart->ErrorCode |= HAL_UART_ERROR_FE;
;;;1695       }
;;;1696   
;;;1697       /* UART noise error interrupt occurred --------------------------------------*/
;;;1698       if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;1699       {
;;;1700         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
;;;1701   
;;;1702         huart->ErrorCode |= HAL_UART_ERROR_NE;
;;;1703       }
;;;1704       
;;;1705       /* UART Over-Run interrupt occurred -----------------------------------------*/
;;;1706       if(((isrflags & USART_ISR_ORE) != RESET) &&
;;;1707          (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
;;;1708       {
;;;1709         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
;;;1710   
;;;1711         huart->ErrorCode |= HAL_UART_ERROR_ORE;
;;;1712       }
;;;1713   
;;;1714       /* Call UART Error Call back function if need be --------------------------*/
;;;1715       if(huart->ErrorCode != HAL_UART_ERROR_NONE)
;;;1716       {
;;;1717         /* UART in mode Receiver ---------------------------------------------------*/
;;;1718         if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1719         {
;;;1720           UART_Receive_IT(huart);
;;;1721         }
;;;1722   
;;;1723         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1724            consider error as blocking */
;;;1725         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
;;;1726             (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1727         {  
;;;1728           /* Blocking error : transfer is aborted
;;;1729              Set the UART state ready to be able to start again the process,
;;;1730              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1731           UART_EndRxTransfer(huart);
;;;1732   
;;;1733           /* Disable the UART DMA Rx request if enabled */
;;;1734           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;1735           {
;;;1736             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1737   
;;;1738             /* Abort the UART DMA Rx channel */
;;;1739             if(huart->hdmarx != NULL)
;;;1740             {
;;;1741               /* Set the UART DMA Abort callback : 
;;;1742                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;1743               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
;;;1744   
;;;1745               /* Abort DMA RX */
;;;1746               if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1747               {
;;;1748                 /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1749                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1750               }
;;;1751             }
;;;1752             else
;;;1753             {
;;;1754               /* Call user error callback */
;;;1755               HAL_UART_ErrorCallback(huart);
;;;1756             }
;;;1757           }
;;;1758           else
;;;1759           {
;;;1760             /* Call user error callback */
;;;1761             HAL_UART_ErrorCallback(huart);
;;;1762           }
;;;1763         }
;;;1764         else
;;;1765         {
;;;1766           /* Non Blocking error : transfer could go on. 
;;;1767              Error is notified to user through user error callback */
;;;1768           HAL_UART_ErrorCallback(huart);
;;;1769           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1770         }
;;;1771       }
;;;1772       return;
;;;1773   
;;;1774     } /* End if some error occurs */
;;;1775   
;;;1776   #if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC)
;;;1777     /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
;;;1778     if(((isrflags & USART_ISR_WUF) != RESET) && ((cr3its & USART_CR3_WUFIE) != RESET))
;;;1779     {
;;;1780       __HAL_UART_CLEAR_IT(huart, UART_CLEAR_WUF);
;;;1781       /* Set the UART state ready to be able to start again the process */
;;;1782       huart->gState  = HAL_UART_STATE_READY;
;;;1783       huart->RxState = HAL_UART_STATE_READY;
;;;1784       HAL_UARTEx_WakeupCallback(huart);
;;;1785       return;
;;;1786     }
;;;1787   #endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC) */
;;;1788   
;;;1789     /* UART in mode Transmitter ------------------------------------------------*/
;;;1790     if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1791     {
;;;1792       UART_Transmit_IT(huart);
;;;1793       return;
;;;1794     }
;;;1795   
;;;1796     /* UART in mode Transmitter (transmission end) -----------------------------*/
;;;1797     if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1798     {
;;;1799       UART_EndTransmit_IT(huart);
;;;1800       return;
;;;1801     }
;;;1802   
;;;1803   }
00002e  bdf8              POP      {r3-r7,pc}
                  |L24.48|
000030  6820              LDR      r0,[r4,#0]            ;1676
000032  6887              LDR      r7,[r0,#8]            ;1676
000034  9800              LDR      r0,[sp,#0]            ;1677
000036  2800              CMP      r0,#0                 ;1677
                  |L24.56|
000038  d07e              BEQ      |L24.312|
00003a  07f8              LSLS     r0,r7,#31             ;1678
00003c  0fc0              LSRS     r0,r0,#31             ;1678
00003e  2800              CMP      r0,#0                 ;1678
000040  d104              BNE      |L24.76|
000042  20ff              MOVS     r0,#0xff              ;1679
000044  3021              ADDS     r0,r0,#0x21           ;1679
000046  4030              ANDS     r0,r0,r6              ;1679
000048  2800              CMP      r0,#0                 ;1679
00004a  d0f5              BEQ      |L24.56|
                  |L24.76|
00004c  07e8              LSLS     r0,r5,#31             ;1682
00004e  0fc0              LSRS     r0,r0,#31             ;1682
000050  2800              CMP      r0,#0                 ;1682
000052  d00b              BEQ      |L24.108|
000054  20ff              MOVS     r0,#0xff              ;1682
000056  3001              ADDS     r0,#1                 ;1682
000058  4030              ANDS     r0,r0,r6              ;1682
00005a  2800              CMP      r0,#0                 ;1682
00005c  d006              BEQ      |L24.108|
00005e  2001              MOVS     r0,#1                 ;1684
000060  6821              LDR      r1,[r4,#0]            ;1684
000062  6208              STR      r0,[r1,#0x20]         ;1684
000064  6ee0              LDR      r0,[r4,#0x6c]         ;1686
000066  2101              MOVS     r1,#1                 ;1686
000068  4308              ORRS     r0,r0,r1              ;1686
00006a  66e0              STR      r0,[r4,#0x6c]         ;1686
                  |L24.108|
00006c  2002              MOVS     r0,#2                 ;1690
00006e  4028              ANDS     r0,r0,r5              ;1690
000070  2800              CMP      r0,#0                 ;1690
000072  d00a              BEQ      |L24.138|
000074  07f8              LSLS     r0,r7,#31             ;1690
000076  0fc0              LSRS     r0,r0,#31             ;1690
000078  2800              CMP      r0,#0                 ;1690
00007a  d006              BEQ      |L24.138|
00007c  2002              MOVS     r0,#2                 ;1692
00007e  6821              LDR      r1,[r4,#0]            ;1692
000080  6208              STR      r0,[r1,#0x20]         ;1692
000082  6ee0              LDR      r0,[r4,#0x6c]         ;1694
000084  2104              MOVS     r1,#4                 ;1694
000086  4308              ORRS     r0,r0,r1              ;1694
000088  66e0              STR      r0,[r4,#0x6c]         ;1694
                  |L24.138|
00008a  2004              MOVS     r0,#4                 ;1698
00008c  4028              ANDS     r0,r0,r5              ;1698
00008e  2800              CMP      r0,#0                 ;1698
000090  d00a              BEQ      |L24.168|
000092  07f8              LSLS     r0,r7,#31             ;1698
000094  0fc0              LSRS     r0,r0,#31             ;1698
000096  2800              CMP      r0,#0                 ;1698
000098  d006              BEQ      |L24.168|
00009a  2004              MOVS     r0,#4                 ;1700
00009c  6821              LDR      r1,[r4,#0]            ;1700
00009e  6208              STR      r0,[r1,#0x20]         ;1700
0000a0  6ee0              LDR      r0,[r4,#0x6c]         ;1702
0000a2  2102              MOVS     r1,#2                 ;1702
0000a4  4308              ORRS     r0,r0,r1              ;1702
0000a6  66e0              STR      r0,[r4,#0x6c]         ;1702
                  |L24.168|
0000a8  2008              MOVS     r0,#8                 ;1706
0000aa  4028              ANDS     r0,r0,r5              ;1706
0000ac  2800              CMP      r0,#0                 ;1706
0000ae  d00e              BEQ      |L24.206|
0000b0  2020              MOVS     r0,#0x20              ;1707
0000b2  4030              ANDS     r0,r0,r6              ;1707
0000b4  2800              CMP      r0,#0                 ;1707
0000b6  d103              BNE      |L24.192|
0000b8  07f8              LSLS     r0,r7,#31             ;1707
0000ba  0fc0              LSRS     r0,r0,#31             ;1707
0000bc  2800              CMP      r0,#0                 ;1707
0000be  d006              BEQ      |L24.206|
                  |L24.192|
0000c0  2008              MOVS     r0,#8                 ;1709
0000c2  6821              LDR      r1,[r4,#0]            ;1709
0000c4  6208              STR      r0,[r1,#0x20]         ;1709
0000c6  6ee0              LDR      r0,[r4,#0x6c]         ;1711
0000c8  2108              MOVS     r1,#8                 ;1711
0000ca  4308              ORRS     r0,r0,r1              ;1711
0000cc  66e0              STR      r0,[r4,#0x6c]         ;1711
                  |L24.206|
0000ce  6ee0              LDR      r0,[r4,#0x6c]         ;1715
0000d0  2800              CMP      r0,#0                 ;1715
0000d2  d041              BEQ      |L24.344|
0000d4  2020              MOVS     r0,#0x20              ;1718
0000d6  4028              ANDS     r0,r0,r5              ;1718
0000d8  2800              CMP      r0,#0                 ;1718
0000da  d006              BEQ      |L24.234|
0000dc  2020              MOVS     r0,#0x20              ;1718
0000de  4030              ANDS     r0,r0,r6              ;1718
0000e0  2800              CMP      r0,#0                 ;1718
0000e2  d002              BEQ      |L24.234|
0000e4  4620              MOV      r0,r4                 ;1720
0000e6  f7fffffe          BL       UART_Receive_IT
                  |L24.234|
0000ea  6ee0              LDR      r0,[r4,#0x6c]         ;1725
0000ec  2108              MOVS     r1,#8                 ;1725
0000ee  4008              ANDS     r0,r0,r1              ;1725
0000f0  2800              CMP      r0,#0                 ;1725
0000f2  d105              BNE      |L24.256|
0000f4  6820              LDR      r0,[r4,#0]            ;1726
0000f6  6880              LDR      r0,[r0,#8]            ;1726
0000f8  2140              MOVS     r1,#0x40              ;1726
0000fa  4008              ANDS     r0,r0,r1              ;1726
0000fc  2800              CMP      r0,#0                 ;1726
0000fe  d026              BEQ      |L24.334|
                  |L24.256|
000100  4620              MOV      r0,r4                 ;1731
000102  f7fffffe          BL       UART_EndRxTransfer
000106  6820              LDR      r0,[r4,#0]            ;1734
000108  6880              LDR      r0,[r0,#8]            ;1734
00010a  2140              MOVS     r1,#0x40              ;1734
00010c  4008              ANDS     r0,r0,r1              ;1734
00010e  2800              CMP      r0,#0                 ;1734
000110  d019              BEQ      |L24.326|
000112  6820              LDR      r0,[r4,#0]            ;1736
000114  6880              LDR      r0,[r0,#8]            ;1736
000116  4388              BICS     r0,r0,r1              ;1736
000118  6821              LDR      r1,[r4,#0]            ;1736
00011a  6088              STR      r0,[r1,#8]            ;1736
00011c  6e60              LDR      r0,[r4,#0x64]         ;1739
00011e  2800              CMP      r0,#0                 ;1739
000120  d00d              BEQ      |L24.318|
000122  481b              LDR      r0,|L24.400|
000124  6e61              LDR      r1,[r4,#0x64]         ;1743
000126  6348              STR      r0,[r1,#0x34]         ;1743
000128  6e60              LDR      r0,[r4,#0x64]         ;1746
00012a  f7fffffe          BL       HAL_DMA_Abort_IT
00012e  2800              CMP      r0,#0                 ;1746
000130  d012              BEQ      |L24.344|
000132  6e60              LDR      r0,[r4,#0x64]         ;1749
000134  6b41              LDR      r1,[r0,#0x34]         ;1749
000136  e000              B        |L24.314|
                  |L24.312|
000138  e00f              B        |L24.346|
                  |L24.314|
00013a  4788              BLX      r1                    ;1749
00013c  e00c              B        |L24.344|
                  |L24.318|
00013e  4620              MOV      r0,r4                 ;1755
000140  f7fffffe          BL       HAL_UART_ErrorCallback
000144  e008              B        |L24.344|
                  |L24.326|
000146  4620              MOV      r0,r4                 ;1761
000148  f7fffffe          BL       HAL_UART_ErrorCallback
00014c  e004              B        |L24.344|
                  |L24.334|
00014e  4620              MOV      r0,r4                 ;1768
000150  f7fffffe          BL       HAL_UART_ErrorCallback
000154  2000              MOVS     r0,#0                 ;1769
000156  66e0              STR      r0,[r4,#0x6c]         ;1769
                  |L24.344|
000158  e769              B        |L24.46|
                  |L24.346|
00015a  2080              MOVS     r0,#0x80              ;1790
00015c  4028              ANDS     r0,r0,r5              ;1790
00015e  2800              CMP      r0,#0                 ;1790
000160  d007              BEQ      |L24.370|
000162  2080              MOVS     r0,#0x80              ;1790
000164  4030              ANDS     r0,r0,r6              ;1790
000166  2800              CMP      r0,#0                 ;1790
000168  d003              BEQ      |L24.370|
00016a  4620              MOV      r0,r4                 ;1792
00016c  f7fffffe          BL       UART_Transmit_IT
000170  e75d              B        |L24.46|
                  |L24.370|
000172  2040              MOVS     r0,#0x40              ;1797
000174  4028              ANDS     r0,r0,r5              ;1797
000176  2800              CMP      r0,#0                 ;1797
000178  d007              BEQ      |L24.394|
00017a  2040              MOVS     r0,#0x40              ;1797
00017c  4030              ANDS     r0,r0,r6              ;1797
00017e  2800              CMP      r0,#0                 ;1797
000180  d003              BEQ      |L24.394|
000182  4620              MOV      r0,r4                 ;1799
000184  f7fffffe          BL       UART_EndTransmit_IT
000188  e751              B        |L24.46|
                  |L24.394|
00018a  bf00              NOP      
00018c  e74f              B        |L24.46|
;;;1804   
                          ENDP

00018e  0000              DCW      0x0000
                  |L24.400|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;290      */
;;;291    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;292    {
000002  4604              MOV      r4,r0
;;;293      /* Check the UART handle allocation */
;;;294      if(huart == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L25.12|
;;;295      {
;;;296        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L25.10|
;;;297      }
;;;298    
;;;299      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;300      {
;;;301        /* Check the parameters */
;;;302        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;303      }
;;;304      else
;;;305      {
;;;306        /* Check the parameters */
;;;307        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;308      }
;;;309    
;;;310      if(huart->gState == HAL_UART_STATE_RESET)
;;;311      {
;;;312        /* Allocate lock resource and initialize it */
;;;313        huart->Lock = HAL_UNLOCKED;
;;;314    
;;;315        /* Init the low level hardware : GPIO, CLOCK */
;;;316        HAL_UART_MspInit(huart);
;;;317      }
;;;318    
;;;319      huart->gState = HAL_UART_STATE_BUSY;
;;;320    
;;;321      /* Disable the Peripheral */
;;;322      __HAL_UART_DISABLE(huart);
;;;323    
;;;324      /* Set the UART Communication parameters */
;;;325      if (UART_SetConfig(huart) == HAL_ERROR)
;;;326      {
;;;327        return HAL_ERROR;
;;;328      }
;;;329    
;;;330      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;331      {
;;;332        UART_AdvFeatureConfig(huart);
;;;333      }
;;;334    
;;;335      /* In asynchronous mode, the following bits must be kept cleared:
;;;336      - LINEN (if LIN is supported) and CLKEN bits in the USART_CR2 register,
;;;337      - SCEN (if Smartcard is supported), HDSEL and IREN (if IrDA is supported)  bits in the USART_CR3 register. */
;;;338    #if defined (USART_CR2_LINEN)
;;;339      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;340    #else
;;;341      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;342    #endif
;;;343    #if defined (USART_CR3_SCEN)
;;;344    #if defined (USART_CR3_IREN)
;;;345      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;346    #else
;;;347      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL));
;;;348    #endif
;;;349    #else
;;;350    #if defined (USART_CR3_IREN)
;;;351      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN));
;;;352    #else
;;;353      CLEAR_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;354    #endif
;;;355    #endif
;;;356    
;;;357      /* Enable the Peripheral */
;;;358      __HAL_UART_ENABLE(huart);
;;;359    
;;;360      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;361      return (UART_CheckIdleState(huart));
;;;362    }
00000a  bd10              POP      {r4,pc}
                  |L25.12|
00000c  69a0              LDR      r0,[r4,#0x18]         ;299
00000e  2800              CMP      r0,#0                 ;299
000010  d000              BEQ      |L25.20|
000012  e000              B        |L25.22|
                  |L25.20|
000014  bf00              NOP                            ;307
                  |L25.22|
000016  2069              MOVS     r0,#0x69              ;310
000018  5d00              LDRB     r0,[r0,r4]            ;310
00001a  2800              CMP      r0,#0                 ;310
00001c  d105              BNE      |L25.42|
00001e  2100              MOVS     r1,#0                 ;313
000020  2068              MOVS     r0,#0x68              ;313
000022  5501              STRB     r1,[r0,r4]            ;313
000024  4620              MOV      r0,r4                 ;316
000026  f7fffffe          BL       HAL_UART_MspInit
                  |L25.42|
00002a  2124              MOVS     r1,#0x24              ;319
00002c  2069              MOVS     r0,#0x69              ;319
00002e  5501              STRB     r1,[r0,r4]            ;319
000030  6820              LDR      r0,[r4,#0]            ;322
000032  6800              LDR      r0,[r0,#0]            ;322
000034  0840              LSRS     r0,r0,#1              ;322
000036  0040              LSLS     r0,r0,#1              ;322
000038  6821              LDR      r1,[r4,#0]            ;322
00003a  6008              STR      r0,[r1,#0]            ;322
00003c  4620              MOV      r0,r4                 ;325
00003e  f7fffffe          BL       UART_SetConfig
000042  2801              CMP      r0,#1                 ;325
000044  d100              BNE      |L25.72|
000046  e7e0              B        |L25.10|
                  |L25.72|
000048  6a60              LDR      r0,[r4,#0x24]         ;330
00004a  2800              CMP      r0,#0                 ;330
00004c  d002              BEQ      |L25.84|
00004e  4620              MOV      r0,r4                 ;332
000050  f7fffffe          BL       UART_AdvFeatureConfig
                  |L25.84|
000054  6820              LDR      r0,[r4,#0]            ;341
000056  6840              LDR      r0,[r0,#4]            ;341
000058  2101              MOVS     r1,#1                 ;341
00005a  02c9              LSLS     r1,r1,#11             ;341
00005c  4388              BICS     r0,r0,r1              ;341
00005e  6821              LDR      r1,[r4,#0]            ;341
000060  6048              STR      r0,[r1,#4]            ;341
000062  6820              LDR      r0,[r4,#0]            ;353
000064  6880              LDR      r0,[r0,#8]            ;353
000066  2108              MOVS     r1,#8                 ;353
000068  4388              BICS     r0,r0,r1              ;353
00006a  6821              LDR      r1,[r4,#0]            ;353
00006c  6088              STR      r0,[r1,#8]            ;353
00006e  6820              LDR      r0,[r4,#0]            ;358
000070  6800              LDR      r0,[r0,#0]            ;358
000072  2101              MOVS     r1,#1                 ;358
000074  4308              ORRS     r0,r0,r1              ;358
000076  6821              LDR      r1,[r4,#0]            ;358
000078  6008              STR      r0,[r1,#0]            ;358
00007a  4620              MOV      r0,r4                 ;361
00007c  f7fffffe          BL       UART_CheckIdleState
000080  e7c3              B        |L25.10|
;;;363    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;587      */
;;;588    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;589    {
;;;590      /* Prevent unused argument(s) compilation warning */
;;;591      UNUSED(huart);
;;;592    
;;;593      /* NOTE : This function should not be modified, when the callback is needed,
;;;594                the HAL_UART_MspDeInit can be implemented in the user file
;;;595       */
;;;596    }
;;;597    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;572      */
;;;573    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;574    {
;;;575      /* Prevent unused argument(s) compilation warning */
;;;576      UNUSED(huart);
;;;577    
;;;578      /* NOTE : This function should not be modified, when the callback is needed,
;;;579                the HAL_UART_MspInit can be implemented in the user file
;;;580       */
;;;581    }
;;;582    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive PROC
;;;774      */
;;;775    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;776    {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;777      uint16_t* tmp;
;;;778      uint16_t uhMask;
;;;779      uint32_t tickstart = 0;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;780    
;;;781      /* Check that a Rx process is not already ongoing */
;;;782      if(huart->RxState == HAL_UART_STATE_READY)
00000e  206a              MOVS     r0,#0x6a
000010  5d00              LDRB     r0,[r0,r4]
000012  2820              CMP      r0,#0x20
000014  d170              BNE      |L28.248|
;;;783      {
;;;784        if((pData == NULL ) || (Size == 0U))
000016  2d00              CMP      r5,#0
000018  d001              BEQ      |L28.30|
00001a  2e00              CMP      r6,#0
00001c  d102              BNE      |L28.36|
                  |L28.30|
;;;785        {
;;;786          return  HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L28.32|
;;;787        }
;;;788    
;;;789        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;790           should be aligned on a u16 frontier, as data to be received from RDR will be 
;;;791           handled through a u16 cast. */
;;;792        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;793        {
;;;794          if((((uint32_t)pData)&1U) != 0U)
;;;795          {
;;;796            return  HAL_ERROR;
;;;797          }
;;;798        }
;;;799    
;;;800        /* Process Locked */
;;;801        __HAL_LOCK(huart);
;;;802    
;;;803        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;804        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;805    
;;;806        /* Init tickstart for timeout managment*/
;;;807        tickstart = HAL_GetTick();
;;;808    
;;;809        huart->RxXferSize = Size;
;;;810        huart->RxXferCount = Size;
;;;811    
;;;812        /* Computation of UART mask to apply to RDR register */
;;;813        UART_MASK_COMPUTATION(huart);
;;;814        uhMask = huart->Mask;
;;;815    
;;;816        /* as long as data have to be received */
;;;817        while(huart->RxXferCount > 0U)
;;;818        {
;;;819          huart->RxXferCount--;
;;;820          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;821          {
;;;822            return HAL_TIMEOUT;
;;;823          }
;;;824          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;825          {
;;;826            tmp = (uint16_t*) pData ;
;;;827            *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
;;;828            pData +=2U;
;;;829          }
;;;830          else
;;;831          {
;;;832            *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
;;;833          }
;;;834        }
;;;835    
;;;836        /* At end of Rx process, restore huart->RxState to Ready */
;;;837        huart->RxState = HAL_UART_STATE_READY;
;;;838    
;;;839        /* Process Unlocked */
;;;840        __HAL_UNLOCK(huart);
;;;841    
;;;842        return HAL_OK;
;;;843      }
;;;844      else
;;;845      {
;;;846        return HAL_BUSY;
;;;847      }
;;;848    }
000020  b007              ADD      sp,sp,#0x1c
000022  bdf0              POP      {r4-r7,pc}
                  |L28.36|
000024  2101              MOVS     r1,#1                 ;792
000026  0309              LSLS     r1,r1,#12             ;792
000028  68a0              LDR      r0,[r4,#8]            ;792
00002a  4288              CMP      r0,r1                 ;792
00002c  d108              BNE      |L28.64|
00002e  6920              LDR      r0,[r4,#0x10]         ;792
000030  2800              CMP      r0,#0                 ;792
000032  d105              BNE      |L28.64|
000034  07e8              LSLS     r0,r5,#31             ;794
000036  0fc0              LSRS     r0,r0,#31             ;794
000038  2800              CMP      r0,#0                 ;794
00003a  d001              BEQ      |L28.64|
00003c  2001              MOVS     r0,#1                 ;796
00003e  e7ef              B        |L28.32|
                  |L28.64|
000040  bf00              NOP                            ;801
000042  2068              MOVS     r0,#0x68              ;801
000044  5d00              LDRB     r0,[r0,r4]            ;801
000046  2801              CMP      r0,#1                 ;801
000048  d101              BNE      |L28.78|
00004a  2002              MOVS     r0,#2                 ;801
00004c  e7e8              B        |L28.32|
                  |L28.78|
00004e  2101              MOVS     r1,#1                 ;801
000050  2068              MOVS     r0,#0x68              ;801
000052  5501              STRB     r1,[r0,r4]            ;801
000054  bf00              NOP                            ;801
000056  2000              MOVS     r0,#0                 ;803
000058  66e0              STR      r0,[r4,#0x6c]         ;803
00005a  2122              MOVS     r1,#0x22              ;804
00005c  206a              MOVS     r0,#0x6a              ;804
00005e  5501              STRB     r1,[r0,r4]            ;804
000060  f7fffffe          BL       HAL_GetTick
000064  9001              STR      r0,[sp,#4]            ;807
000066  2058              MOVS     r0,#0x58              ;809
000068  5306              STRH     r6,[r0,r4]            ;809
00006a  205a              MOVS     r0,#0x5a              ;810
00006c  5306              STRH     r6,[r0,r4]            ;810
00006e  bf00              NOP                            ;813
000070  2101              MOVS     r1,#1                 ;813
000072  0309              LSLS     r1,r1,#12             ;813
000074  68a0              LDR      r0,[r4,#8]            ;813
000076  4288              CMP      r0,r1                 ;813
000078  d10a              BNE      |L28.144|
00007a  6920              LDR      r0,[r4,#0x10]         ;813
00007c  2800              CMP      r0,#0                 ;813
00007e  d103              BNE      |L28.136|
000080  4931              LDR      r1,|L28.328|
000082  205c              MOVS     r0,#0x5c              ;813
000084  5301              STRH     r1,[r0,r4]            ;813
000086  e020              B        |L28.202|
                  |L28.136|
000088  21ff              MOVS     r1,#0xff              ;813
00008a  205c              MOVS     r0,#0x5c              ;813
00008c  5301              STRH     r1,[r0,r4]            ;813
00008e  e01c              B        |L28.202|
                  |L28.144|
000090  68a0              LDR      r0,[r4,#8]            ;813
000092  2800              CMP      r0,#0                 ;813
000094  d10a              BNE      |L28.172|
000096  6920              LDR      r0,[r4,#0x10]         ;813
000098  2800              CMP      r0,#0                 ;813
00009a  d103              BNE      |L28.164|
00009c  21ff              MOVS     r1,#0xff              ;813
00009e  205c              MOVS     r0,#0x5c              ;813
0000a0  5301              STRH     r1,[r0,r4]            ;813
0000a2  e012              B        |L28.202|
                  |L28.164|
0000a4  217f              MOVS     r1,#0x7f              ;813
0000a6  205c              MOVS     r0,#0x5c              ;813
0000a8  5301              STRH     r1,[r0,r4]            ;813
0000aa  e00e              B        |L28.202|
                  |L28.172|
0000ac  2101              MOVS     r1,#1                 ;813
0000ae  0709              LSLS     r1,r1,#28             ;813
0000b0  68a0              LDR      r0,[r4,#8]            ;813
0000b2  4288              CMP      r0,r1                 ;813
0000b4  d109              BNE      |L28.202|
0000b6  6920              LDR      r0,[r4,#0x10]         ;813
0000b8  2800              CMP      r0,#0                 ;813
0000ba  d103              BNE      |L28.196|
0000bc  217f              MOVS     r1,#0x7f              ;813
0000be  205c              MOVS     r0,#0x5c              ;813
0000c0  5301              STRH     r1,[r0,r4]            ;813
0000c2  e002              B        |L28.202|
                  |L28.196|
0000c4  213f              MOVS     r1,#0x3f              ;813
0000c6  205c              MOVS     r0,#0x5c              ;813
0000c8  5301              STRH     r1,[r0,r4]            ;813
                  |L28.202|
0000ca  bf00              NOP                            ;813
0000cc  205c              MOVS     r0,#0x5c              ;814
0000ce  5b00              LDRH     r0,[r0,r4]            ;814
0000d0  9002              STR      r0,[sp,#8]            ;814
0000d2  e029              B        |L28.296|
                  |L28.212|
0000d4  205a              MOVS     r0,#0x5a              ;819
0000d6  5b00              LDRH     r0,[r0,r4]            ;819
0000d8  1e40              SUBS     r0,r0,#1              ;819
0000da  b281              UXTH     r1,r0                 ;819
0000dc  205a              MOVS     r0,#0x5a              ;819
0000de  5301              STRH     r1,[r0,r4]            ;819
0000e0  9806              LDR      r0,[sp,#0x18]         ;820
0000e2  9000              STR      r0,[sp,#0]            ;820
0000e4  2200              MOVS     r2,#0                 ;820
0000e6  2120              MOVS     r1,#0x20              ;820
0000e8  4620              MOV      r0,r4                 ;820
0000ea  9b01              LDR      r3,[sp,#4]            ;820
0000ec  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000f0  2800              CMP      r0,#0                 ;820
0000f2  d002              BEQ      |L28.250|
0000f4  2003              MOVS     r0,#3                 ;822
0000f6  e793              B        |L28.32|
                  |L28.248|
0000f8  e024              B        |L28.324|
                  |L28.250|
0000fa  2101              MOVS     r1,#1                 ;824
0000fc  0309              LSLS     r1,r1,#12             ;824
0000fe  68a0              LDR      r0,[r4,#8]            ;824
000100  4288              CMP      r0,r1                 ;824
000102  d10a              BNE      |L28.282|
000104  6920              LDR      r0,[r4,#0x10]         ;824
000106  2800              CMP      r0,#0                 ;824
000108  d107              BNE      |L28.282|
00010a  462f              MOV      r7,r5                 ;826
00010c  6820              LDR      r0,[r4,#0]            ;827
00010e  8c80              LDRH     r0,[r0,#0x24]         ;827
000110  9902              LDR      r1,[sp,#8]            ;827
000112  4008              ANDS     r0,r0,r1              ;827
000114  8038              STRH     r0,[r7,#0]            ;827
000116  1cad              ADDS     r5,r5,#2              ;828
000118  e006              B        |L28.296|
                  |L28.282|
00011a  6820              LDR      r0,[r4,#0]            ;832
00011c  8c80              LDRH     r0,[r0,#0x24]         ;832
00011e  9902              LDR      r1,[sp,#8]            ;832
000120  b2c9              UXTB     r1,r1                 ;832
000122  4008              ANDS     r0,r0,r1              ;832
000124  7028              STRB     r0,[r5,#0]            ;832
000126  1c6d              ADDS     r5,r5,#1              ;832
                  |L28.296|
000128  205a              MOVS     r0,#0x5a              ;817
00012a  5b00              LDRH     r0,[r0,r4]            ;817
00012c  2800              CMP      r0,#0                 ;817
00012e  d1d1              BNE      |L28.212|
000130  2120              MOVS     r1,#0x20              ;837
000132  206a              MOVS     r0,#0x6a              ;837
000134  5501              STRB     r1,[r0,r4]            ;837
000136  bf00              NOP                            ;840
000138  2100              MOVS     r1,#0                 ;840
00013a  2068              MOVS     r0,#0x68              ;840
00013c  5501              STRB     r1,[r0,r4]            ;840
00013e  bf00              NOP                            ;840
000140  2000              MOVS     r0,#0                 ;842
000142  e76d              B        |L28.32|
                  |L28.324|
000144  2002              MOVS     r0,#2                 ;846
000146  e76b              B        |L28.32|
;;;849    
                          ENDP

                  |L28.328|
                          DCD      0x000001ff

                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1053     */
;;;1054   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1055   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1056     /* Check that a Rx process is not already ongoing */
;;;1057     if(huart->RxState == HAL_UART_STATE_READY)
000008  206a              MOVS     r0,#0x6a
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2820              CMP      r0,#0x20
00000e  d154              BNE      |L29.186|
;;;1058     {
;;;1059       if((pData == NULL ) || (Size == 0U))
000010  2d00              CMP      r5,#0
000012  d001              BEQ      |L29.24|
000014  2e00              CMP      r6,#0
000016  d101              BNE      |L29.28|
                  |L29.24|
;;;1060       {
;;;1061         return HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L29.26|
;;;1062       }
;;;1063   
;;;1064       /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;1065          should be aligned on a u16 frontier, as data copy from RDR will be 
;;;1066          handled by DMA from a u16 frontier. */
;;;1067       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1068       {
;;;1069         if((((uint32_t)pData)&1U) != 0U)
;;;1070         {
;;;1071           return  HAL_ERROR;
;;;1072         }
;;;1073       }
;;;1074   
;;;1075       /* Process Locked */
;;;1076       __HAL_LOCK(huart);
;;;1077   
;;;1078       huart->pRxBuffPtr = pData;
;;;1079       huart->RxXferSize = Size;
;;;1080   
;;;1081       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1082       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1083   
;;;1084       /* Set the UART DMA transfer complete callback */
;;;1085       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;1086   
;;;1087       /* Set the UART DMA Half transfer complete callback */
;;;1088       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1089   
;;;1090       /* Set the DMA error callback */
;;;1091       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1092   
;;;1093       /* Set the DMA abort callback */
;;;1094       huart->hdmarx->XferAbortCallback = NULL;
;;;1095   
;;;1096       /* Enable the DMA channel */
;;;1097       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size);
;;;1098   
;;;1099       /* Process Unlocked */
;;;1100       __HAL_UNLOCK(huart);
;;;1101   
;;;1102       /* Enable the UART Parity Error Interrupt */
;;;1103       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1104   
;;;1105       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1106       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1107   
;;;1108       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1109          in the UART CR3 register */
;;;1110       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1111   
;;;1112       return HAL_OK;
;;;1113     }
;;;1114     else
;;;1115     {
;;;1116       return HAL_BUSY;
;;;1117     }
;;;1118   }
00001a  bd70              POP      {r4-r6,pc}
                  |L29.28|
00001c  2101              MOVS     r1,#1                 ;1067
00001e  0309              LSLS     r1,r1,#12             ;1067
000020  68a0              LDR      r0,[r4,#8]            ;1067
000022  4288              CMP      r0,r1                 ;1067
000024  d108              BNE      |L29.56|
000026  6920              LDR      r0,[r4,#0x10]         ;1067
000028  2800              CMP      r0,#0                 ;1067
00002a  d105              BNE      |L29.56|
00002c  07e8              LSLS     r0,r5,#31             ;1069
00002e  0fc0              LSRS     r0,r0,#31             ;1069
000030  2800              CMP      r0,#0                 ;1069
000032  d001              BEQ      |L29.56|
000034  2001              MOVS     r0,#1                 ;1071
000036  e7f0              B        |L29.26|
                  |L29.56|
000038  bf00              NOP                            ;1076
00003a  2068              MOVS     r0,#0x68              ;1076
00003c  5d00              LDRB     r0,[r0,r4]            ;1076
00003e  2801              CMP      r0,#1                 ;1076
000040  d101              BNE      |L29.70|
000042  2002              MOVS     r0,#2                 ;1076
000044  e7e9              B        |L29.26|
                  |L29.70|
000046  2101              MOVS     r1,#1                 ;1076
000048  2068              MOVS     r0,#0x68              ;1076
00004a  5501              STRB     r1,[r0,r4]            ;1076
00004c  bf00              NOP                            ;1076
00004e  6565              STR      r5,[r4,#0x54]         ;1078
000050  2058              MOVS     r0,#0x58              ;1079
000052  5306              STRH     r6,[r0,r4]            ;1079
000054  2000              MOVS     r0,#0                 ;1081
000056  66e0              STR      r0,[r4,#0x6c]         ;1081
000058  2122              MOVS     r1,#0x22              ;1082
00005a  206a              MOVS     r0,#0x6a              ;1082
00005c  5501              STRB     r1,[r0,r4]            ;1082
00005e  4818              LDR      r0,|L29.192|
000060  6e61              LDR      r1,[r4,#0x64]         ;1085
000062  6288              STR      r0,[r1,#0x28]         ;1085
000064  4817              LDR      r0,|L29.196|
000066  6e61              LDR      r1,[r4,#0x64]         ;1088
000068  62c8              STR      r0,[r1,#0x2c]         ;1088
00006a  4817              LDR      r0,|L29.200|
00006c  6e61              LDR      r1,[r4,#0x64]         ;1091
00006e  6308              STR      r0,[r1,#0x30]         ;1091
000070  2000              MOVS     r0,#0                 ;1094
000072  6e61              LDR      r1,[r4,#0x64]         ;1094
000074  6348              STR      r0,[r1,#0x34]         ;1094
000076  6823              LDR      r3,[r4,#0]            ;1097
000078  4619              MOV      r1,r3                 ;1097
00007a  3124              ADDS     r1,r1,#0x24           ;1097
00007c  4633              MOV      r3,r6                 ;1097
00007e  6d62              LDR      r2,[r4,#0x54]         ;1097
000080  6e60              LDR      r0,[r4,#0x64]         ;1097
000082  f7fffffe          BL       HAL_DMA_Start_IT
000086  bf00              NOP                            ;1100
000088  2100              MOVS     r1,#0                 ;1100
00008a  2068              MOVS     r0,#0x68              ;1100
00008c  5501              STRB     r1,[r0,r4]            ;1100
00008e  bf00              NOP                            ;1100
000090  6820              LDR      r0,[r4,#0]            ;1103
000092  6800              LDR      r0,[r0,#0]            ;1103
000094  21ff              MOVS     r1,#0xff              ;1103
000096  3101              ADDS     r1,#1                 ;1103
000098  4308              ORRS     r0,r0,r1              ;1103
00009a  6821              LDR      r1,[r4,#0]            ;1103
00009c  6008              STR      r0,[r1,#0]            ;1103
00009e  6820              LDR      r0,[r4,#0]            ;1106
0000a0  6880              LDR      r0,[r0,#8]            ;1106
0000a2  2101              MOVS     r1,#1                 ;1106
0000a4  4308              ORRS     r0,r0,r1              ;1106
0000a6  6821              LDR      r1,[r4,#0]            ;1106
0000a8  6088              STR      r0,[r1,#8]            ;1106
0000aa  6820              LDR      r0,[r4,#0]            ;1110
0000ac  6880              LDR      r0,[r0,#8]            ;1110
0000ae  2140              MOVS     r1,#0x40              ;1110
0000b0  4308              ORRS     r0,r0,r1              ;1110
0000b2  6821              LDR      r1,[r4,#0]            ;1110
0000b4  6088              STR      r0,[r1,#8]            ;1110
0000b6  2000              MOVS     r0,#0                 ;1112
0000b8  e7af              B        |L29.26|
                  |L29.186|
0000ba  2002              MOVS     r0,#2                 ;1116
0000bc  e7ad              B        |L29.26|
;;;1119   
                          ENDP

0000be  0000              DCW      0x0000
                  |L29.192|
                          DCD      UART_DMAReceiveCplt
                  |L29.196|
                          DCD      UART_DMARxHalfCplt
                  |L29.200|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_IT PROC
;;;916      */
;;;917    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;918    {
000002  4603              MOV      r3,r0
;;;919      /* Check that a Rx process is not already ongoing */
;;;920      if(huart->RxState == HAL_UART_STATE_READY)
000004  206a              MOVS     r0,#0x6a
000006  5cc0              LDRB     r0,[r0,r3]
000008  2820              CMP      r0,#0x20
00000a  d16a              BNE      |L30.226|
;;;921      {
;;;922        if((pData == NULL ) || (Size == 0U))
00000c  2900              CMP      r1,#0
00000e  d001              BEQ      |L30.20|
000010  2a00              CMP      r2,#0
000012  d101              BNE      |L30.24|
                  |L30.20|
;;;923        {
;;;924          return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L30.22|
;;;925        }
;;;926    
;;;927        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;928           should be aligned on a u16 frontier, as data to be received from RDR will be 
;;;929           handled through a u16 cast. */
;;;930        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;931        {
;;;932          if((((uint32_t)pData)&1U) != 0U)
;;;933          {
;;;934            return  HAL_ERROR;
;;;935          }
;;;936        }
;;;937    
;;;938        /* Process Locked */
;;;939        __HAL_LOCK(huart);
;;;940    
;;;941        huart->pRxBuffPtr = pData;
;;;942        huart->RxXferSize = Size;
;;;943        huart->RxXferCount = Size;
;;;944    
;;;945        /* Computation of UART mask to apply to RDR register */
;;;946        UART_MASK_COMPUTATION(huart);
;;;947    
;;;948        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;949        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;950    
;;;951        /* Process Unlocked */
;;;952        __HAL_UNLOCK(huart);
;;;953    
;;;954        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;955        SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;956    
;;;957        /* Enable the UART Parity Error and Data Register not empty Interrupts */
;;;958        SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;959    
;;;960        return HAL_OK;
;;;961      }
;;;962      else
;;;963      {
;;;964        return HAL_BUSY;
;;;965      }
;;;966    }
000016  bd10              POP      {r4,pc}
                  |L30.24|
000018  2401              MOVS     r4,#1                 ;930
00001a  0324              LSLS     r4,r4,#12             ;930
00001c  6898              LDR      r0,[r3,#8]            ;930
00001e  42a0              CMP      r0,r4                 ;930
000020  d108              BNE      |L30.52|
000022  6918              LDR      r0,[r3,#0x10]         ;930
000024  2800              CMP      r0,#0                 ;930
000026  d105              BNE      |L30.52|
000028  07c8              LSLS     r0,r1,#31             ;932
00002a  0fc0              LSRS     r0,r0,#31             ;932
00002c  2800              CMP      r0,#0                 ;932
00002e  d001              BEQ      |L30.52|
000030  2001              MOVS     r0,#1                 ;934
000032  e7f0              B        |L30.22|
                  |L30.52|
000034  bf00              NOP                            ;939
000036  2068              MOVS     r0,#0x68              ;939
000038  5cc0              LDRB     r0,[r0,r3]            ;939
00003a  2801              CMP      r0,#1                 ;939
00003c  d101              BNE      |L30.66|
00003e  2002              MOVS     r0,#2                 ;939
000040  e7e9              B        |L30.22|
                  |L30.66|
000042  2401              MOVS     r4,#1                 ;939
000044  2068              MOVS     r0,#0x68              ;939
000046  54c4              STRB     r4,[r0,r3]            ;939
000048  bf00              NOP                            ;939
00004a  6559              STR      r1,[r3,#0x54]         ;941
00004c  2058              MOVS     r0,#0x58              ;942
00004e  52c2              STRH     r2,[r0,r3]            ;942
000050  205a              MOVS     r0,#0x5a              ;943
000052  52c2              STRH     r2,[r0,r3]            ;943
000054  bf00              NOP                            ;946
000056  0324              LSLS     r4,r4,#12             ;946
000058  6898              LDR      r0,[r3,#8]            ;946
00005a  42a0              CMP      r0,r4                 ;946
00005c  d10a              BNE      |L30.116|
00005e  6918              LDR      r0,[r3,#0x10]         ;946
000060  2800              CMP      r0,#0                 ;946
000062  d103              BNE      |L30.108|
000064  4c20              LDR      r4,|L30.232|
000066  205c              MOVS     r0,#0x5c              ;946
000068  52c4              STRH     r4,[r0,r3]            ;946
00006a  e020              B        |L30.174|
                  |L30.108|
00006c  24ff              MOVS     r4,#0xff              ;946
00006e  205c              MOVS     r0,#0x5c              ;946
000070  52c4              STRH     r4,[r0,r3]            ;946
000072  e01c              B        |L30.174|
                  |L30.116|
000074  6898              LDR      r0,[r3,#8]            ;946
000076  2800              CMP      r0,#0                 ;946
000078  d10a              BNE      |L30.144|
00007a  6918              LDR      r0,[r3,#0x10]         ;946
00007c  2800              CMP      r0,#0                 ;946
00007e  d103              BNE      |L30.136|
000080  24ff              MOVS     r4,#0xff              ;946
000082  205c              MOVS     r0,#0x5c              ;946
000084  52c4              STRH     r4,[r0,r3]            ;946
000086  e012              B        |L30.174|
                  |L30.136|
000088  247f              MOVS     r4,#0x7f              ;946
00008a  205c              MOVS     r0,#0x5c              ;946
00008c  52c4              STRH     r4,[r0,r3]            ;946
00008e  e00e              B        |L30.174|
                  |L30.144|
000090  2401              MOVS     r4,#1                 ;946
000092  0724              LSLS     r4,r4,#28             ;946
000094  6898              LDR      r0,[r3,#8]            ;946
000096  42a0              CMP      r0,r4                 ;946
000098  d109              BNE      |L30.174|
00009a  6918              LDR      r0,[r3,#0x10]         ;946
00009c  2800              CMP      r0,#0                 ;946
00009e  d103              BNE      |L30.168|
0000a0  247f              MOVS     r4,#0x7f              ;946
0000a2  205c              MOVS     r0,#0x5c              ;946
0000a4  52c4              STRH     r4,[r0,r3]            ;946
0000a6  e002              B        |L30.174|
                  |L30.168|
0000a8  243f              MOVS     r4,#0x3f              ;946
0000aa  205c              MOVS     r0,#0x5c              ;946
0000ac  52c4              STRH     r4,[r0,r3]            ;946
                  |L30.174|
0000ae  bf00              NOP                            ;946
0000b0  2000              MOVS     r0,#0                 ;948
0000b2  66d8              STR      r0,[r3,#0x6c]         ;948
0000b4  2422              MOVS     r4,#0x22              ;949
0000b6  206a              MOVS     r0,#0x6a              ;949
0000b8  54c4              STRB     r4,[r0,r3]            ;949
0000ba  bf00              NOP                            ;952
0000bc  2400              MOVS     r4,#0                 ;952
0000be  2068              MOVS     r0,#0x68              ;952
0000c0  54c4              STRB     r4,[r0,r3]            ;952
0000c2  bf00              NOP                            ;952
0000c4  6818              LDR      r0,[r3,#0]            ;955
0000c6  6880              LDR      r0,[r0,#8]            ;955
0000c8  2401              MOVS     r4,#1                 ;955
0000ca  4320              ORRS     r0,r0,r4              ;955
0000cc  681c              LDR      r4,[r3,#0]            ;955
0000ce  60a0              STR      r0,[r4,#8]            ;955
0000d0  6818              LDR      r0,[r3,#0]            ;958
0000d2  6800              LDR      r0,[r0,#0]            ;958
0000d4  24ff              MOVS     r4,#0xff              ;958
0000d6  3421              ADDS     r4,r4,#0x21           ;958
0000d8  4320              ORRS     r0,r0,r4              ;958
0000da  681c              LDR      r4,[r3,#0]            ;958
0000dc  6020              STR      r0,[r4,#0]            ;958
0000de  2000              MOVS     r0,#0                 ;960
0000e0  e799              B        |L30.22|
                  |L30.226|
0000e2  2002              MOVS     r0,#2                 ;964
0000e4  e797              B        |L30.22|
;;;967    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L30.232|
                          DCD      0x000001ff

                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1839     */
;;;1840   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1841   {
;;;1842     /* Prevent unused argument(s) compilation warning */
;;;1843     UNUSED(huart);
;;;1844   
;;;1845     /* NOTE : This function should not be modified, when the callback is needed,
;;;1846               the HAL_UART_RxCpltCallback can be implemented in the user file.
;;;1847      */
;;;1848   }
;;;1849   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1854     */
;;;1855   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1856   {
;;;1857     /* Prevent unused argument(s) compilation warning */
;;;1858     UNUSED(huart);
;;;1859   
;;;1860     /* NOTE: This function should not be modified, when the callback is needed,
;;;1861              the HAL_UART_RxHalfCpltCallback can be implemented in the user file.
;;;1862      */
;;;1863   }
;;;1864   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;690      */
;;;691    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  b5fe              PUSH     {r1-r7,lr}
;;;692    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;693      uint16_t* tmp;
;;;694      uint32_t tickstart = 0U;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;695    
;;;696      /* Check that a Tx process is not already ongoing */
;;;697      if(huart->gState == HAL_UART_STATE_READY)
00000e  2069              MOVS     r0,#0x69
000010  5d00              LDRB     r0,[r0,r4]
000012  2820              CMP      r0,#0x20
000014  d16a              BNE      |L33.236|
;;;698      {
;;;699        if((pData == NULL ) || (Size == 0U))
000016  2d00              CMP      r5,#0
000018  d001              BEQ      |L33.30|
00001a  2e00              CMP      r6,#0
00001c  d101              BNE      |L33.34|
                  |L33.30|
;;;700        {
;;;701          return  HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L33.32|
;;;702        }
;;;703    
;;;704        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;705           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;706           handled through a u16 cast. */
;;;707        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;708        {
;;;709          if((((uint32_t)pData)&1U) != 0U)
;;;710          {
;;;711            return  HAL_ERROR;
;;;712          }
;;;713        }
;;;714    
;;;715        /* Process Locked */
;;;716        __HAL_LOCK(huart);
;;;717    
;;;718        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;719        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;720    
;;;721        /* Init tickstart for timeout managment*/
;;;722        tickstart = HAL_GetTick();
;;;723    
;;;724        huart->TxXferSize = Size;
;;;725        huart->TxXferCount = Size;
;;;726        while(huart->TxXferCount > 0)
;;;727        {
;;;728          huart->TxXferCount--;
;;;729          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;730          {
;;;731            return HAL_TIMEOUT;
;;;732          }
;;;733          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;734          {
;;;735            tmp = (uint16_t*) pData;
;;;736            huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;737            pData += 2;
;;;738          }
;;;739          else
;;;740          {
;;;741            huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
;;;742          }
;;;743        }
;;;744        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;745        {
;;;746          return HAL_TIMEOUT;
;;;747        }
;;;748    
;;;749        /* At end of Tx process, restore huart->gState to Ready */
;;;750        huart->gState = HAL_UART_STATE_READY;
;;;751    
;;;752        /* Process Unlocked */
;;;753        __HAL_UNLOCK(huart);
;;;754    
;;;755        return HAL_OK;
;;;756      }
;;;757      else
;;;758      {
;;;759        return HAL_BUSY;
;;;760      }
;;;761    }
000020  bdfe              POP      {r1-r7,pc}
                  |L33.34|
000022  2101              MOVS     r1,#1                 ;707
000024  0309              LSLS     r1,r1,#12             ;707
000026  68a0              LDR      r0,[r4,#8]            ;707
000028  4288              CMP      r0,r1                 ;707
00002a  d108              BNE      |L33.62|
00002c  6920              LDR      r0,[r4,#0x10]         ;707
00002e  2800              CMP      r0,#0                 ;707
000030  d105              BNE      |L33.62|
000032  07e8              LSLS     r0,r5,#31             ;709
000034  0fc0              LSRS     r0,r0,#31             ;709
000036  2800              CMP      r0,#0                 ;709
000038  d001              BEQ      |L33.62|
00003a  2001              MOVS     r0,#1                 ;711
00003c  e7f0              B        |L33.32|
                  |L33.62|
00003e  bf00              NOP                            ;716
000040  2068              MOVS     r0,#0x68              ;716
000042  5d00              LDRB     r0,[r0,r4]            ;716
000044  2801              CMP      r0,#1                 ;716
000046  d101              BNE      |L33.76|
000048  2002              MOVS     r0,#2                 ;716
00004a  e7e9              B        |L33.32|
                  |L33.76|
00004c  2101              MOVS     r1,#1                 ;716
00004e  2068              MOVS     r0,#0x68              ;716
000050  5501              STRB     r1,[r0,r4]            ;716
000052  bf00              NOP                            ;716
000054  2000              MOVS     r0,#0                 ;718
000056  66e0              STR      r0,[r4,#0x6c]         ;718
000058  2121              MOVS     r1,#0x21              ;719
00005a  2069              MOVS     r0,#0x69              ;719
00005c  5501              STRB     r1,[r0,r4]            ;719
00005e  f7fffffe          BL       HAL_GetTick
000062  9001              STR      r0,[sp,#4]            ;722
000064  2050              MOVS     r0,#0x50              ;724
000066  5306              STRH     r6,[r0,r4]            ;724
000068  2052              MOVS     r0,#0x52              ;725
00006a  5306              STRH     r6,[r0,r4]            ;725
00006c  e025              B        |L33.186|
                  |L33.110|
00006e  2052              MOVS     r0,#0x52              ;728
000070  5b00              LDRH     r0,[r0,r4]            ;728
000072  1e40              SUBS     r0,r0,#1              ;728
000074  b281              UXTH     r1,r0                 ;728
000076  2052              MOVS     r0,#0x52              ;728
000078  5301              STRH     r1,[r0,r4]            ;728
00007a  9700              STR      r7,[sp,#0]            ;729
00007c  2200              MOVS     r2,#0                 ;729
00007e  2180              MOVS     r1,#0x80              ;729
000080  4620              MOV      r0,r4                 ;729
000082  9b01              LDR      r3,[sp,#4]            ;729
000084  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000088  2800              CMP      r0,#0                 ;729
00008a  d001              BEQ      |L33.144|
00008c  2003              MOVS     r0,#3                 ;731
00008e  e7c7              B        |L33.32|
                  |L33.144|
000090  2101              MOVS     r1,#1                 ;733
000092  0309              LSLS     r1,r1,#12             ;733
000094  68a0              LDR      r0,[r4,#8]            ;733
000096  4288              CMP      r0,r1                 ;733
000098  d10b              BNE      |L33.178|
00009a  6920              LDR      r0,[r4,#0x10]         ;733
00009c  2800              CMP      r0,#0                 ;733
00009e  d108              BNE      |L33.178|
0000a0  9502              STR      r5,[sp,#8]            ;735
0000a2  9d02              LDR      r5,[sp,#8]            ;736
0000a4  8828              LDRH     r0,[r5,#0]            ;736
0000a6  05c0              LSLS     r0,r0,#23             ;736
0000a8  0dc0              LSRS     r0,r0,#23             ;736
0000aa  6821              LDR      r1,[r4,#0]            ;736
0000ac  8508              STRH     r0,[r1,#0x28]         ;736
0000ae  1cad              ADDS     r5,r5,#2              ;737
0000b0  e003              B        |L33.186|
                  |L33.178|
0000b2  7828              LDRB     r0,[r5,#0]            ;741
0000b4  1c6d              ADDS     r5,r5,#1              ;741
0000b6  6821              LDR      r1,[r4,#0]            ;741
0000b8  8508              STRH     r0,[r1,#0x28]         ;741
                  |L33.186|
0000ba  2052              MOVS     r0,#0x52              ;726
0000bc  5b00              LDRH     r0,[r0,r4]            ;726
0000be  2800              CMP      r0,#0                 ;726
0000c0  dcd5              BGT      |L33.110|
0000c2  9700              STR      r7,[sp,#0]            ;744
0000c4  2200              MOVS     r2,#0                 ;744
0000c6  2140              MOVS     r1,#0x40              ;744
0000c8  4620              MOV      r0,r4                 ;744
0000ca  9b01              LDR      r3,[sp,#4]            ;744
0000cc  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000d0  2800              CMP      r0,#0                 ;744
0000d2  d001              BEQ      |L33.216|
0000d4  2003              MOVS     r0,#3                 ;746
0000d6  e7a3              B        |L33.32|
                  |L33.216|
0000d8  2120              MOVS     r1,#0x20              ;750
0000da  2069              MOVS     r0,#0x69              ;750
0000dc  5501              STRB     r1,[r0,r4]            ;750
0000de  bf00              NOP                            ;753
0000e0  2100              MOVS     r1,#0                 ;753
0000e2  2068              MOVS     r0,#0x68              ;753
0000e4  5501              STRB     r1,[r0,r4]            ;753
0000e6  bf00              NOP                            ;753
0000e8  2000              MOVS     r0,#0                 ;755
0000ea  e799              B        |L33.32|
                  |L33.236|
0000ec  2002              MOVS     r0,#2                 ;759
0000ee  e797              B        |L33.32|
;;;762    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;978      */
;;;979    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;980    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;981      /* Check that a Tx process is not already ongoing */
;;;982      if(huart->gState == HAL_UART_STATE_READY)
000008  2069              MOVS     r0,#0x69
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2820              CMP      r0,#0x20
00000e  d14c              BNE      |L34.170|
;;;983      {
;;;984        if((pData == NULL ) || (Size == 0U))
000010  2e00              CMP      r6,#0
000012  d001              BEQ      |L34.24|
000014  2d00              CMP      r5,#0
000016  d101              BNE      |L34.28|
                  |L34.24|
;;;985        {
;;;986          return HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L34.26|
;;;987        }
;;;988    
;;;989        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;990           should be aligned on a u16 frontier, as data copy into TDR will be 
;;;991           handled by DMA from a u16 frontier. */
;;;992        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;993        {
;;;994          if((((uint32_t)pData)&1U) != 0U)
;;;995          {
;;;996            return  HAL_ERROR;
;;;997          }
;;;998        }
;;;999    
;;;1000       /* Process Locked */
;;;1001       __HAL_LOCK(huart);
;;;1002   
;;;1003       huart->pTxBuffPtr = pData;
;;;1004       huart->TxXferSize = Size;
;;;1005       huart->TxXferCount = Size;
;;;1006   
;;;1007       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1008       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1009   
;;;1010       /* Set the UART DMA transfer complete callback */
;;;1011       huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;1012   
;;;1013       /* Set the UART DMA Half transfer complete callback */
;;;1014       huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;1015   
;;;1016       /* Set the DMA error callback */
;;;1017       huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;1018   
;;;1019       /* Set the DMA abort callback */
;;;1020       huart->hdmatx->XferAbortCallback = NULL;
;;;1021   
;;;1022       /* Enable the UART transmit DMA channel */
;;;1023       HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size);
;;;1024   
;;;1025       /* Clear the TC flag in the ICR register */
;;;1026       __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
;;;1027   
;;;1028       /* Process Unlocked */
;;;1029       __HAL_UNLOCK(huart);
;;;1030   
;;;1031       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1032          in the UART CR3 register */
;;;1033       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1034   
;;;1035       return HAL_OK;
;;;1036     }
;;;1037     else
;;;1038     {
;;;1039       return HAL_BUSY;
;;;1040     }
;;;1041   }
00001a  bd70              POP      {r4-r6,pc}
                  |L34.28|
00001c  2101              MOVS     r1,#1                 ;992
00001e  0309              LSLS     r1,r1,#12             ;992
000020  68a0              LDR      r0,[r4,#8]            ;992
000022  4288              CMP      r0,r1                 ;992
000024  d108              BNE      |L34.56|
000026  6920              LDR      r0,[r4,#0x10]         ;992
000028  2800              CMP      r0,#0                 ;992
00002a  d105              BNE      |L34.56|
00002c  07f0              LSLS     r0,r6,#31             ;994
00002e  0fc0              LSRS     r0,r0,#31             ;994
000030  2800              CMP      r0,#0                 ;994
000032  d001              BEQ      |L34.56|
000034  2001              MOVS     r0,#1                 ;996
000036  e7f0              B        |L34.26|
                  |L34.56|
000038  bf00              NOP                            ;1001
00003a  2068              MOVS     r0,#0x68              ;1001
00003c  5d00              LDRB     r0,[r0,r4]            ;1001
00003e  2801              CMP      r0,#1                 ;1001
000040  d101              BNE      |L34.70|
000042  2002              MOVS     r0,#2                 ;1001
000044  e7e9              B        |L34.26|
                  |L34.70|
000046  2101              MOVS     r1,#1                 ;1001
000048  2068              MOVS     r0,#0x68              ;1001
00004a  5501              STRB     r1,[r0,r4]            ;1001
00004c  bf00              NOP                            ;1001
00004e  64e6              STR      r6,[r4,#0x4c]         ;1003
000050  2050              MOVS     r0,#0x50              ;1004
000052  5305              STRH     r5,[r0,r4]            ;1004
000054  2052              MOVS     r0,#0x52              ;1005
000056  5305              STRH     r5,[r0,r4]            ;1005
000058  2000              MOVS     r0,#0                 ;1007
00005a  66e0              STR      r0,[r4,#0x6c]         ;1007
00005c  2121              MOVS     r1,#0x21              ;1008
00005e  2069              MOVS     r0,#0x69              ;1008
000060  5501              STRB     r1,[r0,r4]            ;1008
000062  4813              LDR      r0,|L34.176|
000064  6e21              LDR      r1,[r4,#0x60]         ;1011
000066  6288              STR      r0,[r1,#0x28]         ;1011
000068  4812              LDR      r0,|L34.180|
00006a  6e21              LDR      r1,[r4,#0x60]         ;1014
00006c  62c8              STR      r0,[r1,#0x2c]         ;1014
00006e  4812              LDR      r0,|L34.184|
000070  6e21              LDR      r1,[r4,#0x60]         ;1017
000072  6308              STR      r0,[r1,#0x30]         ;1017
000074  2000              MOVS     r0,#0                 ;1020
000076  6e21              LDR      r1,[r4,#0x60]         ;1020
000078  6348              STR      r0,[r1,#0x34]         ;1020
00007a  6823              LDR      r3,[r4,#0]            ;1023
00007c  461a              MOV      r2,r3                 ;1023
00007e  3228              ADDS     r2,r2,#0x28           ;1023
000080  462b              MOV      r3,r5                 ;1023
000082  6ce1              LDR      r1,[r4,#0x4c]         ;1023
000084  6e20              LDR      r0,[r4,#0x60]         ;1023
000086  f7fffffe          BL       HAL_DMA_Start_IT
00008a  2040              MOVS     r0,#0x40              ;1026
00008c  6821              LDR      r1,[r4,#0]            ;1026
00008e  6208              STR      r0,[r1,#0x20]         ;1026
000090  bf00              NOP                            ;1029
000092  2100              MOVS     r1,#0                 ;1029
000094  2068              MOVS     r0,#0x68              ;1029
000096  5501              STRB     r1,[r0,r4]            ;1029
000098  bf00              NOP                            ;1029
00009a  6820              LDR      r0,[r4,#0]            ;1033
00009c  6880              LDR      r0,[r0,#8]            ;1033
00009e  2180              MOVS     r1,#0x80              ;1033
0000a0  4308              ORRS     r0,r0,r1              ;1033
0000a2  6821              LDR      r1,[r4,#0]            ;1033
0000a4  6088              STR      r0,[r1,#8]            ;1033
0000a6  2000              MOVS     r0,#0                 ;1035
0000a8  e7b7              B        |L34.26|
                  |L34.170|
0000aa  2002              MOVS     r0,#2                 ;1039
0000ac  e7b5              B        |L34.26|
;;;1042   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L34.176|
                          DCD      UART_DMATransmitCplt
                  |L34.180|
                          DCD      UART_DMATxHalfCplt
                  |L34.184|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;860      */
;;;861    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;862    {
000002  4603              MOV      r3,r0
;;;863      /* Check that a Tx process is not already ongoing */
;;;864      if(huart->gState == HAL_UART_STATE_READY)
000004  2069              MOVS     r0,#0x69
000006  5cc0              LDRB     r0,[r0,r3]
000008  2820              CMP      r0,#0x20
00000a  d135              BNE      |L35.120|
;;;865      {
;;;866        if((pData == NULL ) || (Size == 0U))
00000c  2900              CMP      r1,#0
00000e  d001              BEQ      |L35.20|
000010  2a00              CMP      r2,#0
000012  d101              BNE      |L35.24|
                  |L35.20|
;;;867        {
;;;868          return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L35.22|
;;;869        }
;;;870    
;;;871        /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
;;;872           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;873           handled through a u16 cast. */
;;;874        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;875        {
;;;876          if((((uint32_t)pData)&1U) != 0U)
;;;877          {
;;;878            return  HAL_ERROR;
;;;879          }
;;;880        }
;;;881    
;;;882        /* Process Locked */
;;;883        __HAL_LOCK(huart);
;;;884    
;;;885        huart->pTxBuffPtr = pData;
;;;886        huart->TxXferSize = Size;
;;;887        huart->TxXferCount = Size;
;;;888    
;;;889        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;890        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;891    
;;;892        /* Process Unlocked */
;;;893        __HAL_UNLOCK(huart);
;;;894    
;;;895        /* Enable the UART Transmit Data Register Empty Interrupt */
;;;896        SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;897    
;;;898        return HAL_OK;
;;;899      }
;;;900      else
;;;901      {
;;;902        return HAL_BUSY;
;;;903      }
;;;904    }
000016  bd10              POP      {r4,pc}
                  |L35.24|
000018  2401              MOVS     r4,#1                 ;874
00001a  0324              LSLS     r4,r4,#12             ;874
00001c  6898              LDR      r0,[r3,#8]            ;874
00001e  42a0              CMP      r0,r4                 ;874
000020  d108              BNE      |L35.52|
000022  6918              LDR      r0,[r3,#0x10]         ;874
000024  2800              CMP      r0,#0                 ;874
000026  d105              BNE      |L35.52|
000028  07c8              LSLS     r0,r1,#31             ;876
00002a  0fc0              LSRS     r0,r0,#31             ;876
00002c  2800              CMP      r0,#0                 ;876
00002e  d001              BEQ      |L35.52|
000030  2001              MOVS     r0,#1                 ;878
000032  e7f0              B        |L35.22|
                  |L35.52|
000034  bf00              NOP                            ;883
000036  2068              MOVS     r0,#0x68              ;883
000038  5cc0              LDRB     r0,[r0,r3]            ;883
00003a  2801              CMP      r0,#1                 ;883
00003c  d101              BNE      |L35.66|
00003e  2002              MOVS     r0,#2                 ;883
000040  e7e9              B        |L35.22|
                  |L35.66|
000042  2401              MOVS     r4,#1                 ;883
000044  2068              MOVS     r0,#0x68              ;883
000046  54c4              STRB     r4,[r0,r3]            ;883
000048  bf00              NOP                            ;883
00004a  64d9              STR      r1,[r3,#0x4c]         ;885
00004c  2050              MOVS     r0,#0x50              ;886
00004e  52c2              STRH     r2,[r0,r3]            ;886
000050  2052              MOVS     r0,#0x52              ;887
000052  52c2              STRH     r2,[r0,r3]            ;887
000054  2000              MOVS     r0,#0                 ;889
000056  66d8              STR      r0,[r3,#0x6c]         ;889
000058  2421              MOVS     r4,#0x21              ;890
00005a  2069              MOVS     r0,#0x69              ;890
00005c  54c4              STRB     r4,[r0,r3]            ;890
00005e  bf00              NOP                            ;893
000060  2400              MOVS     r4,#0                 ;893
000062  2068              MOVS     r0,#0x68              ;893
000064  54c4              STRB     r4,[r0,r3]            ;893
000066  bf00              NOP                            ;893
000068  6818              LDR      r0,[r3,#0]            ;896
00006a  6800              LDR      r0,[r0,#0]            ;896
00006c  2480              MOVS     r4,#0x80              ;896
00006e  4320              ORRS     r0,r0,r4              ;896
000070  681c              LDR      r4,[r3,#0]            ;896
000072  6020              STR      r0,[r4,#0]            ;896
000074  2000              MOVS     r0,#0                 ;898
000076  e7ce              B        |L35.22|
                  |L35.120|
000078  2002              MOVS     r0,#2                 ;902
00007a  e7cc              B        |L35.22|
;;;905    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1809     */
;;;1810   __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1811   {
;;;1812     /* Prevent unused argument(s) compilation warning */
;;;1813     UNUSED(huart);
;;;1814   
;;;1815     /* NOTE : This function should not be modified, when the callback is needed,
;;;1816               the HAL_UART_TxCpltCallback can be implemented in the user file.
;;;1817      */
;;;1818   }
;;;1819   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1824     */
;;;1825   __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1826   {
;;;1827     /* Prevent unused argument(s) compilation warning */
;;;1828     UNUSED(huart);
;;;1829   
;;;1830     /* NOTE: This function should not be modified, when the callback is needed,
;;;1831              the HAL_UART_TxHalfCpltCallback can be implemented in the user file.
;;;1832      */
;;;1833   }
;;;1834   
                          ENDP


                          AREA ||i.UART_AdvFeatureConfig||, CODE, READONLY, ALIGN=1

                  UART_AdvFeatureConfig PROC
;;;2213     */
;;;2214   void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
000000  8c81              LDRH     r1,[r0,#0x24]
;;;2215   {
;;;2216     /* Check whether the set of advanced features to configure is properly set */
;;;2217     assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
;;;2218   
;;;2219     /* if required, configure TX pin active level inversion */
;;;2220     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
000002  07c9              LSLS     r1,r1,#31
000004  0fc9              LSRS     r1,r1,#31
000006  2900              CMP      r1,#0
000008  d008              BEQ      |L38.28|
;;;2221     {
;;;2222       assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
;;;2223       MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
00000a  6801              LDR      r1,[r0,#0]
00000c  6849              LDR      r1,[r1,#4]
00000e  2201              MOVS     r2,#1
000010  0452              LSLS     r2,r2,#17
000012  4391              BICS     r1,r1,r2
000014  6a82              LDR      r2,[r0,#0x28]
000016  4311              ORRS     r1,r1,r2
000018  6802              LDR      r2,[r0,#0]
00001a  6051              STR      r1,[r2,#4]
                  |L38.28|
;;;2224     }
;;;2225   
;;;2226     /* if required, configure RX pin active level inversion */
;;;2227     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
00001c  2202              MOVS     r2,#2
00001e  6a41              LDR      r1,[r0,#0x24]
000020  4011              ANDS     r1,r1,r2
000022  2900              CMP      r1,#0
000024  d007              BEQ      |L38.54|
;;;2228     {
;;;2229       assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
;;;2230       MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
000026  6801              LDR      r1,[r0,#0]
000028  6849              LDR      r1,[r1,#4]
00002a  03d2              LSLS     r2,r2,#15
00002c  4391              BICS     r1,r1,r2
00002e  6ac2              LDR      r2,[r0,#0x2c]
000030  4311              ORRS     r1,r1,r2
000032  6802              LDR      r2,[r0,#0]
000034  6051              STR      r1,[r2,#4]
                  |L38.54|
;;;2231     }
;;;2232   
;;;2233     /* if required, configure data inversion */
;;;2234     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
000036  2204              MOVS     r2,#4
000038  6a41              LDR      r1,[r0,#0x24]
00003a  4011              ANDS     r1,r1,r2
00003c  2900              CMP      r1,#0
00003e  d007              BEQ      |L38.80|
;;;2235     {
;;;2236       assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
;;;2237       MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
000040  6801              LDR      r1,[r0,#0]
000042  6849              LDR      r1,[r1,#4]
000044  0412              LSLS     r2,r2,#16
000046  4391              BICS     r1,r1,r2
000048  6b02              LDR      r2,[r0,#0x30]
00004a  4311              ORRS     r1,r1,r2
00004c  6802              LDR      r2,[r0,#0]
00004e  6051              STR      r1,[r2,#4]
                  |L38.80|
;;;2238     }
;;;2239   
;;;2240     /* if required, configure RX/TX pins swap */
;;;2241     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
000050  2208              MOVS     r2,#8
000052  6a41              LDR      r1,[r0,#0x24]
000054  4011              ANDS     r1,r1,r2
000056  2900              CMP      r1,#0
000058  d007              BEQ      |L38.106|
;;;2242     {
;;;2243       assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
;;;2244       MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
00005a  6801              LDR      r1,[r0,#0]
00005c  6849              LDR      r1,[r1,#4]
00005e  0312              LSLS     r2,r2,#12
000060  4391              BICS     r1,r1,r2
000062  6b42              LDR      r2,[r0,#0x34]
000064  4311              ORRS     r1,r1,r2
000066  6802              LDR      r2,[r0,#0]
000068  6051              STR      r1,[r2,#4]
                  |L38.106|
;;;2245     }
;;;2246   
;;;2247     /* if required, configure RX overrun detection disabling */
;;;2248     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
00006a  2210              MOVS     r2,#0x10
00006c  6a41              LDR      r1,[r0,#0x24]
00006e  4011              ANDS     r1,r1,r2
000070  2900              CMP      r1,#0
000072  d007              BEQ      |L38.132|
;;;2249     {
;;;2250       assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
;;;2251       MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
000074  6801              LDR      r1,[r0,#0]
000076  6889              LDR      r1,[r1,#8]
000078  0212              LSLS     r2,r2,#8
00007a  4391              BICS     r1,r1,r2
00007c  6b82              LDR      r2,[r0,#0x38]
00007e  4311              ORRS     r1,r1,r2
000080  6802              LDR      r2,[r0,#0]
000082  6091              STR      r1,[r2,#8]
                  |L38.132|
;;;2252     }
;;;2253   
;;;2254     /* if required, configure DMA disabling on reception error */
;;;2255     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
000084  2220              MOVS     r2,#0x20
000086  6a41              LDR      r1,[r0,#0x24]
000088  4011              ANDS     r1,r1,r2
00008a  2900              CMP      r1,#0
00008c  d007              BEQ      |L38.158|
;;;2256     {
;;;2257       assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
;;;2258       MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
00008e  6801              LDR      r1,[r0,#0]
000090  6889              LDR      r1,[r1,#8]
000092  0212              LSLS     r2,r2,#8
000094  4391              BICS     r1,r1,r2
000096  6bc2              LDR      r2,[r0,#0x3c]
000098  4311              ORRS     r1,r1,r2
00009a  6802              LDR      r2,[r0,#0]
00009c  6091              STR      r1,[r2,#8]
                  |L38.158|
;;;2259     }
;;;2260   
;;;2261     /* if required, configure auto Baud rate detection scheme */
;;;2262     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
00009e  2240              MOVS     r2,#0x40
0000a0  6a41              LDR      r1,[r0,#0x24]
0000a2  4011              ANDS     r1,r1,r2
0000a4  2900              CMP      r1,#0
0000a6  d015              BEQ      |L38.212|
;;;2263     {
;;;2264       assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
;;;2265       assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
;;;2266       MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
0000a8  6801              LDR      r1,[r0,#0]
0000aa  6849              LDR      r1,[r1,#4]
0000ac  0392              LSLS     r2,r2,#14
0000ae  4391              BICS     r1,r1,r2
0000b0  6c02              LDR      r2,[r0,#0x40]
0000b2  4311              ORRS     r1,r1,r2
0000b4  6802              LDR      r2,[r0,#0]
0000b6  6051              STR      r1,[r2,#4]
;;;2267       /* set auto Baudrate detection parameters if detection is enabled */
;;;2268       if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
0000b8  2201              MOVS     r2,#1
0000ba  0512              LSLS     r2,r2,#20
0000bc  6c01              LDR      r1,[r0,#0x40]
0000be  4291              CMP      r1,r2
0000c0  d108              BNE      |L38.212|
;;;2269       {
;;;2270         assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
;;;2271         MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
0000c2  6801              LDR      r1,[r0,#0]
0000c4  6849              LDR      r1,[r1,#4]
0000c6  2203              MOVS     r2,#3
0000c8  0552              LSLS     r2,r2,#21
0000ca  4391              BICS     r1,r1,r2
0000cc  6c42              LDR      r2,[r0,#0x44]
0000ce  4311              ORRS     r1,r1,r2
0000d0  6802              LDR      r2,[r0,#0]
0000d2  6051              STR      r1,[r2,#4]
                  |L38.212|
;;;2272       }
;;;2273     }
;;;2274   
;;;2275     /* if required, configure MSB first on communication line */
;;;2276     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
0000d4  2280              MOVS     r2,#0x80
0000d6  6a41              LDR      r1,[r0,#0x24]
0000d8  4011              ANDS     r1,r1,r2
0000da  2900              CMP      r1,#0
0000dc  d007              BEQ      |L38.238|
;;;2277     {
;;;2278       assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
;;;2279       MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
0000de  6801              LDR      r1,[r0,#0]
0000e0  6849              LDR      r1,[r1,#4]
0000e2  0312              LSLS     r2,r2,#12
0000e4  4391              BICS     r1,r1,r2
0000e6  6c82              LDR      r2,[r0,#0x48]
0000e8  4311              ORRS     r1,r1,r2
0000ea  6802              LDR      r2,[r0,#0]
0000ec  6051              STR      r1,[r2,#4]
                  |L38.238|
;;;2280     }
;;;2281   }
0000ee  4770              BX       lr
;;;2282   
                          ENDP


                          AREA ||i.UART_CheckIdleState||, CODE, READONLY, ALIGN=1

                  UART_CheckIdleState PROC
;;;2287     */
;;;2288   HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2289   {
;;;2290   #if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC)
;;;2291     uint32_t tickstart = 0U;
;;;2292   #endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC) */
;;;2293   
;;;2294     /* Initialize the UART ErrorCode */
;;;2295     huart->ErrorCode = HAL_UART_ERROR_NONE;
000002  2000              MOVS     r0,#0
000004  66c8              STR      r0,[r1,#0x6c]
;;;2296   
;;;2297   #if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC)
;;;2298     /* Init tickstart for timeout managment*/
;;;2299     tickstart = HAL_GetTick();
;;;2300   
;;;2301     /* TEACK and REACK bits in ISR are checked only when available (not available on all F0 devices).
;;;2302        Bits are defined for some specific devices, and are available only for UART instances supporting WakeUp from Stop Mode feature. 
;;;2303     */
;;;2304     if (IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance))
;;;2305     {
;;;2306       /* Check if the Transmitter is enabled */
;;;2307       if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
;;;2308       {
;;;2309         /* Wait until TEACK flag is set */
;;;2310         if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
;;;2311         {
;;;2312           /* Timeout occurred */
;;;2313           return HAL_TIMEOUT;
;;;2314         }
;;;2315       }
;;;2316   
;;;2317       /* Check if the Receiver is enabled */
;;;2318       if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
;;;2319       {
;;;2320         /* Wait until REACK flag is set */
;;;2321         if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
;;;2322         {
;;;2323           /* Timeout occurred */
;;;2324           return HAL_TIMEOUT;
;;;2325         }
;;;2326       }
;;;2327     }
;;;2328   #endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC) */
;;;2329   
;;;2330     /* Initialize the UART State */
;;;2331     huart->gState  = HAL_UART_STATE_READY;
000006  2220              MOVS     r2,#0x20
000008  2069              MOVS     r0,#0x69
00000a  5442              STRB     r2,[r0,r1]
;;;2332     huart->RxState = HAL_UART_STATE_READY;
00000c  206a              MOVS     r0,#0x6a
00000e  5442              STRB     r2,[r0,r1]
;;;2333   
;;;2334     /* Process Unlocked */
;;;2335     __HAL_UNLOCK(huart);
000010  bf00              NOP      
000012  2200              MOVS     r2,#0
000014  2068              MOVS     r0,#0x68
000016  5442              STRB     r2,[r0,r1]
000018  bf00              NOP      
;;;2336   
;;;2337     return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;2338   }
00001c  4770              BX       lr
;;;2339   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;2523     */
;;;2524   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2525   {
000002  4605              MOV      r5,r0
;;;2526     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2527     huart->RxXferCount = 0U;
000006  2100              MOVS     r1,#0
000008  205a              MOVS     r0,#0x5a
00000a  5301              STRH     r1,[r0,r4]
;;;2528     huart->TxXferCount = 0U;
00000c  2052              MOVS     r0,#0x52
00000e  5301              STRH     r1,[r0,r4]
;;;2529   
;;;2530     HAL_UART_ErrorCallback(huart);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2531   }
000016  bd70              POP      {r4-r6,pc}
;;;2532   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;2493     */
;;;2494   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2495   {
000002  4605              MOV      r5,r0
;;;2496     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2497   
;;;2498     /* Stop UART DMA Tx request if ongoing */
;;;2499     if (  (huart->gState == HAL_UART_STATE_BUSY_TX)
000006  2069              MOVS     r0,#0x69
000008  5d00              LDRB     r0,[r0,r4]
00000a  2821              CMP      r0,#0x21
00000c  d10b              BNE      |L41.38|
;;;2500         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) )
00000e  6820              LDR      r0,[r4,#0]
000010  6880              LDR      r0,[r0,#8]
000012  2180              MOVS     r1,#0x80
000014  4008              ANDS     r0,r0,r1
000016  2800              CMP      r0,#0
000018  d005              BEQ      |L41.38|
;;;2501     {
;;;2502       huart->TxXferCount = 0U;
00001a  2100              MOVS     r1,#0
00001c  2052              MOVS     r0,#0x52
00001e  5301              STRH     r1,[r0,r4]
;;;2503       UART_EndTxTransfer(huart);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       UART_EndTxTransfer
                  |L41.38|
;;;2504     }
;;;2505   
;;;2506     /* Stop UART DMA Rx request if ongoing */
;;;2507     if (  (huart->RxState == HAL_UART_STATE_BUSY_RX)
000026  206a              MOVS     r0,#0x6a
000028  5d00              LDRB     r0,[r0,r4]
00002a  2822              CMP      r0,#0x22
00002c  d10b              BNE      |L41.70|
;;;2508         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) )
00002e  6820              LDR      r0,[r4,#0]
000030  6880              LDR      r0,[r0,#8]
000032  2140              MOVS     r1,#0x40
000034  4008              ANDS     r0,r0,r1
000036  2800              CMP      r0,#0
000038  d005              BEQ      |L41.70|
;;;2509     {
;;;2510       huart->RxXferCount = 0U;
00003a  2100              MOVS     r1,#0
00003c  205a              MOVS     r0,#0x5a
00003e  5301              STRH     r1,[r0,r4]
;;;2511       UART_EndRxTransfer(huart);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       UART_EndRxTransfer
                  |L41.70|
;;;2512     }
;;;2513   
;;;2514     huart->ErrorCode |= HAL_UART_ERROR_DMA;
000046  6ee0              LDR      r0,[r4,#0x6c]
000048  2110              MOVS     r1,#0x10
00004a  4308              ORRS     r0,r0,r1
00004c  66e0              STR      r0,[r4,#0x6c]
;;;2515     HAL_UART_ErrorCallback(huart);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2516   }
000054  bd70              POP      {r4-r6,pc}
;;;2517   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;2452     */
;;;2453   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2454   {
000002  4605              MOV      r5,r0
;;;2455     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2456   
;;;2457     /* DMA Normal mode */
;;;2458     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  2120              MOVS     r1,#0x20
00000c  4008              ANDS     r0,r0,r1
00000e  2800              CMP      r0,#0
000010  d118              BNE      |L42.68|
;;;2459     {
;;;2460       huart->RxXferCount = 0U;
000012  2100              MOVS     r1,#0
000014  205a              MOVS     r0,#0x5a
000016  5301              STRH     r1,[r0,r4]
;;;2461   
;;;2462       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2463       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000018  6820              LDR      r0,[r4,#0]
00001a  6800              LDR      r0,[r0,#0]
00001c  21ff              MOVS     r1,#0xff
00001e  3101              ADDS     r1,#1
000020  4388              BICS     r0,r0,r1
000022  6821              LDR      r1,[r4,#0]
000024  6008              STR      r0,[r1,#0]
;;;2464       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000026  6820              LDR      r0,[r4,#0]
000028  6880              LDR      r0,[r0,#8]
00002a  0840              LSRS     r0,r0,#1
00002c  0040              LSLS     r0,r0,#1
00002e  6821              LDR      r1,[r4,#0]
000030  6088              STR      r0,[r1,#8]
;;;2465   
;;;2466       /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
;;;2467          in the UART CR3 register */
;;;2468       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000032  6820              LDR      r0,[r4,#0]
000034  6880              LDR      r0,[r0,#8]
000036  2140              MOVS     r1,#0x40
000038  4388              BICS     r0,r0,r1
00003a  6821              LDR      r1,[r4,#0]
00003c  6088              STR      r0,[r1,#8]
;;;2469   
;;;2470       /* At end of Rx process, restore huart->RxState to Ready */
;;;2471       huart->RxState = HAL_UART_STATE_READY;
00003e  2120              MOVS     r1,#0x20
000040  206a              MOVS     r0,#0x6a
000042  5501              STRB     r1,[r0,r4]
                  |L42.68|
;;;2472     }
;;;2473   
;;;2474     HAL_UART_RxCpltCallback(huart);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;2475   }
00004a  bd70              POP      {r4-r6,pc}
;;;2476   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;2582     */
;;;2583   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2584   {
000002  4605              MOV      r5,r0
;;;2585     UART_HandleTypeDef* huart = (UART_HandleTypeDef* )(hdma->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2586     
;;;2587     huart->hdmarx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6e61              LDR      r1,[r4,#0x64]
00000a  6348              STR      r0,[r1,#0x34]
;;;2588   
;;;2589     /* Check if an Abort process is still ongoing */
;;;2590     if(huart->hdmatx != NULL)
00000c  6e20              LDR      r0,[r4,#0x60]
00000e  2800              CMP      r0,#0
000010  d004              BEQ      |L43.28|
;;;2591     {
;;;2592       if(huart->hdmatx->XferAbortCallback != NULL)
000012  6e20              LDR      r0,[r4,#0x60]
000014  6b40              LDR      r0,[r0,#0x34]
000016  2800              CMP      r0,#0
000018  d000              BEQ      |L43.28|
                  |L43.26|
;;;2593       {
;;;2594         return;
;;;2595       }
;;;2596     }
;;;2597     
;;;2598     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2599     huart->TxXferCount = 0U;
;;;2600     huart->RxXferCount = 0U;
;;;2601   
;;;2602     /* Reset errorCode */
;;;2603     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2604   
;;;2605     /* Clear the Error flags in the ICR register */
;;;2606     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
;;;2607   
;;;2608     /* Restore huart->gState and huart->RxState to Ready */
;;;2609     huart->gState  = HAL_UART_STATE_READY;
;;;2610     huart->RxState = HAL_UART_STATE_READY;
;;;2611   
;;;2612     /* Call user Abort complete callback */
;;;2613     HAL_UART_AbortCpltCallback(huart);
;;;2614   }
00001a  bd70              POP      {r4-r6,pc}
                  |L43.28|
00001c  2100              MOVS     r1,#0                 ;2599
00001e  2052              MOVS     r0,#0x52              ;2599
000020  5301              STRH     r1,[r0,r4]            ;2599
000022  205a              MOVS     r0,#0x5a              ;2600
000024  5301              STRH     r1,[r0,r4]            ;2600
000026  2000              MOVS     r0,#0                 ;2603
000028  66e0              STR      r0,[r4,#0x6c]         ;2603
00002a  200f              MOVS     r0,#0xf               ;2606
00002c  6821              LDR      r1,[r4,#0]            ;2606
00002e  6208              STR      r0,[r1,#0x20]         ;2606
000030  2120              MOVS     r1,#0x20              ;2609
000032  2069              MOVS     r0,#0x69              ;2609
000034  5501              STRB     r1,[r0,r4]            ;2609
000036  206a              MOVS     r0,#0x6a              ;2610
000038  5501              STRB     r1,[r0,r4]            ;2610
00003a  4620              MOV      r0,r4                 ;2613
00003c  f7fffffe          BL       HAL_UART_AbortCpltCallback
000040  bf00              NOP      
000042  e7ea              B        |L43.26|
;;;2615   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;2481     */
;;;2482   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2483   {
000002  4604              MOV      r4,r0
;;;2484     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000004  6a65              LDR      r5,[r4,#0x24]
;;;2485   
;;;2486     HAL_UART_RxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;2487   }
00000c  bd70              POP      {r4-r6,pc}
;;;2488   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;2645     */
;;;2646   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2647   {
000002  4605              MOV      r5,r0
;;;2648     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2649   
;;;2650     huart->RxXferCount = 0U;
000006  2100              MOVS     r1,#0
000008  205a              MOVS     r0,#0x5a
00000a  5301              STRH     r1,[r0,r4]
;;;2651   
;;;2652     /* Clear the Error flags in the ICR register */
;;;2653     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
00000c  200f              MOVS     r0,#0xf
00000e  6821              LDR      r1,[r4,#0]
000010  6208              STR      r0,[r1,#0x20]
;;;2654   
;;;2655     /* Restore huart->RxState to Ready */
;;;2656     huart->RxState = HAL_UART_STATE_READY;
000012  2120              MOVS     r1,#0x20
000014  206a              MOVS     r0,#0x6a
000016  5501              STRB     r1,[r0,r4]
;;;2657   
;;;2658     /* Call user Abort complete callback */
;;;2659     HAL_UART_AbortReceiveCpltCallback(huart);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;2660   }
00001e  bd70              POP      {r4-r6,pc}
;;;2661   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2411     */
;;;2412   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2413   {
000002  4605              MOV      r5,r0
;;;2414     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2415     
;;;2416     /* DMA Normal mode */
;;;2417     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  2120              MOVS     r1,#0x20
00000c  4008              ANDS     r0,r0,r1
00000e  2800              CMP      r0,#0
000010  d10f              BNE      |L46.50|
;;;2418     {
;;;2419       huart->TxXferCount = 0;
000012  2100              MOVS     r1,#0
000014  2052              MOVS     r0,#0x52
000016  5301              STRH     r1,[r0,r4]
;;;2420   
;;;2421       /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;2422          in the UART CR3 register */
;;;2423       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000018  6820              LDR      r0,[r4,#0]
00001a  6880              LDR      r0,[r0,#8]
00001c  2180              MOVS     r1,#0x80
00001e  4388              BICS     r0,r0,r1
000020  6821              LDR      r1,[r4,#0]
000022  6088              STR      r0,[r1,#8]
;;;2424   
;;;2425       /* Enable the UART Transmit Complete Interrupt */
;;;2426       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  2140              MOVS     r1,#0x40
00002a  4308              ORRS     r0,r0,r1
00002c  6821              LDR      r1,[r4,#0]
00002e  6008              STR      r0,[r1,#0]
000030  e002              B        |L46.56|
                  |L46.50|
;;;2427     }
;;;2428     /* DMA Circular mode */
;;;2429     else
;;;2430     {
;;;2431       HAL_UART_TxCpltCallback(huart);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_UART_TxCpltCallback
                  |L46.56|
;;;2432     }
;;;2433   
;;;2434   }
000038  bd70              POP      {r4-r6,pc}
;;;2435   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;2540     */
;;;2541   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2542   {
000002  4605              MOV      r5,r0
;;;2543     UART_HandleTypeDef* huart = (UART_HandleTypeDef* )(hdma->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2544     
;;;2545     huart->hdmatx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6e21              LDR      r1,[r4,#0x60]
00000a  6348              STR      r0,[r1,#0x34]
;;;2546   
;;;2547     /* Check if an Abort process is still ongoing */
;;;2548     if(huart->hdmarx != NULL)
00000c  6e60              LDR      r0,[r4,#0x64]
00000e  2800              CMP      r0,#0
000010  d004              BEQ      |L47.28|
;;;2549     {
;;;2550       if(huart->hdmarx->XferAbortCallback != NULL)
000012  6e60              LDR      r0,[r4,#0x64]
000014  6b40              LDR      r0,[r0,#0x34]
000016  2800              CMP      r0,#0
000018  d000              BEQ      |L47.28|
                  |L47.26|
;;;2551       {
;;;2552         return;
;;;2553       }
;;;2554     }
;;;2555     
;;;2556     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2557     huart->TxXferCount = 0U;
;;;2558     huart->RxXferCount = 0U;
;;;2559   
;;;2560     /* Reset errorCode */
;;;2561     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2562   
;;;2563     /* Clear the Error flags in the ICR register */
;;;2564     __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
;;;2565   
;;;2566     /* Restore huart->gState and huart->RxState to Ready */
;;;2567     huart->gState  = HAL_UART_STATE_READY;
;;;2568     huart->RxState = HAL_UART_STATE_READY;
;;;2569   
;;;2570     /* Call user Abort complete callback */
;;;2571     HAL_UART_AbortCpltCallback(huart);
;;;2572   }
00001a  bd70              POP      {r4-r6,pc}
                  |L47.28|
00001c  2100              MOVS     r1,#0                 ;2557
00001e  2052              MOVS     r0,#0x52              ;2557
000020  5301              STRH     r1,[r0,r4]            ;2557
000022  205a              MOVS     r0,#0x5a              ;2558
000024  5301              STRH     r1,[r0,r4]            ;2558
000026  2000              MOVS     r0,#0                 ;2561
000028  66e0              STR      r0,[r4,#0x6c]         ;2561
00002a  200f              MOVS     r0,#0xf               ;2564
00002c  6821              LDR      r1,[r4,#0]            ;2564
00002e  6208              STR      r0,[r1,#0x20]         ;2564
000030  2120              MOVS     r1,#0x20              ;2567
000032  2069              MOVS     r0,#0x69              ;2567
000034  5501              STRB     r1,[r0,r4]            ;2567
000036  206a              MOVS     r0,#0x6a              ;2568
000038  5501              STRB     r1,[r0,r4]            ;2568
00003a  4620              MOV      r0,r4                 ;2571
00003c  f7fffffe          BL       HAL_UART_AbortCpltCallback
000040  bf00              NOP      
000042  e7ea              B        |L47.26|
;;;2573   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;2440     */
;;;2441   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2442   {
000002  4604              MOV      r4,r0
;;;2443     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000004  6a65              LDR      r5,[r4,#0x24]
;;;2444   
;;;2445     HAL_UART_TxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;2446   }
00000c  bd70              POP      {r4-r6,pc}
;;;2447   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;2624     */
;;;2625   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2626   {
000002  4605              MOV      r5,r0
;;;2627     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2628   
;;;2629     huart->TxXferCount = 0U;
000006  2100              MOVS     r1,#0
000008  2052              MOVS     r0,#0x52
00000a  5301              STRH     r1,[r0,r4]
;;;2630   
;;;2631     /* Restore huart->gState to Ready */
;;;2632     huart->gState = HAL_UART_STATE_READY;
00000c  2120              MOVS     r1,#0x20
00000e  2069              MOVS     r0,#0x69
000010  5501              STRB     r1,[r0,r4]
;;;2633   
;;;2634     /* Call user Abort complete callback */
;;;2635     HAL_UART_AbortTransmitCpltCallback(huart);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;2636   }
000018  bd70              POP      {r4-r6,pc}
;;;2637   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;2395     */
;;;2396   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2397   {
;;;2398     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2399     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  6809              LDR      r1,[r1,#0]
000004  22ff              MOVS     r2,#0xff
000006  3221              ADDS     r2,r2,#0x21
000008  4391              BICS     r1,r1,r2
00000a  6802              LDR      r2,[r0,#0]
00000c  6011              STR      r1,[r2,#0]
;;;2400     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6801              LDR      r1,[r0,#0]
000010  6889              LDR      r1,[r1,#8]
000012  0849              LSRS     r1,r1,#1
000014  0049              LSLS     r1,r1,#1
000016  6802              LDR      r2,[r0,#0]
000018  6091              STR      r1,[r2,#8]
;;;2401   
;;;2402     /* At end of Rx process, restore huart->RxState to Ready */
;;;2403     huart->RxState = HAL_UART_STATE_READY;
00001a  2220              MOVS     r2,#0x20
00001c  216a              MOVS     r1,#0x6a
00001e  540a              STRB     r2,[r1,r0]
;;;2404   }
000020  4770              BX       lr
;;;2405   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;2714     */
;;;2715   HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2716   {
000002  4604              MOV      r4,r0
;;;2717     /* Disable the UART Transmit Complete Interrupt */
;;;2718     CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  2140              MOVS     r1,#0x40
00000a  4388              BICS     r0,r0,r1
00000c  6821              LDR      r1,[r4,#0]
00000e  6008              STR      r0,[r1,#0]
;;;2719   
;;;2720     /* Tx process is ended, restore huart->gState to Ready */
;;;2721     huart->gState = HAL_UART_STATE_READY;
000010  2120              MOVS     r1,#0x20
000012  2069              MOVS     r0,#0x69
000014  5501              STRB     r1,[r0,r4]
;;;2722   
;;;2723     HAL_UART_TxCpltCallback(huart);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;2724   
;;;2725     return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;2726   }
00001e  bd10              POP      {r4,pc}
;;;2727   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;2380     */
;;;2381   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2382   {
;;;2383     /* Disable TXEIE and TCIE interrupts */
;;;2384     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  6809              LDR      r1,[r1,#0]
000004  22c0              MOVS     r2,#0xc0
000006  4391              BICS     r1,r1,r2
000008  6802              LDR      r2,[r0,#0]
00000a  6011              STR      r1,[r2,#0]
;;;2385   
;;;2386     /* At end of Tx process, restore huart->gState to Ready */
;;;2387     huart->gState = HAL_UART_STATE_READY;
00000c  2220              MOVS     r2,#0x20
00000e  2169              MOVS     r1,#0x69
000010  540a              STRB     r2,[r1,r0]
;;;2388   }
000012  4770              BX       lr
;;;2389   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;2734     */
;;;2735   HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2736   {
000002  4604              MOV      r4,r0
;;;2737     uint16_t* tmp;
;;;2738     uint16_t  uhMask = huart->Mask;
000004  205c              MOVS     r0,#0x5c
000006  5b07              LDRH     r7,[r0,r4]
;;;2739     uint16_t  uhdata;
;;;2740   
;;;2741     /* Check that a Rx process is ongoing */
;;;2742     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
000008  206a              MOVS     r0,#0x6a
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2822              CMP      r0,#0x22
00000e  d136              BNE      |L53.126|
;;;2743     {
;;;2744       uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
000010  6820              LDR      r0,[r4,#0]
000012  8c85              LDRH     r5,[r0,#0x24]
;;;2745       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
000014  2101              MOVS     r1,#1
000016  0309              LSLS     r1,r1,#12
000018  68a0              LDR      r0,[r4,#8]
00001a  4288              CMP      r0,r1
00001c  d10a              BNE      |L53.52|
00001e  6920              LDR      r0,[r4,#0x10]
000020  2800              CMP      r0,#0
000022  d107              BNE      |L53.52|
;;;2746       {
;;;2747         tmp = (uint16_t*) huart->pRxBuffPtr ;
000024  6d66              LDR      r6,[r4,#0x54]
;;;2748         *tmp = (uint16_t)(uhdata & uhMask);
000026  4628              MOV      r0,r5
000028  4038              ANDS     r0,r0,r7
00002a  8030              STRH     r0,[r6,#0]
;;;2749         huart->pRxBuffPtr +=2U;
00002c  6d60              LDR      r0,[r4,#0x54]
00002e  1c80              ADDS     r0,r0,#2
000030  6560              STR      r0,[r4,#0x54]
000032  e005              B        |L53.64|
                  |L53.52|
;;;2750       }
;;;2751       else
;;;2752       {
;;;2753         *huart->pRxBuffPtr++ = (uint8_t)(uhdata & (uint8_t)uhMask);
000034  b2f8              UXTB     r0,r7
000036  4028              ANDS     r0,r0,r5
000038  6d62              LDR      r2,[r4,#0x54]
00003a  1c51              ADDS     r1,r2,#1
00003c  6561              STR      r1,[r4,#0x54]
00003e  7010              STRB     r0,[r2,#0]
                  |L53.64|
;;;2754       }
;;;2755   
;;;2756       if(--huart->RxXferCount == 0U)
000040  205a              MOVS     r0,#0x5a
000042  5b00              LDRH     r0,[r0,r4]
000044  1e40              SUBS     r0,r0,#1
000046  b281              UXTH     r1,r0
000048  205a              MOVS     r0,#0x5a
00004a  5301              STRH     r1,[r0,r4]
00004c  2900              CMP      r1,#0
00004e  d114              BNE      |L53.122|
;;;2757       {
;;;2758         /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
;;;2759         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000050  6820              LDR      r0,[r4,#0]
000052  6800              LDR      r0,[r0,#0]
000054  21ff              MOVS     r1,#0xff
000056  3121              ADDS     r1,r1,#0x21
000058  4388              BICS     r0,r0,r1
00005a  6821              LDR      r1,[r4,#0]
00005c  6008              STR      r0,[r1,#0]
;;;2760   
;;;2761         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2762         CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00005e  6820              LDR      r0,[r4,#0]
000060  6880              LDR      r0,[r0,#8]
000062  0840              LSRS     r0,r0,#1
000064  0040              LSLS     r0,r0,#1
000066  6821              LDR      r1,[r4,#0]
000068  6088              STR      r0,[r1,#8]
;;;2763   
;;;2764         /* Rx process is completed, restore huart->RxState to Ready */
;;;2765         huart->RxState = HAL_UART_STATE_READY;
00006a  2120              MOVS     r1,#0x20
00006c  206a              MOVS     r0,#0x6a
00006e  5501              STRB     r1,[r0,r4]
;;;2766   
;;;2767         HAL_UART_RxCpltCallback(huart);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;2768   
;;;2769         return HAL_OK;
000076  2000              MOVS     r0,#0
                  |L53.120|
;;;2770       }
;;;2771   
;;;2772       return HAL_OK;
;;;2773     }
;;;2774     else
;;;2775     {
;;;2776       /* Clear RXNE interrupt flag */
;;;2777       __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
;;;2778   
;;;2779       return HAL_BUSY;
;;;2780     }
;;;2781   }
000078  bdf8              POP      {r3-r7,pc}
                  |L53.122|
00007a  2000              MOVS     r0,#0                 ;2772
00007c  e7fc              B        |L53.120|
                  |L53.126|
00007e  6820              LDR      r0,[r4,#0]            ;2777
000080  6980              LDR      r0,[r0,#0x18]         ;2777
000082  2108              MOVS     r1,#8                 ;2777
000084  4308              ORRS     r0,r0,r1              ;2777
000086  6821              LDR      r1,[r4,#0]            ;2777
000088  6188              STR      r0,[r1,#0x18]         ;2777
00008a  2002              MOVS     r0,#2                 ;2779
00008c  e7f4              B        |L53.120|
;;;2782   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;2108     */
;;;2109   HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
000000  b5fe              PUSH     {r1-r7,lr}
;;;2110   {
000002  4604              MOV      r4,r0
;;;2111     uint32_t tmpreg                     = 0x00000000U;
000004  2500              MOVS     r5,#0
;;;2112     UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
000006  2610              MOVS     r6,#0x10
;;;2113     uint16_t brrtemp                    = 0x0000U;
000008  2700              MOVS     r7,#0
;;;2114     uint16_t usartdiv                   = 0x0000U;
00000a  2000              MOVS     r0,#0
00000c  9002              STR      r0,[sp,#8]
;;;2115     HAL_StatusTypeDef ret               = HAL_OK;
00000e  9001              STR      r0,[sp,#4]
;;;2116   
;;;2117     /* Check the parameters */
;;;2118     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;2119     assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;2120     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;2121     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;2122     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;2123     assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;2124     assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
;;;2125     assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;2126   
;;;2127   
;;;2128     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2129     /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
;;;2130      *  the UART Word Length, Parity, Mode and oversampling:
;;;2131      *  set the M bits according to huart->Init.WordLength value
;;;2132      *  set PCE and PS bits according to huart->Init.Parity value
;;;2133      *  set TE and RE bits according to huart->Init.Mode value
;;;2134      *  set OVER8 bit according to huart->Init.OverSampling value */
;;;2135     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
000010  6921              LDR      r1,[r4,#0x10]
000012  68a0              LDR      r0,[r4,#8]
000014  4308              ORRS     r0,r0,r1
000016  6961              LDR      r1,[r4,#0x14]
000018  4308              ORRS     r0,r0,r1
00001a  69e1              LDR      r1,[r4,#0x1c]
00001c  4308              ORRS     r0,r0,r1
00001e  4605              MOV      r5,r0
;;;2136     MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  4974              LDR      r1,|L54.504|
000026  4008              ANDS     r0,r0,r1
000028  4328              ORRS     r0,r0,r5
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
;;;2137   
;;;2138     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;2139     /* Configure the UART Stop Bits: Set STOP[13:12] bits according
;;;2140      * to huart->Init.StopBits value */
;;;2141     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
00002e  6820              LDR      r0,[r4,#0]
000030  6840              LDR      r0,[r0,#4]
000032  2103              MOVS     r1,#3
000034  0309              LSLS     r1,r1,#12
000036  4388              BICS     r0,r0,r1
000038  68e1              LDR      r1,[r4,#0xc]
00003a  4308              ORRS     r0,r0,r1
00003c  6821              LDR      r1,[r4,#0]
00003e  6048              STR      r0,[r1,#4]
;;;2142   
;;;2143     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;2144     /* Configure
;;;2145      * - UART HardWare Flow Control: set CTSE and RTSE bits according
;;;2146      *   to huart->Init.HwFlowCtl value
;;;2147      * - one-bit sampling method versus three samples' majority rule according
;;;2148      *   to huart->Init.OneBitSampling */
;;;2149     tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
000040  6a21              LDR      r1,[r4,#0x20]
000042  69a0              LDR      r0,[r4,#0x18]
000044  4308              ORRS     r0,r0,r1
000046  4605              MOV      r5,r0
;;;2150     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
000048  6820              LDR      r0,[r4,#0]
00004a  6880              LDR      r0,[r0,#8]
00004c  210b              MOVS     r1,#0xb
00004e  0209              LSLS     r1,r1,#8
000050  4388              BICS     r0,r0,r1
000052  4328              ORRS     r0,r0,r5
000054  6821              LDR      r1,[r4,#0]
000056  6088              STR      r0,[r1,#8]
;;;2151   
;;;2152     /*-------------------------- USART BRR Configuration -----------------------*/
;;;2153     UART_GETCLOCKSOURCE(huart, clocksource);
000058  bf00              NOP      
00005a  4968              LDR      r1,|L54.508|
00005c  6820              LDR      r0,[r4,#0]
00005e  4288              CMP      r0,r1
000060  d117              BNE      |L54.146|
000062  4867              LDR      r0,|L54.512|
000064  6b00              LDR      r0,[r0,#0x30]
000066  0780              LSLS     r0,r0,#30
000068  0f80              LSRS     r0,r0,#30
00006a  2800              CMP      r0,#0
00006c  d006              BEQ      |L54.124|
00006e  2801              CMP      r0,#1
000070  d008              BEQ      |L54.132|
000072  2802              CMP      r0,#2
000074  d008              BEQ      |L54.136|
000076  2803              CMP      r0,#3
000078  d108              BNE      |L54.140|
00007a  e001              B        |L54.128|
                  |L54.124|
00007c  2600              MOVS     r6,#0
00007e  e007              B        |L54.144|
                  |L54.128|
000080  2602              MOVS     r6,#2
000082  e005              B        |L54.144|
                  |L54.132|
000084  2604              MOVS     r6,#4
000086  e003              B        |L54.144|
                  |L54.136|
000088  2608              MOVS     r6,#8
00008a  e001              B        |L54.144|
                  |L54.140|
00008c  2610              MOVS     r6,#0x10
00008e  bf00              NOP      
                  |L54.144|
000090  e01e              B        |L54.208|
                  |L54.146|
000092  495c              LDR      r1,|L54.516|
000094  6820              LDR      r0,[r4,#0]
000096  4288              CMP      r0,r1
000098  d101              BNE      |L54.158|
00009a  2600              MOVS     r6,#0
00009c  e018              B        |L54.208|
                  |L54.158|
00009e  495a              LDR      r1,|L54.520|
0000a0  6820              LDR      r0,[r4,#0]
0000a2  4288              CMP      r0,r1
0000a4  d101              BNE      |L54.170|
0000a6  2600              MOVS     r6,#0
0000a8  e012              B        |L54.208|
                  |L54.170|
0000aa  4958              LDR      r1,|L54.524|
0000ac  6820              LDR      r0,[r4,#0]
0000ae  4288              CMP      r0,r1
0000b0  d101              BNE      |L54.182|
0000b2  2600              MOVS     r6,#0
0000b4  e00c              B        |L54.208|
                  |L54.182|
0000b6  4956              LDR      r1,|L54.528|
0000b8  6820              LDR      r0,[r4,#0]
0000ba  4288              CMP      r0,r1
0000bc  d101              BNE      |L54.194|
0000be  2600              MOVS     r6,#0
0000c0  e006              B        |L54.208|
                  |L54.194|
0000c2  4954              LDR      r1,|L54.532|
0000c4  6820              LDR      r0,[r4,#0]
0000c6  4288              CMP      r0,r1
0000c8  d101              BNE      |L54.206|
0000ca  2600              MOVS     r6,#0
0000cc  e000              B        |L54.208|
                  |L54.206|
0000ce  2610              MOVS     r6,#0x10
                  |L54.208|
0000d0  bf00              NOP      
;;;2154     
;;;2155     /* Check UART Over Sampling to set Baud Rate Register */
;;;2156     if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
0000d2  2101              MOVS     r1,#1
0000d4  03c9              LSLS     r1,r1,#15
0000d6  69e0              LDR      r0,[r4,#0x1c]
0000d8  4288              CMP      r0,r1
0000da  d149              BNE      |L54.368|
;;;2157     {
;;;2158       switch (clocksource)
0000dc  2e04              CMP      r6,#4
0000de  d020              BEQ      |L54.290|
0000e0  dc04              BGT      |L54.236|
0000e2  2e00              CMP      r6,#0
0000e4  d007              BEQ      |L54.246|
0000e6  2e02              CMP      r6,#2
0000e8  d132              BNE      |L54.336|
0000ea  e011              B        |L54.272|
                  |L54.236|
0000ec  2e08              CMP      r6,#8
0000ee  d025              BEQ      |L54.316|
0000f0  2e10              CMP      r6,#0x10
0000f2  d12d              BNE      |L54.336|
0000f4  e02d              B        |L54.338|
                  |L54.246|
;;;2159       {
;;;2160         case UART_CLOCKSOURCE_PCLK1:
;;;2161           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
0000f6  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000fa  0040              LSLS     r0,r0,#1
0000fc  6861              LDR      r1,[r4,#4]
0000fe  0849              LSRS     r1,r1,#1
000100  1840              ADDS     r0,r0,r1
000102  9000              STR      r0,[sp,#0]
000104  6861              LDR      r1,[r4,#4]
000106  f7fffffe          BL       __aeabi_uidivmod
00010a  b280              UXTH     r0,r0
00010c  9002              STR      r0,[sp,#8]
;;;2162           break;
00010e  e023              B        |L54.344|
                  |L54.272|
;;;2163         case UART_CLOCKSOURCE_HSI:
;;;2164           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
000110  6861              LDR      r1,[r4,#4]
000112  084a              LSRS     r2,r1,#1
000114  4b40              LDR      r3,|L54.536|
000116  18d0              ADDS     r0,r2,r3
000118  f7fffffe          BL       __aeabi_uidivmod
00011c  b280              UXTH     r0,r0
00011e  9002              STR      r0,[sp,#8]
;;;2165           break;
000120  e01a              B        |L54.344|
                  |L54.290|
;;;2166         case UART_CLOCKSOURCE_SYSCLK:
;;;2167           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
000122  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000126  0040              LSLS     r0,r0,#1
000128  6861              LDR      r1,[r4,#4]
00012a  0849              LSRS     r1,r1,#1
00012c  1840              ADDS     r0,r0,r1
00012e  9000              STR      r0,[sp,#0]
000130  6861              LDR      r1,[r4,#4]
000132  f7fffffe          BL       __aeabi_uidivmod
000136  b280              UXTH     r0,r0
000138  9002              STR      r0,[sp,#8]
;;;2168           break;
00013a  e00d              B        |L54.344|
                  |L54.316|
;;;2169         case UART_CLOCKSOURCE_LSE:
;;;2170           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
00013c  6861              LDR      r1,[r4,#4]
00013e  084a              LSRS     r2,r1,#1
000140  2301              MOVS     r3,#1
000142  041b              LSLS     r3,r3,#16
000144  18d0              ADDS     r0,r2,r3
000146  f7fffffe          BL       __aeabi_uidivmod
00014a  b280              UXTH     r0,r0
00014c  9002              STR      r0,[sp,#8]
;;;2171           break;
00014e  e003              B        |L54.344|
                  |L54.336|
;;;2172         case UART_CLOCKSOURCE_UNDEFINED:
000150  bf00              NOP      
                  |L54.338|
;;;2173         default:
;;;2174           ret = HAL_ERROR;
000152  2001              MOVS     r0,#1
000154  9001              STR      r0,[sp,#4]
;;;2175           break;
000156  bf00              NOP      
                  |L54.344|
000158  bf00              NOP                            ;2162
;;;2176       }
;;;2177   
;;;2178       brrtemp = usartdiv & 0xFFF0U;
00015a  4930              LDR      r1,|L54.540|
00015c  9802              LDR      r0,[sp,#8]
00015e  4008              ANDS     r0,r0,r1
000160  4607              MOV      r7,r0
;;;2179       brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
000162  9802              LDR      r0,[sp,#8]
000164  0700              LSLS     r0,r0,#28
000166  0f40              LSRS     r0,r0,#29
000168  4307              ORRS     r7,r7,r0
;;;2180       huart->Instance->BRR = brrtemp;
00016a  6820              LDR      r0,[r4,#0]
00016c  60c7              STR      r7,[r0,#0xc]
00016e  e040              B        |L54.498|
                  |L54.368|
;;;2181     }
;;;2182     else
;;;2183     {
;;;2184       switch (clocksource)
000170  2e04              CMP      r6,#4
000172  d021              BEQ      |L54.440|
000174  dc04              BGT      |L54.384|
000176  2e00              CMP      r6,#0
000178  d007              BEQ      |L54.394|
00017a  2e02              CMP      r6,#2
00017c  d134              BNE      |L54.488|
00017e  e011              B        |L54.420|
                  |L54.384|
000180  2e08              CMP      r6,#8
000182  d026              BEQ      |L54.466|
000184  2e10              CMP      r6,#0x10
000186  d12f              BNE      |L54.488|
000188  e02f              B        |L54.490|
                  |L54.394|
;;;2185       {
;;;2186         case UART_CLOCKSOURCE_PCLK1:
;;;2187           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
00018a  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00018e  6861              LDR      r1,[r4,#4]
000190  0849              LSRS     r1,r1,#1
000192  1840              ADDS     r0,r0,r1
000194  9000              STR      r0,[sp,#0]
000196  6861              LDR      r1,[r4,#4]
000198  f7fffffe          BL       __aeabi_uidivmod
00019c  b280              UXTH     r0,r0
00019e  6821              LDR      r1,[r4,#0]
0001a0  60c8              STR      r0,[r1,#0xc]
;;;2188           break;
0001a2  e025              B        |L54.496|
                  |L54.420|
;;;2189         case UART_CLOCKSOURCE_HSI:
;;;2190           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
0001a4  6861              LDR      r1,[r4,#4]
0001a6  084a              LSRS     r2,r1,#1
0001a8  4b1d              LDR      r3,|L54.544|
0001aa  18d0              ADDS     r0,r2,r3
0001ac  f7fffffe          BL       __aeabi_uidivmod
0001b0  b280              UXTH     r0,r0
0001b2  6821              LDR      r1,[r4,#0]
0001b4  60c8              STR      r0,[r1,#0xc]
;;;2191           break;
0001b6  e01b              B        |L54.496|
                  |L54.440|
;;;2192         case UART_CLOCKSOURCE_SYSCLK:
;;;2193           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
0001b8  f7fffffe          BL       HAL_RCC_GetSysClockFreq
0001bc  6861              LDR      r1,[r4,#4]
0001be  0849              LSRS     r1,r1,#1
0001c0  1840              ADDS     r0,r0,r1
0001c2  9000              STR      r0,[sp,#0]
0001c4  6861              LDR      r1,[r4,#4]
0001c6  f7fffffe          BL       __aeabi_uidivmod
0001ca  b280              UXTH     r0,r0
0001cc  6821              LDR      r1,[r4,#0]
0001ce  60c8              STR      r0,[r1,#0xc]
;;;2194           break;
0001d0  e00e              B        |L54.496|
                  |L54.466|
;;;2195         case UART_CLOCKSOURCE_LSE:
;;;2196           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
0001d2  6861              LDR      r1,[r4,#4]
0001d4  084a              LSRS     r2,r1,#1
0001d6  2301              MOVS     r3,#1
0001d8  03db              LSLS     r3,r3,#15
0001da  18d0              ADDS     r0,r2,r3
0001dc  f7fffffe          BL       __aeabi_uidivmod
0001e0  b280              UXTH     r0,r0
0001e2  6821              LDR      r1,[r4,#0]
0001e4  60c8              STR      r0,[r1,#0xc]
;;;2197           break;
0001e6  e003              B        |L54.496|
                  |L54.488|
;;;2198         case UART_CLOCKSOURCE_UNDEFINED:
0001e8  bf00              NOP      
                  |L54.490|
;;;2199         default:
;;;2200           ret = HAL_ERROR;
0001ea  2001              MOVS     r0,#1
0001ec  9001              STR      r0,[sp,#4]
;;;2201           break;
0001ee  bf00              NOP      
                  |L54.496|
0001f0  bf00              NOP                            ;2188
                  |L54.498|
;;;2202       }
;;;2203     }
;;;2204   
;;;2205     return ret;
0001f2  9801              LDR      r0,[sp,#4]
;;;2206   
;;;2207   }
0001f4  bdfe              POP      {r1-r7,pc}
;;;2208   
                          ENDP

0001f6  0000              DCW      0x0000
                  |L54.504|
                          DCD      0xefff69f3
                  |L54.508|
                          DCD      0x40013800
                  |L54.512|
                          DCD      0x40021000
                  |L54.516|
                          DCD      0x40004400
                  |L54.520|
                          DCD      0x40004800
                  |L54.524|
                          DCD      0x40004c00
                  |L54.528|
                          DCD      0x40005000
                  |L54.532|
                          DCD      0x40011400
                  |L54.536|
                          DCD      0x00f42400
                  |L54.540|
                          DCD      0x0000fff0
                  |L54.544|
                          DCD      0x007a1200

                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;2668     */
;;;2669   HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2670   {
;;;2671     uint16_t* tmp;
;;;2672   
;;;2673     /* Check that a Tx process is ongoing */
;;;2674     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000002  2069              MOVS     r0,#0x69
000004  5c40              LDRB     r0,[r0,r1]
000006  2821              CMP      r0,#0x21
000008  d131              BNE      |L55.110|
;;;2675     {
;;;2676       if(huart->TxXferCount == 0U)
00000a  2052              MOVS     r0,#0x52
00000c  5a40              LDRH     r0,[r0,r1]
00000e  2800              CMP      r0,#0
000010  d10d              BNE      |L55.46|
;;;2677       {
;;;2678         /* Disable the UART Transmit Data Register Empty Interrupt */
;;;2679         CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
000012  6808              LDR      r0,[r1,#0]
000014  6800              LDR      r0,[r0,#0]
000016  2380              MOVS     r3,#0x80
000018  4398              BICS     r0,r0,r3
00001a  680b              LDR      r3,[r1,#0]
00001c  6018              STR      r0,[r3,#0]
;;;2680   
;;;2681         /* Enable the UART Transmit Complete Interrupt */
;;;2682         SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
00001e  6808              LDR      r0,[r1,#0]
000020  6800              LDR      r0,[r0,#0]
000022  2340              MOVS     r3,#0x40
000024  4318              ORRS     r0,r0,r3
000026  680b              LDR      r3,[r1,#0]
000028  6018              STR      r0,[r3,#0]
;;;2683   
;;;2684         return HAL_OK;
00002a  2000              MOVS     r0,#0
                  |L55.44|
;;;2685       }
;;;2686       else
;;;2687       {
;;;2688         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;2689         {
;;;2690           tmp = (uint16_t*) huart->pTxBuffPtr;
;;;2691           huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;2692           huart->pTxBuffPtr += 2U;
;;;2693         }
;;;2694         else
;;;2695         {
;;;2696           huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0xFFU);
;;;2697         }
;;;2698         huart->TxXferCount--;
;;;2699   
;;;2700         return HAL_OK;
;;;2701       }
;;;2702     }
;;;2703     else
;;;2704     {
;;;2705       return HAL_BUSY;
;;;2706     }
;;;2707   }
00002c  4770              BX       lr
                  |L55.46|
00002e  2301              MOVS     r3,#1                 ;2688
000030  031b              LSLS     r3,r3,#12             ;2688
000032  6888              LDR      r0,[r1,#8]            ;2688
000034  4298              CMP      r0,r3                 ;2688
000036  d10c              BNE      |L55.82|
000038  6908              LDR      r0,[r1,#0x10]         ;2688
00003a  2800              CMP      r0,#0                 ;2688
00003c  d109              BNE      |L55.82|
00003e  6cca              LDR      r2,[r1,#0x4c]         ;2690
000040  8810              LDRH     r0,[r2,#0]            ;2691
000042  05c0              LSLS     r0,r0,#23             ;2691
000044  0dc0              LSRS     r0,r0,#23             ;2691
000046  680b              LDR      r3,[r1,#0]            ;2691
000048  8518              STRH     r0,[r3,#0x28]         ;2691
00004a  6cc8              LDR      r0,[r1,#0x4c]         ;2692
00004c  1c80              ADDS     r0,r0,#2              ;2692
00004e  64c8              STR      r0,[r1,#0x4c]         ;2692
000050  e005              B        |L55.94|
                  |L55.82|
000052  6ccb              LDR      r3,[r1,#0x4c]         ;2696
000054  1c58              ADDS     r0,r3,#1              ;2696
000056  64c8              STR      r0,[r1,#0x4c]         ;2696
000058  7818              LDRB     r0,[r3,#0]            ;2696
00005a  680b              LDR      r3,[r1,#0]            ;2696
00005c  8518              STRH     r0,[r3,#0x28]         ;2696
                  |L55.94|
00005e  2052              MOVS     r0,#0x52              ;2698
000060  5a40              LDRH     r0,[r0,r1]            ;2698
000062  1e40              SUBS     r0,r0,#1              ;2698
000064  b283              UXTH     r3,r0                 ;2698
000066  2052              MOVS     r0,#0x52              ;2698
000068  5243              STRH     r3,[r0,r1]            ;2698
00006a  2000              MOVS     r0,#0                 ;2700
00006c  e7de              B        |L55.44|
                  |L55.110|
00006e  2002              MOVS     r0,#2                 ;2705
000070  e7dc              B        |L55.44|
;;;2708   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;2348     */
;;;2349   HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;2350   {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  9e0a              LDR      r6,[sp,#0x28]
;;;2351     /* Wait until flag is set */
;;;2352     while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
00000c  e024              B        |L56.88|
                  |L56.14|
;;;2353     {
;;;2354       /* Check for the Timeout */
;;;2355       if(Timeout != HAL_MAX_DELAY)
00000e  1c70              ADDS     r0,r6,#1
000010  2800              CMP      r0,#0
000012  d021              BEQ      |L56.88|
;;;2356       {
;;;2357         if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
000014  2e00              CMP      r6,#0
000016  d005              BEQ      |L56.36|
000018  f7fffffe          BL       HAL_GetTick
00001c  9904              LDR      r1,[sp,#0x10]
00001e  1a40              SUBS     r0,r0,r1
000020  42b0              CMP      r0,r6
000022  d919              BLS      |L56.88|
                  |L56.36|
;;;2358         {
;;;2359           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2360           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  21ff              MOVS     r1,#0xff
00002a  31a1              ADDS     r1,r1,#0xa1
00002c  4388              BICS     r0,r0,r1
00002e  6821              LDR      r1,[r4,#0]
000030  6008              STR      r0,[r1,#0]
;;;2361           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000032  6820              LDR      r0,[r4,#0]
000034  6880              LDR      r0,[r0,#8]
000036  0840              LSRS     r0,r0,#1
000038  0040              LSLS     r0,r0,#1
00003a  6821              LDR      r1,[r4,#0]
00003c  6088              STR      r0,[r1,#8]
;;;2362   
;;;2363           huart->gState  = HAL_UART_STATE_READY;
00003e  2120              MOVS     r1,#0x20
000040  2069              MOVS     r0,#0x69
000042  5501              STRB     r1,[r0,r4]
;;;2364           huart->RxState = HAL_UART_STATE_READY;
000044  206a              MOVS     r0,#0x6a
000046  5501              STRB     r1,[r0,r4]
;;;2365   
;;;2366           /* Process Unlocked */
;;;2367           __HAL_UNLOCK(huart);
000048  bf00              NOP      
00004a  2100              MOVS     r1,#0
00004c  2068              MOVS     r0,#0x68
00004e  5501              STRB     r1,[r0,r4]
000050  bf00              NOP      
;;;2368           return HAL_TIMEOUT;
000052  2003              MOVS     r0,#3
                  |L56.84|
;;;2369         }
;;;2370       }
;;;2371     }
;;;2372     return HAL_OK;
;;;2373   }
000054  b005              ADD      sp,sp,#0x14
000056  bdf0              POP      {r4-r7,pc}
                  |L56.88|
000058  6820              LDR      r0,[r4,#0]            ;2352
00005a  69c0              LDR      r0,[r0,#0x1c]         ;2352
00005c  4028              ANDS     r0,r0,r5              ;2352
00005e  42a8              CMP      r0,r5                 ;2352
000060  d101              BNE      |L56.102|
000062  2001              MOVS     r0,#1                 ;2352
000064  e000              B        |L56.104|
                  |L56.102|
000066  2000              MOVS     r0,#0                 ;2352
                  |L56.104|
000068  42b8              CMP      r0,r7                 ;2352
00006a  d0d0              BEQ      |L56.14|
00006c  2000              MOVS     r0,#0                 ;2372
00006e  e7f1              B        |L56.84|
;;;2374   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\stm32f03xx_HAL\\Src\\stm32f0xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f0xx_hal_uart_c_d497114f____REV16|
#line 388 "..\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f0xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f0xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f0xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
