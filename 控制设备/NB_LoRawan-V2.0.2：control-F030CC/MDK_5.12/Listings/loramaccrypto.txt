; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\loramaccrypto.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\loramaccrypto.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS\Device\ST\STM32F0xx\Include -I..\CMSIS\Include -I..\stm32f03xx_HAL\Inc -I..\USER -I..\HAL\inc -I..\HAL\system -I..\Lib\LoRawan-node\misc -I..\Lib\LoRawan-node\crypto -I..\Lib\LoRawan-node\mac -I..\Lib\LoRawan-node\radio -I..\Lib\LoRawan-node\radio\sx1276 -I..\Lib -IE:\NBI项目\NBI_LoRa\LoRa版本备份\NB_LoRawan-V2.0.2：control-F030CC\MDK_5.12\RTE -ID:\mysaftware\keil_5.12\ARM\PACK\Keil\STM32F0xx_DFP\1.5.0\Device\Include -ID:\mysaftware\keil_5.12\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=518 -DSTM32F030xC -DUSE_HAL_DRIVER -DSTM32F030xC -DUSE_MODEM_LORA -DUSE_BAND_433 --omf_browse=.\objects\loramaccrypto.crf ..\Lib\LoRawan-node\mac\LoRaMacCrypto.c]
                          THUMB

                          AREA ||i.LoRaMacComputeMic||, CODE, READONLY, ALIGN=2

                  LoRaMacComputeMic PROC
;;;87      */
;;;88     void LoRaMacComputeMic( const uint8_t *buffer, uint16_t size, const uint8_t *key, uint32_t address, uint8_t dir, uint32_t sequenceCounter, uint32_t *mic )
000000  b5ff              PUSH     {r0-r7,lr}
;;;89     {
000002  b081              SUB      sp,sp,#4
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  461c              MOV      r4,r3
00000a  9d0b              LDR      r5,[sp,#0x2c]
;;;90         MicBlockB0[5] = dir;
00000c  491e              LDR      r1,|L1.136|
00000e  980a              LDR      r0,[sp,#0x28]
000010  7148              STRB     r0,[r1,#5]
;;;91         
;;;92         MicBlockB0[6] = ( address ) & 0xFF;
000012  718c              STRB     r4,[r1,#6]
;;;93         MicBlockB0[7] = ( address >> 8 ) & 0xFF;
000014  0420              LSLS     r0,r4,#16
000016  0e00              LSRS     r0,r0,#24
000018  71c8              STRB     r0,[r1,#7]
;;;94         MicBlockB0[8] = ( address >> 16 ) & 0xFF;
00001a  0220              LSLS     r0,r4,#8
00001c  0e00              LSRS     r0,r0,#24
00001e  7208              STRB     r0,[r1,#8]
;;;95         MicBlockB0[9] = ( address >> 24 ) & 0xFF;
000020  0e20              LSRS     r0,r4,#24
000022  7248              STRB     r0,[r1,#9]
;;;96     
;;;97         MicBlockB0[10] = ( sequenceCounter ) & 0xFF;
000024  728d              STRB     r5,[r1,#0xa]
;;;98         MicBlockB0[11] = ( sequenceCounter >> 8 ) & 0xFF;
000026  0428              LSLS     r0,r5,#16
000028  0e00              LSRS     r0,r0,#24
00002a  72c8              STRB     r0,[r1,#0xb]
;;;99         MicBlockB0[12] = ( sequenceCounter >> 16 ) & 0xFF;
00002c  0228              LSLS     r0,r5,#8
00002e  0e00              LSRS     r0,r0,#24
000030  7308              STRB     r0,[r1,#0xc]
;;;100        MicBlockB0[13] = ( sequenceCounter >> 24 ) & 0xFF;
000032  0e28              LSRS     r0,r5,#24
000034  7348              STRB     r0,[r1,#0xd]
;;;101    
;;;102        MicBlockB0[15] = size & 0xFF;
000036  73ce              STRB     r6,[r1,#0xf]
;;;103    
;;;104        AES_CMAC_Init( AesCmacCtx );
000038  4814              LDR      r0,|L1.140|
00003a  f7fffffe          BL       AES_CMAC_Init
;;;105    
;;;106        AES_CMAC_SetKey( AesCmacCtx, key );
00003e  4813              LDR      r0,|L1.140|
000040  9903              LDR      r1,[sp,#0xc]
000042  f7fffffe          BL       AES_CMAC_SetKey
;;;107    
;;;108        AES_CMAC_Update( AesCmacCtx, MicBlockB0, LORAMAC_MIC_BLOCK_B0_SIZE );
000046  2210              MOVS     r2,#0x10
000048  490f              LDR      r1,|L1.136|
00004a  4810              LDR      r0,|L1.140|
00004c  f7fffffe          BL       AES_CMAC_Update
;;;109        
;;;110        AES_CMAC_Update( AesCmacCtx, buffer, size & 0xFF );
000050  b2f2              UXTB     r2,r6
000052  4639              MOV      r1,r7
000054  480d              LDR      r0,|L1.140|
000056  f7fffffe          BL       AES_CMAC_Update
;;;111        
;;;112        AES_CMAC_Final( Mic, AesCmacCtx );
00005a  490c              LDR      r1,|L1.140|
00005c  480c              LDR      r0,|L1.144|
00005e  f7fffffe          BL       AES_CMAC_Final
;;;113        
;;;114        *mic = ( uint32_t )( ( uint32_t )Mic[3] << 24 | ( uint32_t )Mic[2] << 16 | ( uint32_t )Mic[1] << 8 | ( uint32_t )Mic[0] );
000062  480b              LDR      r0,|L1.144|
000064  78c0              LDRB     r0,[r0,#3]  ; Mic
000066  0600              LSLS     r0,r0,#24
000068  4909              LDR      r1,|L1.144|
00006a  7889              LDRB     r1,[r1,#2]  ; Mic
00006c  0409              LSLS     r1,r1,#16
00006e  4308              ORRS     r0,r0,r1
000070  4907              LDR      r1,|L1.144|
000072  7849              LDRB     r1,[r1,#1]  ; Mic
000074  0209              LSLS     r1,r1,#8
000076  4308              ORRS     r0,r0,r1
000078  4905              LDR      r1,|L1.144|
00007a  7809              LDRB     r1,[r1,#0]  ; Mic
00007c  4308              ORRS     r0,r0,r1
00007e  990c              LDR      r1,[sp,#0x30]
000080  6008              STR      r0,[r1,#0]
;;;115    }
000082  b005              ADD      sp,sp,#0x14
000084  bdf0              POP      {r4-r7,pc}
;;;116    
                          ENDP

000086  0000              DCW      0x0000
                  |L1.136|
                          DCD      MicBlockB0
                  |L1.140|
                          DCD      AesCmacCtx
                  |L1.144|
                          DCD      Mic

                          AREA ||i.LoRaMacJoinComputeMic||, CODE, READONLY, ALIGN=2

                  LoRaMacJoinComputeMic PROC
;;;166    
;;;167    void LoRaMacJoinComputeMic( const uint8_t *buffer, uint16_t size, const uint8_t *key, uint32_t *mic )
000000  b5f8              PUSH     {r3-r7,lr}
;;;168    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;169        AES_CMAC_Init( AesCmacCtx );
00000a  4810              LDR      r0,|L2.76|
00000c  f7fffffe          BL       AES_CMAC_Init
;;;170    
;;;171        AES_CMAC_SetKey( AesCmacCtx, key );
000010  4631              MOV      r1,r6
000012  480e              LDR      r0,|L2.76|
000014  f7fffffe          BL       AES_CMAC_SetKey
;;;172    
;;;173        AES_CMAC_Update( AesCmacCtx, buffer, size & 0xFF );
000018  b2ea              UXTB     r2,r5
00001a  4621              MOV      r1,r4
00001c  480b              LDR      r0,|L2.76|
00001e  f7fffffe          BL       AES_CMAC_Update
;;;174    
;;;175        AES_CMAC_Final( Mic, AesCmacCtx );
000022  490a              LDR      r1,|L2.76|
000024  480a              LDR      r0,|L2.80|
000026  f7fffffe          BL       AES_CMAC_Final
;;;176    
;;;177        *mic = ( uint32_t )( ( uint32_t )Mic[3] << 24 | ( uint32_t )Mic[2] << 16 | ( uint32_t )Mic[1] << 8 | ( uint32_t )Mic[0] );
00002a  4809              LDR      r0,|L2.80|
00002c  78c0              LDRB     r0,[r0,#3]  ; Mic
00002e  0600              LSLS     r0,r0,#24
000030  4907              LDR      r1,|L2.80|
000032  7889              LDRB     r1,[r1,#2]  ; Mic
000034  0409              LSLS     r1,r1,#16
000036  4308              ORRS     r0,r0,r1
000038  4905              LDR      r1,|L2.80|
00003a  7849              LDRB     r1,[r1,#1]  ; Mic
00003c  0209              LSLS     r1,r1,#8
00003e  4308              ORRS     r0,r0,r1
000040  4903              LDR      r1,|L2.80|
000042  7809              LDRB     r1,[r1,#0]  ; Mic
000044  4308              ORRS     r0,r0,r1
000046  6038              STR      r0,[r7,#0]
;;;178    }
000048  bdf8              POP      {r3-r7,pc}
;;;179    
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      AesCmacCtx
                  |L2.80|
                          DCD      Mic

                          AREA ||i.LoRaMacJoinComputeSKeys||, CODE, READONLY, ALIGN=2

                  LoRaMacJoinComputeSKeys PROC
;;;191    
;;;192    void LoRaMacJoinComputeSKeys( const uint8_t *key, const uint8_t *appNonce, uint16_t devNonce, uint8_t *nwkSKey, uint8_t *appSKey )
000000  b5ff              PUSH     {r0-r7,lr}
;;;193    {
000002  b085              SUB      sp,sp,#0x14
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  461c              MOV      r4,r3
00000a  9f0e              LDR      r7,[sp,#0x38]
;;;194        uint8_t nonce[16];
;;;195        uint8_t *pDevNonce = ( uint8_t * )&devNonce;
00000c  a807              ADD      r0,sp,#0x1c
00000e  9000              STR      r0,[sp,#0]
;;;196        
;;;197        memset1( AesContext.ksch, '\0', 240 );
000010  22f0              MOVS     r2,#0xf0
000012  2100              MOVS     r1,#0
000014  481c              LDR      r0,|L3.136|
000016  f7fffffe          BL       memset1
;;;198        aes_set_key( key, 16, &AesContext );
00001a  4a1b              LDR      r2,|L3.136|
00001c  2110              MOVS     r1,#0x10
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       aes_set_key
;;;199    
;;;200        memset1( nonce, 0, sizeof( nonce ) );
000024  2210              MOVS     r2,#0x10
000026  2100              MOVS     r1,#0
000028  a801              ADD      r0,sp,#4
00002a  f7fffffe          BL       memset1
;;;201        nonce[0] = 0x01;
00002e  2101              MOVS     r1,#1
000030  4668              MOV      r0,sp
000032  7101              STRB     r1,[r0,#4]
;;;202        memcpy1( nonce + 1, appNonce, 6 );
000034  2206              MOVS     r2,#6
000036  4631              MOV      r1,r6
000038  1d40              ADDS     r0,r0,#5
00003a  f7fffffe          BL       memcpy1
;;;203        memcpy1( nonce + 7, pDevNonce, 2 );
00003e  2202              MOVS     r2,#2
000040  a802              ADD      r0,sp,#8
000042  3003              ADDS     r0,#3
000044  9900              LDR      r1,[sp,#0]
000046  f7fffffe          BL       memcpy1
;;;204        aes_encrypt( nonce, nwkSKey, &AesContext );
00004a  4a0f              LDR      r2,|L3.136|
00004c  4621              MOV      r1,r4
00004e  a801              ADD      r0,sp,#4
000050  f7fffffe          BL       aes_encrypt
;;;205    
;;;206        memset1( nonce, 0, sizeof( nonce ) );
000054  2210              MOVS     r2,#0x10
000056  2100              MOVS     r1,#0
000058  a801              ADD      r0,sp,#4
00005a  f7fffffe          BL       memset1
;;;207        nonce[0] = 0x02;
00005e  2102              MOVS     r1,#2
000060  4668              MOV      r0,sp
000062  7101              STRB     r1,[r0,#4]
;;;208        memcpy1( nonce + 1, appNonce, 6 );
000064  2206              MOVS     r2,#6
000066  4631              MOV      r1,r6
000068  1d40              ADDS     r0,r0,#5
00006a  f7fffffe          BL       memcpy1
;;;209        memcpy1( nonce + 7, pDevNonce, 2 );
00006e  2202              MOVS     r2,#2
000070  a802              ADD      r0,sp,#8
000072  3003              ADDS     r0,#3
000074  9900              LDR      r1,[sp,#0]
000076  f7fffffe          BL       memcpy1
;;;210        aes_encrypt( nonce, appSKey, &AesContext );
00007a  4a03              LDR      r2,|L3.136|
00007c  4639              MOV      r1,r7
00007e  a801              ADD      r0,sp,#4
000080  f7fffffe          BL       aes_encrypt
;;;211    }
000084  b009              ADD      sp,sp,#0x24
000086  bdf0              POP      {r4-r7,pc}
                          ENDP

                  |L3.136|
                          DCD      AesContext

                          AREA ||i.LoRaMacJoinDecrypt||, CODE, READONLY, ALIGN=2

                  LoRaMacJoinDecrypt PROC
;;;179    
;;;180    void LoRaMacJoinDecrypt( const uint8_t *buffer, uint16_t size, const uint8_t *key, uint8_t *decBuffer )
000000  b5f8              PUSH     {r3-r7,lr}
;;;181    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
000008  461c              MOV      r4,r3
;;;182        memset1( AesContext.ksch, '\0', 240 );
00000a  22f0              MOVS     r2,#0xf0
00000c  2100              MOVS     r1,#0
00000e  480b              LDR      r0,|L4.60|
000010  f7fffffe          BL       memset1
;;;183        aes_set_key( key, 16, &AesContext );
000014  4a09              LDR      r2,|L4.60|
000016  2110              MOVS     r1,#0x10
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       aes_set_key
;;;184        aes_encrypt( buffer, decBuffer, &AesContext );
00001e  4a07              LDR      r2,|L4.60|
000020  4621              MOV      r1,r4
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       aes_encrypt
;;;185        // Check if optional CFList is included
;;;186        if( size >= 16 )
000028  2e10              CMP      r6,#0x10
00002a  db06              BLT      |L4.58|
;;;187        {
;;;188            aes_encrypt( buffer + 16, decBuffer + 16, &AesContext );
00002c  4a03              LDR      r2,|L4.60|
00002e  4621              MOV      r1,r4
000030  3110              ADDS     r1,r1,#0x10
000032  4628              MOV      r0,r5
000034  3010              ADDS     r0,r0,#0x10
000036  f7fffffe          BL       aes_encrypt
                  |L4.58|
;;;189        }
;;;190    }
00003a  bdf8              POP      {r3-r7,pc}
;;;191    
                          ENDP

                  |L4.60|
                          DCD      AesContext

                          AREA ||i.LoRaMacPayloadDecrypt||, CODE, READONLY, ALIGN=1

                  LoRaMacPayloadDecrypt PROC
;;;161    
;;;162    void LoRaMacPayloadDecrypt( const uint8_t *buffer, uint16_t size, const uint8_t *key, uint32_t address, uint8_t dir, uint32_t sequenceCounter, uint8_t *decBuffer )
000000  b5ff              PUSH     {r0-r7,lr}
;;;163    {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  9f0e              LDR      r7,[sp,#0x38]
00000a  9e0c              LDR      r6,[sp,#0x30]
;;;164        LoRaMacPayloadEncrypt( buffer, size, key, address, dir, sequenceCounter, decBuffer );
00000c  980d              LDR      r0,[sp,#0x34]
00000e  9702              STR      r7,[sp,#8]
000010  9600              STR      r6,[sp,#0]
000012  9001              STR      r0,[sp,#4]
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  9b06              LDR      r3,[sp,#0x18]
00001a  9a05              LDR      r2,[sp,#0x14]
00001c  f7fffffe          BL       LoRaMacPayloadEncrypt
;;;165    }
000020  b007              ADD      sp,sp,#0x1c
000022  bdf0              POP      {r4-r7,pc}
;;;166    
                          ENDP


                          AREA ||i.LoRaMacPayloadEncrypt||, CODE, READONLY, ALIGN=2

                  LoRaMacPayloadEncrypt PROC
;;;116    
;;;117    void LoRaMacPayloadEncrypt( const uint8_t *buffer, uint16_t size, const uint8_t *key, uint32_t address, uint8_t dir, uint32_t sequenceCounter, uint8_t *encBuffer )
000000  b5ff              PUSH     {r0-r7,lr}
;;;118    {
000002  b081              SUB      sp,sp,#4
000004  460d              MOV      r5,r1
000006  461e              MOV      r6,r3
;;;119        uint16_t i;
;;;120        uint8_t bufferIndex = 0;
000008  2700              MOVS     r7,#0
;;;121        uint16_t ctr = 1;
00000a  2001              MOVS     r0,#1
00000c  9000              STR      r0,[sp,#0]
;;;122    
;;;123        memset1( AesContext.ksch, '\0', 240 );
00000e  22f0              MOVS     r2,#0xf0
000010  2100              MOVS     r1,#0
000012  4830              LDR      r0,|L6.212|
000014  f7fffffe          BL       memset1
;;;124        aes_set_key( key, 16, &AesContext );
000018  4a2e              LDR      r2,|L6.212|
00001a  2110              MOVS     r1,#0x10
00001c  9803              LDR      r0,[sp,#0xc]
00001e  f7fffffe          BL       aes_set_key
;;;125    
;;;126        aBlock[5] = dir;
000022  492d              LDR      r1,|L6.216|
000024  980a              LDR      r0,[sp,#0x28]
000026  7148              STRB     r0,[r1,#5]
;;;127    
;;;128        aBlock[6] = ( address ) & 0xFF;
000028  718e              STRB     r6,[r1,#6]
;;;129        aBlock[7] = ( address >> 8 ) & 0xFF;
00002a  0430              LSLS     r0,r6,#16
00002c  0e00              LSRS     r0,r0,#24
00002e  71c8              STRB     r0,[r1,#7]
;;;130        aBlock[8] = ( address >> 16 ) & 0xFF;
000030  0230              LSLS     r0,r6,#8
000032  0e00              LSRS     r0,r0,#24
000034  7208              STRB     r0,[r1,#8]
;;;131        aBlock[9] = ( address >> 24 ) & 0xFF;
000036  0e30              LSRS     r0,r6,#24
000038  7248              STRB     r0,[r1,#9]
;;;132    
;;;133        aBlock[10] = ( sequenceCounter ) & 0xFF;
00003a  980b              LDR      r0,[sp,#0x2c]
00003c  7288              STRB     r0,[r1,#0xa]
;;;134        aBlock[11] = ( sequenceCounter >> 8 ) & 0xFF;
00003e  980b              LDR      r0,[sp,#0x2c]
000040  0400              LSLS     r0,r0,#16
000042  0e00              LSRS     r0,r0,#24
000044  72c8              STRB     r0,[r1,#0xb]
;;;135        aBlock[12] = ( sequenceCounter >> 16 ) & 0xFF;
000046  980b              LDR      r0,[sp,#0x2c]
000048  0200              LSLS     r0,r0,#8
00004a  0e00              LSRS     r0,r0,#24
00004c  7308              STRB     r0,[r1,#0xc]
;;;136        aBlock[13] = ( sequenceCounter >> 24 ) & 0xFF;
00004e  980b              LDR      r0,[sp,#0x2c]
000050  0e00              LSRS     r0,r0,#24
000052  7348              STRB     r0,[r1,#0xd]
;;;137    
;;;138        while( size >= 16 )
000054  e020              B        |L6.152|
                  |L6.86|
;;;139        {
;;;140            aBlock[15] = ( ( ctr ) & 0xFF );
000056  4920              LDR      r1,|L6.216|
000058  9800              LDR      r0,[sp,#0]
00005a  73c8              STRB     r0,[r1,#0xf]
;;;141            ctr++;
00005c  9800              LDR      r0,[sp,#0]
00005e  1c40              ADDS     r0,r0,#1
000060  b280              UXTH     r0,r0
000062  9000              STR      r0,[sp,#0]
;;;142            aes_encrypt( aBlock, sBlock, &AesContext );
000064  4a1b              LDR      r2,|L6.212|
000066  491d              LDR      r1,|L6.220|
000068  481b              LDR      r0,|L6.216|
00006a  f7fffffe          BL       aes_encrypt
;;;143            for( i = 0; i < 16; i++ )
00006e  2400              MOVS     r4,#0
000070  e00a              B        |L6.136|
                  |L6.114|
;;;144            {
;;;145                encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
000072  1939              ADDS     r1,r7,r4
000074  9801              LDR      r0,[sp,#4]
000076  5c40              LDRB     r0,[r0,r1]
000078  4918              LDR      r1,|L6.220|
00007a  5d09              LDRB     r1,[r1,r4]
00007c  4048              EORS     r0,r0,r1
00007e  193a              ADDS     r2,r7,r4
000080  990c              LDR      r1,[sp,#0x30]
000082  5488              STRB     r0,[r1,r2]
000084  1c60              ADDS     r0,r4,#1              ;143
000086  b284              UXTH     r4,r0                 ;143
                  |L6.136|
000088  2c10              CMP      r4,#0x10              ;143
00008a  dbf2              BLT      |L6.114|
;;;146            }
;;;147            size -= 16;
00008c  4628              MOV      r0,r5
00008e  3810              SUBS     r0,r0,#0x10
000090  b285              UXTH     r5,r0
;;;148            bufferIndex += 16;
000092  4638              MOV      r0,r7
000094  3010              ADDS     r0,r0,#0x10
000096  b2c7              UXTB     r7,r0
                  |L6.152|
000098  2d10              CMP      r5,#0x10              ;138
00009a  dadc              BGE      |L6.86|
;;;149        }
;;;150    
;;;151        if( size > 0 )
00009c  2d00              CMP      r5,#0
00009e  dd16              BLE      |L6.206|
;;;152        {
;;;153            aBlock[15] = ( ( ctr ) & 0xFF );
0000a0  490d              LDR      r1,|L6.216|
0000a2  9800              LDR      r0,[sp,#0]
0000a4  73c8              STRB     r0,[r1,#0xf]
;;;154            aes_encrypt( aBlock, sBlock, &AesContext );
0000a6  4a0b              LDR      r2,|L6.212|
0000a8  490c              LDR      r1,|L6.220|
0000aa  480b              LDR      r0,|L6.216|
0000ac  f7fffffe          BL       aes_encrypt
;;;155            for( i = 0; i < size; i++ )
0000b0  2400              MOVS     r4,#0
0000b2  e00a              B        |L6.202|
                  |L6.180|
;;;156            {
;;;157                encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
0000b4  1939              ADDS     r1,r7,r4
0000b6  9801              LDR      r0,[sp,#4]
0000b8  5c40              LDRB     r0,[r0,r1]
0000ba  4908              LDR      r1,|L6.220|
0000bc  5d09              LDRB     r1,[r1,r4]
0000be  4048              EORS     r0,r0,r1
0000c0  193a              ADDS     r2,r7,r4
0000c2  990c              LDR      r1,[sp,#0x30]
0000c4  5488              STRB     r0,[r1,r2]
0000c6  1c60              ADDS     r0,r4,#1              ;155
0000c8  b284              UXTH     r4,r0                 ;155
                  |L6.202|
0000ca  42ac              CMP      r4,r5                 ;155
0000cc  dbf2              BLT      |L6.180|
                  |L6.206|
;;;158            }
;;;159        }
;;;160    }
0000ce  b005              ADD      sp,sp,#0x14
0000d0  bdf0              POP      {r4-r7,pc}
;;;161    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L6.212|
                          DCD      AesContext
                  |L6.216|
                          DCD      aBlock
                  |L6.220|
                          DCD      sBlock

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Mic
                          %        16
                  sBlock
                          %        16
                  AesContext
                          %        244
                  AesCmacCtx
                          %        280

                          AREA ||.data||, DATA, ALIGN=2

                  MicBlockB0
000000  49000000          DCB      0x49,0x00,0x00,0x00
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  aBlock
000010  01000000          DCB      0x01,0x00,0x00,0x00
000014  00000000          DCB      0x00,0x00,0x00,0x00
000018  00000000          DCB      0x00,0x00,0x00,0x00
00001c  00000000          DCB      0x00,0x00,0x00,0x00
