; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usart.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS\Device\ST\STM32F0xx\Include -I..\CMSIS\Include -I..\stm32f03xx_HAL\Inc -I..\USER -I..\HAL\inc -I..\HAL\system -I..\Lib\LoRawan-node\misc -I..\Lib\LoRawan-node\crypto -I..\Lib\LoRawan-node\mac -I..\Lib\LoRawan-node\radio -I..\Lib\LoRawan-node\radio\sx1276 -I..\Lib -IE:\NBI项目\NBI_LoRa\LoRa版本备份\NB_LoRawan-V2.0.2：control-F030CC\MDK_5.12\RTE -ID:\mysaftware\keil_5.12\ARM\PACK\Keil\STM32F0xx_DFP\1.5.0\Device\Include -ID:\mysaftware\keil_5.12\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=518 -DSTM32F030xC -DUSE_HAL_DRIVER -DSTM32F030xC -DUSE_MODEM_LORA -DUSE_BAND_433 --omf_browse=.\objects\usart.crf ..\HAL\src\usart.c]
                          THUMB

                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=2

                  HAL_UART_MspDeInit PROC
;;;156    
;;;157    void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
000000  b510              PUSH     {r4,lr}
;;;158    {
000002  4604              MOV      r4,r0
;;;159    
;;;160      if(uartHandle->Instance==USART1)
000004  4911              LDR      r1,|L1.76|
000006  6820              LDR      r0,[r4,#0]
000008  4288              CMP      r0,r1
00000a  d10b              BNE      |L1.36|
;;;161      {
;;;162        /* Peripheral clock disable */
;;;163        __HAL_RCC_USART1_CLK_DISABLE();
00000c  4810              LDR      r0,|L1.80|
00000e  6980              LDR      r0,[r0,#0x18]
000010  2101              MOVS     r1,#1
000012  0389              LSLS     r1,r1,#14
000014  4388              BICS     r0,r0,r1
000016  490e              LDR      r1,|L1.80|
000018  6188              STR      r0,[r1,#0x18]
;;;164      
;;;165        /**USART1 GPIO Configuration    
;;;166        PB6     ------> USART1_TX
;;;167        PB7     ------> USART1_RX 
;;;168        */
;;;169        HAL_GPIO_DeInit(GPIOB, GPIO_PIN_6|GPIO_PIN_7);
00001a  21c0              MOVS     r1,#0xc0
00001c  480d              LDR      r0,|L1.84|
00001e  f7fffffe          BL       HAL_GPIO_DeInit
000022  e011              B        |L1.72|
                  |L1.36|
;;;170      }  
;;;171    	else if(uartHandle->Instance==USART5)
000024  490c              LDR      r1,|L1.88|
000026  6820              LDR      r0,[r4,#0]
000028  4288              CMP      r0,r1
00002a  d10d              BNE      |L1.72|
;;;172      {
;;;173        /* Peripheral clock disable */
;;;174        __HAL_RCC_USART5_CLK_DISABLE();
00002c  4808              LDR      r0,|L1.80|
00002e  69c0              LDR      r0,[r0,#0x1c]
000030  2101              MOVS     r1,#1
000032  0509              LSLS     r1,r1,#20
000034  4388              BICS     r0,r0,r1
000036  4906              LDR      r1,|L1.80|
000038  61c8              STR      r0,[r1,#0x1c]
;;;175      
;;;176        /**USART5 GPIO Configuration    
;;;177        PB3     ------> USART5_TX
;;;178        PB4     ------> USART5_RX 
;;;179        */
;;;180        HAL_GPIO_DeInit(GPIOB, GPIO_PIN_3|GPIO_PIN_4);
00003a  2118              MOVS     r1,#0x18
00003c  4805              LDR      r0,|L1.84|
00003e  f7fffffe          BL       HAL_GPIO_DeInit
;;;181    
;;;182        /* Peripheral interrupt Deinit*/
;;;183        HAL_NVIC_DisableIRQ(USART3_6_IRQn);
000042  201d              MOVS     r0,#0x1d
000044  f7fffffe          BL       HAL_NVIC_DisableIRQ
                  |L1.72|
;;;184      }
;;;185    } 
000048  bd10              POP      {r4,pc}
;;;186    
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
                          DCD      0x40013800
                  |L1.80|
                          DCD      0x40021000
                  |L1.84|
                          DCD      0x48000400
                  |L1.88|
                          DCD      0x40005000

                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=2

                  HAL_UART_MspInit PROC
;;;117    
;;;118    void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
000000  b510              PUSH     {r4,lr}
;;;119    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;120    
;;;121      GPIO_InitTypeDef GPIO_InitStruct;
;;;122      if(uartHandle->Instance==USART1)
000006  492b              LDR      r1,|L2.180|
000008  6820              LDR      r0,[r4,#0]
00000a  4288              CMP      r0,r1
00000c  d12d              BNE      |L2.106|
;;;123      {
;;;124        /* Peripheral clock enable */
;;;125        __HAL_RCC_USART1_CLK_ENABLE();
00000e  bf00              NOP      
000010  4829              LDR      r0,|L2.184|
000012  6980              LDR      r0,[r0,#0x18]
000014  2101              MOVS     r1,#1
000016  0389              LSLS     r1,r1,#14
000018  4308              ORRS     r0,r0,r1
00001a  4927              LDR      r1,|L2.184|
00001c  6188              STR      r0,[r1,#0x18]
00001e  4608              MOV      r0,r1
000020  6980              LDR      r0,[r0,#0x18]
000022  2101              MOVS     r1,#1
000024  0389              LSLS     r1,r1,#14
000026  4008              ANDS     r0,r0,r1
000028  9000              STR      r0,[sp,#0]
00002a  bf00              NOP      
00002c  bf00              NOP      
;;;126    		__HAL_RCC_GPIOB_CLK_ENABLE();
00002e  bf00              NOP      
000030  4821              LDR      r0,|L2.184|
000032  6940              LDR      r0,[r0,#0x14]
000034  0109              LSLS     r1,r1,#4
000036  4308              ORRS     r0,r0,r1
000038  491f              LDR      r1,|L2.184|
00003a  6148              STR      r0,[r1,#0x14]
00003c  4608              MOV      r0,r1
00003e  6940              LDR      r0,[r0,#0x14]
000040  2101              MOVS     r1,#1
000042  0489              LSLS     r1,r1,#18
000044  4008              ANDS     r0,r0,r1
000046  9000              STR      r0,[sp,#0]
000048  bf00              NOP      
00004a  bf00              NOP      
;;;127      
;;;128        /**USART1 GPIO Configuration    
;;;129        PB6     ------> USART1_TX
;;;130        PB7     ------> USART1_RX 
;;;131        */
;;;132        GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
00004c  20c0              MOVS     r0,#0xc0
00004e  9001              STR      r0,[sp,#4]
;;;133        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
000050  2002              MOVS     r0,#2
000052  9002              STR      r0,[sp,#8]
;;;134        GPIO_InitStruct.Pull = GPIO_PULLUP;
000054  2001              MOVS     r0,#1
000056  9003              STR      r0,[sp,#0xc]
;;;135        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
000058  2003              MOVS     r0,#3
00005a  9004              STR      r0,[sp,#0x10]
;;;136        GPIO_InitStruct.Alternate = GPIO_AF0_USART1;
00005c  2000              MOVS     r0,#0
00005e  9005              STR      r0,[sp,#0x14]
;;;137        HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
000060  a901              ADD      r1,sp,#4
000062  4816              LDR      r0,|L2.188|
000064  f7fffffe          BL       HAL_GPIO_Init
000068  e021              B        |L2.174|
                  |L2.106|
;;;138      }  
;;;139    	else if(uartHandle->Instance==USART5)
00006a  4915              LDR      r1,|L2.192|
00006c  6820              LDR      r0,[r4,#0]
00006e  4288              CMP      r0,r1
000070  d11d              BNE      |L2.174|
;;;140      {
;;;141        /* Peripheral clock enable */
;;;142        __HAL_RCC_USART5_CLK_ENABLE();
000072  bf00              NOP      
000074  4810              LDR      r0,|L2.184|
000076  69c0              LDR      r0,[r0,#0x1c]
000078  2101              MOVS     r1,#1
00007a  0509              LSLS     r1,r1,#20
00007c  4308              ORRS     r0,r0,r1
00007e  490e              LDR      r1,|L2.184|
000080  61c8              STR      r0,[r1,#0x1c]
000082  4608              MOV      r0,r1
000084  69c0              LDR      r0,[r0,#0x1c]
000086  2101              MOVS     r1,#1
000088  0509              LSLS     r1,r1,#20
00008a  4008              ANDS     r0,r0,r1
00008c  9000              STR      r0,[sp,#0]
00008e  bf00              NOP      
000090  bf00              NOP      
;;;143      
;;;144        /**USART5 GPIO Configuration    
;;;145        PB3     ------> USART5_TX
;;;146        PB4     ------> USART5_RX 
;;;147        */
;;;148        GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4;
000092  2018              MOVS     r0,#0x18
000094  9001              STR      r0,[sp,#4]
;;;149        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
000096  2002              MOVS     r0,#2
000098  9002              STR      r0,[sp,#8]
;;;150        GPIO_InitStruct.Pull = GPIO_PULLUP;
00009a  2001              MOVS     r0,#1
00009c  9003              STR      r0,[sp,#0xc]
;;;151        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
00009e  2003              MOVS     r0,#3
0000a0  9004              STR      r0,[sp,#0x10]
;;;152        GPIO_InitStruct.Alternate = GPIO_AF4_USART5;
0000a2  2004              MOVS     r0,#4
0000a4  9005              STR      r0,[sp,#0x14]
;;;153        HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
0000a6  a901              ADD      r1,sp,#4
0000a8  4804              LDR      r0,|L2.188|
0000aa  f7fffffe          BL       HAL_GPIO_Init
                  |L2.174|
;;;154      }
;;;155    }
0000ae  b006              ADD      sp,sp,#0x18
0000b0  bd10              POP      {r4,pc}
;;;156    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L2.180|
                          DCD      0x40013800
                  |L2.184|
                          DCD      0x40021000
                  |L2.188|
                          DCD      0x48000400
                  |L2.192|
                          DCD      0x40005000

                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  HAL_UART_RxCpltCallback PROC
;;;188    
;;;189    void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;190    {
000002  4604              MOV      r4,r0
;;;191    	if(huart->Instance==USART5)//如果是串口5
000004  491a              LDR      r1,|L3.112|
000006  6820              LDR      r0,[r4,#0]
000008  4288              CMP      r0,r1
00000a  d130              BNE      |L3.110|
;;;192    	{		
;;;193    		if(UART_RX_DATA.aRxBuffer[0] == '#' && UART_RX_DATA.USART_RX_Len == 4)  ///以'#' = 0x23作为结束标记  
00000c  4819              LDR      r0,|L3.116|
00000e  7980              LDRB     r0,[r0,#6]  ; UART_RX_DATA
000010  2823              CMP      r0,#0x23
000012  d10c              BNE      |L3.46|
000014  4817              LDR      r0,|L3.116|
000016  8880              LDRH     r0,[r0,#4]  ; UART_RX_DATA
000018  2804              CMP      r0,#4
00001a  d108              BNE      |L3.46|
;;;194    		{
;;;195    			UART_RX_DATA.USART_TX_STATE = true;		
00001c  2001              MOVS     r0,#1
00001e  4915              LDR      r1,|L3.116|
000020  71c8              STRB     r0,[r1,#7]
;;;196    			DEBUG(2,"len = %d\r\n",UART_RX_DATA.USART_RX_Len);
000022  4608              MOV      r0,r1
000024  8881              LDRH     r1,[r0,#4]  ; UART_RX_DATA
000026  a014              ADR      r0,|L3.120|
000028  f7fffffe          BL       __2printf
00002c  e016              B        |L3.92|
                  |L3.46|
;;;197    		}
;;;198    		else if(UART_RX_DATA.aRxBuffer[0] == '\n') 
00002e  4811              LDR      r0,|L3.116|
000030  7980              LDRB     r0,[r0,#6]  ; UART_RX_DATA
000032  280a              CMP      r0,#0xa
000034  d108              BNE      |L3.72|
;;;199    		{
;;;200    			DEBUG(4,"rx = %s\r\n",UART_RX_DATA.USART_RX_BUF);
;;;201    			memset(UART_RX_DATA.USART_RX_BUF, 0, UART_RX_DATA.USART_RX_Len);
000036  480f              LDR      r0,|L3.116|
000038  8881              LDRH     r1,[r0,#4]  ; UART_RX_DATA
00003a  4812              LDR      r0,|L3.132|
00003c  f7fffffe          BL       __aeabi_memclr4
;;;202    			UART_RX_DATA.USART_RX_Len = 0;
000040  2100              MOVS     r1,#0
000042  480c              LDR      r0,|L3.116|
000044  8081              STRH     r1,[r0,#4]
000046  e009              B        |L3.92|
                  |L3.72|
;;;203    		}
;;;204    		else
;;;205    		{
;;;206    			UART_RX_DATA.USART_RX_BUF[UART_RX_DATA.USART_RX_Len]=UART_RX_DATA.aRxBuffer[0]; ///直接存取数据，不做printf,printf花费时间多会导致缺失
000048  480a              LDR      r0,|L3.116|
00004a  7981              LDRB     r1,[r0,#6]  ; UART_RX_DATA
00004c  8882              LDRH     r2,[r0,#4]  ; UART_RX_DATA
00004e  480d              LDR      r0,|L3.132|
000050  5481              STRB     r1,[r0,r2]
;;;207    			UART_RX_DATA.USART_RX_Len++;
000052  4808              LDR      r0,|L3.116|
000054  8880              LDRH     r0,[r0,#4]  ; UART_RX_DATA
000056  1c40              ADDS     r0,r0,#1
000058  4906              LDR      r1,|L3.116|
00005a  8088              STRH     r0,[r1,#4]
                  |L3.92|
;;;208    		}
;;;209    		if(UART_RX_DATA.USART_RX_Len >= 1024)
00005c  4805              LDR      r0,|L3.116|
00005e  8880              LDRH     r0,[r0,#4]  ; UART_RX_DATA
000060  2101              MOVS     r1,#1
000062  0289              LSLS     r1,r1,#10
000064  4288              CMP      r0,r1
000066  db02              BLT      |L3.110|
;;;210    			UART_RX_DATA.USART_RX_Len = 0;
000068  2000              MOVS     r0,#0
00006a  4902              LDR      r1,|L3.116|
00006c  8088              STRH     r0,[r1,#4]
                  |L3.110|
;;;211    	}	
;;;212    }
00006e  bd10              POP      {r4,pc}
;;;213    
                          ENDP

                  |L3.112|
                          DCD      0x40005000
                  |L3.116|
                          DCD      UART_RX_DATA+0x400
                  |L3.120|
000078  6c656e20          DCB      "len = %d\r\n",0
00007c  3d202564
000080  0d0a00  
000083  00                DCB      0
                  |L3.132|
                          DCD      UART_RX_DATA+0x4

                          AREA ||i.MX_USART1_UART_Init||, CODE, READONLY, ALIGN=2

                  MX_USART1_UART_Init PROC
;;;74     
;;;75     void MX_USART1_UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;76     {
;;;77     
;;;78       huart1.Instance = USART1;
000002  480e              LDR      r0,|L4.60|
000004  490e              LDR      r1,|L4.64|
000006  6008              STR      r0,[r1,#0]  ; huart1
;;;79       huart1.Init.BaudRate = 115200;
000008  20e1              MOVS     r0,#0xe1
00000a  0240              LSLS     r0,r0,#9
00000c  6048              STR      r0,[r1,#4]  ; huart1
;;;80       huart1.Init.WordLength = UART_WORDLENGTH_8B;
00000e  2100              MOVS     r1,#0
000010  480b              LDR      r0,|L4.64|
000012  6081              STR      r1,[r0,#8]
;;;81       huart1.Init.StopBits = UART_STOPBITS_1;
000014  60c1              STR      r1,[r0,#0xc]
;;;82       huart1.Init.Parity = UART_PARITY_NONE;
000016  6101              STR      r1,[r0,#0x10]
;;;83       huart1.Init.Mode = UART_MODE_TX_RX;
000018  210c              MOVS     r1,#0xc
00001a  6141              STR      r1,[r0,#0x14]
;;;84       huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
00001c  2100              MOVS     r1,#0
00001e  6181              STR      r1,[r0,#0x18]
;;;85       huart1.Init.OverSampling = UART_OVERSAMPLING_16;
000020  61c1              STR      r1,[r0,#0x1c]
;;;86       huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
000022  6201              STR      r1,[r0,#0x20]
;;;87       huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
000024  2000              MOVS     r0,#0
000026  4906              LDR      r1,|L4.64|
000028  6248              STR      r0,[r1,#0x24]  ; huart1
;;;88       if (HAL_UART_Init(&huart1) != HAL_OK)
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       HAL_UART_Init
000030  2800              CMP      r0,#0
000032  d001              BEQ      |L4.56|
;;;89       {
;;;90         Error_Handler();
000034  f7fffffe          BL       Error_Handler
                  |L4.56|
;;;91       }
;;;92     
;;;93     }
000038  bd10              POP      {r4,pc}
;;;94     
                          ENDP

00003a  0000              DCW      0x0000
                  |L4.60|
                          DCD      0x40013800
                  |L4.64|
                          DCD      huart1

                          AREA ||i.MX_USART5_UART_Init||, CODE, READONLY, ALIGN=2

                  MX_USART5_UART_Init PROC
;;;96     
;;;97     void MX_USART5_UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;98     {
;;;99     
;;;100      huart5.Instance = USART5;
000002  4810              LDR      r0,|L5.68|
000004  4910              LDR      r1,|L5.72|
000006  6008              STR      r0,[r1,#0]  ; huart5
;;;101      huart5.Init.BaudRate = 115200;
000008  20e1              MOVS     r0,#0xe1
00000a  0240              LSLS     r0,r0,#9
00000c  6048              STR      r0,[r1,#4]  ; huart5
;;;102      huart5.Init.WordLength = UART_WORDLENGTH_8B;
00000e  2100              MOVS     r1,#0
000010  480d              LDR      r0,|L5.72|
000012  6081              STR      r1,[r0,#8]
;;;103      huart5.Init.StopBits = UART_STOPBITS_1;
000014  60c1              STR      r1,[r0,#0xc]
;;;104      huart5.Init.Parity = UART_PARITY_NONE;
000016  6101              STR      r1,[r0,#0x10]
;;;105      huart5.Init.Mode = UART_MODE_TX_RX;
000018  210c              MOVS     r1,#0xc
00001a  6141              STR      r1,[r0,#0x14]
;;;106      huart5.Init.HwFlowCtl = UART_HWCONTROL_NONE;
00001c  2100              MOVS     r1,#0
00001e  6181              STR      r1,[r0,#0x18]
;;;107      huart5.Init.OverSampling = UART_OVERSAMPLING_16;
000020  61c1              STR      r1,[r0,#0x1c]
;;;108      huart5.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
000022  6201              STR      r1,[r0,#0x20]
;;;109      huart5.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
000024  2000              MOVS     r0,#0
000026  4908              LDR      r1,|L5.72|
000028  6248              STR      r0,[r1,#0x24]  ; huart5
;;;110      if (HAL_UART_Init(&huart5) != HAL_OK)
00002a  4608              MOV      r0,r1
00002c  f7fffffe          BL       HAL_UART_Init
000030  2800              CMP      r0,#0
000032  d001              BEQ      |L5.56|
;;;111      {
;;;112        Error_Handler();
000034  f7fffffe          BL       Error_Handler
                  |L5.56|
;;;113      }
;;;114    	HAL_UART_Receive_IT(&huart5,(uint8_t *)UART_RX_DATA.aRxBuffer, RXBUFFERSIZE);
000038  2201              MOVS     r2,#1
00003a  4904              LDR      r1,|L5.76|
00003c  4802              LDR      r0,|L5.72|
00003e  f7fffffe          BL       HAL_UART_Receive_IT
;;;115    }
000042  bd10              POP      {r4,pc}
;;;116    
                          ENDP

                  |L5.68|
                          DCD      0x40005000
                  |L5.72|
                          DCD      huart5
                  |L5.76|
                          DCD      UART_RX_DATA+0x406

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;61       */
;;;62     PUTCHAR_PROTOTYPE
000000  b513              PUSH     {r0,r1,r4,lr}
;;;63     {
000002  460c              MOV      r4,r1
;;;64       /* Place your implementation of fputc here */
;;;65       /* e.g. write a character to the USART */
;;;66       HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);  ///不需要库原因：从速度考虑直接使用寄存器更好
000004  4b03              LDR      r3,|L6.20|
000006  2201              MOVS     r2,#1
000008  4669              MOV      r1,sp
00000a  4803              LDR      r0,|L6.24|
00000c  f7fffffe          BL       HAL_UART_Transmit
;;;67       return ch;
000010  9800              LDR      r0,[sp,#0]
;;;68     }
000012  bd1c              POP      {r2-r4,pc}
;;;69     
                          ENDP

                  |L6.20|
                          DCD      0x0000ffff
                  |L6.24|
                          DCD      huart1

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  huart1
                          %        112
                  huart5
                          %        112
                  UART_RX_DATA
                          %        1036

;*** Start embedded assembler ***

#line 1 "..\\HAL\\src\\usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_fputc____REV16|
#line 388 "..\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_usart_c_fputc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_fputc____REVSH|
#line 402
|__asm___7_usart_c_fputc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
