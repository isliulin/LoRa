; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f0xx_ll_utils.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f0xx_ll_utils.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS\Device\ST\STM32F0xx\Include -I..\CMSIS\Include -I..\stm32f03xx_HAL\Inc -I..\USER -I..\HAL\inc -I..\HAL\system -I..\Lib\LoRawan-node\misc -I..\Lib\LoRawan-node\crypto -I..\Lib\LoRawan-node\mac -I..\Lib\LoRawan-node\radio -I..\Lib\LoRawan-node\radio\sx1276 -I..\Lib -IE:\NBI项目\NBI_LoRa\LoRa版本备份\NB_LoRawan-V2.0.2：control-F030CC\MDK_5.12\RTE -ID:\mysaftware\keil_5.12\ARM\PACK\Keil\STM32F0xx_DFP\1.5.0\Device\Include -ID:\mysaftware\keil_5.12\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=518 -DSTM32F030xC -DUSE_HAL_DRIVER -DSTM32F030xC -DUSE_MODEM_LORA -DUSE_BAND_433 --omf_browse=.\objects\stm32f0xx_ll_utils.crf ..\stm32f03xx_HAL\Src\stm32f0xx_ll_utils.c]
                          THUMB

                          AREA ||i.LL_Init1msTick||, CODE, READONLY, ALIGN=2

                  LL_Init1msTick PROC
;;;159      */
;;;160    void LL_Init1msTick(uint32_t HCLKFrequency)
000000  b570              PUSH     {r4-r6,lr}
;;;161    {
000002  4604              MOV      r4,r0
;;;162      /* Use frequency provided in argument */
;;;163      LL_InitTick(HCLKFrequency, 1000U);
000004  257d              MOVS     r5,#0x7d
000006  00ed              LSLS     r5,r5,#3
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       __aeabi_uidivmod
000010  1e40              SUBS     r0,r0,#1
000012  4904              LDR      r1,|L1.36|
000014  6148              STR      r0,[r1,#0x14]
000016  2000              MOVS     r0,#0
000018  6188              STR      r0,[r1,#0x18]
00001a  2005              MOVS     r0,#5
00001c  6108              STR      r0,[r1,#0x10]
00001e  bf00              NOP      
;;;164    }
000020  bd70              POP      {r4-r6,pc}
;;;165    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      0xe000e000

                          AREA ||i.LL_PLL_ConfigSystemClock_HSE||, CODE, READONLY, ALIGN=2

                  LL_PLL_ConfigSystemClock_HSE PROC
;;;379      */
;;;380    ErrorStatus LL_PLL_ConfigSystemClock_HSE(uint32_t HSEFrequency, uint32_t HSEBypass,
000000  b5fe              PUSH     {r1-r7,lr}
;;;381                                             LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
;;;382    {
000002  4607              MOV      r7,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
000008  461e              MOV      r6,r3
;;;383      ErrorStatus status = SUCCESS;
00000a  2001              MOVS     r0,#1
00000c  9001              STR      r0,[sp,#4]
;;;384      uint32_t pllfreq = 0U;
00000e  2000              MOVS     r0,#0
000010  9000              STR      r0,[sp,#0]
;;;385    
;;;386      /* Check the parameters */
;;;387      assert_param(IS_LL_UTILS_HSE_FREQUENCY(HSEFrequency));
;;;388      assert_param(IS_LL_UTILS_HSE_BYPASS(HSEBypass));
;;;389    
;;;390      /* Check if one of the PLL is enabled */
;;;391      if (UTILS_PLL_IsBusy() == SUCCESS)
000012  f7fffffe          BL       UTILS_PLL_IsBusy
000016  2801              CMP      r0,#1
000018  d137              BNE      |L2.138|
;;;392      {
;;;393        /* Check PREDIV value */
;;;394    #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
;;;395        assert_param(IS_LL_UTILS_PREDIV_VALUE(UTILS_PLLInitStruct->PLLDiv));
;;;396    #else
;;;397        assert_param(IS_LL_UTILS_PREDIV_VALUE(UTILS_PLLInitStruct->Prediv));
;;;398    #endif /*RCC_PLLSRC_PREDIV1_SUPPORT*/
;;;399    
;;;400        /* Calculate the new PLL output frequency */
;;;401        pllfreq = UTILS_GetPLLOutputFrequency(HSEFrequency, UTILS_PLLInitStruct);
00001a  4621              MOV      r1,r4
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       UTILS_GetPLLOutputFrequency
000022  9000              STR      r0,[sp,#0]
;;;402    
;;;403        /* Enable HSE if not enabled */
;;;404        if (LL_RCC_HSE_IsReady() != 1U)
000024  f7fffffe          BL       LL_RCC_HSE_IsReady
000028  2801              CMP      r0,#1
00002a  d022              BEQ      |L2.114|
;;;405        {
;;;406          /* Check if need to enable HSE bypass feature or not */
;;;407          if (HSEBypass == LL_UTILS_HSEBYPASS_ON)
00002c  2d01              CMP      r5,#1
00002e  d108              BNE      |L2.66|
;;;408          {
;;;409            LL_RCC_HSE_EnableBypass();
000030  bf00              NOP      
000032  4818              LDR      r0,|L2.148|
000034  6800              LDR      r0,[r0,#0]
000036  04a9              LSLS     r1,r5,#18
000038  4308              ORRS     r0,r0,r1
00003a  4916              LDR      r1,|L2.148|
00003c  6008              STR      r0,[r1,#0]
00003e  bf00              NOP      
000040  e009              B        |L2.86|
                  |L2.66|
;;;410          }
;;;411          else
;;;412          {
;;;413            LL_RCC_HSE_DisableBypass();
000042  bf00              NOP      
000044  4813              LDR      r0,|L2.148|
000046  6800              LDR      r0,[r0,#0]
000048  2101              MOVS     r1,#1
00004a  0489              LSLS     r1,r1,#18
00004c  4388              BICS     r0,r0,r1
00004e  4911              LDR      r1,|L2.148|
000050  6008              STR      r0,[r1,#0]
000052  bf00              NOP      
000054  bf00              NOP      
                  |L2.86|
;;;414          }
;;;415    
;;;416          /* Enable HSE */
;;;417          LL_RCC_HSE_Enable();
000056  bf00              NOP      
000058  480e              LDR      r0,|L2.148|
00005a  6800              LDR      r0,[r0,#0]
00005c  2101              MOVS     r1,#1
00005e  0409              LSLS     r1,r1,#16
000060  4308              ORRS     r0,r0,r1
000062  490c              LDR      r1,|L2.148|
000064  6008              STR      r0,[r1,#0]
000066  bf00              NOP      
;;;418          while (LL_RCC_HSE_IsReady() != 1U)
000068  bf00              NOP      
                  |L2.106|
00006a  f7fffffe          BL       LL_RCC_HSE_IsReady
00006e  2801              CMP      r0,#1
000070  d1fb              BNE      |L2.106|
                  |L2.114|
;;;419          {
;;;420            /* Wait for HSE ready */
;;;421          }
;;;422        }
;;;423    
;;;424          /* Configure PLL */
;;;425    #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
;;;426          LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE, UTILS_PLLInitStruct->PLLMul, UTILS_PLLInitStruct->PLLDiv);
000072  2001              MOVS     r0,#1
000074  0400              LSLS     r0,r0,#16
000076  6862              LDR      r2,[r4,#4]
000078  6821              LDR      r1,[r4,#0]
00007a  f7fffffe          BL       LL_RCC_PLL_ConfigDomain_SYS
;;;427    #else
;;;428        LL_RCC_PLL_ConfigDomain_SYS((RCC_CFGR_PLLSRC_HSE_PREDIV | UTILS_PLLInitStruct->Prediv), UTILS_PLLInitStruct->PLLMul);
;;;429    #endif /*RCC_PLLSRC_PREDIV1_SUPPORT*/
;;;430    
;;;431        /* Enable PLL and switch system clock to PLL */
;;;432        status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);
00007e  4631              MOV      r1,r6
000080  9800              LDR      r0,[sp,#0]
000082  f7fffffe          BL       UTILS_EnablePLLAndSwitchSystem
000086  9001              STR      r0,[sp,#4]
000088  e001              B        |L2.142|
                  |L2.138|
;;;433      }
;;;434      else
;;;435      {
;;;436        /* Current PLL configuration cannot be modified */
;;;437        status = ERROR;
00008a  2000              MOVS     r0,#0
00008c  9001              STR      r0,[sp,#4]
                  |L2.142|
;;;438      }
;;;439    
;;;440      return status;
00008e  9801              LDR      r0,[sp,#4]
;;;441    }
000090  bdfe              POP      {r1-r7,pc}
;;;442    
                          ENDP

000092  0000              DCW      0x0000
                  |L2.148|
                          DCD      0x40021000

                          AREA ||i.LL_PLL_ConfigSystemClock_HSI||, CODE, READONLY, ALIGN=2

                  LL_PLL_ConfigSystemClock_HSI PROC
;;;254      */
;;;255    ErrorStatus LL_PLL_ConfigSystemClock_HSI(LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct,
000000  b5f8              PUSH     {r3-r7,lr}
;;;256                                             LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
;;;257    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;258      ErrorStatus status = SUCCESS;
000006  2601              MOVS     r6,#1
;;;259      uint32_t pllfreq = 0U;
000008  2700              MOVS     r7,#0
;;;260    
;;;261      /* Check if one of the PLL is enabled */
;;;262      if (UTILS_PLL_IsBusy() == SUCCESS)
00000a  f7fffffe          BL       UTILS_PLL_IsBusy
00000e  2801              CMP      r0,#1
000010  d121              BNE      |L3.86|
;;;263      {
;;;264    #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
;;;265        /* Check PREDIV value */
;;;266        assert_param(IS_LL_UTILS_PREDIV_VALUE(UTILS_PLLInitStruct->PLLDiv));
;;;267    #else
;;;268        /* Force PREDIV value to 2 */
;;;269        UTILS_PLLInitStruct->Prediv = LL_RCC_PREDIV_DIV_2;
;;;270    #endif /*RCC_PLLSRC_PREDIV1_SUPPORT*/
;;;271        /* Calculate the new PLL output frequency */
;;;272        pllfreq = UTILS_GetPLLOutputFrequency(HSI_VALUE, UTILS_PLLInitStruct);
000012  4621              MOV      r1,r4
000014  4811              LDR      r0,|L3.92|
000016  f7fffffe          BL       UTILS_GetPLLOutputFrequency
00001a  4607              MOV      r7,r0
;;;273    
;;;274        /* Enable HSI if not enabled */
;;;275        if (LL_RCC_HSI_IsReady() != 1U)
00001c  f7fffffe          BL       LL_RCC_HSI_IsReady
000020  2801              CMP      r0,#1
000022  d00c              BEQ      |L3.62|
;;;276        {
;;;277          LL_RCC_HSI_Enable();
000024  bf00              NOP      
000026  480e              LDR      r0,|L3.96|
000028  6800              LDR      r0,[r0,#0]
00002a  2101              MOVS     r1,#1
00002c  4308              ORRS     r0,r0,r1
00002e  490c              LDR      r1,|L3.96|
000030  6008              STR      r0,[r1,#0]
000032  bf00              NOP      
;;;278          while (LL_RCC_HSI_IsReady() != 1U)
000034  bf00              NOP      
                  |L3.54|
000036  f7fffffe          BL       LL_RCC_HSI_IsReady
00003a  2801              CMP      r0,#1
00003c  d1fb              BNE      |L3.54|
                  |L3.62|
;;;279          {
;;;280            /* Wait for HSI ready */
;;;281          }
;;;282        }
;;;283    
;;;284        /* Configure PLL */
;;;285    #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
;;;286        LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, UTILS_PLLInitStruct->PLLMul, UTILS_PLLInitStruct->PLLDiv);
00003e  2001              MOVS     r0,#1
000040  03c0              LSLS     r0,r0,#15
000042  6862              LDR      r2,[r4,#4]
000044  6821              LDR      r1,[r4,#0]
000046  f7fffffe          BL       LL_RCC_PLL_ConfigDomain_SYS
;;;287    #else
;;;288        LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI_DIV_2, UTILS_PLLInitStruct->PLLMul);
;;;289    #endif /*RCC_PLLSRC_PREDIV1_SUPPORT*/
;;;290    
;;;291        /* Enable PLL and switch system clock to PLL */
;;;292        status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);
00004a  4629              MOV      r1,r5
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       UTILS_EnablePLLAndSwitchSystem
000052  4606              MOV      r6,r0
000054  e000              B        |L3.88|
                  |L3.86|
;;;293      }
;;;294      else
;;;295      {
;;;296        /* Current PLL configuration cannot be modified */
;;;297        status = ERROR;
000056  2600              MOVS     r6,#0
                  |L3.88|
;;;298      }
;;;299    
;;;300      return status;
000058  4630              MOV      r0,r6
;;;301    }
00005a  bdf8              POP      {r3-r7,pc}
;;;302    
                          ENDP

                  |L3.92|
                          DCD      0x007a1200
                  |L3.96|
                          DCD      0x40021000

                          AREA ||i.LL_RCC_HSE_IsReady||, CODE, READONLY, ALIGN=2

                  LL_RCC_HSE_IsReady PROC
;;;744      */
;;;745    __STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
000000  4803              LDR      r0,|L4.16|
;;;746    {
;;;747      return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
000002  6800              LDR      r0,[r0,#0]
000004  2101              MOVS     r1,#1
000006  0449              LSLS     r1,r1,#17
000008  4008              ANDS     r0,r0,r1
00000a  0c40              LSRS     r0,r0,#17
;;;748    }
00000c  4770              BX       lr
;;;749    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0x40021000

                          AREA ||i.LL_RCC_HSI_IsReady||, CODE, READONLY, ALIGN=2

                  LL_RCC_HSI_IsReady PROC
;;;782      */
;;;783    __STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
000000  4802              LDR      r0,|L5.12|
;;;784    {
;;;785      return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
000002  6800              LDR      r0,[r0,#0]
000004  2102              MOVS     r1,#2
000006  4008              ANDS     r0,r0,r1
000008  0840              LSRS     r0,r0,#1
;;;786    }
00000a  4770              BX       lr
;;;787    
                          ENDP

                  |L5.12|
                          DCD      0x40021000

                          AREA ||i.LL_RCC_PLL_ConfigDomain_SYS||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLL_ConfigDomain_SYS PROC
;;;1594     */
;;;1595   __STATIC_INLINE void LL_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLMul, uint32_t PLLDiv)
000000  b510              PUSH     {r4,lr}
;;;1596   {
;;;1597     MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL, Source | PLLMul);
000002  4b08              LDR      r3,|L6.36|
000004  685b              LDR      r3,[r3,#4]
000006  247b              MOVS     r4,#0x7b
000008  03e4              LSLS     r4,r4,#15
00000a  43a3              BICS     r3,r3,r4
00000c  4604              MOV      r4,r0
00000e  430c              ORRS     r4,r4,r1
000010  4323              ORRS     r3,r3,r4
000012  4c04              LDR      r4,|L6.36|
000014  6063              STR      r3,[r4,#4]
;;;1598     MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, PLLDiv);
000016  4623              MOV      r3,r4
000018  6adb              LDR      r3,[r3,#0x2c]
00001a  091b              LSRS     r3,r3,#4
00001c  011b              LSLS     r3,r3,#4
00001e  4313              ORRS     r3,r3,r2
000020  62e3              STR      r3,[r4,#0x2c]
;;;1599   }
000022  bd10              POP      {r4,pc}
;;;1600   
                          ENDP

                  |L6.36|
                          DCD      0x40021000

                          AREA ||i.LL_RCC_PLL_IsReady||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLL_IsReady PROC
;;;1542     */
;;;1543   __STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
000000  4803              LDR      r0,|L7.16|
;;;1544   {
;;;1545     return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
000002  6800              LDR      r0,[r0,#0]
000004  2101              MOVS     r1,#1
000006  0649              LSLS     r1,r1,#25
000008  4008              ANDS     r0,r0,r1
00000a  0e40              LSRS     r0,r0,#25
;;;1546   }
00000c  4770              BX       lr
;;;1547   
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      0x40021000

                          AREA ||i.LL_SetSystemCoreClock||, CODE, READONLY, ALIGN=2

                  LL_SetSystemCoreClock PROC
;;;231      */
;;;232    void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
000000  4901              LDR      r1,|L8.8|
;;;233    {
;;;234      /* HCLK clock frequency */
;;;235      SystemCoreClock = HCLKFrequency;
000002  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;236    }
000004  4770              BX       lr
;;;237    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      SystemCoreClock

                          AREA ||i.LL_mDelay||, CODE, READONLY, ALIGN=2

                  LL_mDelay PROC
;;;175      */
;;;176    void LL_mDelay(uint32_t Delay)
000000  b508              PUSH     {r3,lr}
;;;177    {
;;;178      __IO uint32_t  tmp = SysTick->CTRL;  /* Clear the COUNTFLAG first */
000002  490a              LDR      r1,|L9.44|
000004  6909              LDR      r1,[r1,#0x10]
000006  9100              STR      r1,[sp,#0]
;;;179      /* Add this code to indicate that local variable is not used */
;;;180      ((void)tmp);
000008  bf00              NOP      
;;;181    
;;;182      /* Add a period to guaranty minimum wait */
;;;183      if (Delay < LL_MAX_DELAY)
00000a  1c41              ADDS     r1,r0,#1
00000c  2900              CMP      r1,#0
00000e  d000              BEQ      |L9.18|
;;;184      {
;;;185        Delay++;
000010  1c40              ADDS     r0,r0,#1
                  |L9.18|
;;;186      }
;;;187    
;;;188      while (Delay)
000012  e007              B        |L9.36|
                  |L9.20|
;;;189      {
;;;190        if ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U)
000014  4905              LDR      r1,|L9.44|
000016  6909              LDR      r1,[r1,#0x10]
000018  2201              MOVS     r2,#1
00001a  0412              LSLS     r2,r2,#16
00001c  4011              ANDS     r1,r1,r2
00001e  2900              CMP      r1,#0
000020  d000              BEQ      |L9.36|
;;;191        {
;;;192          Delay--;
000022  1e40              SUBS     r0,r0,#1
                  |L9.36|
000024  2800              CMP      r0,#0                 ;188
000026  d1f5              BNE      |L9.20|
;;;193        }
;;;194      }
;;;195    }
000028  bd08              POP      {r3,pc}
;;;196    
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      0xe000e000

                          AREA ||i.UTILS_EnablePLLAndSwitchSystem||, CODE, READONLY, ALIGN=2

                  UTILS_EnablePLLAndSwitchSystem PROC
;;;551      */
;;;552    static ErrorStatus UTILS_EnablePLLAndSwitchSystem(uint32_t SYSCLK_Frequency, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
000000  b5f8              PUSH     {r3-r7,lr}
;;;553    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;554      ErrorStatus status = SUCCESS;
000006  2601              MOVS     r6,#1
;;;555      uint32_t sysclk_frequency_current = 0U;
000008  2700              MOVS     r7,#0
;;;556    
;;;557      assert_param(IS_LL_UTILS_SYSCLK_DIV(UTILS_ClkInitStruct->AHBCLKDivider));
;;;558      assert_param(IS_LL_UTILS_APB1_DIV(UTILS_ClkInitStruct->APB1CLKDivider));
;;;559    
;;;560      /* Calculate current SYSCLK frequency */
;;;561      sysclk_frequency_current = (SystemCoreClock << AHBPrescTable[LL_RCC_GetAHBPrescaler() >> RCC_POSITION_HPRE]);
00000a  bf00              NOP      
00000c  482c              LDR      r0,|L10.192|
00000e  6840              LDR      r0,[r0,#4]
000010  21f0              MOVS     r1,#0xf0
000012  4008              ANDS     r0,r0,r1
000014  0900              LSRS     r0,r0,#4
000016  492b              LDR      r1,|L10.196|
000018  5c09              LDRB     r1,[r1,r0]
00001a  482b              LDR      r0,|L10.200|
00001c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001e  4088              LSLS     r0,r0,r1
000020  4607              MOV      r7,r0
;;;562    
;;;563      /* Increasing the number of wait states because of higher CPU frequency */
;;;564      if (sysclk_frequency_current < SYSCLK_Frequency)
000022  42a7              CMP      r7,r4
000024  d203              BCS      |L10.46|
;;;565      {
;;;566        /* Set FLASH latency to highest latency */
;;;567        status = UTILS_SetFlashLatency(SYSCLK_Frequency);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       UTILS_SetFlashLatency
00002c  4606              MOV      r6,r0
                  |L10.46|
;;;568      }
;;;569    
;;;570      /* Update system clock configuration */
;;;571      if (status == SUCCESS)
00002e  2e01              CMP      r6,#1
000030  d130              BNE      |L10.148|
;;;572      {
;;;573        /* Enable PLL */
;;;574        LL_RCC_PLL_Enable();
000032  bf00              NOP      
000034  4822              LDR      r0,|L10.192|
000036  6800              LDR      r0,[r0,#0]
000038  0631              LSLS     r1,r6,#24
00003a  4308              ORRS     r0,r0,r1
00003c  4920              LDR      r1,|L10.192|
00003e  6008              STR      r0,[r1,#0]
000040  bf00              NOP      
;;;575        while (LL_RCC_PLL_IsReady() != 1U)
000042  bf00              NOP      
                  |L10.68|
000044  f7fffffe          BL       LL_RCC_PLL_IsReady
000048  2801              CMP      r0,#1
00004a  d1fb              BNE      |L10.68|
;;;576        {
;;;577          /* Wait for PLL ready */
;;;578        }
;;;579    
;;;580        /* Sysclk activation on the main PLL */
;;;581        LL_RCC_SetAHBPrescaler(UTILS_ClkInitStruct->AHBCLKDivider);
00004c  6828              LDR      r0,[r5,#0]
00004e  491c              LDR      r1,|L10.192|
000050  6849              LDR      r1,[r1,#4]
000052  22f0              MOVS     r2,#0xf0
000054  4391              BICS     r1,r1,r2
000056  4301              ORRS     r1,r1,r0
000058  4a19              LDR      r2,|L10.192|
00005a  6051              STR      r1,[r2,#4]
00005c  bf00              NOP      
;;;582        LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
00005e  2002              MOVS     r0,#2
000060  4611              MOV      r1,r2
000062  6849              LDR      r1,[r1,#4]
000064  0889              LSRS     r1,r1,#2
000066  0089              LSLS     r1,r1,#2
000068  4301              ORRS     r1,r1,r0
00006a  6051              STR      r1,[r2,#4]
00006c  bf00              NOP      
;;;583        while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
00006e  bf00              NOP      
                  |L10.112|
000070  bf00              NOP      
000072  4813              LDR      r0,|L10.192|
000074  6840              LDR      r0,[r0,#4]
000076  210c              MOVS     r1,#0xc
000078  4008              ANDS     r0,r0,r1
00007a  2808              CMP      r0,#8
00007c  d1f8              BNE      |L10.112|
;;;584        {
;;;585          /* Wait for system clock switch to PLL */
;;;586        }
;;;587    
;;;588        /* Set APB1 & APB2 prescaler*/
;;;589        LL_RCC_SetAPB1Prescaler(UTILS_ClkInitStruct->APB1CLKDivider);
00007e  6868              LDR      r0,[r5,#4]
000080  490f              LDR      r1,|L10.192|
000082  6849              LDR      r1,[r1,#4]
000084  2207              MOVS     r2,#7
000086  0212              LSLS     r2,r2,#8
000088  4391              BICS     r1,r1,r2
00008a  4301              ORRS     r1,r1,r0
00008c  4a0c              LDR      r2,|L10.192|
00008e  6051              STR      r1,[r2,#4]
000090  bf00              NOP      
000092  bf00              NOP      
                  |L10.148|
;;;590      }
;;;591    
;;;592      /* Decreasing the number of wait states because of lower CPU frequency */
;;;593      if (sysclk_frequency_current > SYSCLK_Frequency)
000094  42a7              CMP      r7,r4
000096  d903              BLS      |L10.160|
;;;594      {
;;;595        /* Set FLASH latency to lowest latency */
;;;596        status = UTILS_SetFlashLatency(SYSCLK_Frequency);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       UTILS_SetFlashLatency
00009e  4606              MOV      r6,r0
                  |L10.160|
;;;597      }
;;;598    
;;;599      /* Update SystemCoreClock variable */
;;;600      if (status == SUCCESS)
0000a0  2e01              CMP      r6,#1
0000a2  d10a              BNE      |L10.186|
;;;601      {
;;;602        LL_SetSystemCoreClock(__LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, UTILS_ClkInitStruct->AHBCLKDivider));
0000a4  22f0              MOVS     r2,#0xf0
0000a6  6829              LDR      r1,[r5,#0]
0000a8  4011              ANDS     r1,r1,r2
0000aa  0909              LSRS     r1,r1,#4
0000ac  4a05              LDR      r2,|L10.196|
0000ae  5c52              LDRB     r2,[r2,r1]
0000b0  4621              MOV      r1,r4
0000b2  40d1              LSRS     r1,r1,r2
0000b4  4608              MOV      r0,r1
0000b6  f7fffffe          BL       LL_SetSystemCoreClock
                  |L10.186|
;;;603      }
;;;604    
;;;605      return status;
0000ba  4630              MOV      r0,r6
;;;606    }
0000bc  bdf8              POP      {r3-r7,pc}
;;;607    
                          ENDP

0000be  0000              DCW      0x0000
                  |L10.192|
                          DCD      0x40021000
                  |L10.196|
                          DCD      AHBPrescTable
                  |L10.200|
                          DCD      SystemCoreClock

                          AREA ||i.UTILS_GetPLLOutputFrequency||, CODE, READONLY, ALIGN=1

                  UTILS_GetPLLOutputFrequency PROC
;;;502      */
;;;503    static uint32_t UTILS_GetPLLOutputFrequency(uint32_t PLL_InputFrequency, LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;504    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;505      uint32_t pllfreq = 0U;
000006  2600              MOVS     r6,#0
;;;506    
;;;507      /* Check the parameters */
;;;508      assert_param(IS_LL_UTILS_PLLMUL_VALUE(UTILS_PLLInitStruct->PLLMul));
;;;509    
;;;510      /* Check different PLL parameters according to RM                          */
;;;511      /* The application software must set correctly the PLL multiplication factor to 
;;;512         be in the range 16-48MHz */
;;;513    #if defined(RCC_PLLSRC_PREDIV1_SUPPORT)
;;;514      pllfreq = __LL_RCC_CALC_PLLCLK_FREQ(PLL_InputFrequency, UTILS_PLLInitStruct->PLLMul, UTILS_PLLInitStruct->PLLDiv);
000008  7920              LDRB     r0,[r4,#4]
00000a  0700              LSLS     r0,r0,#28
00000c  0f00              LSRS     r0,r0,#28
00000e  1c41              ADDS     r1,r0,#1
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       __aeabi_uidivmod
000016  220f              MOVS     r2,#0xf
000018  0492              LSLS     r2,r2,#18
00001a  6821              LDR      r1,[r4,#0]
00001c  4011              ANDS     r1,r1,r2
00001e  0c89              LSRS     r1,r1,#18
000020  1c89              ADDS     r1,r1,#2
000022  4348              MULS     r0,r1,r0
000024  4606              MOV      r6,r0
;;;515    #else
;;;516      pllfreq = __LL_RCC_CALC_PLLCLK_FREQ(PLL_InputFrequency / (UTILS_PLLInitStruct->Prediv + 1U), UTILS_PLLInitStruct->PLLMul);
;;;517    #endif /*RCC_PLLSRC_PREDIV1_SUPPORT*/
;;;518      assert_param(IS_LL_UTILS_PLL_FREQUENCY(pllfreq));
;;;519    
;;;520      return pllfreq;
000026  4630              MOV      r0,r6
;;;521    }
000028  bd70              POP      {r4-r6,pc}
;;;522    
                          ENDP


                          AREA ||i.UTILS_PLL_IsBusy||, CODE, READONLY, ALIGN=1

                  UTILS_PLL_IsBusy PROC
;;;528      */
;;;529    static ErrorStatus UTILS_PLL_IsBusy(void)
000000  b510              PUSH     {r4,lr}
;;;530    {
;;;531      ErrorStatus status = SUCCESS;
000002  2401              MOVS     r4,#1
;;;532    
;;;533      /* Check if PLL is busy*/
;;;534      if (LL_RCC_PLL_IsReady() != 0U)
000004  f7fffffe          BL       LL_RCC_PLL_IsReady
000008  2800              CMP      r0,#0
00000a  d000              BEQ      |L12.14|
;;;535      {
;;;536        /* PLL configuration cannot be modified */
;;;537        status = ERROR;
00000c  2400              MOVS     r4,#0
                  |L12.14|
;;;538      }
;;;539    
;;;540      return status;
00000e  4620              MOV      r0,r4
;;;541    }
000010  bd10              POP      {r4,pc}
;;;542    
                          ENDP


                          AREA ||i.UTILS_SetFlashLatency||, CODE, READONLY, ALIGN=2

                  UTILS_SetFlashLatency PROC
;;;462    #if defined(FLASH_ACR_LATENCY)
;;;463    static ErrorStatus UTILS_SetFlashLatency(uint32_t Frequency)
000000  b510              PUSH     {r4,lr}
;;;464    {
000002  4602              MOV      r2,r0
;;;465      ErrorStatus status = SUCCESS;
000004  2001              MOVS     r0,#1
;;;466    
;;;467      uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */
000006  2100              MOVS     r1,#0
;;;468    
;;;469      /* Frequency cannot be equal to 0 */
;;;470      if (Frequency == 0U)
000008  2a00              CMP      r2,#0
00000a  d101              BNE      |L13.16|
;;;471      {
;;;472        status = ERROR;
00000c  2000              MOVS     r0,#0
00000e  e014              B        |L13.58|
                  |L13.16|
;;;473      }
;;;474      else
;;;475      {
;;;476        if (Frequency > UTILS_LATENCY1_FREQ)
000010  4b0a              LDR      r3,|L13.60|
000012  429a              CMP      r2,r3
000014  d900              BLS      |L13.24|
;;;477        {
;;;478          /* 24 < SYSCLK <= 48 => 1WS (2 CPU cycles) */
;;;479          latency = LL_FLASH_LATENCY_1;
000016  2101              MOVS     r1,#1
                  |L13.24|
;;;480        }
;;;481        /* else SYSCLK < 24MHz default LL_FLASH_LATENCY_0 0WS */
;;;482    
;;;483        LL_FLASH_SetLatency(latency);
000018  bf00              NOP      
00001a  4b09              LDR      r3,|L13.64|
00001c  681b              LDR      r3,[r3,#0]
00001e  085b              LSRS     r3,r3,#1
000020  005b              LSLS     r3,r3,#1
000022  430b              ORRS     r3,r3,r1
000024  4c06              LDR      r4,|L13.64|
000026  6023              STR      r3,[r4,#0]
000028  bf00              NOP      
;;;484    
;;;485        /* Check that the new number of wait states is taken into account to access the Flash
;;;486           memory by reading the FLASH_ACR register */
;;;487        if (LL_FLASH_GetLatency() != latency)
00002a  bf00              NOP      
00002c  4623              MOV      r3,r4
00002e  681b              LDR      r3,[r3,#0]
000030  07db              LSLS     r3,r3,#31
000032  0fdb              LSRS     r3,r3,#31
000034  428b              CMP      r3,r1
000036  d000              BEQ      |L13.58|
;;;488        {
;;;489          status = ERROR;
000038  2000              MOVS     r0,#0
                  |L13.58|
;;;490        }
;;;491      }
;;;492      return status;
;;;493    }
00003a  bd10              POP      {r4,pc}
;;;494    #endif /* FLASH_ACR_LATENCY */
                          ENDP

                  |L13.60|
                          DCD      0x016e3600
                  |L13.64|
                          DCD      0x40022000

;*** Start embedded assembler ***

#line 1 "..\\stm32f03xx_HAL\\Src\\stm32f0xx_ll_utils.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f0xx_ll_utils_c_fa0b8999____REV16|
#line 388 "..\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f0xx_ll_utils_c_fa0b8999____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f0xx_ll_utils_c_fa0b8999____REVSH|
#line 402
|__asm___20_stm32f0xx_ll_utils_c_fa0b8999____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
