; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f0xx_hal_adc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f0xx_hal_adc.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS\Device\ST\STM32F0xx\Include -I..\CMSIS\Include -I..\stm32f03xx_HAL\Inc -I..\USER -I..\HAL\inc -I..\HAL\system -I..\Lib\LoRawan-node\misc -I..\Lib\LoRawan-node\crypto -I..\Lib\LoRawan-node\mac -I..\Lib\LoRawan-node\radio -I..\Lib\LoRawan-node\radio\sx1276 -I..\Lib -IE:\NBI项目\NBI_LoRa\LoRa版本备份\NB_LoRawan-V2.0.2：control-F030CC\MDK_5.12\RTE -ID:\mysaftware\keil_5.12\ARM\PACK\Keil\STM32F0xx_DFP\1.5.0\Device\Include -ID:\mysaftware\keil_5.12\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=518 -DSTM32F030xC -DUSE_HAL_DRIVER -DSTM32F030xC -DUSE_MODEM_LORA -DUSE_BAND_433 --omf_browse=.\objects\stm32f0xx_hal_adc.crf ..\stm32f03xx_HAL\Src\stm32f0xx_hal_adc.c]
                          THUMB

                          AREA ||i.ADC_ConversionStop||, CODE, READONLY, ALIGN=1

                  ADC_ConversionStop PROC
;;;2031     */
;;;2032   static HAL_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;2033   {
000002  4604              MOV      r4,r0
;;;2034     uint32_t tickstart = 0U;
000004  2500              MOVS     r5,#0
;;;2035   
;;;2036     /* Check the parameters */
;;;2037     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;2038       
;;;2039     /* Verification if ADC is not already stopped on regular group to bypass    */
;;;2040     /* this function if not needed.                                             */
;;;2041     if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc))
000006  6820              LDR      r0,[r4,#0]
000008  6880              LDR      r0,[r0,#8]
00000a  2104              MOVS     r1,#4
00000c  4008              ANDS     r0,r0,r1
00000e  0880              LSRS     r0,r0,#2
000010  2800              CMP      r0,#0
000012  d029              BEQ      |L1.104|
;;;2042     {
;;;2043       
;;;2044       /* Stop potential conversion on going on regular group */
;;;2045       /* Software is allowed to set ADSTP only when ADSTART=1 and ADDIS=0 */
;;;2046       if (HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADSTART) && 
000014  6820              LDR      r0,[r4,#0]
000016  6880              LDR      r0,[r0,#8]
000018  4008              ANDS     r0,r0,r1
00001a  2800              CMP      r0,#0
00001c  d00b              BEQ      |L1.54|
;;;2047           HAL_IS_BIT_CLR(hadc->Instance->CR, ADC_CR_ADDIS)                  )
00001e  6820              LDR      r0,[r4,#0]
000020  6880              LDR      r0,[r0,#8]
000022  2102              MOVS     r1,#2
000024  4008              ANDS     r0,r0,r1
000026  2800              CMP      r0,#0
000028  d105              BNE      |L1.54|
;;;2048       {
;;;2049         /* Stop conversions on regular group */
;;;2050         hadc->Instance->CR |= ADC_CR_ADSTP;
00002a  6820              LDR      r0,[r4,#0]
00002c  6880              LDR      r0,[r0,#8]
00002e  2110              MOVS     r1,#0x10
000030  4308              ORRS     r0,r0,r1
000032  6821              LDR      r1,[r4,#0]
000034  6088              STR      r0,[r1,#8]
                  |L1.54|
;;;2051       }
;;;2052       
;;;2053       /* Wait for conversion effectively stopped */
;;;2054       /* Get tick count */
;;;2055       tickstart = HAL_GetTick();
000036  f7fffffe          BL       HAL_GetTick
00003a  4605              MOV      r5,r0
;;;2056         
;;;2057       while((hadc->Instance->CR & ADC_CR_ADSTART) != RESET)
00003c  e00e              B        |L1.92|
                  |L1.62|
;;;2058       {
;;;2059         if((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
00003e  f7fffffe          BL       HAL_GetTick
000042  1b40              SUBS     r0,r0,r5
000044  2802              CMP      r0,#2
000046  d909              BLS      |L1.92|
;;;2060         {
;;;2061           /* Update ADC state machine to error */
;;;2062           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
000048  6c60              LDR      r0,[r4,#0x44]
00004a  2110              MOVS     r1,#0x10
00004c  4308              ORRS     r0,r0,r1
00004e  6460              STR      r0,[r4,#0x44]
;;;2063         
;;;2064           /* Set ADC error code to ADC IP internal error */
;;;2065           SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
000050  6ca0              LDR      r0,[r4,#0x48]
000052  2101              MOVS     r1,#1
000054  4308              ORRS     r0,r0,r1
000056  64a0              STR      r0,[r4,#0x48]
;;;2066           
;;;2067           return HAL_ERROR;
000058  2001              MOVS     r0,#1
                  |L1.90|
;;;2068         }
;;;2069       }
;;;2070       
;;;2071     }
;;;2072      
;;;2073     /* Return HAL status */
;;;2074     return HAL_OK;
;;;2075   }
00005a  bd70              POP      {r4-r6,pc}
                  |L1.92|
00005c  6820              LDR      r0,[r4,#0]            ;2057
00005e  6880              LDR      r0,[r0,#8]            ;2057
000060  2104              MOVS     r1,#4                 ;2057
000062  4008              ANDS     r0,r0,r1              ;2057
000064  2800              CMP      r0,#0                 ;2057
000066  d1ea              BNE      |L1.62|
                  |L1.104|
000068  2000              MOVS     r0,#0                 ;2074
00006a  e7f6              B        |L1.90|
;;;2076   
                          ENDP


                          AREA ||i.ADC_DMAConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAConvCplt PROC
;;;2082     */
;;;2083   static void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2084   {
000002  4605              MOV      r5,r0
;;;2085     /* Retrieve ADC handle corresponding to current DMA handle */
;;;2086     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2087     
;;;2088     /* Update state machine on conversion status if not in error state */
;;;2089     if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
000006  6c60              LDR      r0,[r4,#0x44]
000008  2150              MOVS     r1,#0x50
00000a  4008              ANDS     r0,r0,r1
00000c  2800              CMP      r0,#0
00000e  d135              BNE      |L2.124|
;;;2090     {
;;;2091       /* Set ADC state */
;;;2092       SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
000010  6c60              LDR      r0,[r4,#0x44]
000012  2101              MOVS     r1,#1
000014  0249              LSLS     r1,r1,#9
000016  4308              ORRS     r0,r0,r1
000018  6460              STR      r0,[r4,#0x44]
;;;2093       
;;;2094       /* Determine whether any further conversion upcoming on group regular     */
;;;2095       /* by external trigger, continuous mode or scan sequence on going.        */
;;;2096       if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
00001a  6820              LDR      r0,[r4,#0]
00001c  68c0              LDR      r0,[r0,#0xc]
00001e  2103              MOVS     r1,#3
000020  0289              LSLS     r1,r1,#10
000022  4008              ANDS     r0,r0,r1
000024  2800              CMP      r0,#0
000026  d125              BNE      |L2.116|
;;;2097          (hadc->Init.ContinuousConvMode == DISABLE)   )
000028  6a20              LDR      r0,[r4,#0x20]
00002a  2800              CMP      r0,#0
00002c  d122              BNE      |L2.116|
;;;2098       {
;;;2099         /* If End of Sequence is reached, disable interrupts */
;;;2100         if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  2108              MOVS     r1,#8
000034  4008              ANDS     r0,r0,r1
000036  2808              CMP      r0,#8
000038  d11c              BNE      |L2.116|
;;;2101         {
;;;2102           /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit           */
;;;2103           /* ADSTART==0 (no conversion on going)                                */
;;;2104           if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
00003a  6820              LDR      r0,[r4,#0]
00003c  6880              LDR      r0,[r0,#8]
00003e  2104              MOVS     r1,#4
000040  4008              ANDS     r0,r0,r1
000042  0880              LSRS     r0,r0,#2
000044  2800              CMP      r0,#0
000046  d10d              BNE      |L2.100|
;;;2105           {
;;;2106             /* Disable ADC end of single conversion interrupt on group regular */
;;;2107             /* Note: Overrun interrupt was enabled with EOC interrupt in        */
;;;2108             /* HAL_Start_IT(), but is not disabled here because can be used     */
;;;2109             /* by overrun IRQ process below.                                    */
;;;2110             __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
000048  6820              LDR      r0,[r4,#0]
00004a  6840              LDR      r0,[r0,#4]
00004c  210c              MOVS     r1,#0xc
00004e  4388              BICS     r0,r0,r1
000050  6821              LDR      r1,[r4,#0]
000052  6048              STR      r0,[r1,#4]
;;;2111             
;;;2112             /* Set ADC state */
;;;2113             ADC_STATE_CLR_SET(hadc->State,
000054  6c60              LDR      r0,[r4,#0x44]
000056  21ff              MOVS     r1,#0xff
000058  3101              ADDS     r1,#1
00005a  4388              BICS     r0,r0,r1
00005c  2101              MOVS     r1,#1
00005e  4308              ORRS     r0,r0,r1
000060  6460              STR      r0,[r4,#0x44]
000062  e007              B        |L2.116|
                  |L2.100|
;;;2114                               HAL_ADC_STATE_REG_BUSY,
;;;2115                               HAL_ADC_STATE_READY);
;;;2116           }
;;;2117           else
;;;2118           {
;;;2119             /* Change ADC state to error state */
;;;2120             SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
000064  6c60              LDR      r0,[r4,#0x44]
000066  2120              MOVS     r1,#0x20
000068  4308              ORRS     r0,r0,r1
00006a  6460              STR      r0,[r4,#0x44]
;;;2121             
;;;2122             /* Set ADC error code to ADC IP internal error */
;;;2123             SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
00006c  6ca0              LDR      r0,[r4,#0x48]
00006e  2101              MOVS     r1,#1
000070  4308              ORRS     r0,r0,r1
000072  64a0              STR      r0,[r4,#0x48]
                  |L2.116|
;;;2124           }
;;;2125         }
;;;2126       }
;;;2127   
;;;2128       /* Conversion complete callback */
;;;2129       HAL_ADC_ConvCpltCallback(hadc); 
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       HAL_ADC_ConvCpltCallback
00007a  e003              B        |L2.132|
                  |L2.124|
;;;2130     }
;;;2131     else
;;;2132     {
;;;2133       /* Call DMA error callback */
;;;2134       hadc->DMA_Handle->XferErrorCallback(hdma);
00007c  6be0              LDR      r0,[r4,#0x3c]
00007e  6b01              LDR      r1,[r0,#0x30]
000080  4628              MOV      r0,r5
000082  4788              BLX      r1
                  |L2.132|
;;;2135     }
;;;2136   
;;;2137   }
000084  bd70              POP      {r4-r6,pc}
;;;2138   
                          ENDP


                          AREA ||i.ADC_DMAError||, CODE, READONLY, ALIGN=1

                  ADC_DMAError PROC
;;;2157     */
;;;2158   static void ADC_DMAError(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;2159   {
000002  4605              MOV      r5,r0
;;;2160     /* Retrieve ADC handle corresponding to current DMA handle */
;;;2161     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2162     
;;;2163     /* Set ADC state */
;;;2164     SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
000006  6c60              LDR      r0,[r4,#0x44]
000008  2140              MOVS     r1,#0x40
00000a  4308              ORRS     r0,r0,r1
00000c  6460              STR      r0,[r4,#0x44]
;;;2165     
;;;2166     /* Set ADC error code to DMA error */
;;;2167     SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
00000e  6ca0              LDR      r0,[r4,#0x48]
000010  2104              MOVS     r1,#4
000012  4308              ORRS     r0,r0,r1
000014  64a0              STR      r0,[r4,#0x48]
;;;2168     
;;;2169     /* Error callback */
;;;2170     HAL_ADC_ErrorCallback(hadc); 
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       HAL_ADC_ErrorCallback
;;;2171   }
00001c  bd70              POP      {r4-r6,pc}
;;;2172   
                          ENDP


                          AREA ||i.ADC_DMAHalfConvCplt||, CODE, READONLY, ALIGN=1

                  ADC_DMAHalfConvCplt PROC
;;;2143     */
;;;2144   static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;2145   {
000002  4604              MOV      r4,r0
;;;2146     /* Retrieve ADC handle corresponding to current DMA handle */
;;;2147     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a65              LDR      r5,[r4,#0x24]
;;;2148     
;;;2149     /* Half conversion callback */
;;;2150     HAL_ADC_ConvHalfCpltCallback(hadc); 
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_ADC_ConvHalfCpltCallback
;;;2151   }
00000c  bd70              POP      {r4-r6,pc}
;;;2152   
                          ENDP


                          AREA ||i.ADC_Disable||, CODE, READONLY, ALIGN=1

                  ADC_Disable PROC
;;;1974     */
;;;1975   static HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1976   {
000002  4604              MOV      r4,r0
;;;1977     uint32_t tickstart = 0U;
000004  2500              MOVS     r5,#0
;;;1978     
;;;1979     /* Verification if ADC is not already disabled:                             */
;;;1980     /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
;;;1981     /*       disabled.                                                          */
;;;1982     if (ADC_IS_ENABLE(hadc) != RESET)
000006  6820              LDR      r0,[r4,#0]
000008  6880              LDR      r0,[r0,#8]
00000a  0780              LSLS     r0,r0,#30
00000c  0f80              LSRS     r0,r0,#30
00000e  2801              CMP      r0,#1
000010  d10e              BNE      |L5.48|
000012  6820              LDR      r0,[r4,#0]
000014  6800              LDR      r0,[r0,#0]
000016  07c0              LSLS     r0,r0,#31
000018  0fc0              LSRS     r0,r0,#31
00001a  2800              CMP      r0,#0
00001c  d106              BNE      |L5.44|
00001e  6820              LDR      r0,[r4,#0]
000020  68c0              LDR      r0,[r0,#0xc]
000022  2101              MOVS     r1,#1
000024  03c9              LSLS     r1,r1,#15
000026  4008              ANDS     r0,r0,r1
000028  4288              CMP      r0,r1
00002a  d101              BNE      |L5.48|
                  |L5.44|
00002c  2001              MOVS     r0,#1
00002e  e000              B        |L5.50|
                  |L5.48|
000030  2000              MOVS     r0,#0
                  |L5.50|
000032  2800              CMP      r0,#0
000034  d037              BEQ      |L5.166|
;;;1983     {
;;;1984       /* Check if conditions to disable the ADC are fulfilled */
;;;1985       if (ADC_DISABLING_CONDITIONS(hadc) != RESET)
000036  6820              LDR      r0,[r4,#0]
000038  6880              LDR      r0,[r0,#8]
00003a  2105              MOVS     r1,#5
00003c  4008              ANDS     r0,r0,r1
00003e  2801              CMP      r0,#1
000040  d100              BNE      |L5.68|
000042  e000              B        |L5.70|
                  |L5.68|
000044  2000              MOVS     r0,#0
                  |L5.70|
000046  2800              CMP      r0,#0
000048  d00a              BEQ      |L5.96|
;;;1986       {
;;;1987         /* Disable the ADC peripheral */
;;;1988         __HAL_ADC_DISABLE(hadc);
00004a  bf00              NOP      
00004c  6820              LDR      r0,[r4,#0]
00004e  6880              LDR      r0,[r0,#8]
000050  2102              MOVS     r1,#2
000052  4308              ORRS     r0,r0,r1
000054  6821              LDR      r1,[r4,#0]
000056  6088              STR      r0,[r1,#8]
000058  2003              MOVS     r0,#3
00005a  6821              LDR      r1,[r4,#0]
00005c  6008              STR      r0,[r1,#0]
00005e  e009              B        |L5.116|
                  |L5.96|
;;;1989       }
;;;1990       else
;;;1991       {
;;;1992         /* Update ADC state machine to error */
;;;1993         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
000060  6c60              LDR      r0,[r4,#0x44]
000062  2110              MOVS     r1,#0x10
000064  4308              ORRS     r0,r0,r1
000066  6460              STR      r0,[r4,#0x44]
;;;1994       
;;;1995         /* Set ADC error code to ADC IP internal error */
;;;1996         SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
000068  6ca0              LDR      r0,[r4,#0x48]
00006a  2101              MOVS     r1,#1
00006c  4308              ORRS     r0,r0,r1
00006e  64a0              STR      r0,[r4,#0x48]
;;;1997         
;;;1998         return HAL_ERROR;
000070  2001              MOVS     r0,#1
                  |L5.114|
;;;1999       }
;;;2000        
;;;2001       /* Wait for ADC effectively disabled */
;;;2002       /* Get tick count */
;;;2003       tickstart = HAL_GetTick();
;;;2004       
;;;2005       while(HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADEN))
;;;2006       {
;;;2007         if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
;;;2008         {
;;;2009           /* Update ADC state machine to error */
;;;2010           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;2011         
;;;2012           /* Set ADC error code to ADC IP internal error */
;;;2013           SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;2014           
;;;2015           return HAL_ERROR;
;;;2016         }
;;;2017       }
;;;2018     }
;;;2019     
;;;2020     /* Return HAL status */
;;;2021     return HAL_OK;
;;;2022   }
000072  bd70              POP      {r4-r6,pc}
                  |L5.116|
000074  f7fffffe          BL       HAL_GetTick
000078  4605              MOV      r5,r0                 ;2003
00007a  e00e              B        |L5.154|
                  |L5.124|
00007c  f7fffffe          BL       HAL_GetTick
000080  1b40              SUBS     r0,r0,r5              ;2007
000082  2802              CMP      r0,#2                 ;2007
000084  d909              BLS      |L5.154|
000086  6c60              LDR      r0,[r4,#0x44]         ;2010
000088  2110              MOVS     r1,#0x10              ;2010
00008a  4308              ORRS     r0,r0,r1              ;2010
00008c  6460              STR      r0,[r4,#0x44]         ;2010
00008e  6ca0              LDR      r0,[r4,#0x48]         ;2013
000090  2101              MOVS     r1,#1                 ;2013
000092  4308              ORRS     r0,r0,r1              ;2013
000094  64a0              STR      r0,[r4,#0x48]         ;2013
000096  2001              MOVS     r0,#1                 ;2015
000098  e7eb              B        |L5.114|
                  |L5.154|
00009a  6820              LDR      r0,[r4,#0]            ;2005
00009c  6880              LDR      r0,[r0,#8]            ;2005
00009e  07c0              LSLS     r0,r0,#31             ;2005
0000a0  0fc0              LSRS     r0,r0,#31             ;2005
0000a2  2800              CMP      r0,#0                 ;2005
0000a4  d1ea              BNE      |L5.124|
                  |L5.166|
0000a6  2000              MOVS     r0,#0                 ;2021
0000a8  e7e3              B        |L5.114|
;;;2023   
                          ENDP


                          AREA ||i.ADC_Enable||, CODE, READONLY, ALIGN=2

                  ADC_Enable PROC
;;;1909     */
;;;1910   static HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
000000  b538              PUSH     {r3-r5,lr}
;;;1911   {
000002  4604              MOV      r4,r0
;;;1912     uint32_t tickstart = 0U;
000004  2500              MOVS     r5,#0
;;;1913     __IO uint32_t wait_loop_index = 0U;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;1914     
;;;1915     /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
;;;1916     /* enabling phase not yet completed: flag ADC ready not yet set).           */
;;;1917     /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
;;;1918     /* causes: ADC clock not running, ...).                                     */
;;;1919     if (ADC_IS_ENABLE(hadc) == RESET)
00000a  6820              LDR      r0,[r4,#0]
00000c  6880              LDR      r0,[r0,#8]
00000e  0780              LSLS     r0,r0,#30
000010  0f80              LSRS     r0,r0,#30
000012  2801              CMP      r0,#1
000014  d10e              BNE      |L6.52|
000016  6820              LDR      r0,[r4,#0]
000018  6800              LDR      r0,[r0,#0]
00001a  07c0              LSLS     r0,r0,#31
00001c  0fc0              LSRS     r0,r0,#31
00001e  2800              CMP      r0,#0
000020  d106              BNE      |L6.48|
000022  6820              LDR      r0,[r4,#0]
000024  68c0              LDR      r0,[r0,#0xc]
000026  2101              MOVS     r1,#1
000028  03c9              LSLS     r1,r1,#15
00002a  4008              ANDS     r0,r0,r1
00002c  4288              CMP      r0,r1
00002e  d101              BNE      |L6.52|
                  |L6.48|
000030  2001              MOVS     r0,#1
000032  e000              B        |L6.54|
                  |L6.52|
000034  2000              MOVS     r0,#0
                  |L6.54|
000036  2800              CMP      r0,#0
000038  d143              BNE      |L6.194|
;;;1920     {
;;;1921       /* Check if conditions to enable the ADC are fulfilled */
;;;1922       if (ADC_ENABLING_CONDITIONS(hadc) == RESET)
00003a  6820              LDR      r0,[r4,#0]
00003c  6880              LDR      r0,[r0,#8]
00003e  4922              LDR      r1,|L6.200|
000040  4008              ANDS     r0,r0,r1
000042  2800              CMP      r0,#0
000044  d101              BNE      |L6.74|
000046  2001              MOVS     r0,#1
000048  e000              B        |L6.76|
                  |L6.74|
00004a  2000              MOVS     r0,#0
                  |L6.76|
00004c  2800              CMP      r0,#0
00004e  d109              BNE      |L6.100|
;;;1923       {
;;;1924         /* Update ADC state machine to error */
;;;1925         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
000050  6c60              LDR      r0,[r4,#0x44]
000052  2110              MOVS     r1,#0x10
000054  4308              ORRS     r0,r0,r1
000056  6460              STR      r0,[r4,#0x44]
;;;1926       
;;;1927         /* Set ADC error code to ADC IP internal error */
;;;1928         SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
000058  6ca0              LDR      r0,[r4,#0x48]
00005a  2101              MOVS     r1,#1
00005c  4308              ORRS     r0,r0,r1
00005e  64a0              STR      r0,[r4,#0x48]
;;;1929         
;;;1930         return HAL_ERROR;
000060  2001              MOVS     r0,#1
                  |L6.98|
;;;1931       }
;;;1932       
;;;1933       /* Enable the ADC peripheral */
;;;1934       __HAL_ADC_ENABLE(hadc);
;;;1935       
;;;1936       /* Delay for ADC stabilization time */
;;;1937       /* Compute number of CPU cycles to wait for */
;;;1938       wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
;;;1939       while(wait_loop_index != 0U)
;;;1940       {
;;;1941         wait_loop_index--;
;;;1942       }
;;;1943   
;;;1944       /* Get tick count */
;;;1945       tickstart = HAL_GetTick();
;;;1946       
;;;1947       /* Wait for ADC effectively enabled */
;;;1948       while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
;;;1949       {
;;;1950         if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
;;;1951         {
;;;1952           /* Update ADC state machine to error */
;;;1953           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;1954         
;;;1955           /* Set ADC error code to ADC IP internal error */
;;;1956           SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;1957         
;;;1958           return HAL_ERROR;
;;;1959         }
;;;1960       }   
;;;1961       
;;;1962     }
;;;1963      
;;;1964     /* Return HAL status */
;;;1965     return HAL_OK;
;;;1966   }
000062  bd38              POP      {r3-r5,pc}
                  |L6.100|
000064  6820              LDR      r0,[r4,#0]            ;1934
000066  6880              LDR      r0,[r0,#8]            ;1934
000068  2101              MOVS     r1,#1                 ;1934
00006a  4308              ORRS     r0,r0,r1              ;1934
00006c  6821              LDR      r1,[r4,#0]            ;1934
00006e  6088              STR      r0,[r1,#8]            ;1934
000070  4916              LDR      r1,|L6.204|
000072  4817              LDR      r0,|L6.208|
000074  6800              LDR      r0,[r0,#0]            ;1938  ; SystemCoreClock
000076  f7fffffe          BL       __aeabi_uidivmod
00007a  9000              STR      r0,[sp,#0]            ;1938
00007c  e002              B        |L6.132|
                  |L6.126|
00007e  9800              LDR      r0,[sp,#0]            ;1941
000080  1e40              SUBS     r0,r0,#1              ;1941
000082  9000              STR      r0,[sp,#0]            ;1941
                  |L6.132|
000084  9800              LDR      r0,[sp,#0]            ;1939
000086  2800              CMP      r0,#0                 ;1939
000088  d1f9              BNE      |L6.126|
00008a  f7fffffe          BL       HAL_GetTick
00008e  4605              MOV      r5,r0                 ;1945
000090  e00e              B        |L6.176|
                  |L6.146|
000092  f7fffffe          BL       HAL_GetTick
000096  1b40              SUBS     r0,r0,r5              ;1950
000098  2802              CMP      r0,#2                 ;1950
00009a  d909              BLS      |L6.176|
00009c  6c60              LDR      r0,[r4,#0x44]         ;1953
00009e  2110              MOVS     r1,#0x10              ;1953
0000a0  4308              ORRS     r0,r0,r1              ;1953
0000a2  6460              STR      r0,[r4,#0x44]         ;1953
0000a4  6ca0              LDR      r0,[r4,#0x48]         ;1956
0000a6  2101              MOVS     r1,#1                 ;1956
0000a8  4308              ORRS     r0,r0,r1              ;1956
0000aa  64a0              STR      r0,[r4,#0x48]         ;1956
0000ac  2001              MOVS     r0,#1                 ;1958
0000ae  e7d8              B        |L6.98|
                  |L6.176|
0000b0  6820              LDR      r0,[r4,#0]            ;1948
0000b2  6800              LDR      r0,[r0,#0]            ;1948
0000b4  07c0              LSLS     r0,r0,#31             ;1948
0000b6  0fc0              LSRS     r0,r0,#31             ;1948
0000b8  2101              MOVS     r1,#1                 ;1948
0000ba  4048              EORS     r0,r0,r1              ;1948
0000bc  4048              EORS     r0,r0,r1              ;1948
0000be  2800              CMP      r0,#0                 ;1948
0000c0  d0e7              BEQ      |L6.146|
                  |L6.194|
0000c2  2000              MOVS     r0,#0                 ;1965
0000c4  e7cd              B        |L6.98|
;;;1967   
                          ENDP

0000c6  0000              DCW      0x0000
                  |L6.200|
                          DCD      0x80000017
                  |L6.204|
                          DCD      0x000f4240
                  |L6.208|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_ADC_AnalogWDGConfig||, CODE, READONLY, ALIGN=2

                  HAL_ADC_AnalogWDGConfig PROC
;;;1743     */
;;;1744   HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1745   {
000002  4602              MOV      r2,r0
;;;1746     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1747     
;;;1748     uint32_t tmpAWDHighThresholdShifted;
;;;1749     uint32_t tmpAWDLowThresholdShifted;
;;;1750     
;;;1751     /* Check the parameters */
;;;1752     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1753     assert_param(IS_ADC_ANALOG_WATCHDOG_MODE(AnalogWDGConfig->WatchdogMode));
;;;1754     assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));
;;;1755   
;;;1756     /* Verify if threshold is within the selected ADC resolution */
;;;1757     assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), AnalogWDGConfig->HighThreshold));
;;;1758     assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), AnalogWDGConfig->LowThreshold));
;;;1759   
;;;1760     if(AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)
000006  2603              MOVS     r6,#3
000008  05b6              LSLS     r6,r6,#22
00000a  6808              LDR      r0,[r1,#0]
00000c  42b0              CMP      r0,r6
00000e  d100              BNE      |L7.18|
;;;1761     {
;;;1762       assert_param(IS_ADC_CHANNEL(AnalogWDGConfig->Channel));
000010  bf00              NOP      
                  |L7.18|
;;;1763     }
;;;1764     
;;;1765     /* Process locked */
;;;1766     __HAL_LOCK(hadc);
000012  bf00              NOP      
000014  2040              MOVS     r0,#0x40
000016  5c80              LDRB     r0,[r0,r2]
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L7.32|
00001c  2002              MOVS     r0,#2
                  |L7.30|
;;;1767     
;;;1768     /* Parameters update conditioned to ADC state:                              */
;;;1769     /* Parameters that can be updated when ADC is disabled or enabled without   */
;;;1770     /* conversion on going on regular group:                                    */
;;;1771     /*  - Analog watchdog channels                                              */
;;;1772     /*  - Analog watchdog thresholds                                            */
;;;1773     if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
;;;1774     {
;;;1775       /* Configuration of analog watchdog:                                      */
;;;1776       /*  - Set the analog watchdog enable mode: one or overall group of        */
;;;1777       /*    channels.                                                           */
;;;1778       /*  - Set the Analog watchdog channel (is not used if watchdog            */
;;;1779       /*    mode "all channels": ADC_CFGR_AWD1SGL=0).                           */
;;;1780       hadc->Instance->CFGR1 &= ~( ADC_CFGR1_AWDSGL |
;;;1781                                   ADC_CFGR1_AWDEN  |
;;;1782                                   ADC_CFGR1_AWDCH   );
;;;1783       
;;;1784       hadc->Instance->CFGR1 |= ( AnalogWDGConfig->WatchdogMode            |
;;;1785                                  ADC_CFGR_AWDCH(AnalogWDGConfig->Channel)  );
;;;1786   
;;;1787       /* Shift the offset in function of the selected ADC resolution: Thresholds*/
;;;1788       /* have to be left-aligned on bit 11, the LSB (right bits) are set to 0   */
;;;1789       tmpAWDHighThresholdShifted = ADC_AWD1THRESHOLD_SHIFT_RESOLUTION(hadc, AnalogWDGConfig->HighThreshold);
;;;1790       tmpAWDLowThresholdShifted  = ADC_AWD1THRESHOLD_SHIFT_RESOLUTION(hadc, AnalogWDGConfig->LowThreshold);
;;;1791       
;;;1792       /* Set the high and low thresholds */
;;;1793       hadc->Instance->TR &= ~(ADC_TR_HT | ADC_TR_LT);
;;;1794       hadc->Instance->TR |=  ( ADC_TRX_HIGHTHRESHOLD (tmpAWDHighThresholdShifted) |
;;;1795                                tmpAWDLowThresholdShifted                           );
;;;1796       
;;;1797       /* Clear the ADC Analog watchdog flag (in case of left enabled by         */
;;;1798       /* previous ADC operations) to be ready to use for HAL_ADC_IRQHandler()   */
;;;1799       /* or HAL_ADC_PollForEvent().                                             */
;;;1800       __HAL_ADC_CLEAR_FLAG(hadc, ADC_IT_AWD);
;;;1801       
;;;1802       /* Configure ADC Analog watchdog interrupt */
;;;1803       if(AnalogWDGConfig->ITMode == ENABLE)
;;;1804       {
;;;1805         /* Enable the ADC Analog watchdog interrupt */
;;;1806         __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
;;;1807       }
;;;1808       else
;;;1809       {
;;;1810         /* Disable the ADC Analog watchdog interrupt */
;;;1811         __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
;;;1812       }
;;;1813       
;;;1814     }
;;;1815     /* If a conversion is on going on regular group, no update could be done    */
;;;1816     /* on neither of the AWD configuration structure parameters.                */
;;;1817     else
;;;1818     {
;;;1819       /* Update ADC state machine to error */
;;;1820       SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1821       
;;;1822       tmp_hal_status = HAL_ERROR;
;;;1823     }
;;;1824     
;;;1825     
;;;1826     /* Process unlocked */
;;;1827     __HAL_UNLOCK(hadc);
;;;1828     
;;;1829     /* Return function status */
;;;1830     return tmp_hal_status;
;;;1831   }
00001e  bdf0              POP      {r4-r7,pc}
                  |L7.32|
000020  2601              MOVS     r6,#1                 ;1766
000022  2040              MOVS     r0,#0x40              ;1766
000024  5486              STRB     r6,[r0,r2]            ;1766
000026  bf00              NOP                            ;1766
000028  6810              LDR      r0,[r2,#0]            ;1773
00002a  6880              LDR      r0,[r0,#8]            ;1773
00002c  2604              MOVS     r6,#4                 ;1773
00002e  4030              ANDS     r0,r0,r6              ;1773
000030  0880              LSRS     r0,r0,#2              ;1773
000032  2800              CMP      r0,#0                 ;1773
000034  d13e              BNE      |L7.180|
000036  6810              LDR      r0,[r2,#0]            ;1780
000038  68c0              LDR      r0,[r0,#0xc]          ;1780
00003a  4e24              LDR      r6,|L7.204|
00003c  4030              ANDS     r0,r0,r6              ;1780
00003e  6816              LDR      r6,[r2,#0]            ;1780
000040  60f0              STR      r0,[r6,#0xc]          ;1780
000042  790e              LDRB     r6,[r1,#4]            ;1784
000044  06b6              LSLS     r6,r6,#26             ;1784
000046  6808              LDR      r0,[r1,#0]            ;1784
000048  4330              ORRS     r0,r0,r6              ;1784
00004a  6816              LDR      r6,[r2,#0]            ;1784
00004c  68f6              LDR      r6,[r6,#0xc]          ;1784
00004e  4330              ORRS     r0,r0,r6              ;1784
000050  6816              LDR      r6,[r2,#0]            ;1784
000052  60f0              STR      r0,[r6,#0xc]          ;1784
000054  68cb              LDR      r3,[r1,#0xc]          ;1789
000056  6816              LDR      r6,[r2,#0]            ;1789
000058  68f6              LDR      r6,[r6,#0xc]          ;1789
00005a  2718              MOVS     r7,#0x18              ;1789
00005c  403e              ANDS     r6,r6,r7              ;1789
00005e  08f6              LSRS     r6,r6,#3              ;1789
000060  0076              LSLS     r6,r6,#1              ;1789
000062  40b3              LSLS     r3,r3,r6              ;1789
000064  690c              LDR      r4,[r1,#0x10]         ;1790
000066  6816              LDR      r6,[r2,#0]            ;1790
000068  68f6              LDR      r6,[r6,#0xc]          ;1790
00006a  403e              ANDS     r6,r6,r7              ;1790
00006c  08f6              LSRS     r6,r6,#3              ;1790
00006e  0076              LSLS     r6,r6,#1              ;1790
000070  40b4              LSLS     r4,r4,r6              ;1790
000072  6810              LDR      r0,[r2,#0]            ;1793
000074  6a00              LDR      r0,[r0,#0x20]         ;1793
000076  4e16              LDR      r6,|L7.208|
000078  4030              ANDS     r0,r0,r6              ;1793
00007a  6816              LDR      r6,[r2,#0]            ;1793
00007c  6230              STR      r0,[r6,#0x20]         ;1793
00007e  6810              LDR      r0,[r2,#0]            ;1794
000080  6a00              LDR      r0,[r0,#0x20]         ;1794
000082  041e              LSLS     r6,r3,#16             ;1794
000084  4326              ORRS     r6,r6,r4              ;1794
000086  4330              ORRS     r0,r0,r6              ;1794
000088  6816              LDR      r6,[r2,#0]            ;1794
00008a  6230              STR      r0,[r6,#0x20]         ;1794
00008c  2080              MOVS     r0,#0x80              ;1800
00008e  6816              LDR      r6,[r2,#0]            ;1800
000090  6030              STR      r0,[r6,#0]            ;1800
000092  6888              LDR      r0,[r1,#8]            ;1803
000094  2801              CMP      r0,#1                 ;1803
000096  d106              BNE      |L7.166|
000098  6810              LDR      r0,[r2,#0]            ;1806
00009a  6840              LDR      r0,[r0,#4]            ;1806
00009c  2680              MOVS     r6,#0x80              ;1806
00009e  4330              ORRS     r0,r0,r6              ;1806
0000a0  6816              LDR      r6,[r2,#0]            ;1806
0000a2  6070              STR      r0,[r6,#4]            ;1806
0000a4  e00b              B        |L7.190|
                  |L7.166|
0000a6  6810              LDR      r0,[r2,#0]            ;1811
0000a8  6840              LDR      r0,[r0,#4]            ;1811
0000aa  2680              MOVS     r6,#0x80              ;1811
0000ac  43b0              BICS     r0,r0,r6              ;1811
0000ae  6816              LDR      r6,[r2,#0]            ;1811
0000b0  6070              STR      r0,[r6,#4]            ;1811
0000b2  e004              B        |L7.190|
                  |L7.180|
0000b4  6c50              LDR      r0,[r2,#0x44]         ;1820
0000b6  2620              MOVS     r6,#0x20              ;1820
0000b8  4330              ORRS     r0,r0,r6              ;1820
0000ba  6450              STR      r0,[r2,#0x44]         ;1820
0000bc  2501              MOVS     r5,#1                 ;1822
                  |L7.190|
0000be  bf00              NOP                            ;1827
0000c0  2600              MOVS     r6,#0                 ;1827
0000c2  2040              MOVS     r0,#0x40              ;1827
0000c4  5486              STRB     r6,[r0,r2]            ;1827
0000c6  bf00              NOP                            ;1827
0000c8  4628              MOV      r0,r5                 ;1830
0000ca  e7a8              B        |L7.30|
;;;1832   
                          ENDP

                  |L7.204|
                          DCD      0x833fffff
                  |L7.208|
                          DCD      0xf000f000

                          AREA ||i.HAL_ADC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_ADC_ConfigChannel PROC
;;;1610     */
;;;1611   HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1612   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1613     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000006  2600              MOVS     r6,#0
;;;1614     __IO uint32_t wait_loop_index = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;1615   
;;;1616     /* Check the parameters */
;;;1617     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1618     assert_param(IS_ADC_CHANNEL(sConfig->Channel));
;;;1619     assert_param(IS_ADC_RANK(sConfig->Rank));
;;;1620     
;;;1621     if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
00000c  2101              MOVS     r1,#1
00000e  0709              LSLS     r1,r1,#28
000010  6ba0              LDR      r0,[r4,#0x38]
000012  4288              CMP      r0,r1
000014  d015              BEQ      |L8.66|
000016  6ba0              LDR      r0,[r4,#0x38]
000018  2801              CMP      r0,#1
00001a  d012              BEQ      |L8.66|
00001c  6ba0              LDR      r0,[r4,#0x38]
00001e  2802              CMP      r0,#2
000020  d00f              BEQ      |L8.66|
000022  6ba0              LDR      r0,[r4,#0x38]
000024  2803              CMP      r0,#3
000026  d00c              BEQ      |L8.66|
000028  6ba0              LDR      r0,[r4,#0x38]
00002a  2804              CMP      r0,#4
00002c  d009              BEQ      |L8.66|
00002e  6ba0              LDR      r0,[r4,#0x38]
000030  2805              CMP      r0,#5
000032  d006              BEQ      |L8.66|
000034  6ba0              LDR      r0,[r4,#0x38]
000036  2806              CMP      r0,#6
000038  d003              BEQ      |L8.66|
00003a  6ba0              LDR      r0,[r4,#0x38]
00003c  2807              CMP      r0,#7
00003e  d000              BEQ      |L8.66|
;;;1622     {
;;;1623       assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
000040  bf00              NOP      
                  |L8.66|
;;;1624     }
;;;1625     
;;;1626     /* Process locked */
;;;1627     __HAL_LOCK(hadc);
000042  bf00              NOP      
000044  2040              MOVS     r0,#0x40
000046  5d00              LDRB     r0,[r0,r4]
000048  2801              CMP      r0,#1
00004a  d101              BNE      |L8.80|
00004c  2002              MOVS     r0,#2
                  |L8.78|
;;;1628     
;;;1629     /* Parameters update conditioned to ADC state:                              */
;;;1630     /* Parameters that can be updated when ADC is disabled or enabled without   */
;;;1631     /* conversion on going on regular group:                                    */
;;;1632     /*  - Channel number                                                        */
;;;1633     /*  - Channel sampling time                                                 */
;;;1634     /*  - Management of internal measurement channels: VrefInt/TempSensor/Vbat  */
;;;1635     if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
;;;1636     {
;;;1637       /* Configure channel: depending on rank setting, add it or remove it from */
;;;1638       /* ADC conversion sequencer.                                              */
;;;1639       if (sConfig->Rank != ADC_RANK_NONE)
;;;1640       {
;;;1641         /* Regular sequence configuration */
;;;1642         /* Set the channel selection register from the selected channel */
;;;1643         hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
;;;1644         
;;;1645         /* Channel sampling time configuration */
;;;1646         /* Management of parameters "SamplingTimeCommon" and "SamplingTime"     */
;;;1647         /* (obsolete): sampling time set in this function with                  */
;;;1648         /* parameter "SamplingTime" (obsolete) only if not already set into     */
;;;1649         /* ADC initialization structure with parameter "SamplingTimeCommon".    */
;;;1650         if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
;;;1651         {
;;;1652           /* Modify sampling time if needed (not needed in case of reoccurrence */
;;;1653           /* for several channels programmed consecutively into the sequencer)  */
;;;1654           if (sConfig->SamplingTime != ADC_GET_SAMPLINGTIME(hadc))
;;;1655           {
;;;1656             /* Channel sampling time configuration */
;;;1657             /* Clear the old sample time */
;;;1658             hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
;;;1659             
;;;1660             /* Set the new sample time */
;;;1661             hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
;;;1662           }
;;;1663         }
;;;1664         
;;;1665         /* Management of internal measurement channels: VrefInt/TempSensor/Vbat */
;;;1666         /* internal measurement paths enable: If internal channel selected,     */
;;;1667         /* enable dedicated internal buffers and path.                          */
;;;1668         /* Note: these internal measurement paths can be disabled using         */
;;;1669         /*       HAL_ADC_DeInit() or removing the channel from sequencer with   */
;;;1670         /*       channel configuration parameter "Rank".                        */
;;;1671         if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
;;;1672         {
;;;1673           /* If Channel_16 is selected, enable Temp. sensor measurement path. */
;;;1674           /* If Channel_17 is selected, enable VREFINT measurement path. */
;;;1675           /* If Channel_18 is selected, enable VBAT measurement path. */
;;;1676           ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
;;;1677           
;;;1678           /* If Temp. sensor is selected, wait for stabilization delay */
;;;1679           if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
;;;1680           {
;;;1681             /* Delay for temperature sensor stabilization time */
;;;1682             /* Compute number of CPU cycles to wait for */
;;;1683             wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
;;;1684             while(wait_loop_index != 0U)
;;;1685             {
;;;1686               wait_loop_index--;
;;;1687             }
;;;1688           }
;;;1689         }
;;;1690       }
;;;1691       else
;;;1692       {
;;;1693         /* Regular sequence configuration */
;;;1694         /* Reset the channel selection register from the selected channel */
;;;1695         hadc->Instance->CHSELR &= ~ADC_CHSELR_CHANNEL(sConfig->Channel);
;;;1696         
;;;1697         /* Management of internal measurement channels: VrefInt/TempSensor/Vbat */
;;;1698         /* internal measurement paths disable: If internal channel selected,    */
;;;1699         /* disable dedicated internal buffers and path.                         */
;;;1700         if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
;;;1701         {
;;;1702           /* If Channel_16 is selected, disable Temp. sensor measurement path. */
;;;1703           /* If Channel_17 is selected, disable VREFINT measurement path. */
;;;1704           /* If Channel_18 is selected, disable VBAT measurement path. */
;;;1705           ADC->CCR &= ~ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
;;;1706         }
;;;1707       }
;;;1708       
;;;1709     }
;;;1710      
;;;1711     /* If a conversion is on going on regular group, no update on regular       */
;;;1712     /* channel could be done on neither of the channel configuration structure  */
;;;1713     /* parameters.                                                              */
;;;1714     else
;;;1715     {
;;;1716       /* Update ADC state machine to error */
;;;1717       SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1718       
;;;1719       tmp_hal_status = HAL_ERROR;
;;;1720     }
;;;1721     
;;;1722     /* Process unlocked */
;;;1723     __HAL_UNLOCK(hadc);
;;;1724     
;;;1725     /* Return function status */
;;;1726     return tmp_hal_status;
;;;1727   }
00004e  bdf8              POP      {r3-r7,pc}
                  |L8.80|
000050  2101              MOVS     r1,#1                 ;1627
000052  2040              MOVS     r0,#0x40              ;1627
000054  5501              STRB     r1,[r0,r4]            ;1627
000056  bf00              NOP                            ;1627
000058  6820              LDR      r0,[r4,#0]            ;1635
00005a  6880              LDR      r0,[r0,#8]            ;1635
00005c  2104              MOVS     r1,#4                 ;1635
00005e  4008              ANDS     r0,r0,r1              ;1635
000060  0880              LSRS     r0,r0,#2              ;1635
000062  2800              CMP      r0,#0                 ;1635
000064  d17b              BNE      |L8.350|
000066  4944              LDR      r1,|L8.376|
000068  6868              LDR      r0,[r5,#4]            ;1639
00006a  4288              CMP      r0,r1                 ;1639
00006c  d05b              BEQ      |L8.294|
00006e  6820              LDR      r0,[r4,#0]            ;1643
000070  6a80              LDR      r0,[r0,#0x28]         ;1643
000072  782a              LDRB     r2,[r5,#0]            ;1643
000074  2101              MOVS     r1,#1                 ;1643
000076  4091              LSLS     r1,r1,r2              ;1643
000078  4308              ORRS     r0,r0,r1              ;1643
00007a  6821              LDR      r1,[r4,#0]            ;1643
00007c  6288              STR      r0,[r1,#0x28]         ;1643
00007e  2101              MOVS     r1,#1                 ;1650
000080  0709              LSLS     r1,r1,#28             ;1650
000082  6ba0              LDR      r0,[r4,#0x38]         ;1650
000084  4288              CMP      r0,r1                 ;1650
000086  d029              BEQ      |L8.220|
000088  6ba0              LDR      r0,[r4,#0x38]         ;1650
00008a  2801              CMP      r0,#1                 ;1650
00008c  d026              BEQ      |L8.220|
00008e  6ba0              LDR      r0,[r4,#0x38]         ;1650
000090  2802              CMP      r0,#2                 ;1650
000092  d023              BEQ      |L8.220|
000094  6ba0              LDR      r0,[r4,#0x38]         ;1650
000096  2803              CMP      r0,#3                 ;1650
000098  d020              BEQ      |L8.220|
00009a  6ba0              LDR      r0,[r4,#0x38]         ;1650
00009c  2804              CMP      r0,#4                 ;1650
00009e  d01d              BEQ      |L8.220|
0000a0  6ba0              LDR      r0,[r4,#0x38]         ;1650
0000a2  2805              CMP      r0,#5                 ;1650
0000a4  d01a              BEQ      |L8.220|
0000a6  6ba0              LDR      r0,[r4,#0x38]         ;1650
0000a8  2806              CMP      r0,#6                 ;1650
0000aa  d017              BEQ      |L8.220|
0000ac  6ba0              LDR      r0,[r4,#0x38]         ;1650
0000ae  2807              CMP      r0,#7                 ;1650
0000b0  d014              BEQ      |L8.220|
0000b2  68a8              LDR      r0,[r5,#8]            ;1654
0000b4  6821              LDR      r1,[r4,#0]            ;1654
0000b6  6949              LDR      r1,[r1,#0x14]         ;1654
0000b8  0749              LSLS     r1,r1,#29             ;1654
0000ba  0f49              LSRS     r1,r1,#29             ;1654
0000bc  4288              CMP      r0,r1                 ;1654
0000be  d00d              BEQ      |L8.220|
0000c0  6820              LDR      r0,[r4,#0]            ;1658
0000c2  6940              LDR      r0,[r0,#0x14]         ;1658
0000c4  08c0              LSRS     r0,r0,#3              ;1658
0000c6  00c0              LSLS     r0,r0,#3              ;1658
0000c8  6821              LDR      r1,[r4,#0]            ;1658
0000ca  6148              STR      r0,[r1,#0x14]         ;1658
0000cc  6820              LDR      r0,[r4,#0]            ;1661
0000ce  6940              LDR      r0,[r0,#0x14]         ;1661
0000d0  7a29              LDRB     r1,[r5,#8]            ;1661
0000d2  0749              LSLS     r1,r1,#29             ;1661
0000d4  0f49              LSRS     r1,r1,#29             ;1661
0000d6  4308              ORRS     r0,r0,r1              ;1661
0000d8  6821              LDR      r1,[r4,#0]            ;1661
0000da  6148              STR      r0,[r1,#0x14]         ;1661
                  |L8.220|
0000dc  6828              LDR      r0,[r5,#0]            ;1671
0000de  2810              CMP      r0,#0x10              ;1671
0000e0  d002              BEQ      |L8.232|
0000e2  6828              LDR      r0,[r5,#0]            ;1671
0000e4  2811              CMP      r0,#0x11              ;1671
0000e6  d13f              BNE      |L8.360|
                  |L8.232|
0000e8  4824              LDR      r0,|L8.380|
0000ea  6880              LDR      r0,[r0,#8]            ;1676
0000ec  6829              LDR      r1,[r5,#0]            ;1676
0000ee  2910              CMP      r1,#0x10              ;1676
0000f0  d101              BNE      |L8.246|
0000f2  04c9              LSLS     r1,r1,#19             ;1676
0000f4  e001              B        |L8.250|
                  |L8.246|
0000f6  2101              MOVS     r1,#1                 ;1676
0000f8  0589              LSLS     r1,r1,#22             ;1676
                  |L8.250|
0000fa  4308              ORRS     r0,r0,r1              ;1676
0000fc  491f              LDR      r1,|L8.380|
0000fe  6088              STR      r0,[r1,#8]            ;1676
000100  6828              LDR      r0,[r5,#0]            ;1679
000102  2810              CMP      r0,#0x10              ;1679
000104  d130              BNE      |L8.360|
000106  491e              LDR      r1,|L8.384|
000108  481e              LDR      r0,|L8.388|
00010a  6800              LDR      r0,[r0,#0]            ;1683  ; SystemCoreClock
00010c  f7fffffe          BL       __aeabi_uidivmod
000110  210a              MOVS     r1,#0xa               ;1683
000112  4348              MULS     r0,r1,r0              ;1683
000114  9000              STR      r0,[sp,#0]            ;1683
000116  e002              B        |L8.286|
                  |L8.280|
000118  9800              LDR      r0,[sp,#0]            ;1686
00011a  1e40              SUBS     r0,r0,#1              ;1686
00011c  9000              STR      r0,[sp,#0]            ;1686
                  |L8.286|
00011e  9800              LDR      r0,[sp,#0]            ;1684
000120  2800              CMP      r0,#0                 ;1684
000122  d1f9              BNE      |L8.280|
000124  e020              B        |L8.360|
                  |L8.294|
000126  6820              LDR      r0,[r4,#0]            ;1695
000128  6a80              LDR      r0,[r0,#0x28]         ;1695
00012a  782a              LDRB     r2,[r5,#0]            ;1695
00012c  2101              MOVS     r1,#1                 ;1695
00012e  4091              LSLS     r1,r1,r2              ;1695
000130  4388              BICS     r0,r0,r1              ;1695
000132  6821              LDR      r1,[r4,#0]            ;1695
000134  6288              STR      r0,[r1,#0x28]         ;1695
000136  6828              LDR      r0,[r5,#0]            ;1700
000138  2810              CMP      r0,#0x10              ;1700
00013a  d002              BEQ      |L8.322|
00013c  6828              LDR      r0,[r5,#0]            ;1700
00013e  2811              CMP      r0,#0x11              ;1700
000140  d112              BNE      |L8.360|
                  |L8.322|
000142  480e              LDR      r0,|L8.380|
000144  6880              LDR      r0,[r0,#8]            ;1705
000146  6829              LDR      r1,[r5,#0]            ;1705
000148  2910              CMP      r1,#0x10              ;1705
00014a  d102              BNE      |L8.338|
00014c  04c9              LSLS     r1,r1,#19             ;1705
00014e  e002              B        |L8.342|
000150  e005              B        |L8.350|
                  |L8.338|
000152  2101              MOVS     r1,#1                 ;1705
000154  0589              LSLS     r1,r1,#22             ;1705
                  |L8.342|
000156  4388              BICS     r0,r0,r1              ;1705
000158  4908              LDR      r1,|L8.380|
00015a  6088              STR      r0,[r1,#8]            ;1705
00015c  e004              B        |L8.360|
                  |L8.350|
00015e  6c60              LDR      r0,[r4,#0x44]         ;1717
000160  2120              MOVS     r1,#0x20              ;1717
000162  4308              ORRS     r0,r0,r1              ;1717
000164  6460              STR      r0,[r4,#0x44]         ;1717
000166  2601              MOVS     r6,#1                 ;1719
                  |L8.360|
000168  bf00              NOP                            ;1723
00016a  2100              MOVS     r1,#0                 ;1723
00016c  2040              MOVS     r0,#0x40              ;1723
00016e  5501              STRB     r1,[r0,r4]            ;1723
000170  bf00              NOP                            ;1723
000172  4630              MOV      r0,r6                 ;1726
000174  e76b              B        |L8.78|
;;;1728   
                          ENDP

000176  0000              DCW      0x0000
                  |L8.376|
                          DCD      0x00001001
                  |L8.380|
                          DCD      0x40012700
                  |L8.384|
                          DCD      0x000f4240
                  |L8.388|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_ADC_ConvCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvCpltCallback PROC
;;;1510     */
;;;1511   __weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1512   {
;;;1513     /* Prevent unused argument(s) compilation warning */
;;;1514     UNUSED(hadc);
;;;1515   
;;;1516     /* NOTE : This function should not be modified. When the callback is needed,
;;;1517               function HAL_ADC_ConvCpltCallback must be implemented in the user file.
;;;1518      */
;;;1519   }
;;;1520   
                          ENDP


                          AREA ||i.HAL_ADC_ConvHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ConvHalfCpltCallback PROC
;;;1525     */
;;;1526   __weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1527   {
;;;1528     /* Prevent unused argument(s) compilation warning */
;;;1529     UNUSED(hadc);
;;;1530   
;;;1531     /* NOTE : This function should not be modified. When the callback is needed,
;;;1532               function HAL_ADC_ConvHalfCpltCallback must be implemented in the user file.
;;;1533     */
;;;1534   }
;;;1535   
                          ENDP


                          AREA ||i.HAL_ADC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_ADC_DeInit PROC
;;;584      */
;;;585    HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;586    {
000002  4604              MOV      r4,r0
;;;587      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;588      
;;;589      /* Check ADC handle */
;;;590      if(hadc == NULL)
000006  2c00              CMP      r4,#0
000008  d101              BNE      |L11.14|
;;;591      {
;;;592         return HAL_ERROR;
00000a  2001              MOVS     r0,#1
                  |L11.12|
;;;593      }
;;;594      
;;;595      /* Check the parameters */
;;;596      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;597      
;;;598      /* Set ADC state */
;;;599      SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
;;;600      
;;;601      /* Stop potential conversion on going, on regular group */
;;;602      tmp_hal_status = ADC_ConversionStop(hadc);
;;;603      
;;;604      /* Disable ADC peripheral if conversions are effectively stopped */
;;;605      if (tmp_hal_status == HAL_OK)
;;;606      {   
;;;607        /* Disable the ADC peripheral */
;;;608        tmp_hal_status = ADC_Disable(hadc);
;;;609        
;;;610        /* Check if ADC is effectively disabled */
;;;611        if (tmp_hal_status != HAL_ERROR)
;;;612        {
;;;613          /* Change ADC state */
;;;614          hadc->State = HAL_ADC_STATE_READY;
;;;615        }
;;;616      }
;;;617      
;;;618      
;;;619      /* Configuration of ADC parameters if previous preliminary actions are      */ 
;;;620      /* correctly completed.                                                     */
;;;621      if (tmp_hal_status != HAL_ERROR)
;;;622      {
;;;623      
;;;624        /* ========== Reset ADC registers ========== */
;;;625        /* Reset register IER */
;;;626        __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_AWD   | ADC_IT_OVR  |
;;;627                                    ADC_IT_EOS   | ADC_IT_EOC  |
;;;628                                    ADC_IT_EOSMP | ADC_IT_RDY   ) );
;;;629            
;;;630        /* Reset register ISR */
;;;631        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD   | ADC_FLAG_OVR  |
;;;632                                    ADC_FLAG_EOS   | ADC_FLAG_EOC  |
;;;633                                    ADC_FLAG_EOSMP | ADC_FLAG_RDY   ) );
;;;634          
;;;635        /* Reset register CR */
;;;636        /* Bits ADC_CR_ADCAL, ADC_CR_ADSTP, ADC_CR_ADSTART are in access mode     */
;;;637        /* "read-set": no direct reset applicable.                                */
;;;638    
;;;639        /* Reset register CFGR1 */
;;;640        hadc->Instance->CFGR1 &= ~(ADC_CFGR1_AWDCH   | ADC_CFGR1_AWDEN  | ADC_CFGR1_AWDSGL | ADC_CFGR1_DISCEN |
;;;641                                   ADC_CFGR1_AUTOFF  | ADC_CFGR1_WAIT   | ADC_CFGR1_CONT   | ADC_CFGR1_OVRMOD |     
;;;642                                   ADC_CFGR1_EXTEN   | ADC_CFGR1_EXTSEL | ADC_CFGR1_ALIGN  | ADC_CFGR1_RES    |
;;;643                                   ADC_CFGR1_SCANDIR | ADC_CFGR1_DMACFG | ADC_CFGR1_DMAEN                      );
;;;644        
;;;645        /* Reset register CFGR2 */
;;;646        /* Note: Update of ADC clock mode is conditioned to ADC state disabled:   */
;;;647        /*       already done above.                                              */
;;;648        hadc->Instance->CFGR2 &= ~ADC_CFGR2_CKMODE;
;;;649        
;;;650        /* Reset register SMPR */
;;;651        hadc->Instance->SMPR &= ~ADC_SMPR_SMP;
;;;652        
;;;653        /* Reset register TR1 */
;;;654        hadc->Instance->TR &= ~(ADC_TR_HT | ADC_TR_LT);
;;;655        
;;;656        /* Reset register CHSELR */
;;;657        hadc->Instance->CHSELR &= ~(ADC_CHSELR_CHSEL18 | ADC_CHSELR_CHSEL17 | ADC_CHSELR_CHSEL16 |
;;;658                                    ADC_CHSELR_CHSEL15 | ADC_CHSELR_CHSEL14 | ADC_CHSELR_CHSEL13 | ADC_CHSELR_CHSEL12 |
;;;659                                    ADC_CHSELR_CHSEL11 | ADC_CHSELR_CHSEL10 | ADC_CHSELR_CHSEL9  | ADC_CHSELR_CHSEL8  |
;;;660                                    ADC_CHSELR_CHSEL7  | ADC_CHSELR_CHSEL6  | ADC_CHSELR_CHSEL5  | ADC_CHSELR_CHSEL4  |
;;;661                                    ADC_CHSELR_CHSEL3  | ADC_CHSELR_CHSEL2  | ADC_CHSELR_CHSEL1  | ADC_CHSELR_CHSEL0   );
;;;662        
;;;663        /* Reset register DR */
;;;664        /* bits in access mode read only, no direct reset applicable*/
;;;665        
;;;666        /* Reset register CCR */
;;;667        ADC->CCR &= ~(ADC_CCR_ALL);
;;;668    
;;;669        /* ========== Hard reset ADC peripheral ========== */
;;;670        /* Performs a global reset of the entire ADC peripheral: ADC state is     */
;;;671        /* forced to a similar state after device power-on.                       */
;;;672        /* If needed, copy-paste and uncomment the following reset code into      */
;;;673        /* function "void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)":              */
;;;674        /*                                                                        */
;;;675        /*  __HAL_RCC_ADC1_FORCE_RESET()                                                  */
;;;676        /*  __HAL_RCC_ADC1_RELEASE_RESET()                                                */
;;;677        
;;;678        /* DeInit the low level hardware */
;;;679        HAL_ADC_MspDeInit(hadc);
;;;680        
;;;681        /* Set ADC error code to none */
;;;682        ADC_CLEAR_ERRORCODE(hadc);
;;;683        
;;;684        /* Set ADC state */
;;;685        hadc->State = HAL_ADC_STATE_RESET; 
;;;686      }
;;;687      
;;;688      /* Process unlocked */
;;;689      __HAL_UNLOCK(hadc);
;;;690      
;;;691      /* Return function status */
;;;692      return tmp_hal_status;
;;;693    }
00000c  bd70              POP      {r4-r6,pc}
                  |L11.14|
00000e  6c60              LDR      r0,[r4,#0x44]         ;599
000010  2102              MOVS     r1,#2                 ;599
000012  4308              ORRS     r0,r0,r1              ;599
000014  6460              STR      r0,[r4,#0x44]         ;599
000016  4620              MOV      r0,r4                 ;602
000018  f7fffffe          BL       ADC_ConversionStop
00001c  4605              MOV      r5,r0                 ;602
00001e  2d00              CMP      r5,#0                 ;605
000020  d107              BNE      |L11.50|
000022  4620              MOV      r0,r4                 ;608
000024  f7fffffe          BL       ADC_Disable
000028  4605              MOV      r5,r0                 ;608
00002a  2d01              CMP      r5,#1                 ;611
00002c  d001              BEQ      |L11.50|
00002e  2001              MOVS     r0,#1                 ;614
000030  6460              STR      r0,[r4,#0x44]         ;614
                  |L11.50|
000032  2d01              CMP      r5,#1                 ;621
000034  d033              BEQ      |L11.158|
000036  6820              LDR      r0,[r4,#0]            ;626
000038  6840              LDR      r0,[r0,#4]            ;626
00003a  219f              MOVS     r1,#0x9f              ;626
00003c  4388              BICS     r0,r0,r1              ;626
00003e  6821              LDR      r1,[r4,#0]            ;626
000040  6048              STR      r0,[r1,#4]            ;626
000042  209f              MOVS     r0,#0x9f              ;631
000044  6821              LDR      r1,[r4,#0]            ;631
000046  6008              STR      r0,[r1,#0]            ;631
000048  6820              LDR      r0,[r4,#0]            ;640
00004a  68c0              LDR      r0,[r0,#0xc]          ;640
00004c  4917              LDR      r1,|L11.172|
00004e  4008              ANDS     r0,r0,r1              ;640
000050  6821              LDR      r1,[r4,#0]            ;640
000052  60c8              STR      r0,[r1,#0xc]          ;640
000054  6820              LDR      r0,[r4,#0]            ;648
000056  6900              LDR      r0,[r0,#0x10]         ;648
000058  0080              LSLS     r0,r0,#2              ;648
00005a  0880              LSRS     r0,r0,#2              ;648
00005c  6821              LDR      r1,[r4,#0]            ;648
00005e  6108              STR      r0,[r1,#0x10]         ;648
000060  6820              LDR      r0,[r4,#0]            ;651
000062  6940              LDR      r0,[r0,#0x14]         ;651
000064  08c0              LSRS     r0,r0,#3              ;651
000066  00c0              LSLS     r0,r0,#3              ;651
000068  6821              LDR      r1,[r4,#0]            ;651
00006a  6148              STR      r0,[r1,#0x14]         ;651
00006c  6820              LDR      r0,[r4,#0]            ;654
00006e  6a00              LDR      r0,[r0,#0x20]         ;654
000070  490f              LDR      r1,|L11.176|
000072  4008              ANDS     r0,r0,r1              ;654
000074  6821              LDR      r1,[r4,#0]            ;654
000076  6208              STR      r0,[r1,#0x20]         ;654
000078  6820              LDR      r0,[r4,#0]            ;657
00007a  6a80              LDR      r0,[r0,#0x28]         ;657
00007c  0cc0              LSRS     r0,r0,#19             ;657
00007e  04c0              LSLS     r0,r0,#19             ;657
000080  6821              LDR      r1,[r4,#0]            ;657
000082  6288              STR      r0,[r1,#0x28]         ;657
000084  480b              LDR      r0,|L11.180|
000086  6880              LDR      r0,[r0,#8]            ;667
000088  2103              MOVS     r1,#3                 ;667
00008a  0589              LSLS     r1,r1,#22             ;667
00008c  4388              BICS     r0,r0,r1              ;667
00008e  4909              LDR      r1,|L11.180|
000090  6088              STR      r0,[r1,#8]            ;667
000092  4620              MOV      r0,r4                 ;679
000094  f7fffffe          BL       HAL_ADC_MspDeInit
000098  2000              MOVS     r0,#0                 ;682
00009a  64a0              STR      r0,[r4,#0x48]         ;682
00009c  6460              STR      r0,[r4,#0x44]         ;685
                  |L11.158|
00009e  bf00              NOP                            ;689
0000a0  2100              MOVS     r1,#0                 ;689
0000a2  2040              MOVS     r0,#0x40              ;689
0000a4  5501              STRB     r1,[r0,r4]            ;689
0000a6  bf00              NOP                            ;689
0000a8  4628              MOV      r0,r5                 ;692
0000aa  e7af              B        |L11.12|
;;;694    
                          ENDP

                  |L11.172|
                          DCD      0x833e0200
                  |L11.176|
                          DCD      0xf000f000
                  |L11.180|
                          DCD      0x40012700

                          AREA ||i.HAL_ADC_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_ErrorCallback PROC
;;;1556     */
;;;1557   __weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
000000  4770              BX       lr
;;;1558   {
;;;1559     /* Prevent unused argument(s) compilation warning */
;;;1560     UNUSED(hadc);
;;;1561   
;;;1562     /* NOTE : This function should not be modified. When the callback is needed,
;;;1563               function HAL_ADC_ErrorCallback must be implemented in the user file.
;;;1564     */
;;;1565   }
;;;1566   
                          ENDP


                          AREA ||i.HAL_ADC_GetError||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetError PROC
;;;1879     */
;;;1880   uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
000000  4601              MOV      r1,r0
;;;1881   {
;;;1882     return hadc->ErrorCode;
000002  6c88              LDR      r0,[r1,#0x48]
;;;1883   }
000004  4770              BX       lr
;;;1884   
                          ENDP


                          AREA ||i.HAL_ADC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetState PROC
;;;1865     */
;;;1866   uint32_t HAL_ADC_GetState(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;1867   {
;;;1868     /* Check the parameters */
;;;1869     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1870     
;;;1871     /* Return ADC state */
;;;1872     return hadc->State;
000002  6c48              LDR      r0,[r1,#0x44]
;;;1873   }
000004  4770              BX       lr
;;;1874   
                          ENDP


                          AREA ||i.HAL_ADC_GetValue||, CODE, READONLY, ALIGN=1

                  HAL_ADC_GetValue PROC
;;;1377     */
;;;1378   uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
000000  4601              MOV      r1,r0
;;;1379   {
;;;1380     /* Check the parameters */
;;;1381     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1382   
;;;1383     /* Note: EOC flag is not cleared here by software because automatically     */
;;;1384     /*       cleared by hardware when reading register DR.                      */
;;;1385     
;;;1386     /* Return ADC converted value */ 
;;;1387     return hadc->Instance->DR;
000002  6808              LDR      r0,[r1,#0]
000004  6c00              LDR      r0,[r0,#0x40]
;;;1388   }
000006  4770              BX       lr
;;;1389   
                          ENDP


                          AREA ||i.HAL_ADC_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_ADC_IRQHandler PROC
;;;1394     */
;;;1395   void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
000000  b510              PUSH     {r4,lr}
;;;1396   {
000002  4604              MOV      r4,r0
;;;1397     /* Check the parameters */
;;;1398     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1399     assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;1400     assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
;;;1401     
;;;1402     /* ========== Check End of Conversion flag for regular group ========== */
;;;1403     if( (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC)) || 
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  2104              MOVS     r1,#4
00000a  4008              ANDS     r0,r0,r1
00000c  2804              CMP      r0,#4
00000e  d104              BNE      |L16.26|
000010  6820              LDR      r0,[r4,#0]
000012  6840              LDR      r0,[r0,#4]
000014  4008              ANDS     r0,r0,r1
000016  2804              CMP      r0,#4
000018  d00a              BEQ      |L16.48|
                  |L16.26|
;;;1404         (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOS))   )
00001a  6820              LDR      r0,[r4,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  2108              MOVS     r1,#8
000020  4008              ANDS     r0,r0,r1
000022  2808              CMP      r0,#8
000024  d140              BNE      |L16.168|
000026  6820              LDR      r0,[r4,#0]
000028  6840              LDR      r0,[r0,#4]
00002a  4008              ANDS     r0,r0,r1
00002c  2808              CMP      r0,#8
00002e  d13b              BNE      |L16.168|
                  |L16.48|
;;;1405     {
;;;1406       /* Update state machine on conversion status if not in error state */
;;;1407       if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
000030  6c60              LDR      r0,[r4,#0x44]
000032  2110              MOVS     r1,#0x10
000034  4008              ANDS     r0,r0,r1
000036  2800              CMP      r0,#0
000038  d103              BNE      |L16.66|
;;;1408       {
;;;1409         /* Set ADC state */
;;;1410         SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
00003a  6c60              LDR      r0,[r4,#0x44]
00003c  0149              LSLS     r1,r1,#5
00003e  4308              ORRS     r0,r0,r1
000040  6460              STR      r0,[r4,#0x44]
                  |L16.66|
;;;1411       }
;;;1412       
;;;1413       /* Determine whether any further conversion upcoming on group regular     */
;;;1414       /* by external trigger, continuous mode or scan sequence on going.        */
;;;1415       if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
000042  6820              LDR      r0,[r4,#0]
000044  68c0              LDR      r0,[r0,#0xc]
000046  2103              MOVS     r1,#3
000048  0289              LSLS     r1,r1,#10
00004a  4008              ANDS     r0,r0,r1
00004c  2800              CMP      r0,#0
00004e  d125              BNE      |L16.156|
;;;1416          (hadc->Init.ContinuousConvMode == DISABLE)   )
000050  6a20              LDR      r0,[r4,#0x20]
000052  2800              CMP      r0,#0
000054  d122              BNE      |L16.156|
;;;1417       {
;;;1418         /* If End of Sequence is reached, disable interrupts */
;;;1419         if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
000056  6820              LDR      r0,[r4,#0]
000058  6800              LDR      r0,[r0,#0]
00005a  2108              MOVS     r1,#8
00005c  4008              ANDS     r0,r0,r1
00005e  2808              CMP      r0,#8
000060  d11c              BNE      |L16.156|
;;;1420         {
;;;1421           /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit           */
;;;1422           /* ADSTART==0 (no conversion on going)                                */
;;;1423           if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
000062  6820              LDR      r0,[r4,#0]
000064  6880              LDR      r0,[r0,#8]
000066  2104              MOVS     r1,#4
000068  4008              ANDS     r0,r0,r1
00006a  0880              LSRS     r0,r0,#2
00006c  2800              CMP      r0,#0
00006e  d10d              BNE      |L16.140|
;;;1424           {
;;;1425             /* Disable ADC end of single conversion interrupt on group regular */
;;;1426             /* Note: Overrun interrupt was enabled with EOC interrupt in        */
;;;1427             /* HAL_Start_IT(), but is not disabled here because can be used     */
;;;1428             /* by overrun IRQ process below.                                    */
;;;1429             __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
000070  6820              LDR      r0,[r4,#0]
000072  6840              LDR      r0,[r0,#4]
000074  210c              MOVS     r1,#0xc
000076  4388              BICS     r0,r0,r1
000078  6821              LDR      r1,[r4,#0]
00007a  6048              STR      r0,[r1,#4]
;;;1430             
;;;1431             /* Set ADC state */
;;;1432             ADC_STATE_CLR_SET(hadc->State,
00007c  6c60              LDR      r0,[r4,#0x44]
00007e  21ff              MOVS     r1,#0xff
000080  3101              ADDS     r1,#1
000082  4388              BICS     r0,r0,r1
000084  2101              MOVS     r1,#1
000086  4308              ORRS     r0,r0,r1
000088  6460              STR      r0,[r4,#0x44]
00008a  e007              B        |L16.156|
                  |L16.140|
;;;1433                               HAL_ADC_STATE_REG_BUSY,
;;;1434                               HAL_ADC_STATE_READY);
;;;1435           }
;;;1436           else
;;;1437           {
;;;1438             /* Change ADC state to error state */
;;;1439             SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
00008c  6c60              LDR      r0,[r4,#0x44]
00008e  2120              MOVS     r1,#0x20
000090  4308              ORRS     r0,r0,r1
000092  6460              STR      r0,[r4,#0x44]
;;;1440             
;;;1441             /* Set ADC error code to ADC IP internal error */
;;;1442             SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
000094  6ca0              LDR      r0,[r4,#0x48]
000096  2101              MOVS     r1,#1
000098  4308              ORRS     r0,r0,r1
00009a  64a0              STR      r0,[r4,#0x48]
                  |L16.156|
;;;1443           }
;;;1444         }
;;;1445       }
;;;1446       
;;;1447       /* Conversion complete callback */
;;;1448       /* Note: into callback, to determine if conversion has been triggered     */
;;;1449       /*       from EOC or EOS, possibility to use:                             */
;;;1450       /*        " if( __HAL_ADC_GET_FLAG(&hadc, ADC_FLAG_EOS)) "                */
;;;1451         HAL_ADC_ConvCpltCallback(hadc);
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       HAL_ADC_ConvCpltCallback
;;;1452   
;;;1453       
;;;1454       /* Clear regular group conversion flag */
;;;1455       /* Note: in case of overrun set to ADC_OVR_DATA_PRESERVED, end of         */
;;;1456       /*       conversion flags clear induces the release of the preserved data.*/
;;;1457       /*       Therefore, if the preserved data value is needed, it must be     */
;;;1458       /*       read preliminarily into HAL_ADC_ConvCpltCallback().              */
;;;1459       __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS) );
0000a2  200c              MOVS     r0,#0xc
0000a4  6821              LDR      r1,[r4,#0]
0000a6  6008              STR      r0,[r1,#0]
                  |L16.168|
;;;1460     }
;;;1461      
;;;1462     /* ========== Check Analog watchdog flags ========== */
;;;1463     if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD))
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6800              LDR      r0,[r0,#0]
0000ac  2180              MOVS     r1,#0x80
0000ae  4008              ANDS     r0,r0,r1
0000b0  2880              CMP      r0,#0x80
0000b2  d10e              BNE      |L16.210|
0000b4  6820              LDR      r0,[r4,#0]
0000b6  6840              LDR      r0,[r0,#4]
0000b8  4008              ANDS     r0,r0,r1
0000ba  2880              CMP      r0,#0x80
0000bc  d109              BNE      |L16.210|
;;;1464     {
;;;1465         /* Set ADC state */
;;;1466         SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
0000be  6c60              LDR      r0,[r4,#0x44]
0000c0  0249              LSLS     r1,r1,#9
0000c2  4308              ORRS     r0,r0,r1
0000c4  6460              STR      r0,[r4,#0x44]
;;;1467   
;;;1468       /* Level out of window callback */ 
;;;1469       HAL_ADC_LevelOutOfWindowCallback(hadc);
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       HAL_ADC_LevelOutOfWindowCallback
;;;1470       
;;;1471       /* Clear ADC Analog watchdog flag */
;;;1472       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
0000cc  2080              MOVS     r0,#0x80
0000ce  6821              LDR      r1,[r4,#0]
0000d0  6008              STR      r0,[r1,#0]
                  |L16.210|
;;;1473      
;;;1474     }
;;;1475     
;;;1476     
;;;1477     /* ========== Check Overrun flag ========== */
;;;1478     if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR))
0000d2  6820              LDR      r0,[r4,#0]
0000d4  6800              LDR      r0,[r0,#0]
0000d6  2110              MOVS     r1,#0x10
0000d8  4008              ANDS     r0,r0,r1
0000da  2810              CMP      r0,#0x10
0000dc  d11a              BNE      |L16.276|
0000de  6820              LDR      r0,[r4,#0]
0000e0  6840              LDR      r0,[r0,#4]
0000e2  4008              ANDS     r0,r0,r1
0000e4  2810              CMP      r0,#0x10
0000e6  d115              BNE      |L16.276|
;;;1479     {
;;;1480       /* If overrun is set to overwrite previous data (default setting),        */
;;;1481       /* overrun event is not considered as an error.                           */
;;;1482       /* (cf ref manual "Managing conversions without using the DMA and without */
;;;1483       /* overrun ")                                                             */
;;;1484       /* Exception for usage with DMA overrun event always considered as an     */
;;;1485       /* error.                                                                 */
;;;1486       if ((hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)            ||
0000e8  6b60              LDR      r0,[r4,#0x34]
0000ea  2801              CMP      r0,#1
0000ec  d005              BEQ      |L16.250|
;;;1487           HAL_IS_BIT_SET(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN)  )
0000ee  6820              LDR      r0,[r4,#0]
0000f0  68c0              LDR      r0,[r0,#0xc]
0000f2  07c0              LSLS     r0,r0,#31
0000f4  0fc0              LSRS     r0,r0,#31
0000f6  2800              CMP      r0,#0
0000f8  d009              BEQ      |L16.270|
                  |L16.250|
;;;1488       {
;;;1489         /* Set ADC error code to overrun */
;;;1490         SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
0000fa  6ca0              LDR      r0,[r4,#0x48]
0000fc  2102              MOVS     r1,#2
0000fe  4308              ORRS     r0,r0,r1
000100  64a0              STR      r0,[r4,#0x48]
;;;1491         
;;;1492         /* Clear ADC overrun flag */
;;;1493         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
000102  2010              MOVS     r0,#0x10
000104  6821              LDR      r1,[r4,#0]
000106  6008              STR      r0,[r1,#0]
;;;1494         
;;;1495         /* Error callback */ 
;;;1496         HAL_ADC_ErrorCallback(hadc);
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       HAL_ADC_ErrorCallback
                  |L16.270|
;;;1497       }
;;;1498       
;;;1499       /* Clear the Overrun flag */
;;;1500       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
00010e  2010              MOVS     r0,#0x10
000110  6821              LDR      r1,[r4,#0]
000112  6008              STR      r0,[r1,#0]
                  |L16.276|
;;;1501     }
;;;1502   
;;;1503   }
000114  bd10              POP      {r4,pc}
;;;1504   
                          ENDP


                          AREA ||i.HAL_ADC_Init||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Init PROC
;;;358      */
;;;359    HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;360    {
000002  4604              MOV      r4,r0
;;;361      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2600              MOVS     r6,#0
;;;362      uint32_t tmpCFGR1 = 0U;
000006  2500              MOVS     r5,#0
;;;363    
;;;364      /* Check ADC handle */
;;;365      if(hadc == NULL)
000008  2c00              CMP      r4,#0
00000a  d101              BNE      |L17.16|
;;;366      {
;;;367        return HAL_ERROR;
00000c  2001              MOVS     r0,#1
                  |L17.14|
;;;368      }
;;;369      
;;;370      /* Check the parameters */
;;;371      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;372      assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
;;;373      assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
;;;374      assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign)); 
;;;375      assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
;;;376      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;377      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
;;;378      assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));   
;;;379      assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));   
;;;380      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
;;;381      assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
;;;382      assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
;;;383      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
;;;384      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoPowerOff));
;;;385      
;;;386      /* As prerequisite, into HAL_ADC_MspInit(), ADC clock must be configured    */
;;;387      /* at RCC top level depending on both possible clock sources:               */
;;;388      /* APB clock or HSI clock.                                                  */
;;;389      /* Refer to header of this file for more details on clock enabling procedure*/
;;;390      
;;;391      /* Actions performed only if ADC is coming from state reset:                */
;;;392      /* - Initialization of ADC MSP                                              */
;;;393      /* - ADC voltage regulator enable                                           */
;;;394      if (hadc->State == HAL_ADC_STATE_RESET)
;;;395      {
;;;396        /* Initialize ADC error code */
;;;397        ADC_CLEAR_ERRORCODE(hadc);
;;;398        
;;;399        /* Allocate lock resource and initialize it */
;;;400        hadc->Lock = HAL_UNLOCKED;
;;;401        
;;;402        /* Init the low level hardware */
;;;403        HAL_ADC_MspInit(hadc);
;;;404      }
;;;405      
;;;406      /* Configuration of ADC parameters if previous preliminary actions are      */ 
;;;407      /* correctly completed.                                                     */
;;;408      /* and if there is no conversion on going on regular group (ADC can be      */ 
;;;409      /* enabled anyway, in case of call of this function to update a parameter   */
;;;410      /* on the fly).                                                             */
;;;411      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
;;;412          (tmp_hal_status == HAL_OK)                                &&
;;;413          (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)          )
;;;414      {
;;;415        /* Set ADC state */
;;;416        ADC_STATE_CLR_SET(hadc->State,
;;;417                          HAL_ADC_STATE_REG_BUSY,
;;;418                          HAL_ADC_STATE_BUSY_INTERNAL);
;;;419        
;;;420        /* Parameters update conditioned to ADC state:                            */
;;;421        /* Parameters that can be updated only when ADC is disabled:              */
;;;422        /*  - ADC clock mode                                                      */
;;;423        /*  - ADC clock prescaler                                                 */
;;;424        /*  - ADC resolution                                                      */
;;;425        if (ADC_IS_ENABLE(hadc) == RESET)
;;;426        {
;;;427          /* Some parameters of this register are not reset, since they are set   */
;;;428          /* by other functions and must be kept in case of usage of this         */
;;;429          /* function on the fly (update of a parameter of ADC_InitTypeDef        */
;;;430          /* without needing to reconfigure all other ADC groups/channels         */
;;;431          /* parameters):                                                         */
;;;432          /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
;;;433          /*     (set into HAL_ADC_ConfigChannel() )                              */
;;;434         
;;;435          /* Configuration of ADC resolution                                      */
;;;436          MODIFY_REG(hadc->Instance->CFGR1,
;;;437                     ADC_CFGR1_RES        ,
;;;438                     hadc->Init.Resolution );
;;;439          
;;;440          /* Configuration of ADC clock mode: clock source AHB or HSI with        */
;;;441          /* selectable prescaler                                                 */
;;;442          MODIFY_REG(hadc->Instance->CFGR2    ,
;;;443                     ADC_CFGR2_CKMODE         ,
;;;444                     hadc->Init.ClockPrescaler );
;;;445        }
;;;446          
;;;447        /* Configuration of ADC:                                                  */
;;;448        /*  - discontinuous mode                                                  */
;;;449        /*  - LowPowerAutoWait mode                                               */
;;;450        /*  - LowPowerAutoPowerOff mode                                           */
;;;451        /*  - continuous conversion mode                                          */
;;;452        /*  - overrun                                                             */
;;;453        /*  - external trigger to start conversion                                */
;;;454        /*  - external trigger polarity                                           */
;;;455        /*  - data alignment                                                      */
;;;456        /*  - resolution                                                          */
;;;457        /*  - scan direction                                                      */
;;;458        /*  - DMA continuous request                                              */
;;;459        hadc->Instance->CFGR1 &= ~( ADC_CFGR1_DISCEN  |
;;;460                                    ADC_CFGR1_AUTOFF  |
;;;461                                    ADC_CFGR1_AUTDLY  |
;;;462                                    ADC_CFGR1_CONT    |
;;;463                                    ADC_CFGR1_OVRMOD  |
;;;464                                    ADC_CFGR1_EXTSEL  |
;;;465                                    ADC_CFGR1_EXTEN   |
;;;466                                    ADC_CFGR1_ALIGN   |
;;;467                                    ADC_CFGR1_SCANDIR |
;;;468                                    ADC_CFGR1_DMACFG   );
;;;469    
;;;470        tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
;;;471                     ADC_CFGR1_AUTOOFF(hadc->Init.LowPowerAutoPowerOff)     |
;;;472                     ADC_CFGR1_CONTINUOUS(hadc->Init.ContinuousConvMode)    |
;;;473                     ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                  |
;;;474                     hadc->Init.DataAlign                                   |
;;;475                     ADC_SCANDIR(hadc->Init.ScanConvMode)                   |
;;;476                     ADC_CFGR1_DMACONTREQ(hadc->Init.DMAContinuousRequests)  );
;;;477        
;;;478        /* Enable discontinuous mode only if continuous mode is disabled */
;;;479        if (hadc->Init.DiscontinuousConvMode == ENABLE)
;;;480        {
;;;481          if (hadc->Init.ContinuousConvMode == DISABLE)
;;;482          {
;;;483            /* Enable the selected ADC group regular discontinuous mode */
;;;484            tmpCFGR1 |= ADC_CFGR1_DISCEN;
;;;485          }
;;;486          else
;;;487          {
;;;488            /* ADC regular group discontinuous was intended to be enabled,        */
;;;489            /* but ADC regular group modes continuous and sequencer discontinuous */
;;;490            /* cannot be enabled simultaneously.                                  */
;;;491            
;;;492            /* Update ADC state machine to error */
;;;493            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;494            
;;;495            /* Set ADC error code to ADC IP internal error */
;;;496            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;497          }
;;;498        }
;;;499        
;;;500        /* Enable external trigger if trigger selection is different of software  */
;;;501        /* start.                                                                 */
;;;502        /* Note: This configuration keeps the hardware feature of parameter       */
;;;503        /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
;;;504        /*       software start.                                                  */
;;;505        if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
;;;506        {
;;;507          tmpCFGR1 |= ( hadc->Init.ExternalTrigConv    |
;;;508                        hadc->Init.ExternalTrigConvEdge );
;;;509        }
;;;510        
;;;511        /* Update ADC configuration register with previous settings */
;;;512        hadc->Instance->CFGR1 |= tmpCFGR1;
;;;513        
;;;514        /* Channel sampling time configuration */
;;;515        /* Management of parameters "SamplingTimeCommon" and "SamplingTime"       */
;;;516        /* (obsolete): sampling time set in this function if parameter            */
;;;517        /*  "SamplingTimeCommon" has been set to a valid sampling time.           */
;;;518        /* Otherwise, sampling time is set into ADC channel initialization        */
;;;519        /* structure with parameter "SamplingTime" (obsolete).                    */
;;;520        if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
;;;521        {
;;;522          /* Channel sampling time configuration */
;;;523          /* Clear the old sample time */
;;;524          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
;;;525          
;;;526          /* Set the new sample time */
;;;527          hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
;;;528        }
;;;529        
;;;530        /* Check back that ADC registers have effectively been configured to      */
;;;531        /* ensure of no potential problem of ADC core IP clocking.                */
;;;532        /* Check through register CFGR1 (excluding analog watchdog configuration: */
;;;533        /* set into separate dedicated function, and bits of ADC resolution set   */
;;;534        /* out of temporary variable 'tmpCFGR1').                                 */
;;;535        if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWDCH | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL | ADC_CFGR1_RES))
;;;536             == tmpCFGR1)
;;;537        {
;;;538          /* Set ADC error code to none */
;;;539          ADC_CLEAR_ERRORCODE(hadc);
;;;540          
;;;541          /* Set the ADC state */
;;;542          ADC_STATE_CLR_SET(hadc->State,
;;;543                            HAL_ADC_STATE_BUSY_INTERNAL,
;;;544                            HAL_ADC_STATE_READY);
;;;545        }
;;;546        else
;;;547        {
;;;548          /* Update ADC state machine to error */
;;;549          ADC_STATE_CLR_SET(hadc->State,
;;;550                            HAL_ADC_STATE_BUSY_INTERNAL,
;;;551                            HAL_ADC_STATE_ERROR_INTERNAL);
;;;552          
;;;553          /* Set ADC error code to ADC IP internal error */
;;;554          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;555          
;;;556          tmp_hal_status = HAL_ERROR;
;;;557        }
;;;558      
;;;559      }
;;;560      else
;;;561      {
;;;562        /* Update ADC state machine to error */
;;;563        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;564            
;;;565        tmp_hal_status = HAL_ERROR;
;;;566      }
;;;567      
;;;568      /* Return function status */
;;;569      return tmp_hal_status;
;;;570    }
00000e  bd70              POP      {r4-r6,pc}
                  |L17.16|
000010  6c60              LDR      r0,[r4,#0x44]         ;394
000012  2800              CMP      r0,#0                 ;394
000014  d106              BNE      |L17.36|
000016  64a0              STR      r0,[r4,#0x48]         ;397
000018  2100              MOVS     r1,#0                 ;400
00001a  2040              MOVS     r0,#0x40              ;400
00001c  5501              STRB     r1,[r0,r4]            ;400
00001e  4620              MOV      r0,r4                 ;403
000020  f7fffffe          BL       HAL_ADC_MspInit
                  |L17.36|
000024  6c60              LDR      r0,[r4,#0x44]         ;411
000026  2110              MOVS     r1,#0x10              ;411
000028  4008              ANDS     r0,r0,r1              ;411
00002a  2800              CMP      r0,#0                 ;411
                  |L17.44|
00002c  d17e              BNE      |L17.300|
00002e  2e00              CMP      r6,#0                 ;412
000030  d1fc              BNE      |L17.44|
000032  6820              LDR      r0,[r4,#0]            ;413
000034  6880              LDR      r0,[r0,#8]            ;413
000036  2104              MOVS     r1,#4                 ;413
000038  4008              ANDS     r0,r0,r1              ;413
00003a  0880              LSRS     r0,r0,#2              ;413
00003c  2800              CMP      r0,#0                 ;413
00003e  d1f5              BNE      |L17.44|
000040  6c60              LDR      r0,[r4,#0x44]         ;416
000042  0189              LSLS     r1,r1,#6              ;416
000044  4388              BICS     r0,r0,r1              ;416
000046  2102              MOVS     r1,#2                 ;416
000048  4308              ORRS     r0,r0,r1              ;416
00004a  6460              STR      r0,[r4,#0x44]         ;416
00004c  6820              LDR      r0,[r4,#0]            ;425
00004e  6880              LDR      r0,[r0,#8]            ;425
000050  0780              LSLS     r0,r0,#30             ;425
000052  0f80              LSRS     r0,r0,#30             ;425
000054  2801              CMP      r0,#1                 ;425
000056  d10d              BNE      |L17.116|
000058  6820              LDR      r0,[r4,#0]            ;425
00005a  6800              LDR      r0,[r0,#0]            ;425
00005c  07c0              LSLS     r0,r0,#31             ;425
00005e  0fc0              LSRS     r0,r0,#31             ;425
000060  2800              CMP      r0,#0                 ;425
000062  d105              BNE      |L17.112|
000064  6820              LDR      r0,[r4,#0]            ;425
000066  68c0              LDR      r0,[r0,#0xc]          ;425
000068  0389              LSLS     r1,r1,#14             ;425
00006a  4008              ANDS     r0,r0,r1              ;425
00006c  4288              CMP      r0,r1                 ;425
00006e  d101              BNE      |L17.116|
                  |L17.112|
000070  2001              MOVS     r0,#1                 ;425
000072  e000              B        |L17.118|
                  |L17.116|
000074  2000              MOVS     r0,#0                 ;425
                  |L17.118|
000076  2800              CMP      r0,#0                 ;425
000078  d10f              BNE      |L17.154|
00007a  6820              LDR      r0,[r4,#0]            ;436
00007c  68c0              LDR      r0,[r0,#0xc]          ;436
00007e  2118              MOVS     r1,#0x18              ;436
000080  4388              BICS     r0,r0,r1              ;436
000082  68a1              LDR      r1,[r4,#8]            ;436
000084  4308              ORRS     r0,r0,r1              ;436
000086  6821              LDR      r1,[r4,#0]            ;436
000088  60c8              STR      r0,[r1,#0xc]          ;436
00008a  6820              LDR      r0,[r4,#0]            ;442
00008c  6900              LDR      r0,[r0,#0x10]         ;442
00008e  0080              LSLS     r0,r0,#2              ;442
000090  0880              LSRS     r0,r0,#2              ;442
000092  6861              LDR      r1,[r4,#4]            ;442
000094  4308              ORRS     r0,r0,r1              ;442
000096  6821              LDR      r1,[r4,#0]            ;442
000098  6108              STR      r0,[r1,#0x10]         ;442
                  |L17.154|
00009a  6820              LDR      r0,[r4,#0]            ;459
00009c  68c0              LDR      r0,[r0,#0xc]          ;459
00009e  4946              LDR      r1,|L17.440|
0000a0  4008              ANDS     r0,r0,r1              ;459
0000a2  6821              LDR      r1,[r4,#0]            ;459
0000a4  60c8              STR      r0,[r1,#0xc]          ;459
0000a6  69a0              LDR      r0,[r4,#0x18]         ;470
0000a8  0380              LSLS     r0,r0,#14             ;470
0000aa  69e1              LDR      r1,[r4,#0x1c]         ;470
0000ac  03c9              LSLS     r1,r1,#15             ;470
0000ae  4308              ORRS     r0,r0,r1              ;470
0000b0  6a21              LDR      r1,[r4,#0x20]         ;470
0000b2  0349              LSLS     r1,r1,#13             ;470
0000b4  4308              ORRS     r0,r0,r1              ;470
0000b6  6b61              LDR      r1,[r4,#0x34]         ;470
0000b8  2901              CMP      r1,#1                 ;470
0000ba  d002              BEQ      |L17.194|
0000bc  2101              MOVS     r1,#1                 ;473
0000be  0309              LSLS     r1,r1,#12             ;473
0000c0  e000              B        |L17.196|
                  |L17.194|
0000c2  2100              MOVS     r1,#0                 ;473
                  |L17.196|
0000c4  4308              ORRS     r0,r0,r1              ;473
0000c6  68e1              LDR      r1,[r4,#0xc]          ;473
0000c8  4308              ORRS     r0,r0,r1              ;473
0000ca  6921              LDR      r1,[r4,#0x10]         ;473
0000cc  2902              CMP      r1,#2                 ;473
0000ce  d101              BNE      |L17.212|
0000d0  2104              MOVS     r1,#4                 ;475
0000d2  e000              B        |L17.214|
                  |L17.212|
0000d4  2100              MOVS     r1,#0                 ;475
                  |L17.214|
0000d6  4308              ORRS     r0,r0,r1              ;475
0000d8  6b21              LDR      r1,[r4,#0x30]         ;475
0000da  0049              LSLS     r1,r1,#1              ;475
0000dc  4308              ORRS     r0,r0,r1              ;475
0000de  4305              ORRS     r5,r5,r0              ;475
0000e0  6a60              LDR      r0,[r4,#0x24]         ;479
0000e2  2801              CMP      r0,#1                 ;479
0000e4  d10e              BNE      |L17.260|
0000e6  6a20              LDR      r0,[r4,#0x20]         ;481
0000e8  2800              CMP      r0,#0                 ;481
0000ea  d103              BNE      |L17.244|
0000ec  2001              MOVS     r0,#1                 ;484
0000ee  0400              LSLS     r0,r0,#16             ;484
0000f0  4305              ORRS     r5,r5,r0              ;484
0000f2  e007              B        |L17.260|
                  |L17.244|
0000f4  6c60              LDR      r0,[r4,#0x44]         ;493
0000f6  2120              MOVS     r1,#0x20              ;493
0000f8  4308              ORRS     r0,r0,r1              ;493
0000fa  6460              STR      r0,[r4,#0x44]         ;493
0000fc  6ca0              LDR      r0,[r4,#0x48]         ;496
0000fe  2101              MOVS     r1,#1                 ;496
000100  4308              ORRS     r0,r0,r1              ;496
000102  64a0              STR      r0,[r4,#0x48]         ;496
                  |L17.260|
000104  21ff              MOVS     r1,#0xff              ;505
000106  31c2              ADDS     r1,r1,#0xc2           ;505
000108  6aa0              LDR      r0,[r4,#0x28]         ;505
00010a  4288              CMP      r0,r1                 ;505
00010c  d003              BEQ      |L17.278|
00010e  6ae1              LDR      r1,[r4,#0x2c]         ;507
000110  6aa0              LDR      r0,[r4,#0x28]         ;507
000112  4308              ORRS     r0,r0,r1              ;507
000114  4305              ORRS     r5,r5,r0              ;507
                  |L17.278|
000116  6820              LDR      r0,[r4,#0]            ;512
000118  68c0              LDR      r0,[r0,#0xc]          ;512
00011a  4328              ORRS     r0,r0,r5              ;512
00011c  6821              LDR      r1,[r4,#0]            ;512
00011e  60c8              STR      r0,[r1,#0xc]          ;512
000120  2101              MOVS     r1,#1                 ;520
000122  0709              LSLS     r1,r1,#28             ;520
000124  6ba0              LDR      r0,[r4,#0x38]         ;520
000126  4288              CMP      r0,r1                 ;520
000128  d016              BEQ      |L17.344|
00012a  e000              B        |L17.302|
                  |L17.300|
00012c  e03d              B        |L17.426|
                  |L17.302|
00012e  6ba0              LDR      r0,[r4,#0x38]         ;520
000130  2801              CMP      r0,#1                 ;520
000132  d011              BEQ      |L17.344|
000134  6ba0              LDR      r0,[r4,#0x38]         ;520
000136  2802              CMP      r0,#2                 ;520
000138  d00e              BEQ      |L17.344|
00013a  6ba0              LDR      r0,[r4,#0x38]         ;520
00013c  2803              CMP      r0,#3                 ;520
00013e  d00b              BEQ      |L17.344|
000140  6ba0              LDR      r0,[r4,#0x38]         ;520
000142  2804              CMP      r0,#4                 ;520
000144  d008              BEQ      |L17.344|
000146  6ba0              LDR      r0,[r4,#0x38]         ;520
000148  2805              CMP      r0,#5                 ;520
00014a  d005              BEQ      |L17.344|
00014c  6ba0              LDR      r0,[r4,#0x38]         ;520
00014e  2806              CMP      r0,#6                 ;520
000150  d002              BEQ      |L17.344|
000152  6ba0              LDR      r0,[r4,#0x38]         ;520
000154  2807              CMP      r0,#7                 ;520
000156  d10d              BNE      |L17.372|
                  |L17.344|
000158  6820              LDR      r0,[r4,#0]            ;524
00015a  6940              LDR      r0,[r0,#0x14]         ;524
00015c  08c0              LSRS     r0,r0,#3              ;524
00015e  00c0              LSLS     r0,r0,#3              ;524
000160  6821              LDR      r1,[r4,#0]            ;524
000162  6148              STR      r0,[r1,#0x14]         ;524
000164  6820              LDR      r0,[r4,#0]            ;527
000166  6940              LDR      r0,[r0,#0x14]         ;527
000168  8f21              LDRH     r1,[r4,#0x38]         ;527
00016a  0749              LSLS     r1,r1,#29             ;527
00016c  0f49              LSRS     r1,r1,#29             ;527
00016e  4308              ORRS     r0,r0,r1              ;527
000170  6821              LDR      r1,[r4,#0]            ;527
000172  6148              STR      r0,[r1,#0x14]         ;527
                  |L17.372|
000174  6820              LDR      r0,[r4,#0]            ;535
000176  68c0              LDR      r0,[r0,#0xc]          ;535
000178  4910              LDR      r1,|L17.444|
00017a  4008              ANDS     r0,r0,r1              ;535
00017c  42a8              CMP      r0,r5                 ;535
00017e  d108              BNE      |L17.402|
000180  2000              MOVS     r0,#0                 ;539
000182  64a0              STR      r0,[r4,#0x48]         ;539
000184  6c60              LDR      r0,[r4,#0x44]         ;542
000186  2102              MOVS     r1,#2                 ;542
000188  4388              BICS     r0,r0,r1              ;542
00018a  2101              MOVS     r1,#1                 ;542
00018c  4308              ORRS     r0,r0,r1              ;542
00018e  6460              STR      r0,[r4,#0x44]         ;542
000190  e010              B        |L17.436|
                  |L17.402|
000192  6c60              LDR      r0,[r4,#0x44]         ;549
000194  2102              MOVS     r1,#2                 ;549
000196  4388              BICS     r0,r0,r1              ;549
000198  2110              MOVS     r1,#0x10              ;549
00019a  4308              ORRS     r0,r0,r1              ;549
00019c  6460              STR      r0,[r4,#0x44]         ;549
00019e  6ca0              LDR      r0,[r4,#0x48]         ;554
0001a0  2101              MOVS     r1,#1                 ;554
0001a2  4308              ORRS     r0,r0,r1              ;554
0001a4  64a0              STR      r0,[r4,#0x48]         ;554
0001a6  2601              MOVS     r6,#1                 ;556
0001a8  e004              B        |L17.436|
                  |L17.426|
0001aa  6c60              LDR      r0,[r4,#0x44]         ;563
0001ac  2110              MOVS     r1,#0x10              ;563
0001ae  4308              ORRS     r0,r0,r1              ;563
0001b0  6460              STR      r0,[r4,#0x44]         ;563
0001b2  2601              MOVS     r6,#1                 ;565
                  |L17.436|
0001b4  4630              MOV      r0,r6                 ;569
0001b6  e72a              B        |L17.14|
;;;571    
                          ENDP

                  |L17.440|
                          DCD      0xfffe0219
                  |L17.444|
                          DCD      0x833fffe7

                          AREA ||i.HAL_ADC_LevelOutOfWindowCallback||, CODE, READONLY, ALIGN=1

                  HAL_ADC_LevelOutOfWindowCallback PROC
;;;1540     */
;;;1541   __weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;1542   {
;;;1543     /* Prevent unused argument(s) compilation warning */
;;;1544     UNUSED(hadc);
;;;1545   
;;;1546     /* NOTE : This function should not be modified. When the callback is needed,
;;;1547               function HAL_ADC_LevelOoutOfWindowCallback must be implemented in the user file.
;;;1548     */
;;;1549   }
;;;1550   
                          ENDP


                          AREA ||i.HAL_ADC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspDeInit PROC
;;;715      */
;;;716    __weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;717    {
;;;718      /* Prevent unused argument(s) compilation warning */
;;;719      UNUSED(hadc);
;;;720    
;;;721      /* NOTE : This function should not be modified. When the callback is needed,
;;;722                function HAL_ADC_MspDeInit must be implemented in the user file.
;;;723       */ 
;;;724    }
;;;725    
                          ENDP


                          AREA ||i.HAL_ADC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_ADC_MspInit PROC
;;;700      */
;;;701    __weak void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
000000  4770              BX       lr
;;;702    {
;;;703      /* Prevent unused argument(s) compilation warning */
;;;704      UNUSED(hadc);
;;;705    
;;;706      /* NOTE : This function should not be modified. When the callback is needed,
;;;707                function HAL_ADC_MspInit must be implemented in the user file.
;;;708       */ 
;;;709    }
;;;710    
                          ENDP


                          AREA ||i.HAL_ADC_PollForConversion||, CODE, READONLY, ALIGN=1

                  HAL_ADC_PollForConversion PROC
;;;876      */
;;;877    HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
000000  b5f8              PUSH     {r3-r7,lr}
;;;878    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;879      uint32_t tickstart;
;;;880      uint32_t tmp_Flag_EOC;
;;;881     
;;;882      /* Check the parameters */
;;;883      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;884    
;;;885      /* If end of conversion selected to end of sequence */
;;;886      if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
000006  6960              LDR      r0,[r4,#0x14]
000008  2808              CMP      r0,#8
00000a  d101              BNE      |L21.16|
;;;887      {
;;;888        tmp_Flag_EOC = ADC_FLAG_EOS;
00000c  2708              MOVS     r7,#8
00000e  e011              B        |L21.52|
                  |L21.16|
;;;889      }
;;;890      /* If end of conversion selected to end of each conversion */
;;;891      else /* ADC_EOC_SINGLE_CONV */
;;;892      {
;;;893        /* Verification that ADC configuration is compliant with polling for      */
;;;894        /* each conversion:                                                       */
;;;895        /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
;;;896        /* several ranks and polling for end of each conversion.                  */
;;;897        /* For code simplicity sake, this particular case is generalized to       */
;;;898        /* ADC configured in DMA mode and and polling for end of each conversion. */
;;;899        if (HAL_IS_BIT_SET(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN))
000010  6820              LDR      r0,[r4,#0]
000012  68c0              LDR      r0,[r0,#0xc]
000014  07c0              LSLS     r0,r0,#31
000016  0fc0              LSRS     r0,r0,#31
000018  2800              CMP      r0,#0
00001a  d00a              BEQ      |L21.50|
;;;900        {
;;;901          /* Update ADC state machine to error */
;;;902          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
00001c  6c60              LDR      r0,[r4,#0x44]
00001e  2120              MOVS     r1,#0x20
000020  4308              ORRS     r0,r0,r1
000022  6460              STR      r0,[r4,#0x44]
;;;903          
;;;904          /* Process unlocked */
;;;905          __HAL_UNLOCK(hadc);
000024  bf00              NOP      
000026  2100              MOVS     r1,#0
000028  2040              MOVS     r0,#0x40
00002a  5501              STRB     r1,[r0,r4]
00002c  bf00              NOP      
;;;906          
;;;907          return HAL_ERROR;
00002e  2001              MOVS     r0,#1
                  |L21.48|
;;;908        }
;;;909        else
;;;910        {
;;;911          tmp_Flag_EOC = (ADC_FLAG_EOC | ADC_FLAG_EOS);
;;;912        }
;;;913      }
;;;914      
;;;915      /* Get tick count */
;;;916      tickstart = HAL_GetTick();
;;;917      
;;;918      /* Wait until End of Conversion flag is raised */
;;;919      while(HAL_IS_BIT_CLR(hadc->Instance->ISR, tmp_Flag_EOC))
;;;920      {
;;;921        /* Check if timeout is disabled (set to infinite wait) */
;;;922        if(Timeout != HAL_MAX_DELAY)
;;;923        {
;;;924          if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
;;;925          {
;;;926            /* Update ADC state machine to timeout */
;;;927            SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;928            
;;;929            /* Process unlocked */
;;;930            __HAL_UNLOCK(hadc);
;;;931            
;;;932            return HAL_TIMEOUT;
;;;933          }
;;;934        }
;;;935      }
;;;936        
;;;937      /* Update ADC state machine */
;;;938      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
;;;939      
;;;940      /* Determine whether any further conversion upcoming on group regular       */
;;;941      /* by external trigger, continuous mode or scan sequence on going.          */
;;;942      if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
;;;943         (hadc->Init.ContinuousConvMode == DISABLE)   )
;;;944      {
;;;945        /* If End of Sequence is reached, disable interrupts */
;;;946        if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
;;;947        {
;;;948          /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit             */
;;;949          /* ADSTART==0 (no conversion on going)                                  */
;;;950          if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
;;;951          {
;;;952            /* Disable ADC end of single conversion interrupt on group regular */
;;;953            /* Note: Overrun interrupt was enabled with EOC interrupt in          */
;;;954            /* HAL_Start_IT(), but is not disabled here because can be used       */
;;;955            /* by overrun IRQ process below.                                      */
;;;956            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
;;;957            
;;;958            /* Set ADC state */
;;;959            ADC_STATE_CLR_SET(hadc->State,
;;;960                              HAL_ADC_STATE_REG_BUSY,
;;;961                              HAL_ADC_STATE_READY);
;;;962          }
;;;963          else
;;;964          {
;;;965            /* Change ADC state to error state */
;;;966            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;967            
;;;968            /* Set ADC error code to ADC IP internal error */
;;;969            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;970          }
;;;971        }
;;;972      }
;;;973      
;;;974      /* Clear end of conversion flag of regular group if low power feature       */
;;;975      /* "LowPowerAutoWait " is disabled, to not interfere with this feature      */
;;;976      /* until data register is read using function HAL_ADC_GetValue().           */
;;;977      if (hadc->Init.LowPowerAutoWait == DISABLE)
;;;978      {
;;;979        /* Clear regular group conversion flag */
;;;980        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
;;;981      }
;;;982      
;;;983      /* Return ADC state */
;;;984      return HAL_OK;
;;;985    }
000030  bdf8              POP      {r3-r7,pc}
                  |L21.50|
000032  270c              MOVS     r7,#0xc               ;911
                  |L21.52|
000034  f7fffffe          BL       HAL_GetTick
000038  4606              MOV      r6,r0                 ;916
00003a  e014              B        |L21.102|
                  |L21.60|
00003c  1c68              ADDS     r0,r5,#1              ;922
00003e  2800              CMP      r0,#0                 ;922
000040  d011              BEQ      |L21.102|
000042  2d00              CMP      r5,#0                 ;924
000044  d004              BEQ      |L21.80|
000046  f7fffffe          BL       HAL_GetTick
00004a  1b80              SUBS     r0,r0,r6              ;924
00004c  42a8              CMP      r0,r5                 ;924
00004e  d90a              BLS      |L21.102|
                  |L21.80|
000050  6c60              LDR      r0,[r4,#0x44]         ;927
000052  2104              MOVS     r1,#4                 ;927
000054  4308              ORRS     r0,r0,r1              ;927
000056  6460              STR      r0,[r4,#0x44]         ;927
000058  bf00              NOP                            ;930
00005a  2100              MOVS     r1,#0                 ;930
00005c  2040              MOVS     r0,#0x40              ;930
00005e  5501              STRB     r1,[r0,r4]            ;930
000060  bf00              NOP                            ;930
000062  2003              MOVS     r0,#3                 ;932
000064  e7e4              B        |L21.48|
                  |L21.102|
000066  6820              LDR      r0,[r4,#0]            ;919
000068  6800              LDR      r0,[r0,#0]            ;919
00006a  4038              ANDS     r0,r0,r7              ;919
00006c  2800              CMP      r0,#0                 ;919
00006e  d0e5              BEQ      |L21.60|
000070  6c60              LDR      r0,[r4,#0x44]         ;938
000072  2101              MOVS     r1,#1                 ;938
000074  0249              LSLS     r1,r1,#9              ;938
000076  4308              ORRS     r0,r0,r1              ;938
000078  6460              STR      r0,[r4,#0x44]         ;938
00007a  6820              LDR      r0,[r4,#0]            ;942
00007c  68c0              LDR      r0,[r0,#0xc]          ;942
00007e  2103              MOVS     r1,#3                 ;942
000080  0289              LSLS     r1,r1,#10             ;942
000082  4008              ANDS     r0,r0,r1              ;942
000084  2800              CMP      r0,#0                 ;942
000086  d125              BNE      |L21.212|
000088  6a20              LDR      r0,[r4,#0x20]         ;943
00008a  2800              CMP      r0,#0                 ;943
00008c  d122              BNE      |L21.212|
00008e  6820              LDR      r0,[r4,#0]            ;946
000090  6800              LDR      r0,[r0,#0]            ;946
000092  2108              MOVS     r1,#8                 ;946
000094  4008              ANDS     r0,r0,r1              ;946
000096  2808              CMP      r0,#8                 ;946
000098  d11c              BNE      |L21.212|
00009a  6820              LDR      r0,[r4,#0]            ;950
00009c  6880              LDR      r0,[r0,#8]            ;950
00009e  2104              MOVS     r1,#4                 ;950
0000a0  4008              ANDS     r0,r0,r1              ;950
0000a2  0880              LSRS     r0,r0,#2              ;950
0000a4  2800              CMP      r0,#0                 ;950
0000a6  d10d              BNE      |L21.196|
0000a8  6820              LDR      r0,[r4,#0]            ;956
0000aa  6840              LDR      r0,[r0,#4]            ;956
0000ac  210c              MOVS     r1,#0xc               ;956
0000ae  4388              BICS     r0,r0,r1              ;956
0000b0  6821              LDR      r1,[r4,#0]            ;956
0000b2  6048              STR      r0,[r1,#4]            ;956
0000b4  6c60              LDR      r0,[r4,#0x44]         ;959
0000b6  21ff              MOVS     r1,#0xff              ;959
0000b8  3101              ADDS     r1,#1                 ;959
0000ba  4388              BICS     r0,r0,r1              ;959
0000bc  2101              MOVS     r1,#1                 ;959
0000be  4308              ORRS     r0,r0,r1              ;959
0000c0  6460              STR      r0,[r4,#0x44]         ;959
0000c2  e007              B        |L21.212|
                  |L21.196|
0000c4  6c60              LDR      r0,[r4,#0x44]         ;966
0000c6  2120              MOVS     r1,#0x20              ;966
0000c8  4308              ORRS     r0,r0,r1              ;966
0000ca  6460              STR      r0,[r4,#0x44]         ;966
0000cc  6ca0              LDR      r0,[r4,#0x48]         ;969
0000ce  2101              MOVS     r1,#1                 ;969
0000d0  4308              ORRS     r0,r0,r1              ;969
0000d2  64a0              STR      r0,[r4,#0x48]         ;969
                  |L21.212|
0000d4  69a0              LDR      r0,[r4,#0x18]         ;977
0000d6  2800              CMP      r0,#0                 ;977
0000d8  d102              BNE      |L21.224|
0000da  200c              MOVS     r0,#0xc               ;980
0000dc  6821              LDR      r1,[r4,#0]            ;980
0000de  6008              STR      r0,[r1,#0]            ;980
                  |L21.224|
0000e0  2000              MOVS     r0,#0                 ;984
0000e2  e7a5              B        |L21.48|
;;;986    
                          ENDP


                          AREA ||i.HAL_ADC_PollForEvent||, CODE, READONLY, ALIGN=1

                  HAL_ADC_PollForEvent PROC
;;;996      */
;;;997    HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
000000  b5f8              PUSH     {r3-r7,lr}
;;;998    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;999      uint32_t tickstart=0; 
000008  2700              MOVS     r7,#0
;;;1000     
;;;1001     /* Check the parameters */
;;;1002     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1003     assert_param(IS_ADC_EVENT_TYPE(EventType));
;;;1004     
;;;1005     /* Get tick count */
;;;1006     tickstart = HAL_GetTick();   
00000a  f7fffffe          BL       HAL_GetTick
00000e  4607              MOV      r7,r0
;;;1007         
;;;1008     /* Check selected event flag */
;;;1009     while(__HAL_ADC_GET_FLAG(hadc, EventType) == RESET)
000010  e014              B        |L22.60|
                  |L22.18|
;;;1010     {
;;;1011       /* Check if timeout is disabled (set to infinite wait) */
;;;1012       if(Timeout != HAL_MAX_DELAY)
000012  1c70              ADDS     r0,r6,#1
000014  2800              CMP      r0,#0
000016  d011              BEQ      |L22.60|
;;;1013       {
;;;1014         if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
000018  2e00              CMP      r6,#0
00001a  d004              BEQ      |L22.38|
00001c  f7fffffe          BL       HAL_GetTick
000020  1bc0              SUBS     r0,r0,r7
000022  42b0              CMP      r0,r6
000024  d90a              BLS      |L22.60|
                  |L22.38|
;;;1015         {
;;;1016           /* Update ADC state machine to timeout */
;;;1017           SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
000026  6c60              LDR      r0,[r4,#0x44]
000028  2104              MOVS     r1,#4
00002a  4308              ORRS     r0,r0,r1
00002c  6460              STR      r0,[r4,#0x44]
;;;1018           
;;;1019           /* Process unlocked */
;;;1020           __HAL_UNLOCK(hadc);
00002e  bf00              NOP      
000030  2100              MOVS     r1,#0
000032  2040              MOVS     r0,#0x40
000034  5501              STRB     r1,[r0,r4]
000036  bf00              NOP      
;;;1021           
;;;1022           return HAL_TIMEOUT;
000038  2003              MOVS     r0,#3
                  |L22.58|
;;;1023         }
;;;1024       }
;;;1025     }
;;;1026   
;;;1027     switch(EventType)
;;;1028     {
;;;1029     /* Analog watchdog (level out of window) event */
;;;1030     case ADC_AWD_EVENT:
;;;1031       /* Set ADC state */
;;;1032       SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
;;;1033         
;;;1034       /* Clear ADC analog watchdog flag */
;;;1035       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
;;;1036       break;
;;;1037     
;;;1038     /* Overrun event */
;;;1039     default: /* Case ADC_OVR_EVENT */
;;;1040       /* If overrun is set to overwrite previous data, overrun event is not     */
;;;1041       /* considered as an error.                                                */
;;;1042       /* (cf ref manual "Managing conversions without using the DMA and without */
;;;1043       /* overrun ")                                                             */
;;;1044       if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
;;;1045       {
;;;1046         /* Set ADC state */
;;;1047         SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
;;;1048           
;;;1049         /* Set ADC error code to overrun */
;;;1050         SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
;;;1051       }
;;;1052       
;;;1053       /* Clear ADC Overrun flag */
;;;1054       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
;;;1055       break;
;;;1056     }
;;;1057     
;;;1058     /* Return ADC state */
;;;1059     return HAL_OK;
;;;1060   }
00003a  bdf8              POP      {r3-r7,pc}
                  |L22.60|
00003c  6820              LDR      r0,[r4,#0]            ;1009
00003e  6800              LDR      r0,[r0,#0]            ;1009
000040  4028              ANDS     r0,r0,r5              ;1009
000042  42a8              CMP      r0,r5                 ;1009
000044  d101              BNE      |L22.74|
000046  2001              MOVS     r0,#1                 ;1009
000048  e000              B        |L22.76|
                  |L22.74|
00004a  2000              MOVS     r0,#0                 ;1009
                  |L22.76|
00004c  2800              CMP      r0,#0                 ;1009
00004e  d0e0              BEQ      |L22.18|
000050  2d80              CMP      r5,#0x80              ;1027
000052  d107              BNE      |L22.100|
000054  6c60              LDR      r0,[r4,#0x44]         ;1032
000056  0269              LSLS     r1,r5,#9              ;1032
000058  4308              ORRS     r0,r0,r1              ;1032
00005a  6460              STR      r0,[r4,#0x44]         ;1032
00005c  2080              MOVS     r0,#0x80              ;1035
00005e  6821              LDR      r1,[r4,#0]            ;1035
000060  6008              STR      r0,[r1,#0]            ;1035
000062  e00f              B        |L22.132|
                  |L22.100|
000064  6b60              LDR      r0,[r4,#0x34]         ;1044
000066  2801              CMP      r0,#1                 ;1044
000068  d108              BNE      |L22.124|
00006a  6c60              LDR      r0,[r4,#0x44]         ;1047
00006c  2101              MOVS     r1,#1                 ;1047
00006e  0289              LSLS     r1,r1,#10             ;1047
000070  4308              ORRS     r0,r0,r1              ;1047
000072  6460              STR      r0,[r4,#0x44]         ;1047
000074  6ca0              LDR      r0,[r4,#0x48]         ;1050
000076  2102              MOVS     r1,#2                 ;1050
000078  4308              ORRS     r0,r0,r1              ;1050
00007a  64a0              STR      r0,[r4,#0x48]         ;1050
                  |L22.124|
00007c  2010              MOVS     r0,#0x10              ;1054
00007e  6821              LDR      r1,[r4,#0]            ;1054
000080  6008              STR      r0,[r1,#0]            ;1054
000082  bf00              NOP                            ;1055
                  |L22.132|
000084  bf00              NOP                            ;1036
000086  2000              MOVS     r0,#0                 ;1059
000088  e7d7              B        |L22.58|
;;;1061   
                          ENDP


                          AREA ||i.HAL_ADC_Start||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start PROC
;;;757      */
;;;758    HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;759    {
000002  4604              MOV      r4,r0
;;;760      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;761    
;;;762      /* Check the parameters */
;;;763      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;764    
;;;765      /* Perform ADC enable and conversion start if no conversion is on going */
;;;766      if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
000006  6820              LDR      r0,[r4,#0]
000008  6880              LDR      r0,[r0,#8]
00000a  2104              MOVS     r1,#4
00000c  4008              ANDS     r0,r0,r1
00000e  0880              LSRS     r0,r0,#2
000010  2800              CMP      r0,#0
000012  d12b              BNE      |L23.108|
;;;767      {
;;;768        /* Process locked */
;;;769        __HAL_LOCK(hadc);
000014  bf00              NOP      
000016  2040              MOVS     r0,#0x40
000018  5d00              LDRB     r0,[r0,r4]
00001a  2801              CMP      r0,#1
00001c  d101              BNE      |L23.34|
00001e  2002              MOVS     r0,#2
                  |L23.32|
;;;770          
;;;771        /* Enable the ADC peripheral */
;;;772        /* If low power mode AutoPowerOff is enabled, power-on/off phases are     */
;;;773        /* performed automatically by hardware.                                   */
;;;774        if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
;;;775        {
;;;776          tmp_hal_status = ADC_Enable(hadc);
;;;777        }
;;;778        
;;;779        /* Start conversion if ADC is effectively enabled */
;;;780        if (tmp_hal_status == HAL_OK)
;;;781        {
;;;782          /* Set ADC state                                                        */
;;;783          /* - Clear state bitfield related to regular group conversion results   */
;;;784          /* - Set state bitfield related to regular operation                    */
;;;785          ADC_STATE_CLR_SET(hadc->State,
;;;786                            HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
;;;787                            HAL_ADC_STATE_REG_BUSY);
;;;788          
;;;789          /* Reset ADC all error code fields */
;;;790          ADC_CLEAR_ERRORCODE(hadc);
;;;791          
;;;792          /* Process unlocked */
;;;793          /* Unlock before starting ADC conversions: in case of potential         */
;;;794          /* interruption, to let the process to ADC IRQ Handler.                 */
;;;795          __HAL_UNLOCK(hadc);
;;;796          
;;;797          /* Clear regular group conversion flag and overrun flag */
;;;798          /* (To ensure of no unknown state from potential previous ADC           */
;;;799          /* operations)                                                          */
;;;800          __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
;;;801          
;;;802          /* Enable conversion of regular group.                                  */
;;;803          /* If software start has been selected, conversion starts immediately.  */
;;;804          /* If external trigger has been selected, conversion will start at next */
;;;805          /* trigger event.                                                       */
;;;806          hadc->Instance->CR |= ADC_CR_ADSTART;
;;;807        }
;;;808      }
;;;809      else
;;;810      {
;;;811        tmp_hal_status = HAL_BUSY;
;;;812      }
;;;813      
;;;814      /* Return function status */
;;;815      return tmp_hal_status;
;;;816    }
000020  bd70              POP      {r4-r6,pc}
                  |L23.34|
000022  2101              MOVS     r1,#1                 ;769
000024  2040              MOVS     r0,#0x40              ;769
000026  5501              STRB     r1,[r0,r4]            ;769
000028  bf00              NOP                            ;769
00002a  69e0              LDR      r0,[r4,#0x1c]         ;774
00002c  2801              CMP      r0,#1                 ;774
00002e  d003              BEQ      |L23.56|
000030  4620              MOV      r0,r4                 ;776
000032  f7fffffe          BL       ADC_Enable
000036  4605              MOV      r5,r0                 ;776
                  |L23.56|
000038  2d00              CMP      r5,#0                 ;780
00003a  d118              BNE      |L23.110|
00003c  6c60              LDR      r0,[r4,#0x44]         ;785
00003e  490d              LDR      r1,|L23.116|
000040  4008              ANDS     r0,r0,r1              ;785
000042  21ff              MOVS     r1,#0xff              ;785
000044  3101              ADDS     r1,#1                 ;785
000046  4308              ORRS     r0,r0,r1              ;785
000048  6460              STR      r0,[r4,#0x44]         ;785
00004a  2000              MOVS     r0,#0                 ;790
00004c  64a0              STR      r0,[r4,#0x48]         ;790
00004e  bf00              NOP                            ;795
000050  2100              MOVS     r1,#0                 ;795
000052  2040              MOVS     r0,#0x40              ;795
000054  5501              STRB     r1,[r0,r4]            ;795
000056  bf00              NOP                            ;795
000058  201c              MOVS     r0,#0x1c              ;800
00005a  6821              LDR      r1,[r4,#0]            ;800
00005c  6008              STR      r0,[r1,#0]            ;800
00005e  6820              LDR      r0,[r4,#0]            ;806
000060  6880              LDR      r0,[r0,#8]            ;806
000062  2104              MOVS     r1,#4                 ;806
000064  4308              ORRS     r0,r0,r1              ;806
000066  6821              LDR      r1,[r4,#0]            ;806
000068  6088              STR      r0,[r1,#8]            ;806
00006a  e000              B        |L23.110|
                  |L23.108|
00006c  2502              MOVS     r5,#2                 ;811
                  |L23.110|
00006e  4628              MOV      r0,r5                 ;815
000070  e7d6              B        |L23.32|
;;;817    
                          ENDP

000072  0000              DCW      0x0000
                  |L23.116|
                          DCD      0xfffff1fe

                          AREA ||i.HAL_ADC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_DMA PROC
;;;1206     */
;;;1207   HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1208   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1209     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000008  2700              MOVS     r7,#0
;;;1210     
;;;1211     /* Check the parameters */
;;;1212     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1213   
;;;1214     /* Perform ADC enable and conversion start if no conversion is on going */
;;;1215     if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
00000a  6820              LDR      r0,[r4,#0]
00000c  6880              LDR      r0,[r0,#8]
00000e  2104              MOVS     r1,#4
000010  4008              ANDS     r0,r0,r1
000012  0880              LSRS     r0,r0,#2
000014  2800              CMP      r0,#0
000016  d148              BNE      |L24.170|
;;;1216     {
;;;1217       /* Process locked */
;;;1218       __HAL_LOCK(hadc);
000018  bf00              NOP      
00001a  2040              MOVS     r0,#0x40
00001c  5d00              LDRB     r0,[r0,r4]
00001e  2801              CMP      r0,#1
000020  d101              BNE      |L24.38|
000022  2002              MOVS     r0,#2
                  |L24.36|
;;;1219   
;;;1220       /* Enable the ADC peripheral */
;;;1221       /* If low power mode AutoPowerOff is enabled, power-on/off phases are       */
;;;1222       /* performed automatically by hardware.                                     */
;;;1223       if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
;;;1224       {
;;;1225         tmp_hal_status = ADC_Enable(hadc);
;;;1226       }
;;;1227       
;;;1228       /* Start conversion if ADC is effectively enabled */
;;;1229       if (tmp_hal_status == HAL_OK)
;;;1230       {
;;;1231         /* Set ADC state                                                        */
;;;1232         /* - Clear state bitfield related to regular group conversion results   */
;;;1233         /* - Set state bitfield related to regular operation                    */
;;;1234         ADC_STATE_CLR_SET(hadc->State,
;;;1235                           HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
;;;1236                           HAL_ADC_STATE_REG_BUSY);
;;;1237         
;;;1238         /* Reset ADC all error code fields */
;;;1239         ADC_CLEAR_ERRORCODE(hadc);
;;;1240         
;;;1241         /* Process unlocked */
;;;1242         /* Unlock before starting ADC conversions: in case of potential         */
;;;1243         /* interruption, to let the process to ADC IRQ Handler.                 */
;;;1244         __HAL_UNLOCK(hadc);
;;;1245   
;;;1246         /* Set the DMA transfer complete callback */
;;;1247         hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
;;;1248   
;;;1249         /* Set the DMA half transfer complete callback */
;;;1250         hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
;;;1251         
;;;1252         /* Set the DMA error callback */
;;;1253         hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
;;;1254   
;;;1255         
;;;1256         /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC   */
;;;1257         /* start (in case of SW start):                                         */
;;;1258         
;;;1259         /* Clear regular group conversion flag and overrun flag */
;;;1260         /* (To ensure of no unknown state from potential previous ADC           */
;;;1261         /* operations)                                                          */
;;;1262         __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
;;;1263         
;;;1264         /* Enable ADC overrun interrupt */
;;;1265         __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
;;;1266         
;;;1267         /* Enable ADC DMA mode */
;;;1268         hadc->Instance->CFGR1 |= ADC_CFGR1_DMAEN;
;;;1269         
;;;1270         /* Start the DMA channel */
;;;1271         HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
;;;1272              
;;;1273         /* Enable conversion of regular group.                                  */
;;;1274         /* If software start has been selected, conversion starts immediately.  */
;;;1275         /* If external trigger has been selected, conversion will start at next */
;;;1276         /* trigger event.                                                       */
;;;1277         hadc->Instance->CR |= ADC_CR_ADSTART;
;;;1278       }
;;;1279     }
;;;1280     else
;;;1281     {
;;;1282       tmp_hal_status = HAL_BUSY;
;;;1283     }
;;;1284       
;;;1285     /* Return function status */
;;;1286     return tmp_hal_status;
;;;1287   }
000024  bdf8              POP      {r3-r7,pc}
                  |L24.38|
000026  2101              MOVS     r1,#1                 ;1218
000028  2040              MOVS     r0,#0x40              ;1218
00002a  5501              STRB     r1,[r0,r4]            ;1218
00002c  bf00              NOP                            ;1218
00002e  69e0              LDR      r0,[r4,#0x1c]         ;1223
000030  2801              CMP      r0,#1                 ;1223
000032  d003              BEQ      |L24.60|
000034  4620              MOV      r0,r4                 ;1225
000036  f7fffffe          BL       ADC_Enable
00003a  4607              MOV      r7,r0                 ;1225
                  |L24.60|
00003c  2f00              CMP      r7,#0                 ;1229
00003e  d135              BNE      |L24.172|
000040  6c60              LDR      r0,[r4,#0x44]         ;1234
000042  491b              LDR      r1,|L24.176|
000044  4008              ANDS     r0,r0,r1              ;1234
000046  21ff              MOVS     r1,#0xff              ;1234
000048  3101              ADDS     r1,#1                 ;1234
00004a  4308              ORRS     r0,r0,r1              ;1234
00004c  6460              STR      r0,[r4,#0x44]         ;1234
00004e  2000              MOVS     r0,#0                 ;1239
000050  64a0              STR      r0,[r4,#0x48]         ;1239
000052  bf00              NOP                            ;1244
000054  2100              MOVS     r1,#0                 ;1244
000056  2040              MOVS     r0,#0x40              ;1244
000058  5501              STRB     r1,[r0,r4]            ;1244
00005a  bf00              NOP                            ;1244
00005c  4815              LDR      r0,|L24.180|
00005e  6be1              LDR      r1,[r4,#0x3c]         ;1247
000060  6288              STR      r0,[r1,#0x28]         ;1247
000062  4815              LDR      r0,|L24.184|
000064  6be1              LDR      r1,[r4,#0x3c]         ;1250
000066  62c8              STR      r0,[r1,#0x2c]         ;1250
000068  4814              LDR      r0,|L24.188|
00006a  6be1              LDR      r1,[r4,#0x3c]         ;1253
00006c  6308              STR      r0,[r1,#0x30]         ;1253
00006e  201c              MOVS     r0,#0x1c              ;1262
000070  6821              LDR      r1,[r4,#0]            ;1262
000072  6008              STR      r0,[r1,#0]            ;1262
000074  6820              LDR      r0,[r4,#0]            ;1265
000076  6840              LDR      r0,[r0,#4]            ;1265
000078  2110              MOVS     r1,#0x10              ;1265
00007a  4308              ORRS     r0,r0,r1              ;1265
00007c  6821              LDR      r1,[r4,#0]            ;1265
00007e  6048              STR      r0,[r1,#4]            ;1265
000080  6820              LDR      r0,[r4,#0]            ;1268
000082  68c0              LDR      r0,[r0,#0xc]          ;1268
000084  2101              MOVS     r1,#1                 ;1268
000086  4308              ORRS     r0,r0,r1              ;1268
000088  6821              LDR      r1,[r4,#0]            ;1268
00008a  60c8              STR      r0,[r1,#0xc]          ;1268
00008c  6822              LDR      r2,[r4,#0]            ;1271
00008e  4611              MOV      r1,r2                 ;1271
000090  3140              ADDS     r1,r1,#0x40           ;1271
000092  4633              MOV      r3,r6                 ;1271
000094  462a              MOV      r2,r5                 ;1271
000096  6be0              LDR      r0,[r4,#0x3c]         ;1271
000098  f7fffffe          BL       HAL_DMA_Start_IT
00009c  6820              LDR      r0,[r4,#0]            ;1277
00009e  6880              LDR      r0,[r0,#8]            ;1277
0000a0  2104              MOVS     r1,#4                 ;1277
0000a2  4308              ORRS     r0,r0,r1              ;1277
0000a4  6821              LDR      r1,[r4,#0]            ;1277
0000a6  6088              STR      r0,[r1,#8]            ;1277
0000a8  e000              B        |L24.172|
                  |L24.170|
0000aa  2702              MOVS     r7,#2                 ;1282
                  |L24.172|
0000ac  4638              MOV      r0,r7                 ;1286
0000ae  e7b9              B        |L24.36|
;;;1288   
                          ENDP

                  |L24.176|
                          DCD      0xfffff1fe
                  |L24.180|
                          DCD      ADC_DMAConvCplt
                  |L24.184|
                          DCD      ADC_DMAHalfConvCplt
                  |L24.188|
                          DCD      ADC_DMAError

                          AREA ||i.HAL_ADC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_ADC_Start_IT PROC
;;;1072     */
;;;1073   HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1074   {
000002  4604              MOV      r4,r0
;;;1075     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1076     
;;;1077     /* Check the parameters */
;;;1078     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1079       
;;;1080     /* Perform ADC enable and conversion start if no conversion is on going */
;;;1081     if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
000006  6820              LDR      r0,[r4,#0]
000008  6880              LDR      r0,[r0,#8]
00000a  2104              MOVS     r1,#4
00000c  4008              ANDS     r0,r0,r1
00000e  0880              LSRS     r0,r0,#2
000010  2800              CMP      r0,#0
000012  d143              BNE      |L25.156|
;;;1082     {
;;;1083       /* Process locked */
;;;1084       __HAL_LOCK(hadc);
000014  bf00              NOP      
000016  2040              MOVS     r0,#0x40
000018  5d00              LDRB     r0,[r0,r4]
00001a  2801              CMP      r0,#1
00001c  d101              BNE      |L25.34|
00001e  2002              MOVS     r0,#2
                  |L25.32|
;;;1085        
;;;1086       /* Enable the ADC peripheral */
;;;1087       /* If low power mode AutoPowerOff is enabled, power-on/off phases are     */
;;;1088       /* performed automatically by hardware.                                   */
;;;1089       if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
;;;1090       {
;;;1091         tmp_hal_status = ADC_Enable(hadc);
;;;1092       }
;;;1093       
;;;1094       /* Start conversion if ADC is effectively enabled */
;;;1095       if (tmp_hal_status == HAL_OK)
;;;1096       {
;;;1097         /* Set ADC state                                                        */
;;;1098         /* - Clear state bitfield related to regular group conversion results   */
;;;1099         /* - Set state bitfield related to regular operation                    */
;;;1100         ADC_STATE_CLR_SET(hadc->State,
;;;1101                           HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
;;;1102                           HAL_ADC_STATE_REG_BUSY);
;;;1103         
;;;1104         /* Reset ADC all error code fields */
;;;1105         ADC_CLEAR_ERRORCODE(hadc);
;;;1106         
;;;1107         /* Process unlocked */
;;;1108         /* Unlock before starting ADC conversions: in case of potential         */
;;;1109         /* interruption, to let the process to ADC IRQ Handler.                 */
;;;1110         __HAL_UNLOCK(hadc);
;;;1111         
;;;1112         /* Clear regular group conversion flag and overrun flag */
;;;1113         /* (To ensure of no unknown state from potential previous ADC           */
;;;1114         /* operations)                                                          */
;;;1115         __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
;;;1116         
;;;1117         /* Enable ADC end of conversion interrupt */
;;;1118         /* Enable ADC overrun interrupt */  
;;;1119         switch(hadc->Init.EOCSelection)
;;;1120         {
;;;1121           case ADC_EOC_SEQ_CONV: 
;;;1122             __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
;;;1123             __HAL_ADC_ENABLE_IT(hadc, (ADC_IT_EOS | ADC_IT_OVR));
;;;1124             break;
;;;1125           /* case ADC_EOC_SINGLE_CONV */
;;;1126           default:
;;;1127             __HAL_ADC_ENABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_EOS | ADC_IT_OVR));
;;;1128             break;
;;;1129         }
;;;1130         
;;;1131         /* Enable conversion of regular group.                                  */
;;;1132         /* If software start has been selected, conversion starts immediately.  */
;;;1133         /* If external trigger has been selected, conversion will start at next */
;;;1134         /* trigger event.                                                       */
;;;1135         hadc->Instance->CR |= ADC_CR_ADSTART;
;;;1136       }
;;;1137     }
;;;1138     else
;;;1139     {
;;;1140       tmp_hal_status = HAL_BUSY;
;;;1141     }    
;;;1142       
;;;1143     /* Return function status */
;;;1144     return tmp_hal_status;
;;;1145   }
000020  bd70              POP      {r4-r6,pc}
                  |L25.34|
000022  2101              MOVS     r1,#1                 ;1084
000024  2040              MOVS     r0,#0x40              ;1084
000026  5501              STRB     r1,[r0,r4]            ;1084
000028  bf00              NOP                            ;1084
00002a  69e0              LDR      r0,[r4,#0x1c]         ;1089
00002c  2801              CMP      r0,#1                 ;1089
00002e  d003              BEQ      |L25.56|
000030  4620              MOV      r0,r4                 ;1091
000032  f7fffffe          BL       ADC_Enable
000036  4605              MOV      r5,r0                 ;1091
                  |L25.56|
000038  2d00              CMP      r5,#0                 ;1095
00003a  d130              BNE      |L25.158|
00003c  6c60              LDR      r0,[r4,#0x44]         ;1100
00003e  4919              LDR      r1,|L25.164|
000040  4008              ANDS     r0,r0,r1              ;1100
000042  21ff              MOVS     r1,#0xff              ;1100
000044  3101              ADDS     r1,#1                 ;1100
000046  4308              ORRS     r0,r0,r1              ;1100
000048  6460              STR      r0,[r4,#0x44]         ;1100
00004a  2000              MOVS     r0,#0                 ;1105
00004c  64a0              STR      r0,[r4,#0x48]         ;1105
00004e  bf00              NOP                            ;1110
000050  2100              MOVS     r1,#0                 ;1110
000052  2040              MOVS     r0,#0x40              ;1110
000054  5501              STRB     r1,[r0,r4]            ;1110
000056  bf00              NOP                            ;1110
000058  201c              MOVS     r0,#0x1c              ;1115
00005a  6821              LDR      r1,[r4,#0]            ;1115
00005c  6008              STR      r0,[r1,#0]            ;1115
00005e  6960              LDR      r0,[r4,#0x14]         ;1119
000060  2808              CMP      r0,#8                 ;1119
000062  d10c              BNE      |L25.126|
000064  6820              LDR      r0,[r4,#0]            ;1122
000066  6840              LDR      r0,[r0,#4]            ;1122
000068  2104              MOVS     r1,#4                 ;1122
00006a  4388              BICS     r0,r0,r1              ;1122
00006c  6821              LDR      r1,[r4,#0]            ;1122
00006e  6048              STR      r0,[r1,#4]            ;1122
000070  6820              LDR      r0,[r4,#0]            ;1123
000072  6840              LDR      r0,[r0,#4]            ;1123
000074  2118              MOVS     r1,#0x18              ;1123
000076  4308              ORRS     r0,r0,r1              ;1123
000078  6821              LDR      r1,[r4,#0]            ;1123
00007a  6048              STR      r0,[r1,#4]            ;1123
00007c  e006              B        |L25.140|
                  |L25.126|
00007e  6820              LDR      r0,[r4,#0]            ;1127
000080  6840              LDR      r0,[r0,#4]            ;1127
000082  211c              MOVS     r1,#0x1c              ;1127
000084  4308              ORRS     r0,r0,r1              ;1127
000086  6821              LDR      r1,[r4,#0]            ;1127
000088  6048              STR      r0,[r1,#4]            ;1127
00008a  bf00              NOP                            ;1128
                  |L25.140|
00008c  bf00              NOP                            ;1124
00008e  6820              LDR      r0,[r4,#0]            ;1135
000090  6880              LDR      r0,[r0,#8]            ;1135
000092  2104              MOVS     r1,#4                 ;1135
000094  4308              ORRS     r0,r0,r1              ;1135
000096  6821              LDR      r1,[r4,#0]            ;1135
000098  6088              STR      r0,[r1,#8]            ;1135
00009a  e000              B        |L25.158|
                  |L25.156|
00009c  2502              MOVS     r5,#2                 ;1140
                  |L25.158|
00009e  4628              MOV      r0,r5                 ;1144
0000a0  e7be              B        |L25.32|
;;;1146   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L25.164|
                          DCD      0xfffff1fe

                          AREA ||i.HAL_ADC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop PROC
;;;822      */
;;;823    HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;824    { 
000002  4604              MOV      r4,r0
;;;825      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;826      
;;;827      /* Check the parameters */
;;;828      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;829      
;;;830      /* Process locked */
;;;831      __HAL_LOCK(hadc);
000006  bf00              NOP      
000008  2040              MOVS     r0,#0x40
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L26.20|
000010  2002              MOVS     r0,#2
                  |L26.18|
;;;832      
;;;833      /* 1. Stop potential conversion on going, on regular group */
;;;834      tmp_hal_status = ADC_ConversionStop(hadc);
;;;835      
;;;836      /* Disable ADC peripheral if conversions are effectively stopped */
;;;837      if (tmp_hal_status == HAL_OK)
;;;838      {
;;;839        /* 2. Disable the ADC peripheral */
;;;840        tmp_hal_status = ADC_Disable(hadc);
;;;841        
;;;842        /* Check if ADC is effectively disabled */
;;;843        if (tmp_hal_status == HAL_OK)
;;;844        {
;;;845          /* Set ADC state */
;;;846          ADC_STATE_CLR_SET(hadc->State,
;;;847                            HAL_ADC_STATE_REG_BUSY,
;;;848                            HAL_ADC_STATE_READY);
;;;849        }
;;;850      }
;;;851    
;;;852      /* Process unlocked */
;;;853      __HAL_UNLOCK(hadc);
;;;854      
;;;855      /* Return function status */
;;;856      return tmp_hal_status;
;;;857    }
000012  bd70              POP      {r4-r6,pc}
                  |L26.20|
000014  2101              MOVS     r1,#1                 ;831
000016  2040              MOVS     r0,#0x40              ;831
000018  5501              STRB     r1,[r0,r4]            ;831
00001a  bf00              NOP                            ;831
00001c  4620              MOV      r0,r4                 ;834
00001e  f7fffffe          BL       ADC_ConversionStop
000022  4605              MOV      r5,r0                 ;834
000024  2d00              CMP      r5,#0                 ;837
000026  d10c              BNE      |L26.66|
000028  4620              MOV      r0,r4                 ;840
00002a  f7fffffe          BL       ADC_Disable
00002e  4605              MOV      r5,r0                 ;840
000030  2d00              CMP      r5,#0                 ;843
000032  d106              BNE      |L26.66|
000034  6c60              LDR      r0,[r4,#0x44]         ;846
000036  21ff              MOVS     r1,#0xff              ;846
000038  3101              ADDS     r1,#1                 ;846
00003a  4388              BICS     r0,r0,r1              ;846
00003c  2101              MOVS     r1,#1                 ;846
00003e  4308              ORRS     r0,r0,r1              ;846
000040  6460              STR      r0,[r4,#0x44]         ;846
                  |L26.66|
000042  bf00              NOP                            ;853
000044  2100              MOVS     r1,#0                 ;853
000046  2040              MOVS     r0,#0x40              ;853
000048  5501              STRB     r1,[r0,r4]            ;853
00004a  bf00              NOP                            ;853
00004c  4628              MOV      r0,r5                 ;856
00004e  e7e0              B        |L26.18|
;;;858    
                          ENDP


                          AREA ||i.HAL_ADC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_DMA PROC
;;;1295     */
;;;1296   HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1297   {  
000002  4604              MOV      r4,r0
;;;1298     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1299     
;;;1300     /* Check the parameters */
;;;1301     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1302   
;;;1303     /* Process locked */
;;;1304     __HAL_LOCK(hadc);
000006  bf00              NOP      
000008  2040              MOVS     r0,#0x40
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L27.20|
000010  2002              MOVS     r0,#2
                  |L27.18|
;;;1305     
;;;1306     /* 1. Stop potential conversion on going, on regular group */
;;;1307     tmp_hal_status = ADC_ConversionStop(hadc);
;;;1308     
;;;1309     /* Disable ADC peripheral if conversions are effectively stopped */
;;;1310     if (tmp_hal_status == HAL_OK)
;;;1311     {
;;;1312       /* Disable ADC DMA (ADC DMA configuration ADC_CFGR_DMACFG is kept) */
;;;1313       hadc->Instance->CFGR1 &= ~ADC_CFGR1_DMAEN;
;;;1314       
;;;1315       /* Disable the DMA channel (in case of DMA in circular mode or stop while */
;;;1316       /* while DMA transfer is on going)                                        */
;;;1317       tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);   
;;;1318       
;;;1319       /* Check if DMA channel effectively disabled */
;;;1320       if (tmp_hal_status != HAL_OK)
;;;1321       {
;;;1322         /* Update ADC state machine to error */
;;;1323         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
;;;1324       }
;;;1325       
;;;1326       /* Disable ADC overrun interrupt */
;;;1327       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
;;;1328       
;;;1329       /* 2. Disable the ADC peripheral */
;;;1330       /* Update "tmp_hal_status" only if DMA channel disabling passed, to keep  */
;;;1331       /* in memory a potential failing status.                                  */
;;;1332       if (tmp_hal_status == HAL_OK)
;;;1333       {
;;;1334         tmp_hal_status = ADC_Disable(hadc);
;;;1335       }
;;;1336       else
;;;1337       {
;;;1338         ADC_Disable(hadc);
;;;1339       }
;;;1340   
;;;1341       /* Check if ADC is effectively disabled */
;;;1342       if (tmp_hal_status == HAL_OK)
;;;1343       {
;;;1344         /* Set ADC state */
;;;1345         ADC_STATE_CLR_SET(hadc->State,
;;;1346                           HAL_ADC_STATE_REG_BUSY,
;;;1347                           HAL_ADC_STATE_READY);
;;;1348       }
;;;1349       
;;;1350     }
;;;1351   
;;;1352     /* Process unlocked */
;;;1353     __HAL_UNLOCK(hadc);
;;;1354     
;;;1355     /* Return function status */
;;;1356     return tmp_hal_status;
;;;1357   }
000012  bd70              POP      {r4-r6,pc}
                  |L27.20|
000014  2101              MOVS     r1,#1                 ;1304
000016  2040              MOVS     r0,#0x40              ;1304
000018  5501              STRB     r1,[r0,r4]            ;1304
00001a  bf00              NOP                            ;1304
00001c  4620              MOV      r0,r4                 ;1307
00001e  f7fffffe          BL       ADC_ConversionStop
000022  4605              MOV      r5,r0                 ;1307
000024  2d00              CMP      r5,#0                 ;1310
000026  d128              BNE      |L27.122|
000028  6820              LDR      r0,[r4,#0]            ;1313
00002a  68c0              LDR      r0,[r0,#0xc]          ;1313
00002c  0840              LSRS     r0,r0,#1              ;1313
00002e  0040              LSLS     r0,r0,#1              ;1313
000030  6821              LDR      r1,[r4,#0]            ;1313
000032  60c8              STR      r0,[r1,#0xc]          ;1313
000034  6be0              LDR      r0,[r4,#0x3c]         ;1317
000036  f7fffffe          BL       HAL_DMA_Abort
00003a  4605              MOV      r5,r0                 ;1317
00003c  2d00              CMP      r5,#0                 ;1320
00003e  d003              BEQ      |L27.72|
000040  6c60              LDR      r0,[r4,#0x44]         ;1323
000042  2140              MOVS     r1,#0x40              ;1323
000044  4308              ORRS     r0,r0,r1              ;1323
000046  6460              STR      r0,[r4,#0x44]         ;1323
                  |L27.72|
000048  6820              LDR      r0,[r4,#0]            ;1327
00004a  6840              LDR      r0,[r0,#4]            ;1327
00004c  2110              MOVS     r1,#0x10              ;1327
00004e  4388              BICS     r0,r0,r1              ;1327
000050  6821              LDR      r1,[r4,#0]            ;1327
000052  6048              STR      r0,[r1,#4]            ;1327
000054  2d00              CMP      r5,#0                 ;1332
000056  d104              BNE      |L27.98|
000058  4620              MOV      r0,r4                 ;1334
00005a  f7fffffe          BL       ADC_Disable
00005e  4605              MOV      r5,r0                 ;1334
000060  e002              B        |L27.104|
                  |L27.98|
000062  4620              MOV      r0,r4                 ;1338
000064  f7fffffe          BL       ADC_Disable
                  |L27.104|
000068  2d00              CMP      r5,#0                 ;1342
00006a  d106              BNE      |L27.122|
00006c  6c60              LDR      r0,[r4,#0x44]         ;1345
00006e  21ff              MOVS     r1,#0xff              ;1345
000070  3101              ADDS     r1,#1                 ;1345
000072  4388              BICS     r0,r0,r1              ;1345
000074  2101              MOVS     r1,#1                 ;1345
000076  4308              ORRS     r0,r0,r1              ;1345
000078  6460              STR      r0,[r4,#0x44]         ;1345
                  |L27.122|
00007a  bf00              NOP                            ;1353
00007c  2100              MOVS     r1,#0                 ;1353
00007e  2040              MOVS     r0,#0x40              ;1353
000080  5501              STRB     r1,[r0,r4]            ;1353
000082  bf00              NOP                            ;1353
000084  4628              MOV      r0,r5                 ;1356
000086  e7c4              B        |L27.18|
;;;1358   
                          ENDP


                          AREA ||i.HAL_ADC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_ADC_Stop_IT PROC
;;;1153     */
;;;1154   HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1155   {
000002  4604              MOV      r4,r0
;;;1156     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1157     
;;;1158     /* Check the parameters */
;;;1159     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1160     
;;;1161     /* Process locked */
;;;1162     __HAL_LOCK(hadc);
000006  bf00              NOP      
000008  2040              MOVS     r0,#0x40
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L28.20|
000010  2002              MOVS     r0,#2
                  |L28.18|
;;;1163     
;;;1164     /* 1. Stop potential conversion on going, on regular group */
;;;1165     tmp_hal_status = ADC_ConversionStop(hadc);
;;;1166      
;;;1167     /* Disable ADC peripheral if conversions are effectively stopped */
;;;1168     if (tmp_hal_status == HAL_OK)
;;;1169     {
;;;1170       /* Disable ADC end of conversion interrupt for regular group */
;;;1171       /* Disable ADC overrun interrupt */
;;;1172       __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_EOS | ADC_IT_OVR));
;;;1173       
;;;1174       /* 2. Disable the ADC peripheral */
;;;1175       tmp_hal_status = ADC_Disable(hadc);
;;;1176       
;;;1177       /* Check if ADC is effectively disabled */
;;;1178       if (tmp_hal_status == HAL_OK)
;;;1179       {
;;;1180         /* Set ADC state */
;;;1181         ADC_STATE_CLR_SET(hadc->State,
;;;1182                           HAL_ADC_STATE_REG_BUSY,
;;;1183                           HAL_ADC_STATE_READY);
;;;1184       }
;;;1185     }
;;;1186   
;;;1187     /* Process unlocked */
;;;1188     __HAL_UNLOCK(hadc);
;;;1189     
;;;1190     /* Return function status */
;;;1191     return tmp_hal_status;
;;;1192   }
000012  bd70              POP      {r4-r6,pc}
                  |L28.20|
000014  2101              MOVS     r1,#1                 ;1162
000016  2040              MOVS     r0,#0x40              ;1162
000018  5501              STRB     r1,[r0,r4]            ;1162
00001a  bf00              NOP                            ;1162
00001c  4620              MOV      r0,r4                 ;1165
00001e  f7fffffe          BL       ADC_ConversionStop
000022  4605              MOV      r5,r0                 ;1165
000024  2d00              CMP      r5,#0                 ;1168
000026  d112              BNE      |L28.78|
000028  6820              LDR      r0,[r4,#0]            ;1172
00002a  6840              LDR      r0,[r0,#4]            ;1172
00002c  211c              MOVS     r1,#0x1c              ;1172
00002e  4388              BICS     r0,r0,r1              ;1172
000030  6821              LDR      r1,[r4,#0]            ;1172
000032  6048              STR      r0,[r1,#4]            ;1172
000034  4620              MOV      r0,r4                 ;1175
000036  f7fffffe          BL       ADC_Disable
00003a  4605              MOV      r5,r0                 ;1175
00003c  2d00              CMP      r5,#0                 ;1178
00003e  d106              BNE      |L28.78|
000040  6c60              LDR      r0,[r4,#0x44]         ;1181
000042  21ff              MOVS     r1,#0xff              ;1181
000044  3101              ADDS     r1,#1                 ;1181
000046  4388              BICS     r0,r0,r1              ;1181
000048  2101              MOVS     r1,#1                 ;1181
00004a  4308              ORRS     r0,r0,r1              ;1181
00004c  6460              STR      r0,[r4,#0x44]         ;1181
                  |L28.78|
00004e  bf00              NOP                            ;1188
000050  2100              MOVS     r1,#0                 ;1188
000052  2040              MOVS     r0,#0x40              ;1188
000054  5501              STRB     r1,[r0,r4]            ;1188
000056  bf00              NOP                            ;1188
000058  4628              MOV      r0,r5                 ;1191
00005a  e7da              B        |L28.18|
;;;1193   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\stm32f03xx_HAL\\Src\\stm32f0xx_hal_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f0xx_hal_adc_c_52ef8f50____REV16|
#line 388 "..\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f0xx_hal_adc_c_52ef8f50____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f0xx_hal_adc_c_52ef8f50____REVSH|
#line 402
|__asm___19_stm32f0xx_hal_adc_c_52ef8f50____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
