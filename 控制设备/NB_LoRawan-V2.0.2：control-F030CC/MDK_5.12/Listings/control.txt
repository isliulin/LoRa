; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\control.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\control.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS\Device\ST\STM32F0xx\Include -I..\CMSIS\Include -I..\stm32f03xx_HAL\Inc -I..\USER -I..\HAL\inc -I..\HAL\system -I..\Lib\LoRawan-node\misc -I..\Lib\LoRawan-node\crypto -I..\Lib\LoRawan-node\mac -I..\Lib\LoRawan-node\radio -I..\Lib\LoRawan-node\radio\sx1276 -I..\Lib -IE:\NBI项目\NBI_LoRa\LoRa版本备份\NB_LoRawan-V2.0.2：control-F030CC\MDK_5.12\RTE -ID:\mysaftware\keil_5.12\ARM\PACK\Keil\STM32F0xx_DFP\1.5.0\Device\Include -ID:\mysaftware\keil_5.12\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=518 -DSTM32F030xC -DUSE_HAL_DRIVER -DSTM32F030xC -DUSE_MODEM_LORA -DUSE_BAND_433 --omf_browse=.\objects\control.crf ..\HAL\src\control.c]
                          THUMB

                          AREA ||i.Check_Key_Mode||, CODE, READONLY, ALIGN=2

                  Check_Key_Mode PROC
;;;117    */
;;;118    void Check_Key_Mode( void )
000000  b510              PUSH     {r4,lr}
;;;119    {
;;;120    	///增加轮询按键功能，防止MCU断电没查询出中断状态，导致不工作
;;;121    	if( (HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_13)) == KEY_ON ) ///手动模式
000002  2101              MOVS     r1,#1
000004  0349              LSLS     r1,r1,#13
000006  4810              LDR      r0,|L1.72|
000008  f7fffffe          BL       HAL_GPIO_ReadPin
00000c  2801              CMP      r0,#1
00000e  d10d              BNE      |L1.44|
;;;122    	{
;;;123    		delay_ms(20);
000010  2014              MOVS     r0,#0x14
000012  f7fffffe          BL       delay_ms
;;;124    		
;;;125    		if( (HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_13)) == KEY_ON ) ///手动模式
000016  2101              MOVS     r1,#1
000018  0349              LSLS     r1,r1,#13
00001a  480b              LDR      r0,|L1.72|
00001c  f7fffffe          BL       HAL_GPIO_ReadPin
000020  2801              CMP      r0,#1
000022  d110              BNE      |L1.70|
;;;126    		{
;;;127    			Control_States.Auto_Mode = false;
000024  2000              MOVS     r0,#0
000026  4909              LDR      r1,|L1.76|
000028  7008              STRB     r0,[r1,#0]
00002a  e00c              B        |L1.70|
                  |L1.44|
;;;128    		}  
;;;129    	}
;;;130    	else
;;;131    	{
;;;132    		delay_ms(20);
00002c  2014              MOVS     r0,#0x14
00002e  f7fffffe          BL       delay_ms
;;;133    		
;;;134    		if( (HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_13)) == KEY_OFF ) ///自动模式
000032  2101              MOVS     r1,#1
000034  0349              LSLS     r1,r1,#13
000036  4804              LDR      r0,|L1.72|
000038  f7fffffe          BL       HAL_GPIO_ReadPin
00003c  2800              CMP      r0,#0
00003e  d102              BNE      |L1.70|
;;;135    		{
;;;136    			Control_States.Auto_Mode = true;
000040  2001              MOVS     r0,#1
000042  4902              LDR      r1,|L1.76|
000044  7008              STRB     r0,[r1,#0]
                  |L1.70|
;;;137    		}
;;;138    	}	
;;;139    }
000046  bd10              POP      {r4,pc}
;;;140    
                          ENDP

                  |L1.72|
                          DCD      0x48000800
                  |L1.76|
                          DCD      Control_States

                          AREA ||i.Control_Relay||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  Control_Relay PROC
;;;144    */
;;;145    void Control_Relay(uint8_t *rfdata)
000000  b570              PUSH     {r4-r6,lr}
;;;146    {
000002  4604              MOV      r4,r0
;;;147    	 Control_States.retry_conter = 0;
000004  2000              MOVS     r0,#0
000006  4948              LDR      r1,|L2.296|
000008  7248              STRB     r0,[r1,#9]
;;;148    	 memset(Control_States.send_buf, 0, 4);
00000a  2104              MOVS     r1,#4
00000c  4846              LDR      r0,|L2.296|
00000e  1d40              ADDS     r0,r0,#5
000010  f7fffffe          BL       __aeabi_memclr
;;;149    	 DEBUG(2,"tx_data000 = %s\r\n",Control_States.control_buf);
000014  4944              LDR      r1,|L2.296|
000016  1c49              ADDS     r1,r1,#1
000018  a044              ADR      r0,|L2.300|
00001a  f7fffffe          BL       __2printf
;;;150    	 Control_States.control_buf[0] = 01;
00001e  2001              MOVS     r0,#1
000020  4941              LDR      r1,|L2.296|
000022  7048              STRB     r0,[r1,#1]
;;;151    	 Control_States.control_buf[1] = 00;
000024  2100              MOVS     r1,#0
000026  4840              LDR      r0,|L2.296|
000028  7081              STRB     r1,[r0,#2]
;;;152    //	 Control_States.control_buf[2] = HextoDec(&rfdata[0],1);
;;;153    //	 Control_States.control_buf[3] = HextoDec(&rfdata[1],1);	
;;;154    	 Control_States.control_buf[2] = rfdata[0];
00002a  7821              LDRB     r1,[r4,#0]
00002c  70c1              STRB     r1,[r0,#3]
;;;155    	 Control_States.control_buf[3] = rfdata[1];	
00002e  7861              LDRB     r1,[r4,#1]
000030  7101              STRB     r1,[r0,#4]
;;;156    	
;;;157    	if(Control_States.control_buf[2] != 0) ///不执行查询命令
000032  78c0              LDRB     r0,[r0,#3]
000034  2800              CMP      r0,#0
000036  d043              BEQ      |L2.192|
;;;158    	{
;;;159    		do
000038  bf00              NOP      
                  |L2.58|
;;;160    		{			
;;;161    			HAL_UART_Transmit(&huart5, Control_States.control_buf, 4, 0xFFFF);
00003a  4b41              LDR      r3,|L2.320|
00003c  2204              MOVS     r2,#4
00003e  493a              LDR      r1,|L2.296|
000040  1c49              ADDS     r1,r1,#1
000042  4840              LDR      r0,|L2.324|
000044  f7fffffe          BL       HAL_UART_Transmit
;;;162    			DEBUG(2,"tx_data555 = %s\r\n",Control_States.control_buf);
000048  4937              LDR      r1,|L2.296|
00004a  1c49              ADDS     r1,r1,#1
00004c  a03e              ADR      r0,|L2.328|
00004e  f7fffffe          BL       __2printf
;;;163    			delay_ms(50);
000052  2032              MOVS     r0,#0x32
000054  f7fffffe          BL       delay_ms
;;;164    			
;;;165    			///等待USART5接收数据处理完成状态
;;;166    			if(UART_RX_DATA.USART_TX_STATE)
000058  4840              LDR      r0,|L2.348|
00005a  79c0              LDRB     r0,[r0,#7]  ; UART_RX_DATA
00005c  2800              CMP      r0,#0
00005e  d01f              BEQ      |L2.160|
;;;167    			{
;;;168    			 for(uint8_t i = 0; i < 4; i++)
000060  2500              MOVS     r5,#0
000062  e006              B        |L2.114|
                  |L2.100|
;;;169    			 DEBUG(2,"%02d",UART_RX_DATA.USART_RX_BUF[i]);
000064  483e              LDR      r0,|L2.352|
000066  5d41              LDRB     r1,[r0,r5]
000068  a03e              ADR      r0,|L2.356|
00006a  f7fffffe          BL       __2printf
00006e  1c68              ADDS     r0,r5,#1              ;168
000070  b2c5              UXTB     r5,r0                 ;168
                  |L2.114|
000072  2d04              CMP      r5,#4                 ;168
000074  dbf6              BLT      |L2.100|
;;;170    			 DEBUG(2,"\r\n");
000076  a03d              ADR      r0,|L2.364|
000078  f7fffffe          BL       __2printf
;;;171    
;;;172    			 UART_RX_DATA.USART_TX_STATE = false;
00007c  2000              MOVS     r0,#0
00007e  4937              LDR      r1,|L2.348|
000080  71c8              STRB     r0,[r1,#7]
;;;173    			 memcpy(Control_States.send_buf, UART_RX_DATA.USART_RX_BUF, UART_RX_DATA.USART_RX_Len); ///USART5接收缓存copy
000082  4608              MOV      r0,r1
000084  8882              LDRH     r2,[r0,#4]  ; UART_RX_DATA
000086  4936              LDR      r1,|L2.352|
000088  4827              LDR      r0,|L2.296|
00008a  1d40              ADDS     r0,r0,#5
00008c  f7fffffe          BL       __aeabi_memcpy
;;;174    			 memset(UART_RX_DATA.USART_RX_BUF, 0, UART_RX_DATA.USART_RX_Len);
000090  4832              LDR      r0,|L2.348|
000092  8881              LDRH     r1,[r0,#4]  ; UART_RX_DATA
000094  4832              LDR      r0,|L2.352|
000096  f7fffffe          BL       __aeabi_memclr4
;;;175    			 UART_RX_DATA.USART_RX_Len = 0;
00009a  2000              MOVS     r0,#0
00009c  492f              LDR      r1,|L2.348|
00009e  8088              STRH     r0,[r1,#4]
                  |L2.160|
;;;176    			}			 		 
;;;177    		Control_States.retry_conter++;
0000a0  4821              LDR      r0,|L2.296|
0000a2  7a40              LDRB     r0,[r0,#9]  ; Control_States
0000a4  1c40              ADDS     r0,r0,#1
0000a6  4920              LDR      r1,|L2.296|
0000a8  7248              STRB     r0,[r1,#9]
;;;178    		}while((0 != strcmp((char *)Control_States.control_buf,(char *)Control_States.send_buf)) && Control_States.retry_conter<=2);
0000aa  1d49              ADDS     r1,r1,#5
0000ac  1f08              SUBS     r0,r1,#4
0000ae  f7fffffe          BL       strcmp
0000b2  2800              CMP      r0,#0
0000b4  d037              BEQ      |L2.294|
0000b6  481c              LDR      r0,|L2.296|
0000b8  7a40              LDRB     r0,[r0,#9]  ; Control_States
0000ba  2802              CMP      r0,#2
0000bc  ddbd              BLE      |L2.58|
0000be  e032              B        |L2.294|
                  |L2.192|
;;;179    	}
;;;180    	else  ///执行查询命令
;;;181    	{
;;;182    		HAL_UART_Transmit(&huart5, Control_States.control_buf, 4, 0xFFFF);
0000c0  4b1f              LDR      r3,|L2.320|
0000c2  2204              MOVS     r2,#4
0000c4  4918              LDR      r1,|L2.296|
0000c6  1c49              ADDS     r1,r1,#1
0000c8  481e              LDR      r0,|L2.324|
0000ca  f7fffffe          BL       HAL_UART_Transmit
;;;183    		DEBUG(2,"tx_data666 = %s\r\n",Control_States.control_buf);
0000ce  4916              LDR      r1,|L2.296|
0000d0  1c49              ADDS     r1,r1,#1
0000d2  a027              ADR      r0,|L2.368|
0000d4  f7fffffe          BL       __2printf
;;;184    		delay_ms(50);
0000d8  2032              MOVS     r0,#0x32
0000da  f7fffffe          BL       delay_ms
;;;185    		
;;;186    		///等待USART5接收数据处理完成状态
;;;187    		if(UART_RX_DATA.USART_TX_STATE)
0000de  481f              LDR      r0,|L2.348|
0000e0  79c0              LDRB     r0,[r0,#7]  ; UART_RX_DATA
0000e2  2800              CMP      r0,#0
0000e4  d01f              BEQ      |L2.294|
;;;188    		{
;;;189    		 for(uint8_t i = 0; i < 4; i++)
0000e6  2500              MOVS     r5,#0
0000e8  e006              B        |L2.248|
                  |L2.234|
;;;190    		 DEBUG(2,"%02d",UART_RX_DATA.USART_RX_BUF[i]);
0000ea  481d              LDR      r0,|L2.352|
0000ec  5d41              LDRB     r1,[r0,r5]
0000ee  a01d              ADR      r0,|L2.356|
0000f0  f7fffffe          BL       __2printf
0000f4  1c68              ADDS     r0,r5,#1              ;189
0000f6  b2c5              UXTB     r5,r0                 ;189
                  |L2.248|
0000f8  2d04              CMP      r5,#4                 ;189
0000fa  dbf6              BLT      |L2.234|
;;;191    		 DEBUG(2,"\r\n");
0000fc  a01b              ADR      r0,|L2.364|
0000fe  f7fffffe          BL       __2printf
;;;192    		 UART_RX_DATA.USART_TX_STATE = false;
000102  2000              MOVS     r0,#0
000104  4915              LDR      r1,|L2.348|
000106  71c8              STRB     r0,[r1,#7]
;;;193    		 memcpy(Control_States.send_buf, UART_RX_DATA.USART_RX_BUF, UART_RX_DATA.USART_RX_Len);
000108  4608              MOV      r0,r1
00010a  8882              LDRH     r2,[r0,#4]  ; UART_RX_DATA
00010c  4914              LDR      r1,|L2.352|
00010e  4806              LDR      r0,|L2.296|
000110  1d40              ADDS     r0,r0,#5
000112  f7fffffe          BL       __aeabi_memcpy
;;;194    		 memset(UART_RX_DATA.USART_RX_BUF, 0, UART_RX_DATA.USART_RX_Len);
000116  4811              LDR      r0,|L2.348|
000118  8881              LDRH     r1,[r0,#4]  ; UART_RX_DATA
00011a  4811              LDR      r0,|L2.352|
00011c  f7fffffe          BL       __aeabi_memclr4
;;;195    		 UART_RX_DATA.USART_RX_Len = 0;
000120  2000              MOVS     r0,#0
000122  490e              LDR      r1,|L2.348|
000124  8088              STRH     r0,[r1,#4]
                  |L2.294|
;;;196    		}			 
;;;197    	}
;;;198    }
000126  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L2.296|
                          DCD      Control_States
                  |L2.300|
00012c  74785f64          DCB      "tx_data000 = %s\r\n",0
000130  61746130
000134  3030203d
000138  2025730d
00013c  0a00    
00013e  00                DCB      0
00013f  00                DCB      0
                  |L2.320|
                          DCD      0x0000ffff
                  |L2.324|
                          DCD      huart5
                  |L2.328|
000148  74785f64          DCB      "tx_data555 = %s\r\n",0
00014c  61746135
000150  3535203d
000154  2025730d
000158  0a00    
00015a  00                DCB      0
00015b  00                DCB      0
                  |L2.348|
                          DCD      UART_RX_DATA+0x400
                  |L2.352|
                          DCD      UART_RX_DATA+0x4
                  |L2.356|
000164  25303264          DCB      "%02d",0
000168  00      
000169  00                DCB      0
00016a  00                DCB      0
00016b  00                DCB      0
                  |L2.364|
00016c  0d0a00            DCB      "\r\n",0
00016f  00                DCB      0
                  |L2.368|
000170  74785f64          DCB      "tx_data666 = %s\r\n",0
000174  61746136
000178  3636203d
00017c  2025730d
000180  0a00    
000182  00                DCB      0
000183  00                DCB      0

                          AREA ||i.Control_Relay_Init||, CODE, READONLY, ALIGN=2

                  Control_Relay_Init PROC
;;;71     */
;;;72     void Control_Relay_Init( void )
000000  b500              PUSH     {lr}
;;;73     {
000002  b087              SUB      sp,sp,#0x1c
;;;74     	GPIO_InitTypeDef GPIO_InitStruct;
;;;75      
;;;76     	/* Peripheral clock enable */
;;;77     	__HAL_RCC_GPIOA_CLK_ENABLE();
000004  bf00              NOP      
000006  4822              LDR      r0,|L3.144|
000008  6940              LDR      r0,[r0,#0x14]
00000a  2101              MOVS     r1,#1
00000c  0449              LSLS     r1,r1,#17
00000e  4308              ORRS     r0,r0,r1
000010  491f              LDR      r1,|L3.144|
000012  6148              STR      r0,[r1,#0x14]
000014  4608              MOV      r0,r1
000016  6940              LDR      r0,[r0,#0x14]
000018  2101              MOVS     r1,#1
00001a  0449              LSLS     r1,r1,#17
00001c  4008              ANDS     r0,r0,r1
00001e  9001              STR      r0,[sp,#4]
000020  bf00              NOP      
000022  bf00              NOP      
;;;78     	__HAL_RCC_GPIOB_CLK_ENABLE();
000024  bf00              NOP      
000026  481a              LDR      r0,|L3.144|
000028  6940              LDR      r0,[r0,#0x14]
00002a  0049              LSLS     r1,r1,#1
00002c  4308              ORRS     r0,r0,r1
00002e  4918              LDR      r1,|L3.144|
000030  6148              STR      r0,[r1,#0x14]
000032  4608              MOV      r0,r1
000034  6940              LDR      r0,[r0,#0x14]
000036  2101              MOVS     r1,#1
000038  0489              LSLS     r1,r1,#18
00003a  4008              ANDS     r0,r0,r1
00003c  9001              STR      r0,[sp,#4]
00003e  bf00              NOP      
000040  bf00              NOP      
;;;79       
;;;80       GPIO_InitStruct.Pin=GPIO_PIN_1; 
000042  2002              MOVS     r0,#2
000044  9002              STR      r0,[sp,#8]
;;;81     	GPIO_InitStruct.Mode=GPIO_MODE_OUTPUT_PP;//GPIO_MODE_OUTPUT_PP;  //推挽输出
000046  2001              MOVS     r0,#1
000048  9003              STR      r0,[sp,#0xc]
;;;82     	GPIO_InitStruct.Pull=GPIO_PULLUP;          //上拉
00004a  9004              STR      r0,[sp,#0x10]
;;;83     	GPIO_InitStruct.Speed=GPIO_SPEED_FREQ_HIGH;     //高速
00004c  2003              MOVS     r0,#3
00004e  9005              STR      r0,[sp,#0x14]
;;;84     	HAL_GPIO_Init(GPIOA,&GPIO_InitStruct);
000050  a902              ADD      r1,sp,#8
000052  2009              MOVS     r0,#9
000054  06c0              LSLS     r0,r0,#27
000056  f7fffffe          BL       HAL_GPIO_Init
;;;85     
;;;86     	HAL_GPIO_WritePin(GPIOA,GPIO_PIN_1,GPIO_PIN_RESET);	
00005a  2200              MOVS     r2,#0
00005c  2102              MOVS     r1,#2
00005e  2009              MOVS     r0,#9
000060  06c0              LSLS     r0,r0,#27
000062  f7fffffe          BL       HAL_GPIO_WritePin
;;;87     	
;;;88     	GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
000066  2003              MOVS     r0,#3
000068  0200              LSLS     r0,r0,#8
00006a  9002              STR      r0,[sp,#8]
;;;89     	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
00006c  2001              MOVS     r0,#1
00006e  9003              STR      r0,[sp,#0xc]
;;;90     	GPIO_InitStruct.Pull = GPIO_PULLUP;
000070  9004              STR      r0,[sp,#0x10]
;;;91     	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
000072  2003              MOVS     r0,#3
000074  9005              STR      r0,[sp,#0x14]
;;;92     	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
000076  a902              ADD      r1,sp,#8
000078  4806              LDR      r0,|L3.148|
00007a  f7fffffe          BL       HAL_GPIO_Init
;;;93     	
;;;94     	HAL_GPIO_WritePin(GPIOB,GPIO_PIN_8|GPIO_PIN_9,GPIO_PIN_RESET);
00007e  2200              MOVS     r2,#0
000080  2103              MOVS     r1,#3
000082  0209              LSLS     r1,r1,#8
000084  4803              LDR      r0,|L3.148|
000086  f7fffffe          BL       HAL_GPIO_WritePin
;;;95     }
00008a  b007              ADD      sp,sp,#0x1c
00008c  bd00              POP      {pc}
;;;96     
                          ENDP

00008e  0000              DCW      0x0000
                  |L3.144|
                          DCD      0x40021000
                  |L3.148|
                          DCD      0x48000400

                          AREA ||i.Enable_Stm8_Power||, CODE, READONLY, ALIGN=2

                  Enable_Stm8_Power PROC
;;;99     */
;;;100    void Enable_Stm8_Power( void )
000000  b500              PUSH     {lr}
;;;101    {
000002  b087              SUB      sp,sp,#0x1c
;;;102    	GPIO_InitTypeDef GPIO_InitStruct;
;;;103    	
;;;104    	__HAL_RCC_GPIOB_CLK_ENABLE();               		 //开启GPIOB时钟
000004  bf00              NOP      
000006  4811              LDR      r0,|L4.76|
000008  6940              LDR      r0,[r0,#0x14]
00000a  2101              MOVS     r1,#1
00000c  0489              LSLS     r1,r1,#18
00000e  4308              ORRS     r0,r0,r1
000010  490e              LDR      r1,|L4.76|
000012  6148              STR      r0,[r1,#0x14]
000014  4608              MOV      r0,r1
000016  6940              LDR      r0,[r0,#0x14]
000018  2101              MOVS     r1,#1
00001a  0489              LSLS     r1,r1,#18
00001c  4008              ANDS     r0,r0,r1
00001e  9001              STR      r0,[sp,#4]
000020  bf00              NOP      
000022  bf00              NOP      
;;;105    
;;;106    	GPIO_InitStruct.Pin=GPIO_PIN_12;  
000024  1188              ASRS     r0,r1,#6
000026  9002              STR      r0,[sp,#8]
;;;107    	GPIO_InitStruct.Mode=GPIO_MODE_OUTPUT_PP;      			//下拉
000028  2001              MOVS     r0,#1
00002a  9003              STR      r0,[sp,#0xc]
;;;108    	GPIO_InitStruct.Pull=GPIO_PULLDOWN;
00002c  2002              MOVS     r0,#2
00002e  9004              STR      r0,[sp,#0x10]
;;;109    	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
000030  2003              MOVS     r0,#3
000032  9005              STR      r0,[sp,#0x14]
;;;110    	HAL_GPIO_Init(GPIOB,&GPIO_InitStruct);
000034  a902              ADD      r1,sp,#8
000036  4806              LDR      r0,|L4.80|
000038  f7fffffe          BL       HAL_GPIO_Init
;;;111    	
;;;112    	HAL_GPIO_WritePin(GPIOB,GPIO_PIN_12,GPIO_PIN_SET);	
00003c  2201              MOVS     r2,#1
00003e  0311              LSLS     r1,r2,#12
000040  4803              LDR      r0,|L4.80|
000042  f7fffffe          BL       HAL_GPIO_WritePin
;;;113    }
000046  b007              ADD      sp,sp,#0x1c
000048  bd00              POP      {pc}
;;;114    
                          ENDP

00004a  0000              DCW      0x0000
                  |L4.76|
                          DCD      0x40021000
                  |L4.80|
                          DCD      0x48000400

                          AREA ||i.Get_Work_ModeInit||, CODE, READONLY, ALIGN=2

                  Get_Work_ModeInit PROC
;;;51     */
;;;52     void Get_Work_ModeInit( void )
000000  b500              PUSH     {lr}
;;;53     {
000002  b087              SUB      sp,sp,#0x1c
;;;54     	GPIO_InitTypeDef GPIO_InitStruct;
;;;55     	
;;;56     	__HAL_RCC_GPIOC_CLK_ENABLE();               		 //开启GPIOB时钟
000004  bf00              NOP      
000006  4811              LDR      r0,|L5.76|
000008  6940              LDR      r0,[r0,#0x14]
00000a  2101              MOVS     r1,#1
00000c  04c9              LSLS     r1,r1,#19
00000e  4308              ORRS     r0,r0,r1
000010  490e              LDR      r1,|L5.76|
000012  6148              STR      r0,[r1,#0x14]
000014  4608              MOV      r0,r1
000016  6940              LDR      r0,[r0,#0x14]
000018  2101              MOVS     r1,#1
00001a  04c9              LSLS     r1,r1,#19
00001c  4008              ANDS     r0,r0,r1
00001e  9001              STR      r0,[sp,#4]
000020  bf00              NOP      
000022  bf00              NOP      
;;;57     
;;;58     	GPIO_InitStruct.Pin=GPIO_PIN_13;  
000024  1188              ASRS     r0,r1,#6
000026  9002              STR      r0,[sp,#8]
;;;59     	GPIO_InitStruct.Mode=GPIO_MODE_IT_RISING;      			//上升沿触发
000028  4809              LDR      r0,|L5.80|
00002a  9003              STR      r0,[sp,#0xc]
;;;60     	GPIO_InitStruct.Pull=GPIO_PULLDOWN;
00002c  2002              MOVS     r0,#2
00002e  9004              STR      r0,[sp,#0x10]
;;;61     	HAL_GPIO_Init(GPIOC,&GPIO_InitStruct);
000030  a902              ADD      r1,sp,#8
000032  4808              LDR      r0,|L5.84|
000034  f7fffffe          BL       HAL_GPIO_Init
;;;62     	
;;;63     		//中断线4-PC15
;;;64     	HAL_NVIC_SetPriority(EXTI4_15_IRQn,7,0);       //抢占优先级为0，子优先级为0
000038  2200              MOVS     r2,#0
00003a  2107              MOVS     r1,#7
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       HAL_NVIC_SetPriority
;;;65     	HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);             //使能中断线9
000042  2007              MOVS     r0,#7
000044  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;66     }
000048  b007              ADD      sp,sp,#0x1c
00004a  bd00              POP      {pc}
;;;67     
                          ENDP

                  |L5.76|
                          DCD      0x40021000
                  |L5.80|
                          DCD      0x10110000
                  |L5.84|
                          DCD      0x48000800

                          AREA ||i.HextoDec||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  HextoDec PROC
;;;33     ///////////////////////////////////////////////////////// 
;;;34     uint8_t HextoDec(uint8_t *hex, uint8_t length) 
000000  b5f8              PUSH     {r3-r7,lr}
;;;35     { 
000002  4607              MOV      r7,r0
000004  460d              MOV      r5,r1
;;;36         int i; 
;;;37         uint8_t rslt = 0;
000006  2600              MOVS     r6,#0
;;;38         for(i=0; i<length; i++) 
000008  2400              MOVS     r4,#0
00000a  e007              B        |L6.28|
                  |L6.12|
;;;39         { 
;;;40             rslt += (uint8_t)(hex[i])<<(8*(length-1-i)); 
00000c  5d38              LDRB     r0,[r7,r4]
00000e  1e69              SUBS     r1,r5,#1
000010  1b09              SUBS     r1,r1,r4
000012  00c9              LSLS     r1,r1,#3
000014  4088              LSLS     r0,r0,r1
000016  1980              ADDS     r0,r0,r6
000018  b2c6              UXTB     r6,r0
00001a  1c64              ADDS     r4,r4,#1              ;38
                  |L6.28|
00001c  42ac              CMP      r4,r5                 ;38
00001e  dbf5              BLT      |L6.12|
;;;41                                                              
;;;42         }
;;;43     		delay_ms(2);
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       delay_ms
;;;44     		DEBUG(2,"rslt = %d\r\n",rslt);
000026  4631              MOV      r1,r6
000028  a002              ADR      r0,|L6.52|
00002a  f7fffffe          BL       __2printf
;;;45         return rslt; 
00002e  4630              MOV      r0,r6
;;;46     }
000030  bdf8              POP      {r3-r7,pc}
;;;47     
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
000034  72736c74          DCB      "rslt = %d\r\n",0
000038  203d2025
00003c  640d0a00

                          AREA ||.data||, DATA, ALIGN=0

                  Control_States
000000  01010000          DCB      0x01,0x01,0x00,0x00
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\HAL\\src\\control.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_control_c_ee6bde43____REV16|
#line 388 "..\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_control_c_ee6bde43____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_control_c_ee6bde43____REVSH|
#line 402
|__asm___9_control_c_ee6bde43____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
