; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f0xx_hal_tim.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f0xx_hal_tim.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS\Device\ST\STM32F0xx\Include -I..\CMSIS\Include -I..\stm32f03xx_HAL\Inc -I..\USER -I..\HAL\inc -I..\HAL\system -I..\Lib\LoRawan-node\misc -I..\Lib\LoRawan-node\crypto -I..\Lib\LoRawan-node\mac -I..\Lib\LoRawan-node\radio -I..\Lib\LoRawan-node\radio\sx1276 -I..\Lib -IE:\NBI项目\NBI_LoRa\LoRa版本备份\NB_LoRawan-V2.0.2：control-F030CC\MDK_5.12\RTE -ID:\mysaftware\keil_5.12\ARM\PACK\Keil\STM32F0xx_DFP\1.5.0\Device\Include -ID:\mysaftware\keil_5.12\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=518 -DSTM32F030xC -DUSE_HAL_DRIVER -DSTM32F030xC -DUSE_MODEM_LORA -DUSE_BAND_433 --omf_browse=.\objects\stm32f0xx_hal_tim.crf ..\stm32f03xx_HAL\Src\stm32f0xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_DeInit PROC
;;;242      */
;;;243    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;244    {
000002  4604              MOV      r4,r0
;;;245      /* Check the parameters */
;;;246      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;247    
;;;248      htim->State = HAL_TIM_STATE_BUSY;
000004  2102              MOVS     r1,#2
000006  203d              MOVS     r0,#0x3d
000008  5501              STRB     r1,[r0,r4]
;;;249    
;;;250      /* Disable the TIM Peripheral Clock */
;;;251      __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  490e              LDR      r1,|L1.76|
000012  4008              ANDS     r0,r0,r1
000014  2800              CMP      r0,#0
000016  d10b              BNE      |L1.48|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  2800              CMP      r0,#0
000022  d105              BNE      |L1.48|
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  0840              LSRS     r0,r0,#1
00002a  0040              LSLS     r0,r0,#1
00002c  6821              LDR      r1,[r4,#0]
00002e  6008              STR      r0,[r1,#0]
                  |L1.48|
000030  bf00              NOP      
;;;252    
;;;253      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;254      HAL_TIM_Base_MspDeInit(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;255    
;;;256      /* Change TIM state */
;;;257      htim->State = HAL_TIM_STATE_RESET;
000038  2100              MOVS     r1,#0
00003a  203d              MOVS     r0,#0x3d
00003c  5501              STRB     r1,[r0,r4]
;;;258    
;;;259      /* Release Lock */
;;;260      __HAL_UNLOCK(htim);
00003e  bf00              NOP      
000040  203c              MOVS     r0,#0x3c
000042  5501              STRB     r1,[r0,r4]
000044  bf00              NOP      
;;;261    
;;;262      return HAL_OK;
000046  2000              MOVS     r0,#0
;;;263    }
000048  bd10              POP      {r4,pc}
;;;264    
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;4492     */
;;;4493   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4494   {
;;;4495     return htim->State;
000002  203d              MOVS     r0,#0x3d
000004  5c40              LDRB     r0,[r0,r1]
;;;4496   }
000006  4770              BX       lr
;;;4497   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;202      */
;;;203    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;204    {
000002  4604              MOV      r4,r0
;;;205      /* Check the TIM handle allocation */
;;;206      if(htim == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L3.12|
;;;207      {
;;;208        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L3.10|
;;;209      }
;;;210    
;;;211      /* Check the parameters */
;;;212      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;213      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;214      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;215      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;216    
;;;217      if(htim->State == HAL_TIM_STATE_RESET)
;;;218      {
;;;219        /* Allocate lock resource and initialize it */
;;;220        htim->Lock = HAL_UNLOCKED;
;;;221    
;;;222        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;223        HAL_TIM_Base_MspInit(htim);
;;;224      }
;;;225    
;;;226      /* Set the TIM state */
;;;227      htim->State= HAL_TIM_STATE_BUSY;
;;;228    
;;;229      /* Set the Time Base configuration */
;;;230      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;231    
;;;232      /* Initialize the TIM state*/
;;;233      htim->State= HAL_TIM_STATE_READY;
;;;234    
;;;235      return HAL_OK;
;;;236    }
00000a  bd10              POP      {r4,pc}
                  |L3.12|
00000c  203d              MOVS     r0,#0x3d              ;217
00000e  5d00              LDRB     r0,[r0,r4]            ;217
000010  2800              CMP      r0,#0                 ;217
000012  d105              BNE      |L3.32|
000014  2100              MOVS     r1,#0                 ;220
000016  203c              MOVS     r0,#0x3c              ;220
000018  5501              STRB     r1,[r0,r4]            ;220
00001a  4620              MOV      r0,r4                 ;223
00001c  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.32|
000020  2102              MOVS     r1,#2                 ;227
000022  203d              MOVS     r0,#0x3d              ;227
000024  5501              STRB     r1,[r0,r4]            ;227
000026  1d21              ADDS     r1,r4,#4              ;230
000028  6820              LDR      r0,[r4,#0]            ;230
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  2101              MOVS     r1,#1                 ;233
000030  203d              MOVS     r0,#0x3d              ;233
000032  5501              STRB     r1,[r0,r4]            ;233
000034  2000              MOVS     r0,#0                 ;235
000036  e7e8              B        |L3.10|
;;;237    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;284      */
;;;285    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;286    {
;;;287      /* Prevent unused argument(s) compilation warning */
;;;288      UNUSED(htim);
;;;289    
;;;290      /* NOTE : This function Should not be modified, when the callback is needed,
;;;291                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;292       */
;;;293    }
;;;294    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;269      */
;;;270    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;271    {
;;;272      /* Prevent unused argument(s) compilation warning */
;;;273      UNUSED(htim);
;;;274    
;;;275      /* NOTE : This function Should not be modified, when the callback is needed,
;;;276                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;277       */
;;;278    }
;;;279    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;300    */
;;;301    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;302    {
;;;303      /* Check the parameters */
;;;304      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;305    
;;;306      /* Set the TIM state */
;;;307      htim->State= HAL_TIM_STATE_BUSY;
000002  2202              MOVS     r2,#2
000004  203d              MOVS     r0,#0x3d
000006  5442              STRB     r2,[r0,r1]
;;;308    
;;;309      /* Enable the Peripheral */
;;;310      __HAL_TIM_ENABLE(htim);
000008  6808              LDR      r0,[r1,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  2201              MOVS     r2,#1
00000e  4310              ORRS     r0,r0,r2
000010  680a              LDR      r2,[r1,#0]
000012  6010              STR      r0,[r2,#0]
;;;311    
;;;312      /* Change the TIM state*/
;;;313      htim->State= HAL_TIM_STATE_READY;
000014  2201              MOVS     r2,#1
000016  203d              MOVS     r0,#0x3d
000018  5442              STRB     r2,[r0,r1]
;;;314    
;;;315      /* Return function status */
;;;316      return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;317    }
00001c  4770              BX       lr
;;;318    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;387    */
;;;388    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;389    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;390      /* Check the parameters */
;;;391      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;392    
;;;393      if((htim->State == HAL_TIM_STATE_BUSY))
000008  203d              MOVS     r0,#0x3d
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2802              CMP      r0,#2
00000e  d100              BNE      |L7.18|
                  |L7.16|
;;;394      {
;;;395         return HAL_BUSY;
;;;396      }
;;;397      else if((htim->State == HAL_TIM_STATE_READY))
;;;398      {
;;;399        if((pData == 0 ) && (Length > 0))
;;;400        {
;;;401          return HAL_ERROR;
;;;402        }
;;;403        else
;;;404        {
;;;405          htim->State = HAL_TIM_STATE_BUSY;
;;;406        }
;;;407      }
;;;408      /* Set the DMA Period elapsed callback */
;;;409      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;410    
;;;411      /* Set the DMA error callback */
;;;412      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;413    
;;;414      /* Enable the DMA channel */
;;;415      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;416    
;;;417      /* Enable the TIM Update DMA request */
;;;418      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;419    
;;;420      /* Enable the Peripheral */
;;;421      __HAL_TIM_ENABLE(htim);
;;;422    
;;;423      /* Return function status */
;;;424      return HAL_OK;
;;;425    }
000010  bd70              POP      {r4-r6,pc}
                  |L7.18|
000012  203d              MOVS     r0,#0x3d              ;397
000014  5d00              LDRB     r0,[r0,r4]            ;397
000016  2801              CMP      r0,#1                 ;397
000018  d107              BNE      |L7.42|
00001a  2e00              CMP      r6,#0                 ;399
00001c  d102              BNE      |L7.36|
00001e  2d00              CMP      r5,#0                 ;399
000020  dd00              BLE      |L7.36|
000022  e7f5              B        |L7.16|
                  |L7.36|
000024  2102              MOVS     r1,#2                 ;405
000026  203d              MOVS     r0,#0x3d              ;405
000028  5501              STRB     r1,[r0,r4]            ;405
                  |L7.42|
00002a  480e              LDR      r0,|L7.100|
00002c  6a21              LDR      r1,[r4,#0x20]         ;409
00002e  6288              STR      r0,[r1,#0x28]         ;409
000030  480d              LDR      r0,|L7.104|
000032  6a21              LDR      r1,[r4,#0x20]         ;412
000034  6308              STR      r0,[r1,#0x30]         ;412
000036  6821              LDR      r1,[r4,#0]            ;415
000038  460a              MOV      r2,r1                 ;415
00003a  322c              ADDS     r2,r2,#0x2c           ;415
00003c  462b              MOV      r3,r5                 ;415
00003e  4631              MOV      r1,r6                 ;415
000040  6a20              LDR      r0,[r4,#0x20]         ;415
000042  f7fffffe          BL       HAL_DMA_Start_IT
000046  6820              LDR      r0,[r4,#0]            ;418
000048  68c0              LDR      r0,[r0,#0xc]          ;418
00004a  21ff              MOVS     r1,#0xff              ;418
00004c  3101              ADDS     r1,#1                 ;418
00004e  4308              ORRS     r0,r0,r1              ;418
000050  6821              LDR      r1,[r4,#0]            ;418
000052  60c8              STR      r0,[r1,#0xc]          ;418
000054  6820              LDR      r0,[r4,#0]            ;421
000056  6800              LDR      r0,[r0,#0]            ;421
000058  2101              MOVS     r1,#1                 ;421
00005a  4308              ORRS     r0,r0,r1              ;421
00005c  6821              LDR      r1,[r4,#0]            ;421
00005e  6008              STR      r0,[r1,#0]            ;421
000060  2000              MOVS     r0,#0                 ;424
000062  e7d5              B        |L7.16|
;;;426    
                          ENDP

                  |L7.100|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.104|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;346    */
;;;347    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;348    {
;;;349      /* Check the parameters */
;;;350      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;351    
;;;352       /* Enable the TIM Update interrupt */
;;;353       __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  2201              MOVS     r2,#1
000008  4310              ORRS     r0,r0,r2
00000a  680a              LDR      r2,[r1,#0]
00000c  60d0              STR      r0,[r2,#0xc]
;;;354    
;;;355       /* Enable the Peripheral */
;;;356      __HAL_TIM_ENABLE(htim);
00000e  6808              LDR      r0,[r1,#0]
000010  6800              LDR      r0,[r0,#0]
000012  2201              MOVS     r2,#1
000014  4310              ORRS     r0,r0,r2
000016  680a              LDR      r2,[r1,#0]
000018  6010              STR      r0,[r2,#0]
;;;357    
;;;358      /* Return function status */
;;;359      return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;360    }
00001c  4770              BX       lr
;;;361    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Stop PROC
;;;323    */
;;;324    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;325    {
;;;326      /* Check the parameters */
;;;327      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;328    
;;;329      /* Set the TIM state */
;;;330      htim->State= HAL_TIM_STATE_BUSY;
000002  2202              MOVS     r2,#2
000004  203d              MOVS     r0,#0x3d
000006  5442              STRB     r2,[r0,r1]
;;;331    
;;;332      /* Disable the Peripheral */
;;;333      __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6808              LDR      r0,[r1,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  4a0b              LDR      r2,|L9.60|
000010  4010              ANDS     r0,r0,r2
000012  2800              CMP      r0,#0
000014  d10b              BNE      |L9.46|
000016  6808              LDR      r0,[r1,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1092              ASRS     r2,r2,#2
00001c  4010              ANDS     r0,r0,r2
00001e  2800              CMP      r0,#0
000020  d105              BNE      |L9.46|
000022  6808              LDR      r0,[r1,#0]
000024  6800              LDR      r0,[r0,#0]
000026  0840              LSRS     r0,r0,#1
000028  0040              LSLS     r0,r0,#1
00002a  680a              LDR      r2,[r1,#0]
00002c  6010              STR      r0,[r2,#0]
                  |L9.46|
00002e  bf00              NOP      
;;;334    
;;;335      /* Change the TIM state*/
;;;336      htim->State= HAL_TIM_STATE_READY;
000030  2201              MOVS     r2,#1
000032  203d              MOVS     r0,#0x3d
000034  5442              STRB     r2,[r0,r1]
;;;337    
;;;338      /* Return function status */
;;;339      return HAL_OK;
000036  2000              MOVS     r0,#0
;;;340    }
000038  4770              BX       lr
;;;341    
                          ENDP

00003a  0000              DCW      0x0000
                  |L9.60|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Stop_DMA PROC
;;;431    */
;;;432    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;436    
;;;437      /* Disable the TIM Update DMA request */
;;;438      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  22ff              MOVS     r2,#0xff
000008  3201              ADDS     r2,#1
00000a  4390              BICS     r0,r0,r2
00000c  680a              LDR      r2,[r1,#0]
00000e  60d0              STR      r0,[r2,#0xc]
;;;439    
;;;440      /* Disable the Peripheral */
;;;441      __HAL_TIM_DISABLE(htim);
000010  bf00              NOP      
000012  6808              LDR      r0,[r1,#0]
000014  6a00              LDR      r0,[r0,#0x20]
000016  4a0b              LDR      r2,|L10.68|
000018  4010              ANDS     r0,r0,r2
00001a  2800              CMP      r0,#0
00001c  d10b              BNE      |L10.54|
00001e  6808              LDR      r0,[r1,#0]
000020  6a00              LDR      r0,[r0,#0x20]
000022  1092              ASRS     r2,r2,#2
000024  4010              ANDS     r0,r0,r2
000026  2800              CMP      r0,#0
000028  d105              BNE      |L10.54|
00002a  6808              LDR      r0,[r1,#0]
00002c  6800              LDR      r0,[r0,#0]
00002e  0840              LSRS     r0,r0,#1
000030  0040              LSLS     r0,r0,#1
000032  680a              LDR      r2,[r1,#0]
000034  6010              STR      r0,[r2,#0]
                  |L10.54|
000036  bf00              NOP      
;;;442    
;;;443      /* Change the htim state */
;;;444      htim->State = HAL_TIM_STATE_READY;
000038  2201              MOVS     r2,#1
00003a  203d              MOVS     r0,#0x3d
00003c  5442              STRB     r2,[r0,r1]
;;;445    
;;;446      /* Return function status */
;;;447      return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;448    }
000040  4770              BX       lr
;;;449    
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Stop_IT PROC
;;;366    */
;;;367    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;368    {
;;;369      /* Check the parameters */
;;;370      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;371      /* Disable the TIM Update interrupt */
;;;372      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  0840              LSRS     r0,r0,#1
000008  0040              LSLS     r0,r0,#1
00000a  680a              LDR      r2,[r1,#0]
00000c  60d0              STR      r0,[r2,#0xc]
;;;373    
;;;374      /* Disable the Peripheral */
;;;375      __HAL_TIM_DISABLE(htim);
00000e  bf00              NOP      
000010  6808              LDR      r0,[r1,#0]
000012  6a00              LDR      r0,[r0,#0x20]
000014  4a09              LDR      r2,|L11.60|
000016  4010              ANDS     r0,r0,r2
000018  2800              CMP      r0,#0
00001a  d10b              BNE      |L11.52|
00001c  6808              LDR      r0,[r1,#0]
00001e  6a00              LDR      r0,[r0,#0x20]
000020  1092              ASRS     r2,r2,#2
000022  4010              ANDS     r0,r0,r2
000024  2800              CMP      r0,#0
000026  d105              BNE      |L11.52|
000028  6808              LDR      r0,[r1,#0]
00002a  6800              LDR      r0,[r0,#0]
00002c  0840              LSRS     r0,r0,#1
00002e  0040              LSLS     r0,r0,#1
000030  680a              LDR      r2,[r1,#0]
000032  6010              STR      r0,[r2,#0]
                  |L11.52|
000034  bf00              NOP      
;;;376    
;;;377      /* Return function status */
;;;378      return HAL_OK;
000036  2000              MOVS     r0,#0
;;;379    }
000038  4770              BX       lr
;;;380    
                          ENDP

00003a  0000              DCW      0x0000
                  |L11.60|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigClockSource PROC
;;;4018     */ 
;;;4019   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
000000  b5f8              PUSH     {r3-r7,lr}
;;;4020   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4021     uint32_t tmpsmcr = 0U;
000006  2600              MOVS     r6,#0
;;;4022   
;;;4023     /* Process Locked */
;;;4024     __HAL_LOCK(htim);
000008  bf00              NOP      
00000a  203c              MOVS     r0,#0x3c
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L12.22|
000012  2002              MOVS     r0,#2
                  |L12.20|
;;;4025   
;;;4026     htim->State = HAL_TIM_STATE_BUSY;
;;;4027   
;;;4028     /* Check the parameters */
;;;4029     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;4030   
;;;4031     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;4032     tmpsmcr = htim->Instance->SMCR;
;;;4033     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;4034     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;4035     htim->Instance->SMCR = tmpsmcr;
;;;4036   
;;;4037     switch (sClockSourceConfig->ClockSource)
;;;4038     {
;;;4039     case TIM_CLOCKSOURCE_INTERNAL:
;;;4040       {
;;;4041         assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;4042         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;4043         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;4044       }
;;;4045       break;
;;;4046   
;;;4047     case TIM_CLOCKSOURCE_ETRMODE1:
;;;4048       {
;;;4049         /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
;;;4050         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;4051   
;;;4052         /* Check ETR input conditioning related parameters */
;;;4053         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4054         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4055         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4056         
;;;4057         /* Configure the ETR Clock source */
;;;4058         TIM_ETR_SetConfig(htim->Instance,
;;;4059                           sClockSourceConfig->ClockPrescaler,
;;;4060                           sClockSourceConfig->ClockPolarity,
;;;4061                           sClockSourceConfig->ClockFilter);
;;;4062         /* Get the TIMx SMCR register value */
;;;4063         tmpsmcr = htim->Instance->SMCR;
;;;4064         /* Reset the SMS and TS Bits */
;;;4065         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;4066         /* Select the External clock mode1 and the ETRF trigger */
;;;4067         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;4068         /* Write to TIMx SMCR */
;;;4069         htim->Instance->SMCR = tmpsmcr;
;;;4070       }
;;;4071       break;
;;;4072   
;;;4073     case TIM_CLOCKSOURCE_ETRMODE2:
;;;4074       {
;;;4075         /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
;;;4076         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
;;;4077   
;;;4078         /* Check ETR input conditioning related parameters */
;;;4079         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4080         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4081         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4082         
;;;4083         /* Configure the ETR Clock source */
;;;4084         TIM_ETR_SetConfig(htim->Instance,
;;;4085                           sClockSourceConfig->ClockPrescaler,
;;;4086                           sClockSourceConfig->ClockPolarity,
;;;4087                           sClockSourceConfig->ClockFilter);
;;;4088         /* Enable the External clock mode2 */
;;;4089         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;4090       }
;;;4091       break;
;;;4092   
;;;4093     case TIM_CLOCKSOURCE_TI1:
;;;4094       {
;;;4095         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4096         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4097   
;;;4098         /* Check TI1 input conditioning related parameters */
;;;4099         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4100         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4101         
;;;4102         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4103                                  sClockSourceConfig->ClockPolarity,
;;;4104                                  sClockSourceConfig->ClockFilter);
;;;4105         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;4106       }
;;;4107       break;
;;;4108     case TIM_CLOCKSOURCE_TI2:
;;;4109       {
;;;4110         /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
;;;4111         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4112   
;;;4113          /* Check TI2 input conditioning related parameters */
;;;4114         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4115         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4116   
;;;4117         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4118                                  sClockSourceConfig->ClockPolarity,
;;;4119                                  sClockSourceConfig->ClockFilter);
;;;4120         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4121       }
;;;4122       break;
;;;4123     case TIM_CLOCKSOURCE_TI1ED:
;;;4124       {
;;;4125         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4126         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4127   
;;;4128         /* Check TI1 input conditioning related parameters */
;;;4129         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4130         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4131   
;;;4132         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4133                                  sClockSourceConfig->ClockPolarity,
;;;4134                                  sClockSourceConfig->ClockFilter);
;;;4135         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4136       }
;;;4137       break;
;;;4138     case TIM_CLOCKSOURCE_ITR0:
;;;4139       {
;;;4140         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4141         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4142   
;;;4143         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4144       }
;;;4145       break;
;;;4146     case TIM_CLOCKSOURCE_ITR1:
;;;4147       {
;;;4148         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4149         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4150   
;;;4151         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4152       }
;;;4153       break;
;;;4154     case TIM_CLOCKSOURCE_ITR2:
;;;4155       {
;;;4156         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4157         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4158   
;;;4159         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4160       }
;;;4161       break;
;;;4162     case TIM_CLOCKSOURCE_ITR3:
;;;4163       {
;;;4164         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4165         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4166   
;;;4167         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4168       }
;;;4169       break;
;;;4170   
;;;4171     default:
;;;4172       break;
;;;4173     }
;;;4174     htim->State = HAL_TIM_STATE_READY;
;;;4175   
;;;4176     __HAL_UNLOCK(htim);
;;;4177   
;;;4178     return HAL_OK;
;;;4179   }
000014  bdf8              POP      {r3-r7,pc}
                  |L12.22|
000016  2101              MOVS     r1,#1                 ;4024
000018  203c              MOVS     r0,#0x3c              ;4024
00001a  5501              STRB     r1,[r0,r4]            ;4024
00001c  bf00              NOP                            ;4024
00001e  2102              MOVS     r1,#2                 ;4026
000020  203d              MOVS     r0,#0x3d              ;4026
000022  5501              STRB     r1,[r0,r4]            ;4026
000024  6820              LDR      r0,[r4,#0]            ;4032
000026  6886              LDR      r6,[r0,#8]            ;4032
000028  2177              MOVS     r1,#0x77              ;4033
00002a  4630              MOV      r0,r6                 ;4033
00002c  4388              BICS     r0,r0,r1              ;4033
00002e  4606              MOV      r6,r0                 ;4033
000030  21ff              MOVS     r1,#0xff              ;4034
000032  0209              LSLS     r1,r1,#8              ;4034
000034  4630              MOV      r0,r6                 ;4034
000036  4388              BICS     r0,r0,r1              ;4034
000038  4606              MOV      r6,r0                 ;4034
00003a  6820              LDR      r0,[r4,#0]            ;4035
00003c  6086              STR      r6,[r0,#8]            ;4035
00003e  6828              LDR      r0,[r5,#0]            ;4037
000040  2850              CMP      r0,#0x50              ;4037
000042  d03e              BEQ      |L12.194|
000044  dc0c              BGT      |L12.96|
000046  2820              CMP      r0,#0x20              ;4037
000048  d063              BEQ      |L12.274|
00004a  dc04              BGT      |L12.86|
00004c  2800              CMP      r0,#0                 ;4037
00004e  d056              BEQ      |L12.254|
000050  2810              CMP      r0,#0x10              ;4037
000052  d168              BNE      |L12.294|
000054  e058              B        |L12.264|
                  |L12.86|
000056  2830              CMP      r0,#0x30              ;4037
000058  d060              BEQ      |L12.284|
00005a  2840              CMP      r0,#0x40              ;4037
00005c  d163              BNE      |L12.294|
00005e  e044              B        |L12.234|
                  |L12.96|
000060  2860              CMP      r0,#0x60              ;4037
000062  d038              BEQ      |L12.214|
000064  2870              CMP      r0,#0x70              ;4037
000066  d00d              BEQ      |L12.132|
000068  2101              MOVS     r1,#1                 ;4037
00006a  0309              LSLS     r1,r1,#12             ;4037
00006c  1a40              SUBS     r0,r0,r1              ;4037
00006e  d002              BEQ      |L12.118|
000070  1a40              SUBS     r0,r0,r1              ;4037
000072  d158              BNE      |L12.294|
000074  e017              B        |L12.166|
                  |L12.118|
000076  6820              LDR      r0,[r4,#0]            ;4043
000078  6880              LDR      r0,[r0,#8]            ;4043
00007a  08c0              LSRS     r0,r0,#3              ;4043
00007c  00c0              LSLS     r0,r0,#3              ;4043
00007e  6821              LDR      r1,[r4,#0]            ;4043
000080  6088              STR      r0,[r1,#8]            ;4043
000082  e051              B        |L12.296|
                  |L12.132|
000084  68eb              LDR      r3,[r5,#0xc]          ;4058
000086  686a              LDR      r2,[r5,#4]            ;4058
000088  68a9              LDR      r1,[r5,#8]            ;4058
00008a  6820              LDR      r0,[r4,#0]            ;4058
00008c  f7fffffe          BL       TIM_ETR_SetConfig
000090  6820              LDR      r0,[r4,#0]            ;4063
000092  6886              LDR      r6,[r0,#8]            ;4063
000094  2177              MOVS     r1,#0x77              ;4065
000096  4630              MOV      r0,r6                 ;4065
000098  4388              BICS     r0,r0,r1              ;4065
00009a  4606              MOV      r6,r0                 ;4065
00009c  2077              MOVS     r0,#0x77              ;4067
00009e  4306              ORRS     r6,r6,r0              ;4067
0000a0  6820              LDR      r0,[r4,#0]            ;4069
0000a2  6086              STR      r6,[r0,#8]            ;4069
0000a4  e040              B        |L12.296|
                  |L12.166|
0000a6  68eb              LDR      r3,[r5,#0xc]          ;4084
0000a8  686a              LDR      r2,[r5,#4]            ;4084
0000aa  68a9              LDR      r1,[r5,#8]            ;4084
0000ac  6820              LDR      r0,[r4,#0]            ;4084
0000ae  f7fffffe          BL       TIM_ETR_SetConfig
0000b2  6820              LDR      r0,[r4,#0]            ;4089
0000b4  6880              LDR      r0,[r0,#8]            ;4089
0000b6  2101              MOVS     r1,#1                 ;4089
0000b8  0389              LSLS     r1,r1,#14             ;4089
0000ba  4308              ORRS     r0,r0,r1              ;4089
0000bc  6821              LDR      r1,[r4,#0]            ;4089
0000be  6088              STR      r0,[r1,#8]            ;4089
0000c0  e032              B        |L12.296|
                  |L12.194|
0000c2  68ea              LDR      r2,[r5,#0xc]          ;4102
0000c4  6869              LDR      r1,[r5,#4]            ;4102
0000c6  6820              LDR      r0,[r4,#0]            ;4102
0000c8  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000cc  2150              MOVS     r1,#0x50              ;4105
0000ce  6820              LDR      r0,[r4,#0]            ;4105
0000d0  f7fffffe          BL       TIM_ITRx_SetConfig
0000d4  e028              B        |L12.296|
                  |L12.214|
0000d6  68ea              LDR      r2,[r5,#0xc]          ;4117
0000d8  6869              LDR      r1,[r5,#4]            ;4117
0000da  6820              LDR      r0,[r4,#0]            ;4117
0000dc  f7fffffe          BL       TIM_TI2_ConfigInputStage
0000e0  2160              MOVS     r1,#0x60              ;4120
0000e2  6820              LDR      r0,[r4,#0]            ;4120
0000e4  f7fffffe          BL       TIM_ITRx_SetConfig
0000e8  e01e              B        |L12.296|
                  |L12.234|
0000ea  68ea              LDR      r2,[r5,#0xc]          ;4132
0000ec  6869              LDR      r1,[r5,#4]            ;4132
0000ee  6820              LDR      r0,[r4,#0]            ;4132
0000f0  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000f4  2140              MOVS     r1,#0x40              ;4135
0000f6  6820              LDR      r0,[r4,#0]            ;4135
0000f8  f7fffffe          BL       TIM_ITRx_SetConfig
0000fc  e014              B        |L12.296|
                  |L12.254|
0000fe  2100              MOVS     r1,#0                 ;4143
000100  6820              LDR      r0,[r4,#0]            ;4143
000102  f7fffffe          BL       TIM_ITRx_SetConfig
000106  e00f              B        |L12.296|
                  |L12.264|
000108  2110              MOVS     r1,#0x10              ;4151
00010a  6820              LDR      r0,[r4,#0]            ;4151
00010c  f7fffffe          BL       TIM_ITRx_SetConfig
000110  e00a              B        |L12.296|
                  |L12.274|
000112  2120              MOVS     r1,#0x20              ;4159
000114  6820              LDR      r0,[r4,#0]            ;4159
000116  f7fffffe          BL       TIM_ITRx_SetConfig
00011a  e005              B        |L12.296|
                  |L12.284|
00011c  2130              MOVS     r1,#0x30              ;4167
00011e  6820              LDR      r0,[r4,#0]            ;4167
000120  f7fffffe          BL       TIM_ITRx_SetConfig
000124  e000              B        |L12.296|
                  |L12.294|
000126  bf00              NOP                            ;4172
                  |L12.296|
000128  bf00              NOP                            ;4045
00012a  2101              MOVS     r1,#1                 ;4174
00012c  203d              MOVS     r0,#0x3d              ;4174
00012e  5501              STRB     r1,[r0,r4]            ;4174
000130  bf00              NOP                            ;4176
000132  2100              MOVS     r1,#0                 ;4176
000134  203c              MOVS     r0,#0x3c              ;4176
000136  5501              STRB     r1,[r0,r4]            ;4176
000138  bf00              NOP                            ;4176
00013a  2000              MOVS     r0,#0                 ;4178
00013c  e76a              B        |L12.20|
;;;4180   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;3890     */ 
;;;3891   __weak HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3892   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4617              MOV      r7,r2
;;;3893     uint32_t tmpsmcr = 0;
000008  2600              MOVS     r6,#0
;;;3894   
;;;3895     /* Check the parameters */
;;;3896     assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
;;;3897     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;3898     assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;3899     assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;3900     assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;3901   
;;;3902     /* Process Locked */
;;;3903     __HAL_LOCK(htim);
00000a  bf00              NOP      
00000c  203c              MOVS     r0,#0x3c
00000e  5d00              LDRB     r0,[r0,r4]
000010  2801              CMP      r0,#1
000012  d101              BNE      |L13.24|
000014  2002              MOVS     r0,#2
                  |L13.22|
;;;3904   
;;;3905     htim->State = HAL_TIM_STATE_BUSY;
;;;3906   
;;;3907     switch (sClearInputConfig->ClearInputSource)
;;;3908     {
;;;3909       case TIM_CLEARINPUTSOURCE_NONE:
;;;3910       {
;;;3911         /* Get the TIMx SMCR register value */
;;;3912         tmpsmcr = htim->Instance->SMCR;
;;;3913         
;;;3914         /* Clear the OCREF clear selection bit */
;;;3915         tmpsmcr &= ~TIM_SMCR_OCCS;
;;;3916   
;;;3917         /* Clear the ETR Bits */
;;;3918         tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;3919   
;;;3920         /* Set TIMx_SMCR */
;;;3921         htim->Instance->SMCR = tmpsmcr;
;;;3922      }
;;;3923       break;
;;;3924   
;;;3925       case TIM_CLEARINPUTSOURCE_ETR:
;;;3926       {
;;;3927         TIM_ETR_SetConfig(htim->Instance,
;;;3928                           sClearInputConfig->ClearInputPrescaler,
;;;3929                           sClearInputConfig->ClearInputPolarity,
;;;3930                           sClearInputConfig->ClearInputFilter);
;;;3931   
;;;3932         /* Set the OCREF clear selection bit */
;;;3933         htim->Instance->SMCR |= TIM_SMCR_OCCS;
;;;3934       }
;;;3935       break;
;;;3936       default:
;;;3937       break;
;;;3938     }
;;;3939   
;;;3940     switch (Channel)
;;;3941     {
;;;3942       case TIM_CHANNEL_1:
;;;3943         {
;;;3944           if(sClearInputConfig->ClearInputState != RESET)
;;;3945           {
;;;3946             /* Enable the Ocref clear feature for Channel 1 */
;;;3947             htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;3948           }
;;;3949           else
;;;3950           {
;;;3951             /* Disable the Ocref clear feature for Channel 1 */
;;;3952           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;
;;;3953           }
;;;3954         }
;;;3955         break;
;;;3956       case TIM_CHANNEL_2:
;;;3957         {
;;;3958           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3959           if(sClearInputConfig->ClearInputState != RESET)
;;;3960           {
;;;3961             /* Enable the Ocref clear feature for Channel 2 */
;;;3962             htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;3963           }
;;;3964           else
;;;3965           {
;;;3966             /* Disable the Ocref clear feature for Channel 2 */
;;;3967             htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;
;;;3968           }
;;;3969         }
;;;3970       break;
;;;3971       case TIM_CHANNEL_3:
;;;3972         {
;;;3973           assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3974           if(sClearInputConfig->ClearInputState != RESET)
;;;3975           {
;;;3976             /* Enable the Ocref clear feature for Channel 3 */
;;;3977             htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;3978           }
;;;3979           else
;;;3980           {
;;;3981             /* Disable the Ocref clear feature for Channel 3 */
;;;3982           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;
;;;3983           }
;;;3984         }
;;;3985       break;
;;;3986       case TIM_CHANNEL_4:
;;;3987         {
;;;3988           assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3989           if(sClearInputConfig->ClearInputState != RESET)
;;;3990           {
;;;3991             /* Enable the Ocref clear feature for Channel 4 */
;;;3992             htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;3993           }
;;;3994           else
;;;3995           {
;;;3996             /* Disable the Ocref clear feature for Channel 4 */
;;;3997           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;
;;;3998           }
;;;3999         }
;;;4000       break;
;;;4001       default:
;;;4002       break;
;;;4003     }
;;;4004   
;;;4005     htim->State = HAL_TIM_STATE_READY;
;;;4006   
;;;4007     __HAL_UNLOCK(htim);
;;;4008   
;;;4009     return HAL_OK;
;;;4010   }
000016  bdf8              POP      {r3-r7,pc}
                  |L13.24|
000018  2101              MOVS     r1,#1                 ;3903
00001a  203c              MOVS     r0,#0x3c              ;3903
00001c  5501              STRB     r1,[r0,r4]            ;3903
00001e  bf00              NOP                            ;3903
000020  2102              MOVS     r1,#2                 ;3905
000022  203d              MOVS     r0,#0x3d              ;3905
000024  5501              STRB     r1,[r0,r4]            ;3905
000026  6868              LDR      r0,[r5,#4]            ;3907
000028  2800              CMP      r0,#0                 ;3907
00002a  d002              BEQ      |L13.50|
00002c  2801              CMP      r0,#1                 ;3907
00002e  d11c              BNE      |L13.106|
000030  e00d              B        |L13.78|
                  |L13.50|
000032  6820              LDR      r0,[r4,#0]            ;3912
000034  6886              LDR      r6,[r0,#8]            ;3912
000036  2108              MOVS     r1,#8                 ;3915
000038  4630              MOV      r0,r6                 ;3915
00003a  4388              BICS     r0,r0,r1              ;3915
00003c  4606              MOV      r6,r0                 ;3915
00003e  21ff              MOVS     r1,#0xff              ;3918
000040  0209              LSLS     r1,r1,#8              ;3918
000042  4630              MOV      r0,r6                 ;3918
000044  4388              BICS     r0,r0,r1              ;3918
000046  4606              MOV      r6,r0                 ;3918
000048  6820              LDR      r0,[r4,#0]            ;3921
00004a  6086              STR      r6,[r0,#8]            ;3921
00004c  e00e              B        |L13.108|
                  |L13.78|
00004e  692b              LDR      r3,[r5,#0x10]         ;3927
000050  68aa              LDR      r2,[r5,#8]            ;3927
000052  68e9              LDR      r1,[r5,#0xc]          ;3927
000054  6820              LDR      r0,[r4,#0]            ;3927
000056  9000              STR      r0,[sp,#0]            ;3927
000058  f7fffffe          BL       TIM_ETR_SetConfig
00005c  6820              LDR      r0,[r4,#0]            ;3933
00005e  6880              LDR      r0,[r0,#8]            ;3933
000060  2108              MOVS     r1,#8                 ;3933
000062  4308              ORRS     r0,r0,r1              ;3933
000064  6821              LDR      r1,[r4,#0]            ;3933
000066  6088              STR      r0,[r1,#8]            ;3933
000068  e000              B        |L13.108|
                  |L13.106|
00006a  bf00              NOP                            ;3937
                  |L13.108|
00006c  bf00              NOP                            ;3923
00006e  2f00              CMP      r7,#0                 ;3940
000070  d006              BEQ      |L13.128|
000072  2f04              CMP      r7,#4                 ;3940
000074  d015              BEQ      |L13.162|
000076  2f08              CMP      r7,#8                 ;3940
000078  d026              BEQ      |L13.200|
00007a  2f0c              CMP      r7,#0xc               ;3940
00007c  d148              BNE      |L13.272|
00007e  e034              B        |L13.234|
                  |L13.128|
000080  6828              LDR      r0,[r5,#0]            ;3944
000082  2800              CMP      r0,#0                 ;3944
000084  d006              BEQ      |L13.148|
000086  6820              LDR      r0,[r4,#0]            ;3947
000088  6980              LDR      r0,[r0,#0x18]         ;3947
00008a  2180              MOVS     r1,#0x80              ;3947
00008c  4308              ORRS     r0,r0,r1              ;3947
00008e  6821              LDR      r1,[r4,#0]            ;3947
000090  6188              STR      r0,[r1,#0x18]         ;3947
000092  e005              B        |L13.160|
                  |L13.148|
000094  6820              LDR      r0,[r4,#0]            ;3952
000096  6980              LDR      r0,[r0,#0x18]         ;3952
000098  2180              MOVS     r1,#0x80              ;3952
00009a  4388              BICS     r0,r0,r1              ;3952
00009c  6821              LDR      r1,[r4,#0]            ;3952
00009e  6188              STR      r0,[r1,#0x18]         ;3952
                  |L13.160|
0000a0  e037              B        |L13.274|
                  |L13.162|
0000a2  6828              LDR      r0,[r5,#0]            ;3959
0000a4  2800              CMP      r0,#0                 ;3959
0000a6  d007              BEQ      |L13.184|
0000a8  6820              LDR      r0,[r4,#0]            ;3962
0000aa  6980              LDR      r0,[r0,#0x18]         ;3962
0000ac  2101              MOVS     r1,#1                 ;3962
0000ae  03c9              LSLS     r1,r1,#15             ;3962
0000b0  4308              ORRS     r0,r0,r1              ;3962
0000b2  6821              LDR      r1,[r4,#0]            ;3962
0000b4  6188              STR      r0,[r1,#0x18]         ;3962
0000b6  e006              B        |L13.198|
                  |L13.184|
0000b8  6820              LDR      r0,[r4,#0]            ;3967
0000ba  6980              LDR      r0,[r0,#0x18]         ;3967
0000bc  2101              MOVS     r1,#1                 ;3967
0000be  03c9              LSLS     r1,r1,#15             ;3967
0000c0  4388              BICS     r0,r0,r1              ;3967
0000c2  6821              LDR      r1,[r4,#0]            ;3967
0000c4  6188              STR      r0,[r1,#0x18]         ;3967
                  |L13.198|
0000c6  e024              B        |L13.274|
                  |L13.200|
0000c8  6828              LDR      r0,[r5,#0]            ;3974
0000ca  2800              CMP      r0,#0                 ;3974
0000cc  d006              BEQ      |L13.220|
0000ce  6820              LDR      r0,[r4,#0]            ;3977
0000d0  69c0              LDR      r0,[r0,#0x1c]         ;3977
0000d2  2180              MOVS     r1,#0x80              ;3977
0000d4  4308              ORRS     r0,r0,r1              ;3977
0000d6  6821              LDR      r1,[r4,#0]            ;3977
0000d8  61c8              STR      r0,[r1,#0x1c]         ;3977
0000da  e005              B        |L13.232|
                  |L13.220|
0000dc  6820              LDR      r0,[r4,#0]            ;3982
0000de  69c0              LDR      r0,[r0,#0x1c]         ;3982
0000e0  2180              MOVS     r1,#0x80              ;3982
0000e2  4388              BICS     r0,r0,r1              ;3982
0000e4  6821              LDR      r1,[r4,#0]            ;3982
0000e6  61c8              STR      r0,[r1,#0x1c]         ;3982
                  |L13.232|
0000e8  e013              B        |L13.274|
                  |L13.234|
0000ea  6828              LDR      r0,[r5,#0]            ;3989
0000ec  2800              CMP      r0,#0                 ;3989
0000ee  d007              BEQ      |L13.256|
0000f0  6820              LDR      r0,[r4,#0]            ;3992
0000f2  69c0              LDR      r0,[r0,#0x1c]         ;3992
0000f4  2101              MOVS     r1,#1                 ;3992
0000f6  03c9              LSLS     r1,r1,#15             ;3992
0000f8  4308              ORRS     r0,r0,r1              ;3992
0000fa  6821              LDR      r1,[r4,#0]            ;3992
0000fc  61c8              STR      r0,[r1,#0x1c]         ;3992
0000fe  e006              B        |L13.270|
                  |L13.256|
000100  6820              LDR      r0,[r4,#0]            ;3997
000102  69c0              LDR      r0,[r0,#0x1c]         ;3997
000104  2101              MOVS     r1,#1                 ;3997
000106  03c9              LSLS     r1,r1,#15             ;3997
000108  4388              BICS     r0,r0,r1              ;3997
00010a  6821              LDR      r1,[r4,#0]            ;3997
00010c  61c8              STR      r0,[r1,#0x1c]         ;3997
                  |L13.270|
00010e  e000              B        |L13.274|
                  |L13.272|
000110  bf00              NOP                            ;4002
                  |L13.274|
000112  bf00              NOP                            ;3955
000114  2101              MOVS     r1,#1                 ;4005
000116  203d              MOVS     r0,#0x3d              ;4005
000118  5501              STRB     r1,[r0,r4]            ;4005
00011a  bf00              NOP                            ;4007
00011c  2100              MOVS     r1,#0                 ;4007
00011e  203c              MOVS     r0,#0x3c              ;4007
000120  5501              STRB     r1,[r0,r4]            ;4007
000122  bf00              NOP                            ;4007
000124  2000              MOVS     r0,#0                 ;4009
000126  e776              B        |L13.22|
;;;4011   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;4192     */
;;;4193   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  b510              PUSH     {r4,lr}
;;;4194   {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;4195     uint32_t tmpcr2 = 0U;
000006  2100              MOVS     r1,#0
;;;4196   
;;;4197     /* Check the parameters */
;;;4198     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;4199     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4200   
;;;4201     /* Get the TIMx CR2 register value */
;;;4202     tmpcr2 = htim->Instance->CR2;
000008  6810              LDR      r0,[r2,#0]
00000a  6841              LDR      r1,[r0,#4]
;;;4203   
;;;4204     /* Reset the TI1 selection */
;;;4205     tmpcr2 &= ~TIM_CR2_TI1S;
00000c  2480              MOVS     r4,#0x80
00000e  4608              MOV      r0,r1
000010  43a0              BICS     r0,r0,r4
000012  4601              MOV      r1,r0
;;;4206   
;;;4207     /* Set the the TI1 selection */
;;;4208     tmpcr2 |= TI1_Selection;
000014  4608              MOV      r0,r1
000016  4318              ORRS     r0,r0,r3
000018  4601              MOV      r1,r0
;;;4209   
;;;4210     /* Write to TIMxCR2 */
;;;4211     htim->Instance->CR2 = tmpcr2;
00001a  6810              LDR      r0,[r2,#0]
00001c  6041              STR      r1,[r0,#4]
;;;4212   
;;;4213     return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;4214   }
000020  bd10              POP      {r4,pc}
;;;4215   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_MultiReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_MultiReadStart PROC
;;;3648     */
;;;3649   HAL_StatusTypeDef HAL_TIM_DMABurst_MultiReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  b5f8              PUSH     {r3-r7,lr}
;;;3650                                                     uint32_t  *BurstBuffer, uint32_t  BurstLength, uint32_t  DataLength)
;;;3651   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;3652     /* Check the parameters */
;;;3653     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3654     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3655     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3656     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3657     assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));
;;;3658   
;;;3659     if((htim->State == HAL_TIM_STATE_BUSY))
00000a  203d              MOVS     r0,#0x3d
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2802              CMP      r0,#2
000010  d100              BNE      |L15.20|
                  |L15.18|
;;;3660     {
;;;3661        return HAL_BUSY;
;;;3662     }
;;;3663     else if((htim->State == HAL_TIM_STATE_READY))
;;;3664     {
;;;3665       if((BurstBuffer == 0U ) && (BurstLength > 0U))
;;;3666       {
;;;3667         return HAL_ERROR;
;;;3668       }
;;;3669       else
;;;3670       {
;;;3671         htim->State = HAL_TIM_STATE_BUSY;
;;;3672       }
;;;3673     }
;;;3674     switch(BurstRequestSrc)
;;;3675     {
;;;3676       case TIM_DMA_UPDATE:
;;;3677       {
;;;3678         /* Set the DMA Period elapsed callback */
;;;3679         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3680   
;;;3681         /* Set the DMA error callback */
;;;3682         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3683   
;;;3684         /* Enable the DMA channel */
;;;3685          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3686       }
;;;3687       break;
;;;3688       case TIM_DMA_CC1:
;;;3689       {
;;;3690         /* Set the DMA Period elapsed callback */
;;;3691         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3692   
;;;3693         /* Set the DMA error callback */
;;;3694         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3695   
;;;3696         /* Enable the DMA channel */
;;;3697         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3698       }
;;;3699       break;
;;;3700       case TIM_DMA_CC2:
;;;3701       {
;;;3702         /* Set the DMA Period elapsed callback */
;;;3703         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3704   
;;;3705         /* Set the DMA error callback */
;;;3706         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3707   
;;;3708         /* Enable the DMA channel */
;;;3709         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3710       }
;;;3711       break;
;;;3712       case TIM_DMA_CC3:
;;;3713       {
;;;3714         /* Set the DMA Period elapsed callback */
;;;3715         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3716   
;;;3717         /* Set the DMA error callback */
;;;3718         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3719   
;;;3720         /* Enable the DMA channel */
;;;3721         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3722       }
;;;3723       break;
;;;3724       case TIM_DMA_CC4:
;;;3725       {
;;;3726         /* Set the DMA Period elapsed callback */
;;;3727         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3728   
;;;3729         /* Set the DMA error callback */
;;;3730         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3731   
;;;3732         /* Enable the DMA channel */
;;;3733         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3734       }
;;;3735       break;
;;;3736       case TIM_DMA_COM:
;;;3737       {
;;;3738         /* Set the DMA Period elapsed callback */
;;;3739         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3740   
;;;3741         /* Set the DMA error callback */
;;;3742         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3743   
;;;3744         /* Enable the DMA channel */
;;;3745         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3746       }
;;;3747       break;
;;;3748       case TIM_DMA_TRIGGER:
;;;3749       {
;;;3750         /* Set the DMA Period elapsed callback */
;;;3751         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3752   
;;;3753         /* Set the DMA error callback */
;;;3754         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3755   
;;;3756         /* Enable the DMA channel */
;;;3757         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, DataLength);
;;;3758       }
;;;3759       break;
;;;3760       default:
;;;3761       break;
;;;3762     }
;;;3763   
;;;3764     /* configure the DMA Burst Mode */
;;;3765     htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3766   
;;;3767     /* Enable the TIM DMA Request */
;;;3768     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3769   
;;;3770     htim->State = HAL_TIM_STATE_READY;
;;;3771   
;;;3772     /* Return function status */
;;;3773     return HAL_OK;
;;;3774   }
000012  bdf8              POP      {r3-r7,pc}
                  |L15.20|
000014  203d              MOVS     r0,#0x3d              ;3663
000016  5d00              LDRB     r0,[r0,r4]            ;3663
000018  2801              CMP      r0,#1                 ;3663
00001a  d109              BNE      |L15.48|
00001c  2e00              CMP      r6,#0                 ;3665
00001e  d104              BNE      |L15.42|
000020  9806              LDR      r0,[sp,#0x18]         ;3665
000022  2800              CMP      r0,#0                 ;3665
000024  d001              BEQ      |L15.42|
000026  2001              MOVS     r0,#1                 ;3667
000028  e7f3              B        |L15.18|
                  |L15.42|
00002a  2102              MOVS     r1,#2                 ;3671
00002c  203d              MOVS     r0,#0x3d              ;3671
00002e  5501              STRB     r1,[r0,r4]            ;3671
                  |L15.48|
000030  4628              MOV      r0,r5                 ;3674
000032  2201              MOVS     r2,#1                 ;3674
000034  02d2              LSLS     r2,r2,#11             ;3674
000036  1aa9              SUBS     r1,r5,r2              ;3674
000038  4295              CMP      r5,r2                 ;3674
00003a  d047              BEQ      |L15.204|
00003c  dc0d              BGT      |L15.90|
00003e  38ff              SUBS     r0,r0,#0xff           ;3674
000040  3801              SUBS     r0,#1                 ;3674
000042  2800              CMP      r0,#0                 ;3674
000044  d015              BEQ      |L15.114|
000046  38ff              SUBS     r0,r0,#0xff           ;3674
000048  3801              SUBS     r0,#1                 ;3674
00004a  2800              CMP      r0,#0                 ;3674
00004c  d020              BEQ      |L15.144|
00004e  38ff              SUBS     r0,r0,#0xff           ;3674
000050  38ff              SUBS     r0,r0,#0xff           ;3674
000052  3802              SUBS     r0,#2                 ;3674
000054  2800              CMP      r0,#0                 ;3674
000056  d176              BNE      |L15.326|
000058  e029              B        |L15.174|
                  |L15.90|
00005a  2001              MOVS     r0,#1                 ;3674
00005c  02c0              LSLS     r0,r0,#11             ;3674
00005e  1a08              SUBS     r0,r1,r0              ;3674
000060  d043              BEQ      |L15.234|
000062  2101              MOVS     r1,#1                 ;3674
000064  0309              LSLS     r1,r1,#12             ;3674
000066  1a40              SUBS     r0,r0,r1              ;3674
000068  d04e              BEQ      |L15.264|
00006a  0049              LSLS     r1,r1,#1              ;3674
00006c  1a40              SUBS     r0,r0,r1              ;3674
00006e  d16a              BNE      |L15.326|
000070  e059              B        |L15.294|
                  |L15.114|
000072  483d              LDR      r0,|L15.360|
000074  6a21              LDR      r1,[r4,#0x20]         ;3679
000076  6288              STR      r0,[r1,#0x28]         ;3679
000078  483c              LDR      r0,|L15.364|
00007a  6a21              LDR      r1,[r4,#0x20]         ;3682
00007c  6308              STR      r0,[r1,#0x30]         ;3682
00007e  6822              LDR      r2,[r4,#0]            ;3685
000080  4611              MOV      r1,r2                 ;3685
000082  314c              ADDS     r1,r1,#0x4c           ;3685
000084  6a20              LDR      r0,[r4,#0x20]         ;3685
000086  4632              MOV      r2,r6                 ;3685
000088  9b07              LDR      r3,[sp,#0x1c]         ;3685
00008a  f7fffffe          BL       HAL_DMA_Start_IT
00008e  e05b              B        |L15.328|
                  |L15.144|
000090  4937              LDR      r1,|L15.368|
000092  6a60              LDR      r0,[r4,#0x24]         ;3691
000094  6281              STR      r1,[r0,#0x28]         ;3691
000096  4935              LDR      r1,|L15.364|
000098  6a60              LDR      r0,[r4,#0x24]         ;3694
00009a  6301              STR      r1,[r0,#0x30]         ;3694
00009c  6822              LDR      r2,[r4,#0]            ;3697
00009e  4611              MOV      r1,r2                 ;3697
0000a0  314c              ADDS     r1,r1,#0x4c           ;3697
0000a2  6a60              LDR      r0,[r4,#0x24]         ;3697
0000a4  4632              MOV      r2,r6                 ;3697
0000a6  9b07              LDR      r3,[sp,#0x1c]         ;3697
0000a8  f7fffffe          BL       HAL_DMA_Start_IT
0000ac  e04c              B        |L15.328|
                  |L15.174|
0000ae  4930              LDR      r1,|L15.368|
0000b0  6aa0              LDR      r0,[r4,#0x28]         ;3703
0000b2  6281              STR      r1,[r0,#0x28]         ;3703
0000b4  492d              LDR      r1,|L15.364|
0000b6  6aa0              LDR      r0,[r4,#0x28]         ;3706
0000b8  6301              STR      r1,[r0,#0x30]         ;3706
0000ba  6822              LDR      r2,[r4,#0]            ;3709
0000bc  4611              MOV      r1,r2                 ;3709
0000be  314c              ADDS     r1,r1,#0x4c           ;3709
0000c0  6aa0              LDR      r0,[r4,#0x28]         ;3709
0000c2  4632              MOV      r2,r6                 ;3709
0000c4  9b07              LDR      r3,[sp,#0x1c]         ;3709
0000c6  f7fffffe          BL       HAL_DMA_Start_IT
0000ca  e03d              B        |L15.328|
                  |L15.204|
0000cc  4928              LDR      r1,|L15.368|
0000ce  6ae0              LDR      r0,[r4,#0x2c]         ;3715
0000d0  6281              STR      r1,[r0,#0x28]         ;3715
0000d2  4926              LDR      r1,|L15.364|
0000d4  6ae0              LDR      r0,[r4,#0x2c]         ;3718
0000d6  6301              STR      r1,[r0,#0x30]         ;3718
0000d8  6822              LDR      r2,[r4,#0]            ;3721
0000da  4611              MOV      r1,r2                 ;3721
0000dc  314c              ADDS     r1,r1,#0x4c           ;3721
0000de  6ae0              LDR      r0,[r4,#0x2c]         ;3721
0000e0  4632              MOV      r2,r6                 ;3721
0000e2  9b07              LDR      r3,[sp,#0x1c]         ;3721
0000e4  f7fffffe          BL       HAL_DMA_Start_IT
0000e8  e02e              B        |L15.328|
                  |L15.234|
0000ea  4921              LDR      r1,|L15.368|
0000ec  6b20              LDR      r0,[r4,#0x30]         ;3727
0000ee  6281              STR      r1,[r0,#0x28]         ;3727
0000f0  491e              LDR      r1,|L15.364|
0000f2  6b20              LDR      r0,[r4,#0x30]         ;3730
0000f4  6301              STR      r1,[r0,#0x30]         ;3730
0000f6  6822              LDR      r2,[r4,#0]            ;3733
0000f8  4611              MOV      r1,r2                 ;3733
0000fa  314c              ADDS     r1,r1,#0x4c           ;3733
0000fc  6b20              LDR      r0,[r4,#0x30]         ;3733
0000fe  4632              MOV      r2,r6                 ;3733
000100  9b07              LDR      r3,[sp,#0x1c]         ;3733
000102  f7fffffe          BL       HAL_DMA_Start_IT
000106  e01f              B        |L15.328|
                  |L15.264|
000108  491a              LDR      r1,|L15.372|
00010a  6b60              LDR      r0,[r4,#0x34]         ;3739
00010c  6281              STR      r1,[r0,#0x28]         ;3739
00010e  4917              LDR      r1,|L15.364|
000110  6b60              LDR      r0,[r4,#0x34]         ;3742
000112  6301              STR      r1,[r0,#0x30]         ;3742
000114  6822              LDR      r2,[r4,#0]            ;3745
000116  4611              MOV      r1,r2                 ;3745
000118  314c              ADDS     r1,r1,#0x4c           ;3745
00011a  6b60              LDR      r0,[r4,#0x34]         ;3745
00011c  4632              MOV      r2,r6                 ;3745
00011e  9b07              LDR      r3,[sp,#0x1c]         ;3745
000120  f7fffffe          BL       HAL_DMA_Start_IT
000124  e010              B        |L15.328|
                  |L15.294|
000126  4914              LDR      r1,|L15.376|
000128  6ba0              LDR      r0,[r4,#0x38]         ;3751
00012a  6281              STR      r1,[r0,#0x28]         ;3751
00012c  490f              LDR      r1,|L15.364|
00012e  6ba0              LDR      r0,[r4,#0x38]         ;3754
000130  6301              STR      r1,[r0,#0x30]         ;3754
000132  6822              LDR      r2,[r4,#0]            ;3757
000134  4611              MOV      r1,r2                 ;3757
000136  314c              ADDS     r1,r1,#0x4c           ;3757
000138  6ba0              LDR      r0,[r4,#0x38]         ;3757
00013a  4632              MOV      r2,r6                 ;3757
00013c  9b07              LDR      r3,[sp,#0x1c]         ;3757
00013e  f7fffffe          BL       HAL_DMA_Start_IT
000142  e001              B        |L15.328|
000144  e7ff              B        |L15.326|
                  |L15.326|
000146  bf00              NOP                            ;3761
                  |L15.328|
000148  bf00              NOP                            ;3687
00014a  9806              LDR      r0,[sp,#0x18]         ;3765
00014c  4338              ORRS     r0,r0,r7              ;3765
00014e  6821              LDR      r1,[r4,#0]            ;3765
000150  6488              STR      r0,[r1,#0x48]         ;3765
000152  6820              LDR      r0,[r4,#0]            ;3768
000154  68c0              LDR      r0,[r0,#0xc]          ;3768
000156  4328              ORRS     r0,r0,r5              ;3768
000158  6821              LDR      r1,[r4,#0]            ;3768
00015a  60c8              STR      r0,[r1,#0xc]          ;3768
00015c  2101              MOVS     r1,#1                 ;3770
00015e  203d              MOVS     r0,#0x3d              ;3770
000160  5501              STRB     r1,[r0,r4]            ;3770
000162  2000              MOVS     r0,#0                 ;3773
000164  e755              B        |L15.18|
;;;3775   
                          ENDP

000166  0000              DCW      0x0000
                  |L15.360|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.364|
                          DCD      TIM_DMAError
                  |L15.368|
                          DCD      TIM_DMACaptureCplt
                  |L15.372|
                          DCD      TIMEx_DMACommutationCplt
                  |L15.376|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_MultiWriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_MultiWriteStart PROC
;;;3378     */
;;;3379   HAL_StatusTypeDef HAL_TIM_DMABurst_MultiWriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  b5f8              PUSH     {r3-r7,lr}
;;;3380                                                      uint32_t* BurstBuffer, uint32_t  BurstLength,  uint32_t  DataLength)
;;;3381   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;3382     /* Check the parameters */
;;;3383     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3384     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3385     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3386     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3387     assert_param(IS_TIM_DMA_DATA_LENGTH(DataLength));
;;;3388   
;;;3389     if((htim->State == HAL_TIM_STATE_BUSY))
00000a  203d              MOVS     r0,#0x3d
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2802              CMP      r0,#2
000010  d100              BNE      |L16.20|
                  |L16.18|
;;;3390     {
;;;3391        return HAL_BUSY;
;;;3392     }
;;;3393     else if((htim->State == HAL_TIM_STATE_READY))
;;;3394     {
;;;3395       if((BurstBuffer == 0U ) && (BurstLength > 0U))
;;;3396       {
;;;3397         return HAL_ERROR;
;;;3398       }
;;;3399       else
;;;3400       {
;;;3401         htim->State = HAL_TIM_STATE_BUSY;
;;;3402       }
;;;3403     }
;;;3404     switch(BurstRequestSrc)
;;;3405     {
;;;3406       case TIM_DMA_UPDATE:
;;;3407       {
;;;3408         /* Set the DMA Period elapsed callback */
;;;3409         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3410   
;;;3411         /* Set the DMA error callback */
;;;3412         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3413   
;;;3414         /* Enable the DMA channel */
;;;3415         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3416       }
;;;3417       break;
;;;3418       case TIM_DMA_CC1:
;;;3419       {
;;;3420         /* Set the DMA Period elapsed callback */
;;;3421         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3422   
;;;3423         /* Set the DMA error callback */
;;;3424         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3425   
;;;3426         /* Enable the DMA channel */
;;;3427         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3428       }
;;;3429       break;
;;;3430       case TIM_DMA_CC2:
;;;3431       {
;;;3432         /* Set the DMA Period elapsed callback */
;;;3433         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3434   
;;;3435         /* Set the DMA error callback */
;;;3436         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3437   
;;;3438         /* Enable the DMA channel */
;;;3439         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3440       }
;;;3441       break;
;;;3442       case TIM_DMA_CC3:
;;;3443       {
;;;3444         /* Set the DMA Period elapsed callback */
;;;3445         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3446   
;;;3447         /* Set the DMA error callback */
;;;3448         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3449   
;;;3450         /* Enable the DMA channel */
;;;3451         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3452       }
;;;3453       break;
;;;3454       case TIM_DMA_CC4:
;;;3455       {
;;;3456         /* Set the DMA Period elapsed callback */
;;;3457         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3458   
;;;3459         /* Set the DMA error callback */
;;;3460         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3461   
;;;3462         /* Enable the DMA channel */
;;;3463         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3464       }
;;;3465       break;
;;;3466       case TIM_DMA_COM:
;;;3467       {
;;;3468         /* Set the DMA Period elapsed callback */
;;;3469         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3470   
;;;3471         /* Set the DMA error callback */
;;;3472         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3473   
;;;3474         /* Enable the DMA channel */
;;;3475         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3476       }
;;;3477       break;
;;;3478       case TIM_DMA_TRIGGER:
;;;3479       {
;;;3480         /* Set the DMA Period elapsed callback */
;;;3481         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3482   
;;;3483         /* Set the DMA error callback */
;;;3484         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3485   
;;;3486         /* Enable the DMA channel */
;;;3487         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, DataLength);
;;;3488       }
;;;3489       break;
;;;3490       default:
;;;3491       break;
;;;3492     }
;;;3493      /* configure the DMA Burst Mode */
;;;3494      htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3495   
;;;3496      /* Enable the TIM DMA Request */
;;;3497      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3498   
;;;3499      htim->State = HAL_TIM_STATE_READY;
;;;3500   
;;;3501     /* Return function status */
;;;3502     return HAL_OK;
;;;3503   }
000012  bdf8              POP      {r3-r7,pc}
                  |L16.20|
000014  203d              MOVS     r0,#0x3d              ;3393
000016  5d00              LDRB     r0,[r0,r4]            ;3393
000018  2801              CMP      r0,#1                 ;3393
00001a  d109              BNE      |L16.48|
00001c  2e00              CMP      r6,#0                 ;3395
00001e  d104              BNE      |L16.42|
000020  9806              LDR      r0,[sp,#0x18]         ;3395
000022  2800              CMP      r0,#0                 ;3395
000024  d001              BEQ      |L16.42|
000026  2001              MOVS     r0,#1                 ;3397
000028  e7f3              B        |L16.18|
                  |L16.42|
00002a  2102              MOVS     r1,#2                 ;3401
00002c  203d              MOVS     r0,#0x3d              ;3401
00002e  5501              STRB     r1,[r0,r4]            ;3401
                  |L16.48|
000030  4628              MOV      r0,r5                 ;3404
000032  2201              MOVS     r2,#1                 ;3404
000034  02d2              LSLS     r2,r2,#11             ;3404
000036  1aa9              SUBS     r1,r5,r2              ;3404
000038  4295              CMP      r5,r2                 ;3404
00003a  d047              BEQ      |L16.204|
00003c  dc0d              BGT      |L16.90|
00003e  38ff              SUBS     r0,r0,#0xff           ;3404
000040  3801              SUBS     r0,#1                 ;3404
000042  2800              CMP      r0,#0                 ;3404
000044  d015              BEQ      |L16.114|
000046  38ff              SUBS     r0,r0,#0xff           ;3404
000048  3801              SUBS     r0,#1                 ;3404
00004a  2800              CMP      r0,#0                 ;3404
00004c  d020              BEQ      |L16.144|
00004e  38ff              SUBS     r0,r0,#0xff           ;3404
000050  38ff              SUBS     r0,r0,#0xff           ;3404
000052  3802              SUBS     r0,#2                 ;3404
000054  2800              CMP      r0,#0                 ;3404
000056  d176              BNE      |L16.326|
000058  e029              B        |L16.174|
                  |L16.90|
00005a  2001              MOVS     r0,#1                 ;3404
00005c  02c0              LSLS     r0,r0,#11             ;3404
00005e  1a08              SUBS     r0,r1,r0              ;3404
000060  d043              BEQ      |L16.234|
000062  2101              MOVS     r1,#1                 ;3404
000064  0309              LSLS     r1,r1,#12             ;3404
000066  1a40              SUBS     r0,r0,r1              ;3404
000068  d04e              BEQ      |L16.264|
00006a  0049              LSLS     r1,r1,#1              ;3404
00006c  1a40              SUBS     r0,r0,r1              ;3404
00006e  d16a              BNE      |L16.326|
000070  e059              B        |L16.294|
                  |L16.114|
000072  483d              LDR      r0,|L16.360|
000074  6a21              LDR      r1,[r4,#0x20]         ;3409
000076  6288              STR      r0,[r1,#0x28]         ;3409
000078  483c              LDR      r0,|L16.364|
00007a  6a21              LDR      r1,[r4,#0x20]         ;3412
00007c  6308              STR      r0,[r1,#0x30]         ;3412
00007e  6821              LDR      r1,[r4,#0]            ;3415
000080  460a              MOV      r2,r1                 ;3415
000082  324c              ADDS     r2,r2,#0x4c           ;3415
000084  6a20              LDR      r0,[r4,#0x20]         ;3415
000086  4631              MOV      r1,r6                 ;3415
000088  9b07              LDR      r3,[sp,#0x1c]         ;3415
00008a  f7fffffe          BL       HAL_DMA_Start_IT
00008e  e05b              B        |L16.328|
                  |L16.144|
000090  4937              LDR      r1,|L16.368|
000092  6a60              LDR      r0,[r4,#0x24]         ;3421
000094  6281              STR      r1,[r0,#0x28]         ;3421
000096  4935              LDR      r1,|L16.364|
000098  6a60              LDR      r0,[r4,#0x24]         ;3424
00009a  6301              STR      r1,[r0,#0x30]         ;3424
00009c  6821              LDR      r1,[r4,#0]            ;3427
00009e  460a              MOV      r2,r1                 ;3427
0000a0  324c              ADDS     r2,r2,#0x4c           ;3427
0000a2  6a60              LDR      r0,[r4,#0x24]         ;3427
0000a4  4631              MOV      r1,r6                 ;3427
0000a6  9b07              LDR      r3,[sp,#0x1c]         ;3427
0000a8  f7fffffe          BL       HAL_DMA_Start_IT
0000ac  e04c              B        |L16.328|
                  |L16.174|
0000ae  4930              LDR      r1,|L16.368|
0000b0  6aa0              LDR      r0,[r4,#0x28]         ;3433
0000b2  6281              STR      r1,[r0,#0x28]         ;3433
0000b4  492d              LDR      r1,|L16.364|
0000b6  6aa0              LDR      r0,[r4,#0x28]         ;3436
0000b8  6301              STR      r1,[r0,#0x30]         ;3436
0000ba  6821              LDR      r1,[r4,#0]            ;3439
0000bc  460a              MOV      r2,r1                 ;3439
0000be  324c              ADDS     r2,r2,#0x4c           ;3439
0000c0  6aa0              LDR      r0,[r4,#0x28]         ;3439
0000c2  4631              MOV      r1,r6                 ;3439
0000c4  9b07              LDR      r3,[sp,#0x1c]         ;3439
0000c6  f7fffffe          BL       HAL_DMA_Start_IT
0000ca  e03d              B        |L16.328|
                  |L16.204|
0000cc  4928              LDR      r1,|L16.368|
0000ce  6ae0              LDR      r0,[r4,#0x2c]         ;3445
0000d0  6281              STR      r1,[r0,#0x28]         ;3445
0000d2  4926              LDR      r1,|L16.364|
0000d4  6ae0              LDR      r0,[r4,#0x2c]         ;3448
0000d6  6301              STR      r1,[r0,#0x30]         ;3448
0000d8  6821              LDR      r1,[r4,#0]            ;3451
0000da  460a              MOV      r2,r1                 ;3451
0000dc  324c              ADDS     r2,r2,#0x4c           ;3451
0000de  6ae0              LDR      r0,[r4,#0x2c]         ;3451
0000e0  4631              MOV      r1,r6                 ;3451
0000e2  9b07              LDR      r3,[sp,#0x1c]         ;3451
0000e4  f7fffffe          BL       HAL_DMA_Start_IT
0000e8  e02e              B        |L16.328|
                  |L16.234|
0000ea  4921              LDR      r1,|L16.368|
0000ec  6b20              LDR      r0,[r4,#0x30]         ;3457
0000ee  6281              STR      r1,[r0,#0x28]         ;3457
0000f0  491e              LDR      r1,|L16.364|
0000f2  6b20              LDR      r0,[r4,#0x30]         ;3460
0000f4  6301              STR      r1,[r0,#0x30]         ;3460
0000f6  6821              LDR      r1,[r4,#0]            ;3463
0000f8  460a              MOV      r2,r1                 ;3463
0000fa  324c              ADDS     r2,r2,#0x4c           ;3463
0000fc  6b20              LDR      r0,[r4,#0x30]         ;3463
0000fe  4631              MOV      r1,r6                 ;3463
000100  9b07              LDR      r3,[sp,#0x1c]         ;3463
000102  f7fffffe          BL       HAL_DMA_Start_IT
000106  e01f              B        |L16.328|
                  |L16.264|
000108  491a              LDR      r1,|L16.372|
00010a  6b60              LDR      r0,[r4,#0x34]         ;3469
00010c  6281              STR      r1,[r0,#0x28]         ;3469
00010e  4917              LDR      r1,|L16.364|
000110  6b60              LDR      r0,[r4,#0x34]         ;3472
000112  6301              STR      r1,[r0,#0x30]         ;3472
000114  6821              LDR      r1,[r4,#0]            ;3475
000116  460a              MOV      r2,r1                 ;3475
000118  324c              ADDS     r2,r2,#0x4c           ;3475
00011a  6b60              LDR      r0,[r4,#0x34]         ;3475
00011c  4631              MOV      r1,r6                 ;3475
00011e  9b07              LDR      r3,[sp,#0x1c]         ;3475
000120  f7fffffe          BL       HAL_DMA_Start_IT
000124  e010              B        |L16.328|
                  |L16.294|
000126  4914              LDR      r1,|L16.376|
000128  6ba0              LDR      r0,[r4,#0x38]         ;3481
00012a  6281              STR      r1,[r0,#0x28]         ;3481
00012c  490f              LDR      r1,|L16.364|
00012e  6ba0              LDR      r0,[r4,#0x38]         ;3484
000130  6301              STR      r1,[r0,#0x30]         ;3484
000132  6821              LDR      r1,[r4,#0]            ;3487
000134  460a              MOV      r2,r1                 ;3487
000136  324c              ADDS     r2,r2,#0x4c           ;3487
000138  6ba0              LDR      r0,[r4,#0x38]         ;3487
00013a  4631              MOV      r1,r6                 ;3487
00013c  9b07              LDR      r3,[sp,#0x1c]         ;3487
00013e  f7fffffe          BL       HAL_DMA_Start_IT
000142  e001              B        |L16.328|
000144  e7ff              B        |L16.326|
                  |L16.326|
000146  bf00              NOP                            ;3491
                  |L16.328|
000148  bf00              NOP                            ;3417
00014a  9806              LDR      r0,[sp,#0x18]         ;3494
00014c  4338              ORRS     r0,r0,r7              ;3494
00014e  6821              LDR      r1,[r4,#0]            ;3494
000150  6488              STR      r0,[r1,#0x48]         ;3494
000152  6820              LDR      r0,[r4,#0]            ;3497
000154  68c0              LDR      r0,[r0,#0xc]          ;3497
000156  4328              ORRS     r0,r0,r5              ;3497
000158  6821              LDR      r1,[r4,#0]            ;3497
00015a  60c8              STR      r0,[r1,#0xc]          ;3497
00015c  2101              MOVS     r1,#1                 ;3499
00015e  203d              MOVS     r0,#0x3d              ;3499
000160  5501              STRB     r1,[r0,r4]            ;3499
000162  2000              MOVS     r0,#0                 ;3502
000164  e755              B        |L16.18|
;;;3504   
                          ENDP

000166  0000              DCW      0x0000
                  |L16.360|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L16.364|
                          DCD      TIM_DMAError
                  |L16.368|
                          DCD      TIM_DMADelayPulseCplt
                  |L16.372|
                          DCD      TIMEx_DMACommutationCplt
                  |L16.376|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3602     */
;;;3603   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  b5ff              PUSH     {r0-r7,lr}
;;;3604                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3605   {
000002  b083              SUB      sp,sp,#0xc
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  9c0c              LDR      r4,[sp,#0x30]
;;;3606   return HAL_TIM_DMABurst_MultiReadStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength, ((BurstLength) >> 8U) + 1U);
00000c  0a20              LSRS     r0,r4,#8
00000e  1c40              ADDS     r0,r0,#1
000010  9400              STR      r4,[sp,#0]
000012  9001              STR      r0,[sp,#4]
000014  463a              MOV      r2,r7
000016  4631              MOV      r1,r6
000018  4628              MOV      r0,r5
00001a  9b06              LDR      r3,[sp,#0x18]
00001c  f7fffffe          BL       HAL_TIM_DMABurst_MultiReadStart
;;;3607   }
000020  b007              ADD      sp,sp,#0x1c
000022  bdf0              POP      {r4-r7,pc}
;;;3608   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;3781     */
;;;3782   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3783   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3784     /* Check the parameters */
;;;3785     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3786   
;;;3787     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3788     switch(BurstRequestSrc)
000006  4628              MOV      r0,r5
000008  2201              MOVS     r2,#1
00000a  02d2              LSLS     r2,r2,#11
00000c  1aa9              SUBS     r1,r5,r2
00000e  4295              CMP      r5,r2
000010  d026              BEQ      |L18.96|
000012  dc0d              BGT      |L18.48|
000014  38ff              SUBS     r0,r0,#0xff
000016  3801              SUBS     r0,#1
000018  2800              CMP      r0,#0
00001a  d015              BEQ      |L18.72|
00001c  38ff              SUBS     r0,r0,#0xff
00001e  3801              SUBS     r0,#1
000020  2800              CMP      r0,#0
000022  d015              BEQ      |L18.80|
000024  38ff              SUBS     r0,r0,#0xff
000026  38ff              SUBS     r0,r0,#0xff
000028  3802              SUBS     r0,#2
00002a  2800              CMP      r0,#0
00002c  d128              BNE      |L18.128|
00002e  e013              B        |L18.88|
                  |L18.48|
000030  2001              MOVS     r0,#1
000032  02c0              LSLS     r0,r0,#11
000034  1a08              SUBS     r0,r1,r0
000036  d017              BEQ      |L18.104|
000038  2101              MOVS     r1,#1
00003a  0309              LSLS     r1,r1,#12
00003c  1a40              SUBS     r0,r0,r1
00003e  d017              BEQ      |L18.112|
000040  0049              LSLS     r1,r1,#1
000042  1a40              SUBS     r0,r0,r1
000044  d11c              BNE      |L18.128|
000046  e017              B        |L18.120|
                  |L18.72|
;;;3789     {
;;;3790       case TIM_DMA_UPDATE:
;;;3791       {
;;;3792         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
000048  6a20              LDR      r0,[r4,#0x20]
00004a  f7fffffe          BL       HAL_DMA_Abort
;;;3793       }
;;;3794       break;
00004e  e018              B        |L18.130|
                  |L18.80|
;;;3795       case TIM_DMA_CC1:
;;;3796       {
;;;3797         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
000050  6a60              LDR      r0,[r4,#0x24]
000052  f7fffffe          BL       HAL_DMA_Abort
;;;3798       }
;;;3799       break;
000056  e014              B        |L18.130|
                  |L18.88|
;;;3800       case TIM_DMA_CC2:
;;;3801       {
;;;3802         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
000058  6aa0              LDR      r0,[r4,#0x28]
00005a  f7fffffe          BL       HAL_DMA_Abort
;;;3803       }
;;;3804       break;
00005e  e010              B        |L18.130|
                  |L18.96|
;;;3805       case TIM_DMA_CC3:
;;;3806       {
;;;3807         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
000060  6ae0              LDR      r0,[r4,#0x2c]
000062  f7fffffe          BL       HAL_DMA_Abort
;;;3808       }
;;;3809       break;
000066  e00c              B        |L18.130|
                  |L18.104|
;;;3810       case TIM_DMA_CC4:
;;;3811       {
;;;3812         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000068  6b20              LDR      r0,[r4,#0x30]
00006a  f7fffffe          BL       HAL_DMA_Abort
;;;3813       }
;;;3814       break;
00006e  e008              B        |L18.130|
                  |L18.112|
;;;3815       case TIM_DMA_COM:
;;;3816       {
;;;3817         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
000070  6b60              LDR      r0,[r4,#0x34]
000072  f7fffffe          BL       HAL_DMA_Abort
;;;3818       }
;;;3819       break;
000076  e004              B        |L18.130|
                  |L18.120|
;;;3820       case TIM_DMA_TRIGGER:
;;;3821       {
;;;3822         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
000078  6ba0              LDR      r0,[r4,#0x38]
00007a  f7fffffe          BL       HAL_DMA_Abort
;;;3823       }
;;;3824       break;
00007e  e000              B        |L18.130|
                  |L18.128|
;;;3825       default:
;;;3826       break;
000080  bf00              NOP      
                  |L18.130|
000082  bf00              NOP                            ;3794
;;;3827     }
;;;3828   
;;;3829     /* Disable the TIM Update DMA request */
;;;3830     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000084  6820              LDR      r0,[r4,#0]
000086  68c0              LDR      r0,[r0,#0xc]
000088  43a8              BICS     r0,r0,r5
00008a  6821              LDR      r1,[r4,#0]
00008c  60c8              STR      r0,[r1,#0xc]
;;;3831   
;;;3832     /* Return function status */
;;;3833     return HAL_OK;
00008e  2000              MOVS     r0,#0
;;;3834   }
000090  bd70              POP      {r4-r6,pc}
;;;3835   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3332     */
;;;3333   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  b5ff              PUSH     {r0-r7,lr}
;;;3334                                                 uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3335   {
000002  b083              SUB      sp,sp,#0xc
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  9c0c              LDR      r4,[sp,#0x30]
;;;3336   return HAL_TIM_DMABurst_MultiWriteStart(htim, BurstBaseAddress, BurstRequestSrc, BurstBuffer, BurstLength, ((BurstLength) >> 8U) + 1U);
00000c  0a20              LSRS     r0,r4,#8
00000e  1c40              ADDS     r0,r0,#1
000010  9400              STR      r4,[sp,#0]
000012  9001              STR      r0,[sp,#4]
000014  463a              MOV      r2,r7
000016  4631              MOV      r1,r6
000018  4628              MOV      r0,r5
00001a  9b06              LDR      r3,[sp,#0x18]
00001c  f7fffffe          BL       HAL_TIM_DMABurst_MultiWriteStart
;;;3337   }
000020  b007              ADD      sp,sp,#0x1c
000022  bdf0              POP      {r4-r7,pc}
;;;3338   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3510     */
;;;3511   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3512   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3513     /* Check the parameters */
;;;3514     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3515   
;;;3516     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3517     switch(BurstRequestSrc)
000006  4628              MOV      r0,r5
000008  2201              MOVS     r2,#1
00000a  02d2              LSLS     r2,r2,#11
00000c  1aa9              SUBS     r1,r5,r2
00000e  4295              CMP      r5,r2
000010  d026              BEQ      |L20.96|
000012  dc0d              BGT      |L20.48|
000014  38ff              SUBS     r0,r0,#0xff
000016  3801              SUBS     r0,#1
000018  2800              CMP      r0,#0
00001a  d015              BEQ      |L20.72|
00001c  38ff              SUBS     r0,r0,#0xff
00001e  3801              SUBS     r0,#1
000020  2800              CMP      r0,#0
000022  d015              BEQ      |L20.80|
000024  38ff              SUBS     r0,r0,#0xff
000026  38ff              SUBS     r0,r0,#0xff
000028  3802              SUBS     r0,#2
00002a  2800              CMP      r0,#0
00002c  d128              BNE      |L20.128|
00002e  e013              B        |L20.88|
                  |L20.48|
000030  2001              MOVS     r0,#1
000032  02c0              LSLS     r0,r0,#11
000034  1a08              SUBS     r0,r1,r0
000036  d017              BEQ      |L20.104|
000038  2101              MOVS     r1,#1
00003a  0309              LSLS     r1,r1,#12
00003c  1a40              SUBS     r0,r0,r1
00003e  d017              BEQ      |L20.112|
000040  0049              LSLS     r1,r1,#1
000042  1a40              SUBS     r0,r0,r1
000044  d11c              BNE      |L20.128|
000046  e017              B        |L20.120|
                  |L20.72|
;;;3518     {
;;;3519       case TIM_DMA_UPDATE:
;;;3520       {
;;;3521         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
000048  6a20              LDR      r0,[r4,#0x20]
00004a  f7fffffe          BL       HAL_DMA_Abort
;;;3522       }
;;;3523       break;
00004e  e018              B        |L20.130|
                  |L20.80|
;;;3524       case TIM_DMA_CC1:
;;;3525       {
;;;3526         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
000050  6a60              LDR      r0,[r4,#0x24]
000052  f7fffffe          BL       HAL_DMA_Abort
;;;3527       }
;;;3528       break;
000056  e014              B        |L20.130|
                  |L20.88|
;;;3529       case TIM_DMA_CC2:
;;;3530       {
;;;3531         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
000058  6aa0              LDR      r0,[r4,#0x28]
00005a  f7fffffe          BL       HAL_DMA_Abort
;;;3532       }
;;;3533       break;
00005e  e010              B        |L20.130|
                  |L20.96|
;;;3534       case TIM_DMA_CC3:
;;;3535       {
;;;3536         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
000060  6ae0              LDR      r0,[r4,#0x2c]
000062  f7fffffe          BL       HAL_DMA_Abort
;;;3537       }
;;;3538       break;
000066  e00c              B        |L20.130|
                  |L20.104|
;;;3539       case TIM_DMA_CC4:
;;;3540       {
;;;3541         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000068  6b20              LDR      r0,[r4,#0x30]
00006a  f7fffffe          BL       HAL_DMA_Abort
;;;3542       }
;;;3543       break;
00006e  e008              B        |L20.130|
                  |L20.112|
;;;3544       case TIM_DMA_COM:
;;;3545       {
;;;3546         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
000070  6b60              LDR      r0,[r4,#0x34]
000072  f7fffffe          BL       HAL_DMA_Abort
;;;3547       }
;;;3548       break;
000076  e004              B        |L20.130|
                  |L20.120|
;;;3549       case TIM_DMA_TRIGGER:
;;;3550       {
;;;3551         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
000078  6ba0              LDR      r0,[r4,#0x38]
00007a  f7fffffe          BL       HAL_DMA_Abort
;;;3552       }
;;;3553       break;
00007e  e000              B        |L20.130|
                  |L20.128|
;;;3554       default:
;;;3555       break;
000080  bf00              NOP      
                  |L20.130|
000082  bf00              NOP                            ;3523
;;;3556     }
;;;3557   
;;;3558     /* Disable the TIM Update DMA request */
;;;3559     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000084  6820              LDR      r0,[r4,#0]
000086  68c0              LDR      r0,[r0,#0xc]
000088  43a8              BICS     r0,r0,r5
00008a  6821              LDR      r1,[r4,#0]
00008c  60c8              STR      r0,[r1,#0xc]
;;;3560   
;;;3561     /* Return function status */
;;;3562     return HAL_OK;
00008e  2000              MOVS     r0,#0
;;;3563   }
000090  bd70              POP      {r4-r6,pc}
;;;3564   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_DeInit PROC
;;;2339     */
;;;2340   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2341   {
000002  4604              MOV      r4,r0
;;;2342     /* Check the parameters */
;;;2343     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2344   
;;;2345     htim->State = HAL_TIM_STATE_BUSY;
000004  2102              MOVS     r1,#2
000006  203d              MOVS     r0,#0x3d
000008  5501              STRB     r1,[r0,r4]
;;;2346   
;;;2347     /* Disable the TIM Peripheral Clock */
;;;2348     __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  490e              LDR      r1,|L21.76|
000012  4008              ANDS     r0,r0,r1
000014  2800              CMP      r0,#0
000016  d10b              BNE      |L21.48|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  2800              CMP      r0,#0
000022  d105              BNE      |L21.48|
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  0840              LSRS     r0,r0,#1
00002a  0040              LSLS     r0,r0,#1
00002c  6821              LDR      r1,[r4,#0]
00002e  6008              STR      r0,[r1,#0]
                  |L21.48|
000030  bf00              NOP      
;;;2349   
;;;2350     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2351     HAL_TIM_Encoder_MspDeInit(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2352   
;;;2353     /* Change TIM state */
;;;2354     htim->State = HAL_TIM_STATE_RESET;
000038  2100              MOVS     r1,#0
00003a  203d              MOVS     r0,#0x3d
00003c  5501              STRB     r1,[r0,r4]
;;;2355   
;;;2356     /* Release Lock */
;;;2357     __HAL_UNLOCK(htim);
00003e  bf00              NOP      
000040  203c              MOVS     r0,#0x3c
000042  5501              STRB     r1,[r0,r4]
000044  bf00              NOP      
;;;2358   
;;;2359     return HAL_OK;
000046  2000              MOVS     r0,#0
;;;2360   }
000048  bd10              POP      {r4,pc}
;;;2361   
                          ENDP

00004a  0000              DCW      0x0000
                  |L21.76|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;4542     */
;;;4543   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4544   {
;;;4545     return htim->State;
000002  203d              MOVS     r0,#0x3d
000004  5c40              LDRB     r0,[r0,r1]
;;;4546   }
000006  4770              BX       lr
;;;4547   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Init PROC
;;;2246     */
;;;2247   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2248   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2249     uint32_t tmpsmcr = 0U;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;2250     uint32_t tmpccmr1 = 0U;
00000a  2600              MOVS     r6,#0
;;;2251     uint32_t tmpccer = 0U;
00000c  2700              MOVS     r7,#0
;;;2252   
;;;2253     /* Check the TIM handle allocation */
;;;2254     if(htim == NULL)
00000e  2c00              CMP      r4,#0
000010  d101              BNE      |L23.22|
;;;2255     {
;;;2256       return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L23.20|
;;;2257     }
;;;2258   
;;;2259     /* Check the parameters */
;;;2260     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2261     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2262     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2263     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2264     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2265     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2266     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2267     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2268     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2269     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2270     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2271     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2272     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2273   
;;;2274     if(htim->State == HAL_TIM_STATE_RESET)
;;;2275     {
;;;2276       /* Allocate lock resource and initialize it */
;;;2277       htim->Lock = HAL_UNLOCKED;
;;;2278   
;;;2279       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2280       HAL_TIM_Encoder_MspInit(htim);
;;;2281     }
;;;2282   
;;;2283     /* Set the TIM state */
;;;2284     htim->State= HAL_TIM_STATE_BUSY;
;;;2285   
;;;2286     /* Reset the SMS bits */
;;;2287     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2288   
;;;2289     /* Configure the Time base in the Encoder Mode */
;;;2290     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2291   
;;;2292     /* Get the TIMx SMCR register value */
;;;2293     tmpsmcr = htim->Instance->SMCR;
;;;2294   
;;;2295     /* Get the TIMx CCMR1 register value */
;;;2296     tmpccmr1 = htim->Instance->CCMR1;
;;;2297   
;;;2298     /* Get the TIMx CCER register value */
;;;2299     tmpccer = htim->Instance->CCER;
;;;2300   
;;;2301     /* Set the encoder Mode */
;;;2302     tmpsmcr |= sConfig->EncoderMode;
;;;2303   
;;;2304     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2305     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2306     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
;;;2307   
;;;2308     /* Set the the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2309     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2310     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2311     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
;;;2312     tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
;;;2313   
;;;2314     /* Set the TI1 and the TI2 Polarities */
;;;2315     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2316     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2317     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
;;;2318   
;;;2319     /* Write to TIMx SMCR */
;;;2320     htim->Instance->SMCR = tmpsmcr;
;;;2321   
;;;2322     /* Write to TIMx CCMR1 */
;;;2323     htim->Instance->CCMR1 = tmpccmr1;
;;;2324   
;;;2325     /* Write to TIMx CCER */
;;;2326     htim->Instance->CCER = tmpccer;
;;;2327   
;;;2328     /* Initialize the TIM state*/
;;;2329     htim->State= HAL_TIM_STATE_READY;
;;;2330   
;;;2331     return HAL_OK;
;;;2332   }
000014  bdf8              POP      {r3-r7,pc}
                  |L23.22|
000016  203d              MOVS     r0,#0x3d              ;2274
000018  5d00              LDRB     r0,[r0,r4]            ;2274
00001a  2800              CMP      r0,#0                 ;2274
00001c  d105              BNE      |L23.42|
00001e  2100              MOVS     r1,#0                 ;2277
000020  203c              MOVS     r0,#0x3c              ;2277
000022  5501              STRB     r1,[r0,r4]            ;2277
000024  4620              MOV      r0,r4                 ;2280
000026  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L23.42|
00002a  2102              MOVS     r1,#2                 ;2284
00002c  203d              MOVS     r0,#0x3d              ;2284
00002e  5501              STRB     r1,[r0,r4]            ;2284
000030  6820              LDR      r0,[r4,#0]            ;2287
000032  6880              LDR      r0,[r0,#8]            ;2287
000034  08c0              LSRS     r0,r0,#3              ;2287
000036  00c0              LSLS     r0,r0,#3              ;2287
000038  6821              LDR      r1,[r4,#0]            ;2287
00003a  6088              STR      r0,[r1,#8]            ;2287
00003c  1d21              ADDS     r1,r4,#4              ;2290
00003e  6820              LDR      r0,[r4,#0]            ;2290
000040  f7fffffe          BL       TIM_Base_SetConfig
000044  6820              LDR      r0,[r4,#0]            ;2293
000046  6880              LDR      r0,[r0,#8]            ;2293
000048  9000              STR      r0,[sp,#0]            ;2293
00004a  6820              LDR      r0,[r4,#0]            ;2296
00004c  6986              LDR      r6,[r0,#0x18]         ;2296
00004e  6820              LDR      r0,[r4,#0]            ;2299
000050  6a07              LDR      r7,[r0,#0x20]         ;2299
000052  6828              LDR      r0,[r5,#0]            ;2302
000054  9900              LDR      r1,[sp,#0]            ;2302
000056  4308              ORRS     r0,r0,r1              ;2302
000058  9000              STR      r0,[sp,#0]            ;2302
00005a  4817              LDR      r0,|L23.184|
00005c  4006              ANDS     r6,r6,r0              ;2305
00005e  69a9              LDR      r1,[r5,#0x18]         ;2306
000060  0209              LSLS     r1,r1,#8              ;2306
000062  68a8              LDR      r0,[r5,#8]            ;2306
000064  4308              ORRS     r0,r0,r1              ;2306
000066  4306              ORRS     r6,r6,r0              ;2306
000068  4814              LDR      r0,|L23.188|
00006a  4006              ANDS     r6,r6,r0              ;2309
00006c  4814              LDR      r0,|L23.192|
00006e  4006              ANDS     r6,r6,r0              ;2310
000070  69e9              LDR      r1,[r5,#0x1c]         ;2311
000072  0209              LSLS     r1,r1,#8              ;2311
000074  68e8              LDR      r0,[r5,#0xc]          ;2311
000076  4308              ORRS     r0,r0,r1              ;2311
000078  4306              ORRS     r6,r6,r0              ;2311
00007a  6928              LDR      r0,[r5,#0x10]         ;2312
00007c  0100              LSLS     r0,r0,#4              ;2312
00007e  6a29              LDR      r1,[r5,#0x20]         ;2312
000080  0309              LSLS     r1,r1,#12             ;2312
000082  4308              ORRS     r0,r0,r1              ;2312
000084  4306              ORRS     r6,r6,r0              ;2312
000086  2122              MOVS     r1,#0x22              ;2315
000088  4638              MOV      r0,r7                 ;2315
00008a  4388              BICS     r0,r0,r1              ;2315
00008c  4607              MOV      r7,r0                 ;2315
00008e  2188              MOVS     r1,#0x88              ;2316
000090  4638              MOV      r0,r7                 ;2316
000092  4388              BICS     r0,r0,r1              ;2316
000094  4607              MOV      r7,r0                 ;2316
000096  6969              LDR      r1,[r5,#0x14]         ;2317
000098  0109              LSLS     r1,r1,#4              ;2317
00009a  6868              LDR      r0,[r5,#4]            ;2317
00009c  4308              ORRS     r0,r0,r1              ;2317
00009e  4307              ORRS     r7,r7,r0              ;2317
0000a0  9800              LDR      r0,[sp,#0]            ;2320
0000a2  6821              LDR      r1,[r4,#0]            ;2320
0000a4  6088              STR      r0,[r1,#8]            ;2320
0000a6  6820              LDR      r0,[r4,#0]            ;2323
0000a8  6186              STR      r6,[r0,#0x18]         ;2323
0000aa  6820              LDR      r0,[r4,#0]            ;2326
0000ac  6207              STR      r7,[r0,#0x20]         ;2326
0000ae  2101              MOVS     r1,#1                 ;2329
0000b0  203d              MOVS     r0,#0x3d              ;2329
0000b2  5501              STRB     r1,[r0,r4]            ;2329
0000b4  2000              MOVS     r0,#0                 ;2331
0000b6  e7ad              B        |L23.20|
;;;2333   
                          ENDP

                  |L23.184|
                          DCD      0xfffffcfc
                  |L23.188|
                          DCD      0xfffff3f3
                  |L23.192|
                          DCD      0xffff0f0f

                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2381     */
;;;2382   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2383   {
;;;2384     /* Prevent unused argument(s) compilation warning */
;;;2385     UNUSED(htim);
;;;2386   
;;;2387     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2388               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2389      */
;;;2390   }
;;;2391   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2366     */
;;;2367   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2368   {
;;;2369     /* Prevent unused argument(s) compilation warning */
;;;2370     UNUSED(htim);
;;;2371   
;;;2372     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2373               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2374      */
;;;2375   }
;;;2376   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start PROC
;;;2401   */
;;;2402   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2403   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2404     /* Check the parameters */
;;;2405     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2406   
;;;2407     /* Enable the encoder interface channels */
;;;2408     switch (Channel)
000006  2d00              CMP      r5,#0
000008  d002              BEQ      |L26.16|
00000a  2d04              CMP      r5,#4
00000c  d10c              BNE      |L26.40|
00000e  e005              B        |L26.28|
                  |L26.16|
;;;2409     {
;;;2410       case TIM_CHANNEL_1:
;;;2411     {
;;;2412       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000010  2201              MOVS     r2,#1
000012  2100              MOVS     r1,#0
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;2413         break;
00001a  e010              B        |L26.62|
                  |L26.28|
;;;2414     }
;;;2415       case TIM_CHANNEL_2:
;;;2416     {
;;;2417       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
00001c  2201              MOVS     r2,#1
00001e  2104              MOVS     r1,#4
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       TIM_CCxChannelCmd
;;;2418         break;
000026  e00a              B        |L26.62|
                  |L26.40|
;;;2419     }
;;;2420       default :
;;;2421     {
;;;2422        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000028  2201              MOVS     r2,#1
00002a  2100              MOVS     r1,#0
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2423        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000032  2201              MOVS     r2,#1
000034  2104              MOVS     r1,#4
000036  6820              LDR      r0,[r4,#0]
000038  f7fffffe          BL       TIM_CCxChannelCmd
;;;2424        break;
00003c  bf00              NOP      
                  |L26.62|
00003e  bf00              NOP                            ;2413
;;;2425       }
;;;2426     }
;;;2427     /* Enable the Peripheral */
;;;2428     __HAL_TIM_ENABLE(htim);
000040  6820              LDR      r0,[r4,#0]
000042  6800              LDR      r0,[r0,#0]
000044  2101              MOVS     r1,#1
000046  4308              ORRS     r0,r0,r1
000048  6821              LDR      r1,[r4,#0]
00004a  6008              STR      r0,[r1,#0]
;;;2429   
;;;2430     /* Return function status */
;;;2431     return HAL_OK;
00004c  2000              MOVS     r0,#0
;;;2432   }
00004e  bd30              POP      {r4,r5,pc}
;;;2433   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2589   */
;;;2590   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2591   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
000008  461d              MOV      r5,r3
;;;2592     /* Check the parameters */
;;;2593     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2594   
;;;2595     if((htim->State == HAL_TIM_STATE_BUSY))
00000a  203d              MOVS     r0,#0x3d
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2802              CMP      r0,#2
000010  d100              BNE      |L27.20|
                  |L27.18|
;;;2596     {
;;;2597        return HAL_BUSY;
;;;2598     }
;;;2599     else if((htim->State == HAL_TIM_STATE_READY))
;;;2600     {
;;;2601       if((((pData1 == 0U) || (pData2 == 0U) )) && (Length > 0U))
;;;2602       {
;;;2603         return HAL_ERROR;
;;;2604       }
;;;2605       else
;;;2606       {
;;;2607         htim->State = HAL_TIM_STATE_BUSY;
;;;2608       }
;;;2609     }
;;;2610   
;;;2611     switch (Channel)
;;;2612     {
;;;2613       case TIM_CHANNEL_1:
;;;2614       {
;;;2615         /* Set the DMA Period elapsed callback */
;;;2616         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2617   
;;;2618         /* Set the DMA error callback */
;;;2619         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2620   
;;;2621         /* Enable the DMA channel */
;;;2622         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length);
;;;2623   
;;;2624         /* Enable the TIM Input Capture DMA request */
;;;2625         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2626   
;;;2627         /* Enable the Peripheral */
;;;2628         __HAL_TIM_ENABLE(htim);
;;;2629   
;;;2630         /* Enable the Capture compare channel */
;;;2631         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2632       }
;;;2633       break;
;;;2634   
;;;2635       case TIM_CHANNEL_2:
;;;2636       {
;;;2637         /* Set the DMA Period elapsed callback */
;;;2638         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2639   
;;;2640         /* Set the DMA error callback */
;;;2641         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
;;;2642         /* Enable the DMA channel */
;;;2643         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2644   
;;;2645         /* Enable the TIM Input Capture  DMA request */
;;;2646         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2647   
;;;2648         /* Enable the Peripheral */
;;;2649         __HAL_TIM_ENABLE(htim);
;;;2650   
;;;2651         /* Enable the Capture compare channel */
;;;2652         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2653       }
;;;2654       break;
;;;2655   
;;;2656       case TIM_CHANNEL_ALL:
;;;2657       {
;;;2658         /* Set the DMA Period elapsed callback */
;;;2659         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2660   
;;;2661         /* Set the DMA error callback */
;;;2662         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2663   
;;;2664         /* Enable the DMA channel */
;;;2665         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2666   
;;;2667         /* Set the DMA Period elapsed callback */
;;;2668         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2669   
;;;2670         /* Set the DMA error callback */
;;;2671         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;2672   
;;;2673         /* Enable the DMA channel */
;;;2674         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2675   
;;;2676        /* Enable the Peripheral */
;;;2677         __HAL_TIM_ENABLE(htim);
;;;2678   
;;;2679         /* Enable the Capture compare channel */
;;;2680         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2681         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2682   
;;;2683         /* Enable the TIM Input Capture  DMA request */
;;;2684         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2685         /* Enable the TIM Input Capture  DMA request */
;;;2686         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2687       }
;;;2688       break;
;;;2689   
;;;2690       default:
;;;2691       break;
;;;2692     }
;;;2693     /* Return function status */
;;;2694     return HAL_OK;
;;;2695   }
000012  bdf8              POP      {r3-r7,pc}
                  |L27.20|
000014  203d              MOVS     r0,#0x3d              ;2599
000016  5d00              LDRB     r0,[r0,r4]            ;2599
000018  2801              CMP      r0,#1                 ;2599
00001a  d10b              BNE      |L27.52|
00001c  2f00              CMP      r7,#0                 ;2601
00001e  d001              BEQ      |L27.36|
000020  2d00              CMP      r5,#0                 ;2601
000022  d104              BNE      |L27.46|
                  |L27.36|
000024  9806              LDR      r0,[sp,#0x18]         ;2601
000026  2800              CMP      r0,#0                 ;2601
000028  d001              BEQ      |L27.46|
00002a  2001              MOVS     r0,#1                 ;2603
00002c  e7f1              B        |L27.18|
                  |L27.46|
00002e  2102              MOVS     r1,#2                 ;2607
000030  203d              MOVS     r0,#0x3d              ;2607
000032  5501              STRB     r1,[r0,r4]            ;2607
                  |L27.52|
000034  2e00              CMP      r6,#0                 ;2611
000036  d004              BEQ      |L27.66|
000038  2e04              CMP      r6,#4                 ;2611
00003a  d023              BEQ      |L27.132|
00003c  2e18              CMP      r6,#0x18              ;2611
00003e  d17e              BNE      |L27.318|
000040  e041              B        |L27.198|
                  |L27.66|
000042  4941              LDR      r1,|L27.328|
000044  6a60              LDR      r0,[r4,#0x24]         ;2616
000046  6281              STR      r1,[r0,#0x28]         ;2616
000048  4940              LDR      r1,|L27.332|
00004a  6a60              LDR      r0,[r4,#0x24]         ;2619
00004c  6301              STR      r1,[r0,#0x30]         ;2619
00004e  6822              LDR      r2,[r4,#0]            ;2622
000050  4611              MOV      r1,r2                 ;2622
000052  3134              ADDS     r1,r1,#0x34           ;2622
000054  6a60              LDR      r0,[r4,#0x24]         ;2622
000056  463a              MOV      r2,r7                 ;2622
000058  9b06              LDR      r3,[sp,#0x18]         ;2622
00005a  f7fffffe          BL       HAL_DMA_Start_IT
00005e  6820              LDR      r0,[r4,#0]            ;2625
000060  68c0              LDR      r0,[r0,#0xc]          ;2625
000062  2101              MOVS     r1,#1                 ;2625
000064  0249              LSLS     r1,r1,#9              ;2625
000066  4308              ORRS     r0,r0,r1              ;2625
000068  6821              LDR      r1,[r4,#0]            ;2625
00006a  60c8              STR      r0,[r1,#0xc]          ;2625
00006c  6820              LDR      r0,[r4,#0]            ;2628
00006e  6800              LDR      r0,[r0,#0]            ;2628
000070  2101              MOVS     r1,#1                 ;2628
000072  4308              ORRS     r0,r0,r1              ;2628
000074  6821              LDR      r1,[r4,#0]            ;2628
000076  6008              STR      r0,[r1,#0]            ;2628
000078  2201              MOVS     r2,#1                 ;2631
00007a  2100              MOVS     r1,#0                 ;2631
00007c  6820              LDR      r0,[r4,#0]            ;2631
00007e  f7fffffe          BL       TIM_CCxChannelCmd
000082  e05d              B        |L27.320|
                  |L27.132|
000084  4930              LDR      r1,|L27.328|
000086  6aa0              LDR      r0,[r4,#0x28]         ;2638
000088  6281              STR      r1,[r0,#0x28]         ;2638
00008a  4930              LDR      r1,|L27.332|
00008c  6aa0              LDR      r0,[r4,#0x28]         ;2641
00008e  6301              STR      r1,[r0,#0x30]         ;2641
000090  6822              LDR      r2,[r4,#0]            ;2643
000092  4611              MOV      r1,r2                 ;2643
000094  3138              ADDS     r1,r1,#0x38           ;2643
000096  6aa0              LDR      r0,[r4,#0x28]         ;2643
000098  462a              MOV      r2,r5                 ;2643
00009a  9b06              LDR      r3,[sp,#0x18]         ;2643
00009c  f7fffffe          BL       HAL_DMA_Start_IT
0000a0  6820              LDR      r0,[r4,#0]            ;2646
0000a2  68c0              LDR      r0,[r0,#0xc]          ;2646
0000a4  2101              MOVS     r1,#1                 ;2646
0000a6  0289              LSLS     r1,r1,#10             ;2646
0000a8  4308              ORRS     r0,r0,r1              ;2646
0000aa  6821              LDR      r1,[r4,#0]            ;2646
0000ac  60c8              STR      r0,[r1,#0xc]          ;2646
0000ae  6820              LDR      r0,[r4,#0]            ;2649
0000b0  6800              LDR      r0,[r0,#0]            ;2649
0000b2  2101              MOVS     r1,#1                 ;2649
0000b4  4308              ORRS     r0,r0,r1              ;2649
0000b6  6821              LDR      r1,[r4,#0]            ;2649
0000b8  6008              STR      r0,[r1,#0]            ;2649
0000ba  2201              MOVS     r2,#1                 ;2652
0000bc  2104              MOVS     r1,#4                 ;2652
0000be  6820              LDR      r0,[r4,#0]            ;2652
0000c0  f7fffffe          BL       TIM_CCxChannelCmd
0000c4  e03c              B        |L27.320|
                  |L27.198|
0000c6  4920              LDR      r1,|L27.328|
0000c8  6a60              LDR      r0,[r4,#0x24]         ;2659
0000ca  6281              STR      r1,[r0,#0x28]         ;2659
0000cc  491f              LDR      r1,|L27.332|
0000ce  6a60              LDR      r0,[r4,#0x24]         ;2662
0000d0  6301              STR      r1,[r0,#0x30]         ;2662
0000d2  6822              LDR      r2,[r4,#0]            ;2665
0000d4  4611              MOV      r1,r2                 ;2665
0000d6  3134              ADDS     r1,r1,#0x34           ;2665
0000d8  6a60              LDR      r0,[r4,#0x24]         ;2665
0000da  463a              MOV      r2,r7                 ;2665
0000dc  9b06              LDR      r3,[sp,#0x18]         ;2665
0000de  f7fffffe          BL       HAL_DMA_Start_IT
0000e2  4919              LDR      r1,|L27.328|
0000e4  6aa0              LDR      r0,[r4,#0x28]         ;2668
0000e6  6281              STR      r1,[r0,#0x28]         ;2668
0000e8  4918              LDR      r1,|L27.332|
0000ea  6aa0              LDR      r0,[r4,#0x28]         ;2671
0000ec  6301              STR      r1,[r0,#0x30]         ;2671
0000ee  6822              LDR      r2,[r4,#0]            ;2674
0000f0  4611              MOV      r1,r2                 ;2674
0000f2  3138              ADDS     r1,r1,#0x38           ;2674
0000f4  6aa0              LDR      r0,[r4,#0x28]         ;2674
0000f6  462a              MOV      r2,r5                 ;2674
0000f8  9b06              LDR      r3,[sp,#0x18]         ;2674
0000fa  f7fffffe          BL       HAL_DMA_Start_IT
0000fe  6820              LDR      r0,[r4,#0]            ;2677
000100  6800              LDR      r0,[r0,#0]            ;2677
000102  2101              MOVS     r1,#1                 ;2677
000104  4308              ORRS     r0,r0,r1              ;2677
000106  6821              LDR      r1,[r4,#0]            ;2677
000108  6008              STR      r0,[r1,#0]            ;2677
00010a  2201              MOVS     r2,#1                 ;2680
00010c  2100              MOVS     r1,#0                 ;2680
00010e  6820              LDR      r0,[r4,#0]            ;2680
000110  f7fffffe          BL       TIM_CCxChannelCmd
000114  2201              MOVS     r2,#1                 ;2681
000116  2104              MOVS     r1,#4                 ;2681
000118  6820              LDR      r0,[r4,#0]            ;2681
00011a  f7fffffe          BL       TIM_CCxChannelCmd
00011e  6820              LDR      r0,[r4,#0]            ;2684
000120  68c0              LDR      r0,[r0,#0xc]          ;2684
000122  2101              MOVS     r1,#1                 ;2684
000124  0249              LSLS     r1,r1,#9              ;2684
000126  4308              ORRS     r0,r0,r1              ;2684
000128  6821              LDR      r1,[r4,#0]            ;2684
00012a  60c8              STR      r0,[r1,#0xc]          ;2684
00012c  6820              LDR      r0,[r4,#0]            ;2686
00012e  68c0              LDR      r0,[r0,#0xc]          ;2686
000130  2101              MOVS     r1,#1                 ;2686
000132  0289              LSLS     r1,r1,#10             ;2686
000134  4308              ORRS     r0,r0,r1              ;2686
000136  6821              LDR      r1,[r4,#0]            ;2686
000138  60c8              STR      r0,[r1,#0xc]          ;2686
00013a  e001              B        |L27.320|
00013c  e7ff              B        |L27.318|
                  |L27.318|
00013e  bf00              NOP                            ;2691
                  |L27.320|
000140  bf00              NOP                            ;2633
000142  2000              MOVS     r0,#0                 ;2694
000144  e765              B        |L27.18|
;;;2696   
                          ENDP

000146  0000              DCW      0x0000
                  |L27.328|
                          DCD      TIM_DMACaptureCplt
                  |L27.332|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2487   */
;;;2488   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2489   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2490     /* Check the parameters */
;;;2491     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2492   
;;;2493     /* Enable the encoder interface channels */
;;;2494     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2495     switch (Channel)
000006  2d00              CMP      r5,#0
000008  d002              BEQ      |L28.16|
00000a  2d04              CMP      r5,#4
00000c  d118              BNE      |L28.64|
00000e  e00b              B        |L28.40|
                  |L28.16|
;;;2496     {
;;;2497       case TIM_CHANNEL_1:
;;;2498     {
;;;2499       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000010  2201              MOVS     r2,#1
000012  2100              MOVS     r1,#0
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;2500       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
00001a  6820              LDR      r0,[r4,#0]
00001c  68c0              LDR      r0,[r0,#0xc]
00001e  2102              MOVS     r1,#2
000020  4308              ORRS     r0,r0,r1
000022  6821              LDR      r1,[r4,#0]
000024  60c8              STR      r0,[r1,#0xc]
;;;2501         break;
000026  e022              B        |L28.110|
                  |L28.40|
;;;2502     }
;;;2503       case TIM_CHANNEL_2:
;;;2504     {
;;;2505       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000028  2201              MOVS     r2,#1
00002a  2104              MOVS     r1,#4
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2506       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  2104              MOVS     r1,#4
000038  4308              ORRS     r0,r0,r1
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;2507         break;
00003e  e016              B        |L28.110|
                  |L28.64|
;;;2508     }
;;;2509       default :
;;;2510     {
;;;2511        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000040  2201              MOVS     r2,#1
000042  2100              MOVS     r1,#0
000044  6820              LDR      r0,[r4,#0]
000046  f7fffffe          BL       TIM_CCxChannelCmd
;;;2512        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
00004a  2201              MOVS     r2,#1
00004c  2104              MOVS     r1,#4
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       TIM_CCxChannelCmd
;;;2513        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000054  6820              LDR      r0,[r4,#0]
000056  68c0              LDR      r0,[r0,#0xc]
000058  2102              MOVS     r1,#2
00005a  4308              ORRS     r0,r0,r1
00005c  6821              LDR      r1,[r4,#0]
00005e  60c8              STR      r0,[r1,#0xc]
;;;2514        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000060  6820              LDR      r0,[r4,#0]
000062  68c0              LDR      r0,[r0,#0xc]
000064  2104              MOVS     r1,#4
000066  4308              ORRS     r0,r0,r1
000068  6821              LDR      r1,[r4,#0]
00006a  60c8              STR      r0,[r1,#0xc]
;;;2515        break;
00006c  bf00              NOP      
                  |L28.110|
00006e  bf00              NOP                            ;2501
;;;2516       }
;;;2517     }
;;;2518   
;;;2519     /* Enable the Peripheral */
;;;2520     __HAL_TIM_ENABLE(htim);
000070  6820              LDR      r0,[r4,#0]
000072  6800              LDR      r0,[r0,#0]
000074  2101              MOVS     r1,#1
000076  4308              ORRS     r0,r0,r1
000078  6821              LDR      r1,[r4,#0]
00007a  6008              STR      r0,[r1,#0]
;;;2521   
;;;2522     /* Return function status */
;;;2523     return HAL_OK;
00007c  2000              MOVS     r0,#0
;;;2524   }
00007e  bd30              POP      {r4,r5,pc}
;;;2525   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Stop PROC
;;;2443   */
;;;2444   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2445   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2446     /* Check the parameters */
;;;2447       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2448   
;;;2449      /* Disable the Input Capture channels 1 and 2
;;;2450       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2451     switch (Channel)
000006  2d00              CMP      r5,#0
000008  d002              BEQ      |L29.16|
00000a  2d04              CMP      r5,#4
00000c  d10c              BNE      |L29.40|
00000e  e005              B        |L29.28|
                  |L29.16|
;;;2452     {
;;;2453       case TIM_CHANNEL_1:
;;;2454     {
;;;2455        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000010  2200              MOVS     r2,#0
000012  4611              MOV      r1,r2
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;2456         break;
00001a  e010              B        |L29.62|
                  |L29.28|
;;;2457     }
;;;2458       case TIM_CHANNEL_2:
;;;2459     {
;;;2460       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
00001c  2200              MOVS     r2,#0
00001e  2104              MOVS     r1,#4
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       TIM_CCxChannelCmd
;;;2461         break;
000026  e00a              B        |L29.62|
                  |L29.40|
;;;2462     }
;;;2463       default :
;;;2464     {
;;;2465       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000028  2200              MOVS     r2,#0
00002a  4611              MOV      r1,r2
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2466       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000032  2200              MOVS     r2,#0
000034  2104              MOVS     r1,#4
000036  6820              LDR      r0,[r4,#0]
000038  f7fffffe          BL       TIM_CCxChannelCmd
;;;2467        break;
00003c  bf00              NOP      
                  |L29.62|
00003e  bf00              NOP                            ;2456
;;;2468       }
;;;2469     }
;;;2470   
;;;2471     /* Disable the Peripheral */
;;;2472     __HAL_TIM_DISABLE(htim);
000040  bf00              NOP      
000042  6820              LDR      r0,[r4,#0]
000044  6a00              LDR      r0,[r0,#0x20]
000046  4909              LDR      r1,|L29.108|
000048  4008              ANDS     r0,r0,r1
00004a  2800              CMP      r0,#0
00004c  d10b              BNE      |L29.102|
00004e  6820              LDR      r0,[r4,#0]
000050  6a00              LDR      r0,[r0,#0x20]
000052  1089              ASRS     r1,r1,#2
000054  4008              ANDS     r0,r0,r1
000056  2800              CMP      r0,#0
000058  d105              BNE      |L29.102|
00005a  6820              LDR      r0,[r4,#0]
00005c  6800              LDR      r0,[r0,#0]
00005e  0840              LSRS     r0,r0,#1
000060  0040              LSLS     r0,r0,#1
000062  6821              LDR      r1,[r4,#0]
000064  6008              STR      r0,[r1,#0]
                  |L29.102|
000066  bf00              NOP      
;;;2473   
;;;2474     /* Return function status */
;;;2475     return HAL_OK;
000068  2000              MOVS     r0,#0
;;;2476   }
00006a  bd30              POP      {r4,r5,pc}
;;;2477   
                          ENDP

                  |L29.108|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2706   */
;;;2707   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2708   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2709     /* Check the parameters */
;;;2710     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2711   
;;;2712     /* Disable the Input Capture channels 1 and 2
;;;2713       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2714     if(Channel == TIM_CHANNEL_1)
000006  2d00              CMP      r5,#0
000008  d10c              BNE      |L30.36|
;;;2715     {
;;;2716       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000a  2200              MOVS     r2,#0
00000c  4611              MOV      r1,r2
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       TIM_CCxChannelCmd
;;;2717   
;;;2718       /* Disable the capture compare DMA Request 1 */
;;;2719       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000014  6820              LDR      r0,[r4,#0]
000016  68c0              LDR      r0,[r0,#0xc]
000018  2101              MOVS     r1,#1
00001a  0249              LSLS     r1,r1,#9
00001c  4388              BICS     r0,r0,r1
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
000022  e025              B        |L30.112|
                  |L30.36|
;;;2720     }
;;;2721     else if(Channel == TIM_CHANNEL_2)
000024  2d04              CMP      r5,#4
000026  d10b              BNE      |L30.64|
;;;2722     {
;;;2723       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000028  2200              MOVS     r2,#0
00002a  2104              MOVS     r1,#4
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2724   
;;;2725       /* Disable the capture compare DMA Request 2 */
;;;2726       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  0229              LSLS     r1,r5,#8
000038  4388              BICS     r0,r0,r1
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
00003e  e017              B        |L30.112|
                  |L30.64|
;;;2727     }
;;;2728     else
;;;2729     {
;;;2730       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000040  2200              MOVS     r2,#0
000042  4611              MOV      r1,r2
000044  6820              LDR      r0,[r4,#0]
000046  f7fffffe          BL       TIM_CCxChannelCmd
;;;2731       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
00004a  2200              MOVS     r2,#0
00004c  2104              MOVS     r1,#4
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       TIM_CCxChannelCmd
;;;2732   
;;;2733       /* Disable the capture compare DMA Request 1 and 2 */
;;;2734       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000054  6820              LDR      r0,[r4,#0]
000056  68c0              LDR      r0,[r0,#0xc]
000058  2101              MOVS     r1,#1
00005a  0249              LSLS     r1,r1,#9
00005c  4388              BICS     r0,r0,r1
00005e  6821              LDR      r1,[r4,#0]
000060  60c8              STR      r0,[r1,#0xc]
;;;2735       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000062  6820              LDR      r0,[r4,#0]
000064  68c0              LDR      r0,[r0,#0xc]
000066  2101              MOVS     r1,#1
000068  0289              LSLS     r1,r1,#10
00006a  4388              BICS     r0,r0,r1
00006c  6821              LDR      r1,[r4,#0]
00006e  60c8              STR      r0,[r1,#0xc]
                  |L30.112|
;;;2736     }
;;;2737   
;;;2738     /* Disable the Peripheral */
;;;2739     __HAL_TIM_DISABLE(htim);
000070  bf00              NOP      
000072  6820              LDR      r0,[r4,#0]
000074  6a00              LDR      r0,[r0,#0x20]
000076  490b              LDR      r1,|L30.164|
000078  4008              ANDS     r0,r0,r1
00007a  2800              CMP      r0,#0
00007c  d10b              BNE      |L30.150|
00007e  6820              LDR      r0,[r4,#0]
000080  6a00              LDR      r0,[r0,#0x20]
000082  1089              ASRS     r1,r1,#2
000084  4008              ANDS     r0,r0,r1
000086  2800              CMP      r0,#0
000088  d105              BNE      |L30.150|
00008a  6820              LDR      r0,[r4,#0]
00008c  6800              LDR      r0,[r0,#0]
00008e  0840              LSRS     r0,r0,#1
000090  0040              LSLS     r0,r0,#1
000092  6821              LDR      r1,[r4,#0]
000094  6008              STR      r0,[r1,#0]
                  |L30.150|
000096  bf00              NOP      
;;;2740   
;;;2741     /* Change the htim state */
;;;2742     htim->State = HAL_TIM_STATE_READY;
000098  2101              MOVS     r1,#1
00009a  203d              MOVS     r0,#0x3d
00009c  5501              STRB     r1,[r0,r4]
;;;2743   
;;;2744     /* Return function status */
;;;2745     return HAL_OK;
00009e  2000              MOVS     r0,#0
;;;2746   }
0000a0  bd30              POP      {r4,r5,pc}
;;;2747   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L30.164|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2535   */
;;;2536   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2537   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2538     /* Check the parameters */
;;;2539     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2540   
;;;2541     /* Disable the Input Capture channels 1 and 2
;;;2542       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2543     if(Channel == TIM_CHANNEL_1)
000006  2d00              CMP      r5,#0
000008  d10b              BNE      |L31.34|
;;;2544     {
;;;2545       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000a  2200              MOVS     r2,#0
00000c  4611              MOV      r1,r2
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       TIM_CCxChannelCmd
;;;2546   
;;;2547       /* Disable the capture compare Interrupts 1 */
;;;2548     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000014  6820              LDR      r0,[r4,#0]
000016  68c0              LDR      r0,[r0,#0xc]
000018  2102              MOVS     r1,#2
00001a  4388              BICS     r0,r0,r1
00001c  6821              LDR      r1,[r4,#0]
00001e  60c8              STR      r0,[r1,#0xc]
000020  e023              B        |L31.106|
                  |L31.34|
;;;2549     }
;;;2550     else if(Channel == TIM_CHANNEL_2)
000022  2d04              CMP      r5,#4
000024  d10b              BNE      |L31.62|
;;;2551     {
;;;2552       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  2104              MOVS     r1,#4
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2553   
;;;2554       /* Disable the capture compare Interrupts 2 */
;;;2555     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000030  6820              LDR      r0,[r4,#0]
000032  68c0              LDR      r0,[r0,#0xc]
000034  2104              MOVS     r1,#4
000036  4388              BICS     r0,r0,r1
000038  6821              LDR      r1,[r4,#0]
00003a  60c8              STR      r0,[r1,#0xc]
00003c  e015              B        |L31.106|
                  |L31.62|
;;;2556     }
;;;2557     else
;;;2558     {
;;;2559       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00003e  2200              MOVS     r2,#0
000040  4611              MOV      r1,r2
000042  6820              LDR      r0,[r4,#0]
000044  f7fffffe          BL       TIM_CCxChannelCmd
;;;2560       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000048  2200              MOVS     r2,#0
00004a  2104              MOVS     r1,#4
00004c  6820              LDR      r0,[r4,#0]
00004e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2561   
;;;2562       /* Disable the capture compare Interrupts 1 and 2 */
;;;2563       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000052  6820              LDR      r0,[r4,#0]
000054  68c0              LDR      r0,[r0,#0xc]
000056  2102              MOVS     r1,#2
000058  4388              BICS     r0,r0,r1
00005a  6821              LDR      r1,[r4,#0]
00005c  60c8              STR      r0,[r1,#0xc]
;;;2564       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00005e  6820              LDR      r0,[r4,#0]
000060  68c0              LDR      r0,[r0,#0xc]
000062  2104              MOVS     r1,#4
000064  4388              BICS     r0,r0,r1
000066  6821              LDR      r1,[r4,#0]
000068  60c8              STR      r0,[r1,#0xc]
                  |L31.106|
;;;2565     }
;;;2566   
;;;2567     /* Disable the Peripheral */
;;;2568     __HAL_TIM_DISABLE(htim);
00006a  bf00              NOP      
00006c  6820              LDR      r0,[r4,#0]
00006e  6a00              LDR      r0,[r0,#0x20]
000070  490a              LDR      r1,|L31.156|
000072  4008              ANDS     r0,r0,r1
000074  2800              CMP      r0,#0
000076  d10b              BNE      |L31.144|
000078  6820              LDR      r0,[r4,#0]
00007a  6a00              LDR      r0,[r0,#0x20]
00007c  1089              ASRS     r1,r1,#2
00007e  4008              ANDS     r0,r0,r1
000080  2800              CMP      r0,#0
000082  d105              BNE      |L31.144|
000084  6820              LDR      r0,[r4,#0]
000086  6800              LDR      r0,[r0,#0]
000088  0840              LSRS     r0,r0,#1
00008a  0040              LSLS     r0,r0,#1
00008c  6821              LDR      r1,[r4,#0]
00008e  6008              STR      r0,[r1,#0]
                  |L31.144|
000090  bf00              NOP      
;;;2569   
;;;2570     /* Change the htim state */
;;;2571     htim->State = HAL_TIM_STATE_READY;
000092  2101              MOVS     r1,#1
000094  203d              MOVS     r0,#0x3d
000096  5501              STRB     r1,[r0,r4]
;;;2572   
;;;2573     /* Return function status */
;;;2574     return HAL_OK;
000098  2000              MOVS     r0,#0
;;;2575   }
00009a  bd30              POP      {r4,r5,pc}
;;;2576   
                          ENDP

                  |L31.156|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4458     */
;;;4459   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4460   {
;;;4461     /* Prevent unused argument(s) compilation warning */
;;;4462     UNUSED(htim);
;;;4463   
;;;4464     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4465               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4466      */
;;;4467   }
;;;4468   
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;3853   
;;;3854   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  4602              MOV      r2,r0
;;;3855   {
;;;3856     /* Check the parameters */
;;;3857     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3858     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;3859   
;;;3860     /* Process Locked */
;;;3861     __HAL_LOCK(htim);
000002  bf00              NOP      
000004  203c              MOVS     r0,#0x3c
000006  5c80              LDRB     r0,[r0,r2]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L33.16|
00000c  2002              MOVS     r0,#2
                  |L33.14|
;;;3862   
;;;3863     /* Change the TIM state */
;;;3864     htim->State = HAL_TIM_STATE_BUSY;
;;;3865   
;;;3866     /* Set the event sources */
;;;3867     htim->Instance->EGR = EventSource;
;;;3868   
;;;3869     /* Change the TIM state */
;;;3870     htim->State = HAL_TIM_STATE_READY;
;;;3871   
;;;3872     __HAL_UNLOCK(htim);
;;;3873   
;;;3874     /* Return function status */
;;;3875     return HAL_OK;
;;;3876   }
00000e  4770              BX       lr
                  |L33.16|
000010  2301              MOVS     r3,#1                 ;3861
000012  203c              MOVS     r0,#0x3c              ;3861
000014  5483              STRB     r3,[r0,r2]            ;3861
000016  bf00              NOP                            ;3861
000018  2302              MOVS     r3,#2                 ;3864
00001a  203d              MOVS     r0,#0x3d              ;3864
00001c  5483              STRB     r3,[r0,r2]            ;3864
00001e  6810              LDR      r0,[r2,#0]            ;3867
000020  6141              STR      r1,[r0,#0x14]         ;3867
000022  2301              MOVS     r3,#1                 ;3870
000024  203d              MOVS     r0,#0x3d              ;3870
000026  5483              STRB     r3,[r0,r2]            ;3870
000028  bf00              NOP                            ;3872
00002a  2300              MOVS     r3,#0                 ;3872
00002c  203c              MOVS     r0,#0x3c              ;3872
00002e  5483              STRB     r3,[r0,r2]            ;3872
000030  bf00              NOP                            ;3872
000032  2000              MOVS     r0,#0                 ;3875
000034  e7eb              B        |L33.14|
;;;3877   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4413     */
;;;4414   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4415   {
;;;4416     /* Prevent unused argument(s) compilation warning */
;;;4417     UNUSED(htim);
;;;4418   
;;;4419     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4420               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4421      */
;;;4422   }
;;;4423   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_ConfigChannel PROC
;;;3000     */
;;;3001   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3002   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3003     /* Check the parameters */
;;;3004     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3005     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;3006     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;3007     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;3008     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;3009   
;;;3010     __HAL_LOCK(htim);
000008  bf00              NOP      
00000a  203c              MOVS     r0,#0x3c
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L35.22|
000012  2002              MOVS     r0,#2
                  |L35.20|
;;;3011   
;;;3012     htim->State = HAL_TIM_STATE_BUSY;
;;;3013   
;;;3014     if (Channel == TIM_CHANNEL_1)
;;;3015     {
;;;3016       /* TI1 Configuration */
;;;3017       TIM_TI1_SetConfig(htim->Instance,
;;;3018                  sConfig->ICPolarity,
;;;3019                  sConfig->ICSelection,
;;;3020                  sConfig->ICFilter);
;;;3021   
;;;3022       /* Reset the IC1PSC Bits */
;;;3023       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3024   
;;;3025       /* Set the IC1PSC value */
;;;3026       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3027     }
;;;3028     else if (Channel == TIM_CHANNEL_2)
;;;3029     {
;;;3030       /* TI2 Configuration */
;;;3031       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3032   
;;;3033       TIM_TI2_SetConfig(htim->Instance,
;;;3034                         sConfig->ICPolarity,
;;;3035                         sConfig->ICSelection,
;;;3036                         sConfig->ICFilter);
;;;3037   
;;;3038       /* Reset the IC2PSC Bits */
;;;3039       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3040   
;;;3041       /* Set the IC2PSC value */
;;;3042       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
;;;3043     }
;;;3044     else if (Channel == TIM_CHANNEL_3)
;;;3045     {
;;;3046       /* TI3 Configuration */
;;;3047       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3048   
;;;3049       TIM_TI3_SetConfig(htim->Instance,
;;;3050                  sConfig->ICPolarity,
;;;3051                  sConfig->ICSelection,
;;;3052                  sConfig->ICFilter);
;;;3053   
;;;3054       /* Reset the IC3PSC Bits */
;;;3055       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3056   
;;;3057       /* Set the IC3PSC value */
;;;3058       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3059     }
;;;3060     else
;;;3061     {
;;;3062       /* TI4 Configuration */
;;;3063       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3064   
;;;3065       TIM_TI4_SetConfig(htim->Instance,
;;;3066                  sConfig->ICPolarity,
;;;3067                  sConfig->ICSelection,
;;;3068                  sConfig->ICFilter);
;;;3069   
;;;3070       /* Reset the IC4PSC Bits */
;;;3071       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
;;;3072   
;;;3073       /* Set the IC4PSC value */
;;;3074       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
;;;3075     }
;;;3076   
;;;3077     htim->State = HAL_TIM_STATE_READY;
;;;3078   
;;;3079     __HAL_UNLOCK(htim);
;;;3080   
;;;3081     return HAL_OK;
;;;3082   }
000014  bdf8              POP      {r3-r7,pc}
                  |L35.22|
000016  2101              MOVS     r1,#1                 ;3010
000018  203c              MOVS     r0,#0x3c              ;3010
00001a  5501              STRB     r1,[r0,r4]            ;3010
00001c  bf00              NOP                            ;3010
00001e  2102              MOVS     r1,#2                 ;3012
000020  203d              MOVS     r0,#0x3d              ;3012
000022  5501              STRB     r1,[r0,r4]            ;3012
000024  2e00              CMP      r6,#0                 ;3014
000026  d112              BNE      |L35.78|
000028  68eb              LDR      r3,[r5,#0xc]          ;3017
00002a  686a              LDR      r2,[r5,#4]            ;3017
00002c  6829              LDR      r1,[r5,#0]            ;3017
00002e  6820              LDR      r0,[r4,#0]            ;3017
000030  f7fffffe          BL       TIM_TI1_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;3023
000036  6980              LDR      r0,[r0,#0x18]         ;3023
000038  210c              MOVS     r1,#0xc               ;3023
00003a  4388              BICS     r0,r0,r1              ;3023
00003c  6821              LDR      r1,[r4,#0]            ;3023
00003e  6188              STR      r0,[r1,#0x18]         ;3023
000040  6820              LDR      r0,[r4,#0]            ;3026
000042  6980              LDR      r0,[r0,#0x18]         ;3026
000044  68a9              LDR      r1,[r5,#8]            ;3026
000046  4308              ORRS     r0,r0,r1              ;3026
000048  6821              LDR      r1,[r4,#0]            ;3026
00004a  6188              STR      r0,[r1,#0x18]         ;3026
00004c  e03f              B        |L35.206|
                  |L35.78|
00004e  2e04              CMP      r6,#4                 ;3028
000050  d114              BNE      |L35.124|
000052  68eb              LDR      r3,[r5,#0xc]          ;3033
000054  686a              LDR      r2,[r5,#4]            ;3033
000056  6829              LDR      r1,[r5,#0]            ;3033
000058  6820              LDR      r0,[r4,#0]            ;3033
00005a  f7fffffe          BL       TIM_TI2_SetConfig
00005e  6820              LDR      r0,[r4,#0]            ;3039
000060  6980              LDR      r0,[r0,#0x18]         ;3039
000062  2103              MOVS     r1,#3                 ;3039
000064  0289              LSLS     r1,r1,#10             ;3039
000066  4388              BICS     r0,r0,r1              ;3039
000068  6821              LDR      r1,[r4,#0]            ;3039
00006a  6188              STR      r0,[r1,#0x18]         ;3039
00006c  6820              LDR      r0,[r4,#0]            ;3042
00006e  6980              LDR      r0,[r0,#0x18]         ;3042
000070  68a9              LDR      r1,[r5,#8]            ;3042
000072  0209              LSLS     r1,r1,#8              ;3042
000074  4308              ORRS     r0,r0,r1              ;3042
000076  6821              LDR      r1,[r4,#0]            ;3042
000078  6188              STR      r0,[r1,#0x18]         ;3042
00007a  e028              B        |L35.206|
                  |L35.124|
00007c  2e08              CMP      r6,#8                 ;3044
00007e  d112              BNE      |L35.166|
000080  68eb              LDR      r3,[r5,#0xc]          ;3049
000082  686a              LDR      r2,[r5,#4]            ;3049
000084  6829              LDR      r1,[r5,#0]            ;3049
000086  6820              LDR      r0,[r4,#0]            ;3049
000088  f7fffffe          BL       TIM_TI3_SetConfig
00008c  6820              LDR      r0,[r4,#0]            ;3055
00008e  69c0              LDR      r0,[r0,#0x1c]         ;3055
000090  210c              MOVS     r1,#0xc               ;3055
000092  4388              BICS     r0,r0,r1              ;3055
000094  6821              LDR      r1,[r4,#0]            ;3055
000096  61c8              STR      r0,[r1,#0x1c]         ;3055
000098  6820              LDR      r0,[r4,#0]            ;3058
00009a  69c0              LDR      r0,[r0,#0x1c]         ;3058
00009c  68a9              LDR      r1,[r5,#8]            ;3058
00009e  4308              ORRS     r0,r0,r1              ;3058
0000a0  6821              LDR      r1,[r4,#0]            ;3058
0000a2  61c8              STR      r0,[r1,#0x1c]         ;3058
0000a4  e013              B        |L35.206|
                  |L35.166|
0000a6  68eb              LDR      r3,[r5,#0xc]          ;3065
0000a8  686a              LDR      r2,[r5,#4]            ;3065
0000aa  6829              LDR      r1,[r5,#0]            ;3065
0000ac  6820              LDR      r0,[r4,#0]            ;3065
0000ae  f7fffffe          BL       TIM_TI4_SetConfig
0000b2  6820              LDR      r0,[r4,#0]            ;3071
0000b4  69c0              LDR      r0,[r0,#0x1c]         ;3071
0000b6  2103              MOVS     r1,#3                 ;3071
0000b8  0289              LSLS     r1,r1,#10             ;3071
0000ba  4388              BICS     r0,r0,r1              ;3071
0000bc  6821              LDR      r1,[r4,#0]            ;3071
0000be  61c8              STR      r0,[r1,#0x1c]         ;3071
0000c0  6820              LDR      r0,[r4,#0]            ;3074
0000c2  69c0              LDR      r0,[r0,#0x1c]         ;3074
0000c4  68a9              LDR      r1,[r5,#8]            ;3074
0000c6  0209              LSLS     r1,r1,#8              ;3074
0000c8  4308              ORRS     r0,r0,r1              ;3074
0000ca  6821              LDR      r1,[r4,#0]            ;3074
0000cc  61c8              STR      r0,[r1,#0x1c]         ;3074
                  |L35.206|
0000ce  2101              MOVS     r1,#1                 ;3077
0000d0  203d              MOVS     r0,#0x3d              ;3077
0000d2  5501              STRB     r1,[r0,r4]            ;3077
0000d4  bf00              NOP                            ;3079
0000d6  2100              MOVS     r1,#0                 ;3079
0000d8  203c              MOVS     r0,#0x3c              ;3079
0000da  5501              STRB     r1,[r0,r4]            ;3079
0000dc  bf00              NOP                            ;3079
0000de  2000              MOVS     r0,#0                 ;3081
0000e0  e798              B        |L35.20|
;;;3083   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_DeInit PROC
;;;1537     */
;;;1538   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1539   {
000002  4604              MOV      r4,r0
;;;1540     /* Check the parameters */
;;;1541     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1542   
;;;1543     htim->State = HAL_TIM_STATE_BUSY;
000004  2102              MOVS     r1,#2
000006  203d              MOVS     r0,#0x3d
000008  5501              STRB     r1,[r0,r4]
;;;1544   
;;;1545     /* Disable the TIM Peripheral Clock */
;;;1546     __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  490e              LDR      r1,|L36.76|
000012  4008              ANDS     r0,r0,r1
000014  2800              CMP      r0,#0
000016  d10b              BNE      |L36.48|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  2800              CMP      r0,#0
000022  d105              BNE      |L36.48|
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  0840              LSRS     r0,r0,#1
00002a  0040              LSLS     r0,r0,#1
00002c  6821              LDR      r1,[r4,#0]
00002e  6008              STR      r0,[r1,#0]
                  |L36.48|
000030  bf00              NOP      
;;;1547   
;;;1548     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1549     HAL_TIM_IC_MspDeInit(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1550   
;;;1551     /* Change TIM state */
;;;1552     htim->State = HAL_TIM_STATE_RESET;
000038  2100              MOVS     r1,#0
00003a  203d              MOVS     r0,#0x3d
00003c  5501              STRB     r1,[r0,r4]
;;;1553   
;;;1554     /* Release Lock */
;;;1555     __HAL_UNLOCK(htim);
00003e  bf00              NOP      
000040  203c              MOVS     r0,#0x3c
000042  5501              STRB     r1,[r0,r4]
000044  bf00              NOP      
;;;1556   
;;;1557     return HAL_OK;
000046  2000              MOVS     r0,#0
;;;1558   }
000048  bd10              POP      {r4,pc}
;;;1559   
                          ENDP

00004a  0000              DCW      0x0000
                  |L36.76|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;4522     */
;;;4523   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4524   {
;;;4525     return htim->State;
000002  203d              MOVS     r0,#0x3d
000004  5c40              LDRB     r0,[r0,r1]
;;;4526   }
000006  4770              BX       lr
;;;4527   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1497     */
;;;1498   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1499   {
000002  4604              MOV      r4,r0
;;;1500     /* Check the TIM handle allocation */
;;;1501     if(htim == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L38.12|
;;;1502     {
;;;1503       return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L38.10|
;;;1504     }
;;;1505   
;;;1506     /* Check the parameters */
;;;1507     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1508     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1509     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1510     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1511   
;;;1512     if(htim->State == HAL_TIM_STATE_RESET)
;;;1513     {
;;;1514       /* Allocate lock resource and initialize it */
;;;1515       htim->Lock = HAL_UNLOCKED;
;;;1516   
;;;1517       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1518       HAL_TIM_IC_MspInit(htim);
;;;1519     }
;;;1520   
;;;1521     /* Set the TIM state */
;;;1522     htim->State= HAL_TIM_STATE_BUSY;
;;;1523   
;;;1524     /* Init the base time for the input capture */
;;;1525     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1526   
;;;1527     /* Initialize the TIM state*/
;;;1528     htim->State= HAL_TIM_STATE_READY;
;;;1529   
;;;1530     return HAL_OK;
;;;1531   }
00000a  bd10              POP      {r4,pc}
                  |L38.12|
00000c  203d              MOVS     r0,#0x3d              ;1512
00000e  5d00              LDRB     r0,[r0,r4]            ;1512
000010  2800              CMP      r0,#0                 ;1512
000012  d105              BNE      |L38.32|
000014  2100              MOVS     r1,#0                 ;1515
000016  203c              MOVS     r0,#0x3c              ;1515
000018  5501              STRB     r1,[r0,r4]            ;1515
00001a  4620              MOV      r0,r4                 ;1518
00001c  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L38.32|
000020  2102              MOVS     r1,#2                 ;1522
000022  203d              MOVS     r0,#0x3d              ;1522
000024  5501              STRB     r1,[r0,r4]            ;1522
000026  1d21              ADDS     r1,r4,#4              ;1525
000028  6820              LDR      r0,[r4,#0]            ;1525
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  2101              MOVS     r1,#1                 ;1528
000030  203d              MOVS     r0,#0x3d              ;1528
000032  5501              STRB     r1,[r0,r4]            ;1528
000034  2000              MOVS     r0,#0                 ;1530
000036  e7e8              B        |L38.10|
;;;1532   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1579     */
;;;1580   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1581   {
;;;1582     /* Prevent unused argument(s) compilation warning */
;;;1583     UNUSED(htim);
;;;1584   
;;;1585     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1586               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1587      */
;;;1588   }
;;;1589   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1564     */
;;;1565   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1566   {
;;;1567     /* Prevent unused argument(s) compilation warning */
;;;1568     UNUSED(htim);
;;;1569   
;;;1570     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1571               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1572      */
;;;1573   }
;;;1574   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1600   */
;;;1601   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1602   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1603     /* Check the parameters */
;;;1604     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1605   
;;;1606     /* Enable the Input Capture channel */
;;;1607     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1608   
;;;1609     /* Enable the Peripheral */
;;;1610     __HAL_TIM_ENABLE(htim);
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  2101              MOVS     r1,#1
000016  4308              ORRS     r0,r0,r1
000018  6821              LDR      r1,[r4,#0]
00001a  6008              STR      r0,[r1,#0]
;;;1611   
;;;1612     /* Return function status */
;;;1613     return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;1614   }
00001e  bd30              POP      {r4,r5,pc}
;;;1615   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;1773   */
;;;1774   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1775   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;1776     /* Check the parameters */
;;;1777     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1778     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1779   
;;;1780     if((htim->State == HAL_TIM_STATE_BUSY))
00000a  203d              MOVS     r0,#0x3d
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2802              CMP      r0,#2
000010  d100              BNE      |L42.20|
                  |L42.18|
;;;1781     {
;;;1782        return HAL_BUSY;
;;;1783     }
;;;1784     else if((htim->State == HAL_TIM_STATE_READY))
;;;1785     {
;;;1786       if((pData == 0U ) && (Length > 0U))
;;;1787       {
;;;1788         return HAL_ERROR;
;;;1789       }
;;;1790       else
;;;1791       {
;;;1792         htim->State = HAL_TIM_STATE_BUSY;
;;;1793       }
;;;1794     }
;;;1795   
;;;1796     switch (Channel)
;;;1797     {
;;;1798       case TIM_CHANNEL_1:
;;;1799       {
;;;1800         /* Set the DMA Period elapsed callback */
;;;1801         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1802   
;;;1803         /* Set the DMA error callback */
;;;1804         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1805   
;;;1806         /* Enable the DMA channel */
;;;1807         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
;;;1808   
;;;1809         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1810         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1811       }
;;;1812       break;
;;;1813   
;;;1814       case TIM_CHANNEL_2:
;;;1815       {
;;;1816         /* Set the DMA Period elapsed callback */
;;;1817         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1818   
;;;1819         /* Set the DMA error callback */
;;;1820         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1821   
;;;1822         /* Enable the DMA channel */
;;;1823         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1824   
;;;1825         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1826         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1827       }
;;;1828       break;
;;;1829   
;;;1830       case TIM_CHANNEL_3:
;;;1831       {
;;;1832         /* Set the DMA Period elapsed callback */
;;;1833         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1834   
;;;1835         /* Set the DMA error callback */
;;;1836         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1837   
;;;1838         /* Enable the DMA channel */
;;;1839         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;1840   
;;;1841         /* Enable the TIM Capture/Compare 3  DMA request */
;;;1842         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1843       }
;;;1844       break;
;;;1845   
;;;1846       case TIM_CHANNEL_4:
;;;1847       {
;;;1848         /* Set the DMA Period elapsed callback */
;;;1849         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1850   
;;;1851         /* Set the DMA error callback */
;;;1852         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1853   
;;;1854         /* Enable the DMA channel */
;;;1855         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;1856   
;;;1857         /* Enable the TIM Capture/Compare 4  DMA request */
;;;1858         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1859       }
;;;1860       break;
;;;1861   
;;;1862       default:
;;;1863       break;
;;;1864     }
;;;1865   
;;;1866     /* Enable the Input Capture channel */
;;;1867     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1868   
;;;1869     /* Enable the Peripheral */
;;;1870     __HAL_TIM_ENABLE(htim);
;;;1871   
;;;1872     /* Return function status */
;;;1873     return HAL_OK;
;;;1874   }
000012  bdf8              POP      {r3-r7,pc}
                  |L42.20|
000014  203d              MOVS     r0,#0x3d              ;1784
000016  5d00              LDRB     r0,[r0,r4]            ;1784
000018  2801              CMP      r0,#1                 ;1784
00001a  d107              BNE      |L42.44|
00001c  2e00              CMP      r6,#0                 ;1786
00001e  d102              BNE      |L42.38|
000020  2f00              CMP      r7,#0                 ;1786
000022  d000              BEQ      |L42.38|
000024  e7f5              B        |L42.18|
                  |L42.38|
000026  2102              MOVS     r1,#2                 ;1792
000028  203d              MOVS     r0,#0x3d              ;1792
00002a  5501              STRB     r1,[r0,r4]            ;1792
                  |L42.44|
00002c  2d00              CMP      r5,#0                 ;1796
00002e  d006              BEQ      |L42.62|
000030  2d04              CMP      r5,#4                 ;1796
000032  d01a              BEQ      |L42.106|
000034  2d08              CMP      r5,#8                 ;1796
000036  d02e              BEQ      |L42.150|
000038  2d0c              CMP      r5,#0xc               ;1796
00003a  d158              BNE      |L42.238|
00003c  e041              B        |L42.194|
                  |L42.62|
00003e  4933              LDR      r1,|L42.268|
000040  6a60              LDR      r0,[r4,#0x24]         ;1801
000042  6281              STR      r1,[r0,#0x28]         ;1801
000044  4932              LDR      r1,|L42.272|
000046  6a60              LDR      r0,[r4,#0x24]         ;1804
000048  6301              STR      r1,[r0,#0x30]         ;1804
00004a  6822              LDR      r2,[r4,#0]            ;1807
00004c  4611              MOV      r1,r2                 ;1807
00004e  3134              ADDS     r1,r1,#0x34           ;1807
000050  463b              MOV      r3,r7                 ;1807
000052  4632              MOV      r2,r6                 ;1807
000054  6a60              LDR      r0,[r4,#0x24]         ;1807
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6820              LDR      r0,[r4,#0]            ;1810
00005c  68c0              LDR      r0,[r0,#0xc]          ;1810
00005e  2101              MOVS     r1,#1                 ;1810
000060  0249              LSLS     r1,r1,#9              ;1810
000062  4308              ORRS     r0,r0,r1              ;1810
000064  6821              LDR      r1,[r4,#0]            ;1810
000066  60c8              STR      r0,[r1,#0xc]          ;1810
000068  e042              B        |L42.240|
                  |L42.106|
00006a  4928              LDR      r1,|L42.268|
00006c  6aa0              LDR      r0,[r4,#0x28]         ;1817
00006e  6281              STR      r1,[r0,#0x28]         ;1817
000070  4927              LDR      r1,|L42.272|
000072  6aa0              LDR      r0,[r4,#0x28]         ;1820
000074  6301              STR      r1,[r0,#0x30]         ;1820
000076  6822              LDR      r2,[r4,#0]            ;1823
000078  4611              MOV      r1,r2                 ;1823
00007a  3138              ADDS     r1,r1,#0x38           ;1823
00007c  463b              MOV      r3,r7                 ;1823
00007e  4632              MOV      r2,r6                 ;1823
000080  6aa0              LDR      r0,[r4,#0x28]         ;1823
000082  f7fffffe          BL       HAL_DMA_Start_IT
000086  6820              LDR      r0,[r4,#0]            ;1826
000088  68c0              LDR      r0,[r0,#0xc]          ;1826
00008a  2101              MOVS     r1,#1                 ;1826
00008c  0289              LSLS     r1,r1,#10             ;1826
00008e  4308              ORRS     r0,r0,r1              ;1826
000090  6821              LDR      r1,[r4,#0]            ;1826
000092  60c8              STR      r0,[r1,#0xc]          ;1826
000094  e02c              B        |L42.240|
                  |L42.150|
000096  491d              LDR      r1,|L42.268|
000098  6ae0              LDR      r0,[r4,#0x2c]         ;1833
00009a  6281              STR      r1,[r0,#0x28]         ;1833
00009c  491c              LDR      r1,|L42.272|
00009e  6ae0              LDR      r0,[r4,#0x2c]         ;1836
0000a0  6301              STR      r1,[r0,#0x30]         ;1836
0000a2  6822              LDR      r2,[r4,#0]            ;1839
0000a4  4611              MOV      r1,r2                 ;1839
0000a6  313c              ADDS     r1,r1,#0x3c           ;1839
0000a8  463b              MOV      r3,r7                 ;1839
0000aa  4632              MOV      r2,r6                 ;1839
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;1839
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  6820              LDR      r0,[r4,#0]            ;1842
0000b4  68c0              LDR      r0,[r0,#0xc]          ;1842
0000b6  2101              MOVS     r1,#1                 ;1842
0000b8  02c9              LSLS     r1,r1,#11             ;1842
0000ba  4308              ORRS     r0,r0,r1              ;1842
0000bc  6821              LDR      r1,[r4,#0]            ;1842
0000be  60c8              STR      r0,[r1,#0xc]          ;1842
0000c0  e016              B        |L42.240|
                  |L42.194|
0000c2  4912              LDR      r1,|L42.268|
0000c4  6b20              LDR      r0,[r4,#0x30]         ;1849
0000c6  6281              STR      r1,[r0,#0x28]         ;1849
0000c8  4911              LDR      r1,|L42.272|
0000ca  6b20              LDR      r0,[r4,#0x30]         ;1852
0000cc  6301              STR      r1,[r0,#0x30]         ;1852
0000ce  6822              LDR      r2,[r4,#0]            ;1855
0000d0  4611              MOV      r1,r2                 ;1855
0000d2  3140              ADDS     r1,r1,#0x40           ;1855
0000d4  463b              MOV      r3,r7                 ;1855
0000d6  4632              MOV      r2,r6                 ;1855
0000d8  6b20              LDR      r0,[r4,#0x30]         ;1855
0000da  f7fffffe          BL       HAL_DMA_Start_IT
0000de  6820              LDR      r0,[r4,#0]            ;1858
0000e0  68c0              LDR      r0,[r0,#0xc]          ;1858
0000e2  2101              MOVS     r1,#1                 ;1858
0000e4  0309              LSLS     r1,r1,#12             ;1858
0000e6  4308              ORRS     r0,r0,r1              ;1858
0000e8  6821              LDR      r1,[r4,#0]            ;1858
0000ea  60c8              STR      r0,[r1,#0xc]          ;1858
0000ec  e000              B        |L42.240|
                  |L42.238|
0000ee  bf00              NOP                            ;1863
                  |L42.240|
0000f0  bf00              NOP                            ;1812
0000f2  2201              MOVS     r2,#1                 ;1867
0000f4  4629              MOV      r1,r5                 ;1867
0000f6  6820              LDR      r0,[r4,#0]            ;1867
0000f8  f7fffffe          BL       TIM_CCxChannelCmd
0000fc  6820              LDR      r0,[r4,#0]            ;1870
0000fe  6800              LDR      r0,[r0,#0]            ;1870
000100  2101              MOVS     r1,#1                 ;1870
000102  4308              ORRS     r0,r0,r1              ;1870
000104  6821              LDR      r1,[r4,#0]            ;1870
000106  6008              STR      r0,[r1,#0]            ;1870
000108  2000              MOVS     r0,#0                 ;1873
00010a  e782              B        |L42.18|
;;;1875   
                          ENDP

                  |L42.268|
                          DCD      TIM_DMACaptureCplt
                  |L42.272|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1652   */
;;;1653   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1654   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1655     /* Check the parameters */
;;;1656     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1657   
;;;1658     switch (Channel)
000006  2d00              CMP      r5,#0
000008  d006              BEQ      |L43.24|
00000a  2d04              CMP      r5,#4
00000c  d00b              BEQ      |L43.38|
00000e  2d08              CMP      r5,#8
000010  d010              BEQ      |L43.52|
000012  2d0c              CMP      r5,#0xc
000014  d11c              BNE      |L43.80|
000016  e014              B        |L43.66|
                  |L43.24|
;;;1659     {
;;;1660       case TIM_CHANNEL_1:
;;;1661       {
;;;1662         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1663         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000018  6820              LDR      r0,[r4,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  2102              MOVS     r1,#2
00001e  4308              ORRS     r0,r0,r1
000020  6821              LDR      r1,[r4,#0]
000022  60c8              STR      r0,[r1,#0xc]
;;;1664       }
;;;1665       break;
000024  e015              B        |L43.82|
                  |L43.38|
;;;1666   
;;;1667       case TIM_CHANNEL_2:
;;;1668       {
;;;1669         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1670         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000026  6820              LDR      r0,[r4,#0]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  2104              MOVS     r1,#4
00002c  4308              ORRS     r0,r0,r1
00002e  6821              LDR      r1,[r4,#0]
000030  60c8              STR      r0,[r1,#0xc]
;;;1671       }
;;;1672       break;
000032  e00e              B        |L43.82|
                  |L43.52|
;;;1673   
;;;1674       case TIM_CHANNEL_3:
;;;1675       {
;;;1676         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1677         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000034  6820              LDR      r0,[r4,#0]
000036  68c0              LDR      r0,[r0,#0xc]
000038  2108              MOVS     r1,#8
00003a  4308              ORRS     r0,r0,r1
00003c  6821              LDR      r1,[r4,#0]
00003e  60c8              STR      r0,[r1,#0xc]
;;;1678       }
;;;1679       break;
000040  e007              B        |L43.82|
                  |L43.66|
;;;1680   
;;;1681       case TIM_CHANNEL_4:
;;;1682       {
;;;1683         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1684         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000042  6820              LDR      r0,[r4,#0]
000044  68c0              LDR      r0,[r0,#0xc]
000046  2110              MOVS     r1,#0x10
000048  4308              ORRS     r0,r0,r1
00004a  6821              LDR      r1,[r4,#0]
00004c  60c8              STR      r0,[r1,#0xc]
;;;1685       }
;;;1686       break;
00004e  e000              B        |L43.82|
                  |L43.80|
;;;1687   
;;;1688       default:
;;;1689       break;
000050  bf00              NOP      
                  |L43.82|
000052  bf00              NOP                            ;1665
;;;1690     }
;;;1691     /* Enable the Input Capture channel */
;;;1692     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000054  2201              MOVS     r2,#1
000056  4629              MOV      r1,r5
000058  6820              LDR      r0,[r4,#0]
00005a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1693   
;;;1694     /* Enable the Peripheral */
;;;1695     __HAL_TIM_ENABLE(htim);
00005e  6820              LDR      r0,[r4,#0]
000060  6800              LDR      r0,[r0,#0]
000062  2101              MOVS     r1,#1
000064  4308              ORRS     r0,r0,r1
000066  6821              LDR      r1,[r4,#0]
000068  6008              STR      r0,[r1,#0]
;;;1696   
;;;1697     /* Return function status */
;;;1698     return HAL_OK;
00006a  2000              MOVS     r0,#0
;;;1699   }
00006c  bd30              POP      {r4,r5,pc}
;;;1700   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Stop PROC
;;;1626   */
;;;1627   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1628   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1629     /* Check the parameters */
;;;1630     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1631   
;;;1632     /* Disable the Input Capture channel */
;;;1633     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1634   
;;;1635     /* Disable the Peripheral */
;;;1636     __HAL_TIM_DISABLE(htim);
000010  bf00              NOP      
000012  6820              LDR      r0,[r4,#0]
000014  6a00              LDR      r0,[r0,#0x20]
000016  4909              LDR      r1,|L44.60|
000018  4008              ANDS     r0,r0,r1
00001a  2800              CMP      r0,#0
00001c  d10b              BNE      |L44.54|
00001e  6820              LDR      r0,[r4,#0]
000020  6a00              LDR      r0,[r0,#0x20]
000022  1089              ASRS     r1,r1,#2
000024  4008              ANDS     r0,r0,r1
000026  2800              CMP      r0,#0
000028  d105              BNE      |L44.54|
00002a  6820              LDR      r0,[r4,#0]
00002c  6800              LDR      r0,[r0,#0]
00002e  0840              LSRS     r0,r0,#1
000030  0040              LSLS     r0,r0,#1
000032  6821              LDR      r1,[r4,#0]
000034  6008              STR      r0,[r1,#0]
                  |L44.54|
000036  bf00              NOP      
;;;1637   
;;;1638     /* Return function status */
;;;1639     return HAL_OK;
000038  2000              MOVS     r0,#0
;;;1640   }
00003a  bd30              POP      {r4,r5,pc}
;;;1641   
                          ENDP

                  |L44.60|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Stop_DMA PROC
;;;1886   */
;;;1887   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1888   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1889     /* Check the parameters */
;;;1890     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1891     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1892   
;;;1893     switch (Channel)
000006  2d00              CMP      r5,#0
000008  d006              BEQ      |L45.24|
00000a  2d04              CMP      r5,#4
00000c  d00c              BEQ      |L45.40|
00000e  2d08              CMP      r5,#8
000010  d012              BEQ      |L45.56|
000012  2d0c              CMP      r5,#0xc
000014  d120              BNE      |L45.88|
000016  e017              B        |L45.72|
                  |L45.24|
;;;1894     {
;;;1895       case TIM_CHANNEL_1:
;;;1896       {
;;;1897         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1898         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000018  6820              LDR      r0,[r4,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  2101              MOVS     r1,#1
00001e  0249              LSLS     r1,r1,#9
000020  4388              BICS     r0,r0,r1
000022  6821              LDR      r1,[r4,#0]
000024  60c8              STR      r0,[r1,#0xc]
;;;1899       }
;;;1900       break;
000026  e018              B        |L45.90|
                  |L45.40|
;;;1901   
;;;1902       case TIM_CHANNEL_2:
;;;1903       {
;;;1904         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1905         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000028  6820              LDR      r0,[r4,#0]
00002a  68c0              LDR      r0,[r0,#0xc]
00002c  2101              MOVS     r1,#1
00002e  0289              LSLS     r1,r1,#10
000030  4388              BICS     r0,r0,r1
000032  6821              LDR      r1,[r4,#0]
000034  60c8              STR      r0,[r1,#0xc]
;;;1906       }
;;;1907       break;
000036  e010              B        |L45.90|
                  |L45.56|
;;;1908   
;;;1909       case TIM_CHANNEL_3:
;;;1910       {
;;;1911         /* Disable the TIM Capture/Compare 3  DMA request */
;;;1912         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000038  6820              LDR      r0,[r4,#0]
00003a  68c0              LDR      r0,[r0,#0xc]
00003c  2101              MOVS     r1,#1
00003e  02c9              LSLS     r1,r1,#11
000040  4388              BICS     r0,r0,r1
000042  6821              LDR      r1,[r4,#0]
000044  60c8              STR      r0,[r1,#0xc]
;;;1913       }
;;;1914       break;
000046  e008              B        |L45.90|
                  |L45.72|
;;;1915   
;;;1916       case TIM_CHANNEL_4:
;;;1917       {
;;;1918         /* Disable the TIM Capture/Compare 4  DMA request */
;;;1919         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000048  6820              LDR      r0,[r4,#0]
00004a  68c0              LDR      r0,[r0,#0xc]
00004c  2101              MOVS     r1,#1
00004e  0309              LSLS     r1,r1,#12
000050  4388              BICS     r0,r0,r1
000052  6821              LDR      r1,[r4,#0]
000054  60c8              STR      r0,[r1,#0xc]
;;;1920       }
;;;1921       break;
000056  e000              B        |L45.90|
                  |L45.88|
;;;1922   
;;;1923       default:
;;;1924       break;
000058  bf00              NOP      
                  |L45.90|
00005a  bf00              NOP                            ;1900
;;;1925     }
;;;1926   
;;;1927     /* Disable the Input Capture channel */
;;;1928     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00005c  2200              MOVS     r2,#0
00005e  4629              MOV      r1,r5
000060  6820              LDR      r0,[r4,#0]
000062  f7fffffe          BL       TIM_CCxChannelCmd
;;;1929   
;;;1930     /* Disable the Peripheral */
;;;1931     __HAL_TIM_DISABLE(htim);
000066  bf00              NOP      
000068  6820              LDR      r0,[r4,#0]
00006a  6a00              LDR      r0,[r0,#0x20]
00006c  490a              LDR      r1,|L45.152|
00006e  4008              ANDS     r0,r0,r1
000070  2800              CMP      r0,#0
000072  d10b              BNE      |L45.140|
000074  6820              LDR      r0,[r4,#0]
000076  6a00              LDR      r0,[r0,#0x20]
000078  1089              ASRS     r1,r1,#2
00007a  4008              ANDS     r0,r0,r1
00007c  2800              CMP      r0,#0
00007e  d105              BNE      |L45.140|
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  0840              LSRS     r0,r0,#1
000086  0040              LSLS     r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
                  |L45.140|
00008c  bf00              NOP      
;;;1932   
;;;1933     /* Change the htim state */
;;;1934     htim->State = HAL_TIM_STATE_READY;
00008e  2101              MOVS     r1,#1
000090  203d              MOVS     r0,#0x3d
000092  5501              STRB     r1,[r0,r4]
;;;1935   
;;;1936     /* Return function status */
;;;1937     return HAL_OK;
000094  2000              MOVS     r0,#0
;;;1938   }
000096  bd30              POP      {r4,r5,pc}
;;;1939   /**
                          ENDP

                  |L45.152|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Stop_IT PROC
;;;1711   */
;;;1712   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1713   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1714     /* Check the parameters */
;;;1715     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1716   
;;;1717     switch (Channel)
000006  2d00              CMP      r5,#0
000008  d006              BEQ      |L46.24|
00000a  2d04              CMP      r5,#4
00000c  d00b              BEQ      |L46.38|
00000e  2d08              CMP      r5,#8
000010  d010              BEQ      |L46.52|
000012  2d0c              CMP      r5,#0xc
000014  d11c              BNE      |L46.80|
000016  e014              B        |L46.66|
                  |L46.24|
;;;1718     {
;;;1719       case TIM_CHANNEL_1:
;;;1720       {
;;;1721         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1722         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000018  6820              LDR      r0,[r4,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  2102              MOVS     r1,#2
00001e  4388              BICS     r0,r0,r1
000020  6821              LDR      r1,[r4,#0]
000022  60c8              STR      r0,[r1,#0xc]
;;;1723       }
;;;1724       break;
000024  e015              B        |L46.82|
                  |L46.38|
;;;1725   
;;;1726       case TIM_CHANNEL_2:
;;;1727       {
;;;1728         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1729         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000026  6820              LDR      r0,[r4,#0]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  2104              MOVS     r1,#4
00002c  4388              BICS     r0,r0,r1
00002e  6821              LDR      r1,[r4,#0]
000030  60c8              STR      r0,[r1,#0xc]
;;;1730       }
;;;1731       break;
000032  e00e              B        |L46.82|
                  |L46.52|
;;;1732   
;;;1733       case TIM_CHANNEL_3:
;;;1734       {
;;;1735         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1736         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000034  6820              LDR      r0,[r4,#0]
000036  68c0              LDR      r0,[r0,#0xc]
000038  2108              MOVS     r1,#8
00003a  4388              BICS     r0,r0,r1
00003c  6821              LDR      r1,[r4,#0]
00003e  60c8              STR      r0,[r1,#0xc]
;;;1737       }
;;;1738       break;
000040  e007              B        |L46.82|
                  |L46.66|
;;;1739   
;;;1740       case TIM_CHANNEL_4:
;;;1741       {
;;;1742         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1743         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000042  6820              LDR      r0,[r4,#0]
000044  68c0              LDR      r0,[r0,#0xc]
000046  2110              MOVS     r1,#0x10
000048  4388              BICS     r0,r0,r1
00004a  6821              LDR      r1,[r4,#0]
00004c  60c8              STR      r0,[r1,#0xc]
;;;1744       }
;;;1745       break;
00004e  e000              B        |L46.82|
                  |L46.80|
;;;1746   
;;;1747       default:
;;;1748       break;
000050  bf00              NOP      
                  |L46.82|
000052  bf00              NOP                            ;1724
;;;1749     }
;;;1750   
;;;1751     /* Disable the Input Capture channel */
;;;1752     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000054  2200              MOVS     r2,#0
000056  4629              MOV      r1,r5
000058  6820              LDR      r0,[r4,#0]
00005a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1753   
;;;1754     /* Disable the Peripheral */
;;;1755     __HAL_TIM_DISABLE(htim);
00005e  bf00              NOP      
000060  6820              LDR      r0,[r4,#0]
000062  6a00              LDR      r0,[r0,#0x20]
000064  4909              LDR      r1,|L46.140|
000066  4008              ANDS     r0,r0,r1
000068  2800              CMP      r0,#0
00006a  d10b              BNE      |L46.132|
00006c  6820              LDR      r0,[r4,#0]
00006e  6a00              LDR      r0,[r0,#0x20]
000070  1089              ASRS     r1,r1,#2
000072  4008              ANDS     r0,r0,r1
000074  2800              CMP      r0,#0
000076  d105              BNE      |L46.132|
000078  6820              LDR      r0,[r4,#0]
00007a  6800              LDR      r0,[r0,#0]
00007c  0840              LSRS     r0,r0,#1
00007e  0040              LSLS     r0,r0,#1
000080  6821              LDR      r1,[r4,#0]
000082  6008              STR      r0,[r1,#0]
                  |L46.132|
000084  bf00              NOP      
;;;1756   
;;;1757     /* Return function status */
;;;1758     return HAL_OK;
000086  2000              MOVS     r0,#0
;;;1759   }
000088  bd30              POP      {r4,r5,pc}
;;;1760   
                          ENDP

00008a  0000              DCW      0x0000
                  |L46.140|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;2768     */
;;;2769   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2770   {
000002  4604              MOV      r4,r0
;;;2771     /* Capture compare 1 event */
;;;2772     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6820              LDR      r0,[r4,#0]
000006  6900              LDR      r0,[r0,#0x10]
000008  2102              MOVS     r1,#2
00000a  4008              ANDS     r0,r0,r1
00000c  0840              LSRS     r0,r0,#1
00000e  2800              CMP      r0,#0
000010  d01c              BEQ      |L47.76|
;;;2773     {
;;;2774       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  4008              ANDS     r0,r0,r1
000018  0840              LSRS     r0,r0,#1
00001a  2800              CMP      r0,#0
00001c  d016              BEQ      |L47.76|
;;;2775       {
;;;2776         {
;;;2777           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
00001e  1f48              SUBS     r0,r1,#5
000020  6821              LDR      r1,[r4,#0]
000022  6108              STR      r0,[r1,#0x10]
;;;2778           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000024  2001              MOVS     r0,#1
000026  7720              STRB     r0,[r4,#0x1c]
;;;2779   
;;;2780           /* Input capture event */
;;;2781           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
000028  6820              LDR      r0,[r4,#0]
00002a  6980              LDR      r0,[r0,#0x18]
00002c  0780              LSLS     r0,r0,#30
00002e  0f80              LSRS     r0,r0,#30
000030  2800              CMP      r0,#0
000032  d003              BEQ      |L47.60|
;;;2782           {
;;;2783             HAL_TIM_IC_CaptureCallback(htim);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00003a  e005              B        |L47.72|
                  |L47.60|
;;;2784           }
;;;2785           /* Output compare event */
;;;2786           else
;;;2787           {
;;;2788             HAL_TIM_OC_DelayElapsedCallback(htim);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2789             HAL_TIM_PWM_PulseFinishedCallback(htim);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L47.72|
;;;2790           }
;;;2791           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000048  2000              MOVS     r0,#0
00004a  7720              STRB     r0,[r4,#0x1c]
                  |L47.76|
;;;2792         }
;;;2793       }
;;;2794     }
;;;2795     /* Capture compare 2 event */
;;;2796     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
00004c  6820              LDR      r0,[r4,#0]
00004e  6900              LDR      r0,[r0,#0x10]
000050  2104              MOVS     r1,#4
000052  4008              ANDS     r0,r0,r1
000054  0880              LSRS     r0,r0,#2
000056  2800              CMP      r0,#0
000058  d01d              BEQ      |L47.150|
;;;2797     {
;;;2798       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
00005a  6820              LDR      r0,[r4,#0]
00005c  68c0              LDR      r0,[r0,#0xc]
00005e  4008              ANDS     r0,r0,r1
000060  0880              LSRS     r0,r0,#2
000062  2800              CMP      r0,#0
000064  d017              BEQ      |L47.150|
;;;2799       {
;;;2800         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
000066  43c8              MVNS     r0,r1
000068  6821              LDR      r1,[r4,#0]
00006a  6108              STR      r0,[r1,#0x10]
;;;2801         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00006c  2002              MOVS     r0,#2
00006e  7720              STRB     r0,[r4,#0x1c]
;;;2802         /* Input capture event */
;;;2803         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
000070  6820              LDR      r0,[r4,#0]
000072  6980              LDR      r0,[r0,#0x18]
000074  2103              MOVS     r1,#3
000076  0209              LSLS     r1,r1,#8
000078  4008              ANDS     r0,r0,r1
00007a  2800              CMP      r0,#0
00007c  d003              BEQ      |L47.134|
;;;2804         {
;;;2805           HAL_TIM_IC_CaptureCallback(htim);
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000084  e005              B        |L47.146|
                  |L47.134|
;;;2806         }
;;;2807         /* Output compare event */
;;;2808         else
;;;2809         {
;;;2810           HAL_TIM_OC_DelayElapsedCallback(htim);
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2811           HAL_TIM_PWM_PulseFinishedCallback(htim);
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L47.146|
;;;2812         }
;;;2813         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000092  2000              MOVS     r0,#0
000094  7720              STRB     r0,[r4,#0x1c]
                  |L47.150|
;;;2814       }
;;;2815     }
;;;2816     /* Capture compare 3 event */
;;;2817     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
000096  6820              LDR      r0,[r4,#0]
000098  6900              LDR      r0,[r0,#0x10]
00009a  2108              MOVS     r1,#8
00009c  4008              ANDS     r0,r0,r1
00009e  08c0              LSRS     r0,r0,#3
0000a0  2800              CMP      r0,#0
0000a2  d01c              BEQ      |L47.222|
;;;2818     {
;;;2819       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
0000a4  6820              LDR      r0,[r4,#0]
0000a6  68c0              LDR      r0,[r0,#0xc]
0000a8  4008              ANDS     r0,r0,r1
0000aa  08c0              LSRS     r0,r0,#3
0000ac  2800              CMP      r0,#0
0000ae  d016              BEQ      |L47.222|
;;;2820       {
;;;2821         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
0000b0  43c8              MVNS     r0,r1
0000b2  6821              LDR      r1,[r4,#0]
0000b4  6108              STR      r0,[r1,#0x10]
;;;2822         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
0000b6  2004              MOVS     r0,#4
0000b8  7720              STRB     r0,[r4,#0x1c]
;;;2823         /* Input capture event */
;;;2824         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
0000ba  6820              LDR      r0,[r4,#0]
0000bc  69c0              LDR      r0,[r0,#0x1c]
0000be  0780              LSLS     r0,r0,#30
0000c0  0f80              LSRS     r0,r0,#30
0000c2  2800              CMP      r0,#0
0000c4  d003              BEQ      |L47.206|
;;;2825         {
;;;2826           HAL_TIM_IC_CaptureCallback(htim);
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000cc  e005              B        |L47.218|
                  |L47.206|
;;;2827         }
;;;2828         /* Output compare event */
;;;2829         else
;;;2830         {
;;;2831           HAL_TIM_OC_DelayElapsedCallback(htim);
0000ce  4620              MOV      r0,r4
0000d0  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2832           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000d4  4620              MOV      r0,r4
0000d6  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L47.218|
;;;2833         }
;;;2834         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000da  2000              MOVS     r0,#0
0000dc  7720              STRB     r0,[r4,#0x1c]
                  |L47.222|
;;;2835       }
;;;2836     }
;;;2837     /* Capture compare 4 event */
;;;2838     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000de  6820              LDR      r0,[r4,#0]
0000e0  6900              LDR      r0,[r0,#0x10]
0000e2  2110              MOVS     r1,#0x10
0000e4  4008              ANDS     r0,r0,r1
0000e6  0900              LSRS     r0,r0,#4
0000e8  2800              CMP      r0,#0
0000ea  d01d              BEQ      |L47.296|
;;;2839     {
;;;2840       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
0000ec  6820              LDR      r0,[r4,#0]
0000ee  68c0              LDR      r0,[r0,#0xc]
0000f0  4008              ANDS     r0,r0,r1
0000f2  0900              LSRS     r0,r0,#4
0000f4  2800              CMP      r0,#0
0000f6  d017              BEQ      |L47.296|
;;;2841       {
;;;2842         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
0000f8  43c8              MVNS     r0,r1
0000fa  6821              LDR      r1,[r4,#0]
0000fc  6108              STR      r0,[r1,#0x10]
;;;2843         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000fe  2008              MOVS     r0,#8
000100  7720              STRB     r0,[r4,#0x1c]
;;;2844         /* Input capture event */
;;;2845         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
000102  6820              LDR      r0,[r4,#0]
000104  69c0              LDR      r0,[r0,#0x1c]
000106  2103              MOVS     r1,#3
000108  0209              LSLS     r1,r1,#8
00010a  4008              ANDS     r0,r0,r1
00010c  2800              CMP      r0,#0
00010e  d003              BEQ      |L47.280|
;;;2846         {
;;;2847           HAL_TIM_IC_CaptureCallback(htim);
000110  4620              MOV      r0,r4
000112  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000116  e005              B        |L47.292|
                  |L47.280|
;;;2848         }
;;;2849         /* Output compare event */
;;;2850         else
;;;2851         {
;;;2852           HAL_TIM_OC_DelayElapsedCallback(htim);
000118  4620              MOV      r0,r4
00011a  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2853           HAL_TIM_PWM_PulseFinishedCallback(htim);
00011e  4620              MOV      r0,r4
000120  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L47.292|
;;;2854         }
;;;2855         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000124  2000              MOVS     r0,#0
000126  7720              STRB     r0,[r4,#0x1c]
                  |L47.296|
;;;2856       }
;;;2857     }
;;;2858     /* TIM Update event */
;;;2859     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
000128  6820              LDR      r0,[r4,#0]
00012a  6900              LDR      r0,[r0,#0x10]
00012c  07c0              LSLS     r0,r0,#31
00012e  0fc0              LSRS     r0,r0,#31
000130  2101              MOVS     r1,#1
000132  4048              EORS     r0,r0,r1
000134  4048              EORS     r0,r0,r1
000136  2800              CMP      r0,#0
000138  d00c              BEQ      |L47.340|
;;;2860     {
;;;2861       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
00013a  6820              LDR      r0,[r4,#0]
00013c  68c0              LDR      r0,[r0,#0xc]
00013e  4008              ANDS     r0,r0,r1
000140  4048              EORS     r0,r0,r1
000142  4048              EORS     r0,r0,r1
000144  2800              CMP      r0,#0
000146  d005              BEQ      |L47.340|
;;;2862       {
;;;2863         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
000148  1ec8              SUBS     r0,r1,#3
00014a  6821              LDR      r1,[r4,#0]
00014c  6108              STR      r0,[r1,#0x10]
;;;2864         HAL_TIM_PeriodElapsedCallback(htim);
00014e  4620              MOV      r0,r4
000150  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L47.340|
;;;2865       }
;;;2866     }
;;;2867     /* TIM Break input event */
;;;2868     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
000154  6820              LDR      r0,[r4,#0]
000156  6900              LDR      r0,[r0,#0x10]
000158  2180              MOVS     r1,#0x80
00015a  4008              ANDS     r0,r0,r1
00015c  09c0              LSRS     r0,r0,#7
00015e  2800              CMP      r0,#0
000160  d00b              BEQ      |L47.378|
;;;2869     {
;;;2870       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
000162  6820              LDR      r0,[r4,#0]
000164  68c0              LDR      r0,[r0,#0xc]
000166  4008              ANDS     r0,r0,r1
000168  09c0              LSRS     r0,r0,#7
00016a  2800              CMP      r0,#0
00016c  d005              BEQ      |L47.378|
;;;2871       {
;;;2872         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
00016e  43c8              MVNS     r0,r1
000170  6821              LDR      r1,[r4,#0]
000172  6108              STR      r0,[r1,#0x10]
;;;2873         HAL_TIMEx_BreakCallback(htim);
000174  4620              MOV      r0,r4
000176  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L47.378|
;;;2874       }
;;;2875     }
;;;2876     /* TIM Trigger detection event */
;;;2877     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
00017a  6820              LDR      r0,[r4,#0]
00017c  6900              LDR      r0,[r0,#0x10]
00017e  2140              MOVS     r1,#0x40
000180  4008              ANDS     r0,r0,r1
000182  0980              LSRS     r0,r0,#6
000184  2800              CMP      r0,#0
000186  d00b              BEQ      |L47.416|
;;;2878     {
;;;2879       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
000188  6820              LDR      r0,[r4,#0]
00018a  68c0              LDR      r0,[r0,#0xc]
00018c  4008              ANDS     r0,r0,r1
00018e  0980              LSRS     r0,r0,#6
000190  2800              CMP      r0,#0
000192  d005              BEQ      |L47.416|
;;;2880       {
;;;2881         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
000194  43c8              MVNS     r0,r1
000196  6821              LDR      r1,[r4,#0]
000198  6108              STR      r0,[r1,#0x10]
;;;2882         HAL_TIM_TriggerCallback(htim);
00019a  4620              MOV      r0,r4
00019c  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L47.416|
;;;2883       }
;;;2884     }
;;;2885     /* TIM commutation event */
;;;2886     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
0001a0  6820              LDR      r0,[r4,#0]
0001a2  6900              LDR      r0,[r0,#0x10]
0001a4  2120              MOVS     r1,#0x20
0001a6  4008              ANDS     r0,r0,r1
0001a8  0940              LSRS     r0,r0,#5
0001aa  2800              CMP      r0,#0
0001ac  d00b              BEQ      |L47.454|
;;;2887     {
;;;2888       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
0001ae  6820              LDR      r0,[r4,#0]
0001b0  68c0              LDR      r0,[r0,#0xc]
0001b2  4008              ANDS     r0,r0,r1
0001b4  0940              LSRS     r0,r0,#5
0001b6  2800              CMP      r0,#0
0001b8  d005              BEQ      |L47.454|
;;;2889       {
;;;2890         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
0001ba  43c8              MVNS     r0,r1
0001bc  6821              LDR      r1,[r4,#0]
0001be  6108              STR      r0,[r1,#0x10]
;;;2891         HAL_TIMEx_CommutationCallback(htim);
0001c0  4620              MOV      r0,r4
0001c2  f7fffffe          BL       HAL_TIMEx_CommutationCallback
                  |L47.454|
;;;2892       }
;;;2893     }
;;;2894   }
0001c6  bd10              POP      {r4,pc}
;;;2895   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_ConfigChannel PROC
;;;2931     */
;;;2932   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;2933   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;2934     /* Check the parameters */
;;;2935     assert_param(IS_TIM_CHANNELS(Channel));
;;;2936     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;2937     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2938   
;;;2939     /* Check input state */
;;;2940     __HAL_LOCK(htim);
000008  bf00              NOP      
00000a  203c              MOVS     r0,#0x3c
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L48.22|
000012  2002              MOVS     r0,#2
                  |L48.20|
;;;2941   
;;;2942     htim->State = HAL_TIM_STATE_BUSY;
;;;2943   
;;;2944     switch (Channel)
;;;2945     {
;;;2946       case TIM_CHANNEL_1:
;;;2947       {
;;;2948         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2949         /* Configure the TIM Channel 1 in Output Compare */
;;;2950         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;2951       }
;;;2952       break;
;;;2953   
;;;2954       case TIM_CHANNEL_2:
;;;2955       {
;;;2956         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2957         /* Configure the TIM Channel 2 in Output Compare */
;;;2958         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;2959       }
;;;2960       break;
;;;2961   
;;;2962       case TIM_CHANNEL_3:
;;;2963       {
;;;2964          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;2965         /* Configure the TIM Channel 3 in Output Compare */
;;;2966         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;2967       }
;;;2968       break;
;;;2969   
;;;2970       case TIM_CHANNEL_4:
;;;2971       {
;;;2972         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;2973          /* Configure the TIM Channel 4 in Output Compare */
;;;2974          TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;2975       }
;;;2976       break;
;;;2977   
;;;2978       default:
;;;2979       break;
;;;2980     }
;;;2981     htim->State = HAL_TIM_STATE_READY;
;;;2982   
;;;2983     __HAL_UNLOCK(htim);
;;;2984   
;;;2985     return HAL_OK;
;;;2986   }
000014  bd70              POP      {r4-r6,pc}
                  |L48.22|
000016  2101              MOVS     r1,#1                 ;2940
000018  203c              MOVS     r0,#0x3c              ;2940
00001a  5501              STRB     r1,[r0,r4]            ;2940
00001c  bf00              NOP                            ;2940
00001e  2102              MOVS     r1,#2                 ;2942
000020  203d              MOVS     r0,#0x3d              ;2942
000022  5501              STRB     r1,[r0,r4]            ;2942
000024  2d00              CMP      r5,#0                 ;2944
000026  d006              BEQ      |L48.54|
000028  2d04              CMP      r5,#4                 ;2944
00002a  d009              BEQ      |L48.64|
00002c  2d08              CMP      r5,#8                 ;2944
00002e  d00c              BEQ      |L48.74|
000030  2d0c              CMP      r5,#0xc               ;2944
000032  d114              BNE      |L48.94|
000034  e00e              B        |L48.84|
                  |L48.54|
000036  4631              MOV      r1,r6                 ;2950
000038  6820              LDR      r0,[r4,#0]            ;2950
00003a  f7fffffe          BL       TIM_OC1_SetConfig
00003e  e00f              B        |L48.96|
                  |L48.64|
000040  4631              MOV      r1,r6                 ;2958
000042  6820              LDR      r0,[r4,#0]            ;2958
000044  f7fffffe          BL       TIM_OC2_SetConfig
000048  e00a              B        |L48.96|
                  |L48.74|
00004a  4631              MOV      r1,r6                 ;2966
00004c  6820              LDR      r0,[r4,#0]            ;2966
00004e  f7fffffe          BL       TIM_OC3_SetConfig
000052  e005              B        |L48.96|
                  |L48.84|
000054  4631              MOV      r1,r6                 ;2974
000056  6820              LDR      r0,[r4,#0]            ;2974
000058  f7fffffe          BL       TIM_OC4_SetConfig
00005c  e000              B        |L48.96|
                  |L48.94|
00005e  bf00              NOP                            ;2979
                  |L48.96|
000060  bf00              NOP                            ;2952
000062  2101              MOVS     r1,#1                 ;2981
000064  203d              MOVS     r0,#0x3d              ;2981
000066  5501              STRB     r1,[r0,r4]            ;2981
000068  bf00              NOP                            ;2983
00006a  2100              MOVS     r1,#0                 ;2983
00006c  203c              MOVS     r0,#0x3c              ;2983
00006e  5501              STRB     r1,[r0,r4]            ;2983
000070  bf00              NOP                            ;2983
000072  2000              MOVS     r0,#0                 ;2985
000074  e7ce              B        |L48.20|
;;;2987   
                          ENDP


                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_DeInit PROC
;;;520      */
;;;521    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;522    {
000002  4604              MOV      r4,r0
;;;523      /* Check the parameters */
;;;524      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;525    
;;;526       htim->State = HAL_TIM_STATE_BUSY;
000004  2102              MOVS     r1,#2
000006  203d              MOVS     r0,#0x3d
000008  5501              STRB     r1,[r0,r4]
;;;527    
;;;528      /* Disable the TIM Peripheral Clock */
;;;529      __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  490e              LDR      r1,|L49.76|
000012  4008              ANDS     r0,r0,r1
000014  2800              CMP      r0,#0
000016  d10b              BNE      |L49.48|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  2800              CMP      r0,#0
000022  d105              BNE      |L49.48|
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  0840              LSRS     r0,r0,#1
00002a  0040              LSLS     r0,r0,#1
00002c  6821              LDR      r1,[r4,#0]
00002e  6008              STR      r0,[r1,#0]
                  |L49.48|
000030  bf00              NOP      
;;;530    
;;;531      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;532      HAL_TIM_OC_MspDeInit(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;533    
;;;534      /* Change TIM state */
;;;535      htim->State = HAL_TIM_STATE_RESET;
000038  2100              MOVS     r1,#0
00003a  203d              MOVS     r0,#0x3d
00003c  5501              STRB     r1,[r0,r4]
;;;536    
;;;537      /* Release Lock */
;;;538      __HAL_UNLOCK(htim);
00003e  bf00              NOP      
000040  203c              MOVS     r0,#0x3c
000042  5501              STRB     r1,[r0,r4]
000044  bf00              NOP      
;;;539    
;;;540      return HAL_OK;
000046  2000              MOVS     r0,#0
;;;541    }
000048  bd10              POP      {r4,pc}
;;;542    
                          ENDP

00004a  0000              DCW      0x0000
                  |L49.76|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4399     */
;;;4400   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4401   {
;;;4402     /* Prevent unused argument(s) compilation warning */
;;;4403     UNUSED(htim);
;;;4404   
;;;4405     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4406               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4407      */
;;;4408   }
;;;4409   /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;4502     */
;;;4503   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4504   {
;;;4505     return htim->State;
000002  203d              MOVS     r0,#0x3d
000004  5c40              LDRB     r0,[r0,r1]
;;;4506   }
000006  4770              BX       lr
;;;4507   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;480      */
;;;481    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000000  b510              PUSH     {r4,lr}
;;;482    {
000002  4604              MOV      r4,r0
;;;483      /* Check the TIM handle allocation */
;;;484      if(htim == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L52.12|
;;;485      {
;;;486        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L52.10|
;;;487      }
;;;488    
;;;489      /* Check the parameters */
;;;490      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;491      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;492      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;493      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;494    
;;;495      if(htim->State == HAL_TIM_STATE_RESET)
;;;496      {
;;;497        /* Allocate lock resource and initialize it */
;;;498        htim->Lock = HAL_UNLOCKED;
;;;499    
;;;500        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;501        HAL_TIM_OC_MspInit(htim);
;;;502      }
;;;503    
;;;504      /* Set the TIM state */
;;;505      htim->State= HAL_TIM_STATE_BUSY;
;;;506    
;;;507      /* Init the base time for the Output Compare */
;;;508      TIM_Base_SetConfig(htim->Instance,  &htim->Init);
;;;509    
;;;510      /* Initialize the TIM state*/
;;;511      htim->State= HAL_TIM_STATE_READY;
;;;512    
;;;513      return HAL_OK;
;;;514    }
00000a  bd10              POP      {r4,pc}
                  |L52.12|
00000c  203d              MOVS     r0,#0x3d              ;495
00000e  5d00              LDRB     r0,[r0,r4]            ;495
000010  2800              CMP      r0,#0                 ;495
000012  d105              BNE      |L52.32|
000014  2100              MOVS     r1,#0                 ;498
000016  203c              MOVS     r0,#0x3c              ;498
000018  5501              STRB     r1,[r0,r4]            ;498
00001a  4620              MOV      r0,r4                 ;501
00001c  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L52.32|
000020  2102              MOVS     r1,#2                 ;505
000022  203d              MOVS     r0,#0x3d              ;505
000024  5501              STRB     r1,[r0,r4]            ;505
000026  1d21              ADDS     r1,r4,#4              ;508
000028  6820              LDR      r0,[r4,#0]            ;508
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  2101              MOVS     r1,#1                 ;511
000030  203d              MOVS     r0,#0x3d              ;511
000032  5501              STRB     r1,[r0,r4]            ;511
000034  2000              MOVS     r0,#0                 ;513
000036  e7e8              B        |L52.10|
;;;515    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;562      */
;;;563    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;564    {
;;;565      /* Prevent unused argument(s) compilation warning */
;;;566      UNUSED(htim);
;;;567    
;;;568      /* NOTE : This function Should not be modified, when the callback is needed,
;;;569                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;570       */
;;;571    }
;;;572    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;547      */
;;;548    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;549    {
;;;550      /* Prevent unused argument(s) compilation warning */
;;;551      UNUSED(htim);
;;;552    
;;;553      /* NOTE : This function Should not be modified, when the callback is needed,
;;;554                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;555       */
;;;556    }
;;;557    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start PROC
;;;583    */
;;;584    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;585    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;586      /* Check the parameters */
;;;587      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;588    
;;;589      /* Enable the Output compare channel */
;;;590      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;591    
;;;592      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000010  4911              LDR      r1,|L55.88|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d00b              BEQ      |L55.48|
000018  4910              LDR      r1,|L55.92|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d007              BEQ      |L55.48|
000020  490f              LDR      r1,|L55.96|
000022  6820              LDR      r0,[r4,#0]
000024  4288              CMP      r0,r1
000026  d003              BEQ      |L55.48|
000028  490e              LDR      r1,|L55.100|
00002a  6820              LDR      r0,[r4,#0]
00002c  4288              CMP      r0,r1
00002e  d101              BNE      |L55.52|
                  |L55.48|
000030  2001              MOVS     r0,#1
000032  e000              B        |L55.54|
                  |L55.52|
000034  2000              MOVS     r0,#0
                  |L55.54|
000036  2800              CMP      r0,#0
000038  d006              BEQ      |L55.72|
;;;593      {
;;;594        /* Enable the main output */
;;;595        __HAL_TIM_MOE_ENABLE(htim);
00003a  6820              LDR      r0,[r4,#0]
00003c  6c40              LDR      r0,[r0,#0x44]
00003e  2101              MOVS     r1,#1
000040  03c9              LSLS     r1,r1,#15
000042  4308              ORRS     r0,r0,r1
000044  6821              LDR      r1,[r4,#0]
000046  6448              STR      r0,[r1,#0x44]
                  |L55.72|
;;;596      }
;;;597    
;;;598      /* Enable the Peripheral */
;;;599      __HAL_TIM_ENABLE(htim);
000048  6820              LDR      r0,[r4,#0]
00004a  6800              LDR      r0,[r0,#0]
00004c  2101              MOVS     r1,#1
00004e  4308              ORRS     r0,r0,r1
000050  6821              LDR      r1,[r4,#0]
000052  6008              STR      r0,[r1,#0]
;;;600    
;;;601      /* Return function status */
;;;602      return HAL_OK;
000054  2000              MOVS     r0,#0
;;;603    }
000056  bd30              POP      {r4,r5,pc}
;;;604    
                          ENDP

                  |L55.88|
                          DCD      0x40012c00
                  |L55.92|
                          DCD      0x40014000
                  |L55.96|
                          DCD      0x40014400
                  |L55.100|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;781    */
;;;782    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b5f8              PUSH     {r3-r7,lr}
;;;783    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
000008  461f              MOV      r7,r3
;;;784      /* Check the parameters */
;;;785      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;786    
;;;787      if((htim->State == HAL_TIM_STATE_BUSY))
00000a  203d              MOVS     r0,#0x3d
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2802              CMP      r0,#2
000010  d100              BNE      |L56.20|
                  |L56.18|
;;;788      {
;;;789         return HAL_BUSY;
;;;790      }
;;;791      else if((htim->State == HAL_TIM_STATE_READY))
;;;792      {
;;;793        if(((uint32_t)pData == 0U ) && (Length > 0U))
;;;794        {
;;;795          return HAL_ERROR;
;;;796        }
;;;797        else
;;;798        {
;;;799          htim->State = HAL_TIM_STATE_BUSY;
;;;800        }
;;;801      }
;;;802      switch (Channel)
;;;803      {
;;;804        case TIM_CHANNEL_1:
;;;805        {
;;;806          /* Set the DMA Period elapsed callback */
;;;807          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;808    
;;;809          /* Set the DMA error callback */
;;;810          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;811    
;;;812          /* Enable the DMA channel */
;;;813          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;814    
;;;815          /* Enable the TIM Capture/Compare 1 DMA request */
;;;816          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;817        }
;;;818        break;
;;;819    
;;;820        case TIM_CHANNEL_2:
;;;821        {
;;;822          /* Set the DMA Period elapsed callback */
;;;823          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;824    
;;;825          /* Set the DMA error callback */
;;;826          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;827    
;;;828          /* Enable the DMA channel */
;;;829          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;830    
;;;831          /* Enable the TIM Capture/Compare 2 DMA request */
;;;832          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;833        }
;;;834        break;
;;;835    
;;;836        case TIM_CHANNEL_3:
;;;837        {
;;;838          /* Set the DMA Period elapsed callback */
;;;839          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;840    
;;;841          /* Set the DMA error callback */
;;;842          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;843    
;;;844          /* Enable the DMA channel */
;;;845          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;846    
;;;847          /* Enable the TIM Capture/Compare 3 DMA request */
;;;848          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;849        }
;;;850        break;
;;;851    
;;;852        case TIM_CHANNEL_4:
;;;853        {
;;;854         /* Set the DMA Period elapsed callback */
;;;855          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;856    
;;;857          /* Set the DMA error callback */
;;;858          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;859    
;;;860          /* Enable the DMA channel */
;;;861          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;862    
;;;863          /* Enable the TIM Capture/Compare 4 DMA request */
;;;864          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;865        }
;;;866        break;
;;;867    
;;;868        default:
;;;869        break;
;;;870      }
;;;871    
;;;872      /* Enable the Output compare channel */
;;;873      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;874    
;;;875      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;876      {
;;;877        /* Enable the main output */
;;;878        __HAL_TIM_MOE_ENABLE(htim);
;;;879      }
;;;880    
;;;881      /* Enable the Peripheral */
;;;882      __HAL_TIM_ENABLE(htim);
;;;883    
;;;884      /* Return function status */
;;;885      return HAL_OK;
;;;886    }
000012  bdf8              POP      {r3-r7,pc}
                  |L56.20|
000014  203d              MOVS     r0,#0x3d              ;791
000016  5d00              LDRB     r0,[r0,r4]            ;791
000018  2801              CMP      r0,#1                 ;791
00001a  d107              BNE      |L56.44|
00001c  2d00              CMP      r5,#0                 ;793
00001e  d102              BNE      |L56.38|
000020  2f00              CMP      r7,#0                 ;793
000022  d000              BEQ      |L56.38|
000024  e7f5              B        |L56.18|
                  |L56.38|
000026  2102              MOVS     r1,#2                 ;799
000028  203d              MOVS     r0,#0x3d              ;799
00002a  5501              STRB     r1,[r0,r4]            ;799
                  |L56.44|
00002c  2e00              CMP      r6,#0                 ;802
00002e  d006              BEQ      |L56.62|
000030  2e04              CMP      r6,#4                 ;802
000032  d01a              BEQ      |L56.106|
000034  2e08              CMP      r6,#8                 ;802
000036  d02e              BEQ      |L56.150|
000038  2e0c              CMP      r6,#0xc               ;802
00003a  d158              BNE      |L56.238|
00003c  e041              B        |L56.194|
                  |L56.62|
00003e  4941              LDR      r1,|L56.324|
000040  6a60              LDR      r0,[r4,#0x24]         ;807
000042  6281              STR      r1,[r0,#0x28]         ;807
000044  4940              LDR      r1,|L56.328|
000046  6a60              LDR      r0,[r4,#0x24]         ;810
000048  6301              STR      r1,[r0,#0x30]         ;810
00004a  6821              LDR      r1,[r4,#0]            ;813
00004c  460a              MOV      r2,r1                 ;813
00004e  3234              ADDS     r2,r2,#0x34           ;813
000050  463b              MOV      r3,r7                 ;813
000052  4629              MOV      r1,r5                 ;813
000054  6a60              LDR      r0,[r4,#0x24]         ;813
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6820              LDR      r0,[r4,#0]            ;816
00005c  68c0              LDR      r0,[r0,#0xc]          ;816
00005e  2101              MOVS     r1,#1                 ;816
000060  0249              LSLS     r1,r1,#9              ;816
000062  4308              ORRS     r0,r0,r1              ;816
000064  6821              LDR      r1,[r4,#0]            ;816
000066  60c8              STR      r0,[r1,#0xc]          ;816
000068  e042              B        |L56.240|
                  |L56.106|
00006a  4936              LDR      r1,|L56.324|
00006c  6aa0              LDR      r0,[r4,#0x28]         ;823
00006e  6281              STR      r1,[r0,#0x28]         ;823
000070  4935              LDR      r1,|L56.328|
000072  6aa0              LDR      r0,[r4,#0x28]         ;826
000074  6301              STR      r1,[r0,#0x30]         ;826
000076  6821              LDR      r1,[r4,#0]            ;829
000078  460a              MOV      r2,r1                 ;829
00007a  3238              ADDS     r2,r2,#0x38           ;829
00007c  463b              MOV      r3,r7                 ;829
00007e  4629              MOV      r1,r5                 ;829
000080  6aa0              LDR      r0,[r4,#0x28]         ;829
000082  f7fffffe          BL       HAL_DMA_Start_IT
000086  6820              LDR      r0,[r4,#0]            ;832
000088  68c0              LDR      r0,[r0,#0xc]          ;832
00008a  2101              MOVS     r1,#1                 ;832
00008c  0289              LSLS     r1,r1,#10             ;832
00008e  4308              ORRS     r0,r0,r1              ;832
000090  6821              LDR      r1,[r4,#0]            ;832
000092  60c8              STR      r0,[r1,#0xc]          ;832
000094  e02c              B        |L56.240|
                  |L56.150|
000096  492b              LDR      r1,|L56.324|
000098  6ae0              LDR      r0,[r4,#0x2c]         ;839
00009a  6281              STR      r1,[r0,#0x28]         ;839
00009c  492a              LDR      r1,|L56.328|
00009e  6ae0              LDR      r0,[r4,#0x2c]         ;842
0000a0  6301              STR      r1,[r0,#0x30]         ;842
0000a2  6821              LDR      r1,[r4,#0]            ;845
0000a4  460a              MOV      r2,r1                 ;845
0000a6  323c              ADDS     r2,r2,#0x3c           ;845
0000a8  463b              MOV      r3,r7                 ;845
0000aa  4629              MOV      r1,r5                 ;845
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;845
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  6820              LDR      r0,[r4,#0]            ;848
0000b4  68c0              LDR      r0,[r0,#0xc]          ;848
0000b6  2101              MOVS     r1,#1                 ;848
0000b8  02c9              LSLS     r1,r1,#11             ;848
0000ba  4308              ORRS     r0,r0,r1              ;848
0000bc  6821              LDR      r1,[r4,#0]            ;848
0000be  60c8              STR      r0,[r1,#0xc]          ;848
0000c0  e016              B        |L56.240|
                  |L56.194|
0000c2  4920              LDR      r1,|L56.324|
0000c4  6b20              LDR      r0,[r4,#0x30]         ;855
0000c6  6281              STR      r1,[r0,#0x28]         ;855
0000c8  491f              LDR      r1,|L56.328|
0000ca  6b20              LDR      r0,[r4,#0x30]         ;858
0000cc  6301              STR      r1,[r0,#0x30]         ;858
0000ce  6821              LDR      r1,[r4,#0]            ;861
0000d0  460a              MOV      r2,r1                 ;861
0000d2  3240              ADDS     r2,r2,#0x40           ;861
0000d4  463b              MOV      r3,r7                 ;861
0000d6  4629              MOV      r1,r5                 ;861
0000d8  6b20              LDR      r0,[r4,#0x30]         ;861
0000da  f7fffffe          BL       HAL_DMA_Start_IT
0000de  6820              LDR      r0,[r4,#0]            ;864
0000e0  68c0              LDR      r0,[r0,#0xc]          ;864
0000e2  2101              MOVS     r1,#1                 ;864
0000e4  0309              LSLS     r1,r1,#12             ;864
0000e6  4308              ORRS     r0,r0,r1              ;864
0000e8  6821              LDR      r1,[r4,#0]            ;864
0000ea  60c8              STR      r0,[r1,#0xc]          ;864
0000ec  e000              B        |L56.240|
                  |L56.238|
0000ee  bf00              NOP                            ;869
                  |L56.240|
0000f0  bf00              NOP                            ;818
0000f2  2201              MOVS     r2,#1                 ;873
0000f4  4631              MOV      r1,r6                 ;873
0000f6  6820              LDR      r0,[r4,#0]            ;873
0000f8  f7fffffe          BL       TIM_CCxChannelCmd
0000fc  4913              LDR      r1,|L56.332|
0000fe  6820              LDR      r0,[r4,#0]            ;875
000100  4288              CMP      r0,r1                 ;875
000102  d00b              BEQ      |L56.284|
000104  4912              LDR      r1,|L56.336|
000106  6820              LDR      r0,[r4,#0]            ;875
000108  4288              CMP      r0,r1                 ;875
00010a  d007              BEQ      |L56.284|
00010c  4911              LDR      r1,|L56.340|
00010e  6820              LDR      r0,[r4,#0]            ;875
000110  4288              CMP      r0,r1                 ;875
000112  d003              BEQ      |L56.284|
000114  4910              LDR      r1,|L56.344|
000116  6820              LDR      r0,[r4,#0]            ;875
000118  4288              CMP      r0,r1                 ;875
00011a  d101              BNE      |L56.288|
                  |L56.284|
00011c  2001              MOVS     r0,#1                 ;875
00011e  e000              B        |L56.290|
                  |L56.288|
000120  2000              MOVS     r0,#0                 ;875
                  |L56.290|
000122  2800              CMP      r0,#0                 ;875
000124  d006              BEQ      |L56.308|
000126  6820              LDR      r0,[r4,#0]            ;878
000128  6c40              LDR      r0,[r0,#0x44]         ;878
00012a  2101              MOVS     r1,#1                 ;878
00012c  03c9              LSLS     r1,r1,#15             ;878
00012e  4308              ORRS     r0,r0,r1              ;878
000130  6821              LDR      r1,[r4,#0]            ;878
000132  6448              STR      r0,[r1,#0x44]         ;878
                  |L56.308|
000134  6820              LDR      r0,[r4,#0]            ;882
000136  6800              LDR      r0,[r0,#0]            ;882
000138  2101              MOVS     r1,#1                 ;882
00013a  4308              ORRS     r0,r0,r1              ;882
00013c  6821              LDR      r1,[r4,#0]            ;882
00013e  6008              STR      r0,[r1,#0]            ;882
000140  2000              MOVS     r0,#0                 ;885
000142  e766              B        |L56.18|
;;;887    
                          ENDP

                  |L56.324|
                          DCD      TIM_DMADelayPulseCplt
                  |L56.328|
                          DCD      TIM_DMAError
                  |L56.332|
                          DCD      0x40012c00
                  |L56.336|
                          DCD      0x40014000
                  |L56.340|
                          DCD      0x40014400
                  |L56.344|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_IT PROC
;;;647    */
;;;648    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;649    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;650      /* Check the parameters */
;;;651      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;652    
;;;653      switch (Channel)
000006  2d00              CMP      r5,#0
000008  d006              BEQ      |L57.24|
00000a  2d04              CMP      r5,#4
00000c  d00b              BEQ      |L57.38|
00000e  2d08              CMP      r5,#8
000010  d010              BEQ      |L57.52|
000012  2d0c              CMP      r5,#0xc
000014  d11c              BNE      |L57.80|
000016  e014              B        |L57.66|
                  |L57.24|
;;;654      {
;;;655        case TIM_CHANNEL_1:
;;;656        {
;;;657          /* Enable the TIM Capture/Compare 1 interrupt */
;;;658          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000018  6820              LDR      r0,[r4,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  2102              MOVS     r1,#2
00001e  4308              ORRS     r0,r0,r1
000020  6821              LDR      r1,[r4,#0]
000022  60c8              STR      r0,[r1,#0xc]
;;;659        }
;;;660        break;
000024  e015              B        |L57.82|
                  |L57.38|
;;;661    
;;;662        case TIM_CHANNEL_2:
;;;663        {
;;;664          /* Enable the TIM Capture/Compare 2 interrupt */
;;;665          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000026  6820              LDR      r0,[r4,#0]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  2104              MOVS     r1,#4
00002c  4308              ORRS     r0,r0,r1
00002e  6821              LDR      r1,[r4,#0]
000030  60c8              STR      r0,[r1,#0xc]
;;;666        }
;;;667        break;
000032  e00e              B        |L57.82|
                  |L57.52|
;;;668    
;;;669        case TIM_CHANNEL_3:
;;;670        {
;;;671          /* Enable the TIM Capture/Compare 3 interrupt */
;;;672          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000034  6820              LDR      r0,[r4,#0]
000036  68c0              LDR      r0,[r0,#0xc]
000038  2108              MOVS     r1,#8
00003a  4308              ORRS     r0,r0,r1
00003c  6821              LDR      r1,[r4,#0]
00003e  60c8              STR      r0,[r1,#0xc]
;;;673        }
;;;674        break;
000040  e007              B        |L57.82|
                  |L57.66|
;;;675    
;;;676        case TIM_CHANNEL_4:
;;;677        {
;;;678          /* Enable the TIM Capture/Compare 4 interrupt */
;;;679          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000042  6820              LDR      r0,[r4,#0]
000044  68c0              LDR      r0,[r0,#0xc]
000046  2110              MOVS     r1,#0x10
000048  4308              ORRS     r0,r0,r1
00004a  6821              LDR      r1,[r4,#0]
00004c  60c8              STR      r0,[r1,#0xc]
;;;680        }
;;;681        break;
00004e  e000              B        |L57.82|
                  |L57.80|
;;;682    
;;;683        default:
;;;684        break;
000050  bf00              NOP      
                  |L57.82|
000052  bf00              NOP                            ;660
;;;685      }
;;;686    
;;;687      /* Enable the Output compare channel */
;;;688      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000054  2201              MOVS     r2,#1
000056  4629              MOV      r1,r5
000058  6820              LDR      r0,[r4,#0]
00005a  f7fffffe          BL       TIM_CCxChannelCmd
;;;689    
;;;690      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00005e  4912              LDR      r1,|L57.168|
000060  6820              LDR      r0,[r4,#0]
000062  4288              CMP      r0,r1
000064  d00b              BEQ      |L57.126|
000066  4911              LDR      r1,|L57.172|
000068  6820              LDR      r0,[r4,#0]
00006a  4288              CMP      r0,r1
00006c  d007              BEQ      |L57.126|
00006e  4910              LDR      r1,|L57.176|
000070  6820              LDR      r0,[r4,#0]
000072  4288              CMP      r0,r1
000074  d003              BEQ      |L57.126|
000076  490f              LDR      r1,|L57.180|
000078  6820              LDR      r0,[r4,#0]
00007a  4288              CMP      r0,r1
00007c  d101              BNE      |L57.130|
                  |L57.126|
00007e  2001              MOVS     r0,#1
000080  e000              B        |L57.132|
                  |L57.130|
000082  2000              MOVS     r0,#0
                  |L57.132|
000084  2800              CMP      r0,#0
000086  d006              BEQ      |L57.150|
;;;691      {
;;;692        /* Enable the main output */
;;;693        __HAL_TIM_MOE_ENABLE(htim);
000088  6820              LDR      r0,[r4,#0]
00008a  6c40              LDR      r0,[r0,#0x44]
00008c  2101              MOVS     r1,#1
00008e  03c9              LSLS     r1,r1,#15
000090  4308              ORRS     r0,r0,r1
000092  6821              LDR      r1,[r4,#0]
000094  6448              STR      r0,[r1,#0x44]
                  |L57.150|
;;;694      }
;;;695    
;;;696      /* Enable the Peripheral */
;;;697      __HAL_TIM_ENABLE(htim);
000096  6820              LDR      r0,[r4,#0]
000098  6800              LDR      r0,[r0,#0]
00009a  2101              MOVS     r1,#1
00009c  4308              ORRS     r0,r0,r1
00009e  6821              LDR      r1,[r4,#0]
0000a0  6008              STR      r0,[r1,#0]
;;;698    
;;;699      /* Return function status */
;;;700      return HAL_OK;
0000a2  2000              MOVS     r0,#0
;;;701    }
0000a4  bd30              POP      {r4,r5,pc}
;;;702    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L57.168|
                          DCD      0x40012c00
                  |L57.172|
                          DCD      0x40014000
                  |L57.176|
                          DCD      0x40014400
                  |L57.180|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop PROC
;;;615    */
;;;616    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;617    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;618      /* Check the parameters */
;;;619      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;620    
;;;621      /* Disable the Output compare channel */
;;;622      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;623    
;;;624      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000010  491f              LDR      r1,|L58.144|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d00b              BEQ      |L58.48|
000018  491e              LDR      r1,|L58.148|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d007              BEQ      |L58.48|
000020  491d              LDR      r1,|L58.152|
000022  6820              LDR      r0,[r4,#0]
000024  4288              CMP      r0,r1
000026  d003              BEQ      |L58.48|
000028  491c              LDR      r1,|L58.156|
00002a  6820              LDR      r0,[r4,#0]
00002c  4288              CMP      r0,r1
00002e  d101              BNE      |L58.52|
                  |L58.48|
000030  2001              MOVS     r0,#1
000032  e000              B        |L58.54|
                  |L58.52|
000034  2000              MOVS     r0,#0
                  |L58.54|
000036  2800              CMP      r0,#0
000038  d014              BEQ      |L58.100|
;;;625      {
;;;626        /* Disable the Main Ouput */
;;;627        __HAL_TIM_MOE_DISABLE(htim);
00003a  bf00              NOP      
00003c  6820              LDR      r0,[r4,#0]
00003e  6a00              LDR      r0,[r0,#0x20]
000040  4917              LDR      r1,|L58.160|
000042  4008              ANDS     r0,r0,r1
000044  2800              CMP      r0,#0
000046  d10c              BNE      |L58.98|
000048  6820              LDR      r0,[r4,#0]
00004a  6a00              LDR      r0,[r0,#0x20]
00004c  1089              ASRS     r1,r1,#2
00004e  4008              ANDS     r0,r0,r1
000050  2800              CMP      r0,#0
000052  d106              BNE      |L58.98|
000054  6820              LDR      r0,[r4,#0]
000056  6c40              LDR      r0,[r0,#0x44]
000058  2101              MOVS     r1,#1
00005a  03c9              LSLS     r1,r1,#15
00005c  4388              BICS     r0,r0,r1
00005e  6821              LDR      r1,[r4,#0]
000060  6448              STR      r0,[r1,#0x44]
                  |L58.98|
000062  bf00              NOP      
                  |L58.100|
;;;628      }
;;;629    
;;;630      /* Disable the Peripheral */
;;;631      __HAL_TIM_DISABLE(htim);
000064  bf00              NOP      
000066  6820              LDR      r0,[r4,#0]
000068  6a00              LDR      r0,[r0,#0x20]
00006a  490d              LDR      r1,|L58.160|
00006c  4008              ANDS     r0,r0,r1
00006e  2800              CMP      r0,#0
000070  d10b              BNE      |L58.138|
000072  6820              LDR      r0,[r4,#0]
000074  6a00              LDR      r0,[r0,#0x20]
000076  1089              ASRS     r1,r1,#2
000078  4008              ANDS     r0,r0,r1
00007a  2800              CMP      r0,#0
00007c  d105              BNE      |L58.138|
00007e  6820              LDR      r0,[r4,#0]
000080  6800              LDR      r0,[r0,#0]
000082  0840              LSRS     r0,r0,#1
000084  0040              LSLS     r0,r0,#1
000086  6821              LDR      r1,[r4,#0]
000088  6008              STR      r0,[r1,#0]
                  |L58.138|
00008a  bf00              NOP      
;;;632    
;;;633      /* Return function status */
;;;634      return HAL_OK;
00008c  2000              MOVS     r0,#0
;;;635    }
00008e  bd30              POP      {r4,r5,pc}
;;;636    
                          ENDP

                  |L58.144|
                          DCD      0x40012c00
                  |L58.148|
                          DCD      0x40014000
                  |L58.152|
                          DCD      0x40014400
                  |L58.156|
                          DCD      0x40014800
                  |L58.160|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_DMA PROC
;;;898    */
;;;899    HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;900    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;901      /* Check the parameters */
;;;902      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;903    
;;;904      switch (Channel)
000006  2d00              CMP      r5,#0
000008  d006              BEQ      |L59.24|
00000a  2d04              CMP      r5,#4
00000c  d00c              BEQ      |L59.40|
00000e  2d08              CMP      r5,#8
000010  d012              BEQ      |L59.56|
000012  2d0c              CMP      r5,#0xc
000014  d120              BNE      |L59.88|
000016  e017              B        |L59.72|
                  |L59.24|
;;;905      {
;;;906        case TIM_CHANNEL_1:
;;;907        {
;;;908          /* Disable the TIM Capture/Compare 1 DMA request */
;;;909          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000018  6820              LDR      r0,[r4,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  2101              MOVS     r1,#1
00001e  0249              LSLS     r1,r1,#9
000020  4388              BICS     r0,r0,r1
000022  6821              LDR      r1,[r4,#0]
000024  60c8              STR      r0,[r1,#0xc]
;;;910        }
;;;911        break;
000026  e018              B        |L59.90|
                  |L59.40|
;;;912    
;;;913        case TIM_CHANNEL_2:
;;;914        {
;;;915          /* Disable the TIM Capture/Compare 2 DMA request */
;;;916          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000028  6820              LDR      r0,[r4,#0]
00002a  68c0              LDR      r0,[r0,#0xc]
00002c  2101              MOVS     r1,#1
00002e  0289              LSLS     r1,r1,#10
000030  4388              BICS     r0,r0,r1
000032  6821              LDR      r1,[r4,#0]
000034  60c8              STR      r0,[r1,#0xc]
;;;917        }
;;;918        break;
000036  e010              B        |L59.90|
                  |L59.56|
;;;919    
;;;920        case TIM_CHANNEL_3:
;;;921        {
;;;922          /* Disable the TIM Capture/Compare 3 DMA request */
;;;923          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000038  6820              LDR      r0,[r4,#0]
00003a  68c0              LDR      r0,[r0,#0xc]
00003c  2101              MOVS     r1,#1
00003e  02c9              LSLS     r1,r1,#11
000040  4388              BICS     r0,r0,r1
000042  6821              LDR      r1,[r4,#0]
000044  60c8              STR      r0,[r1,#0xc]
;;;924        }
;;;925        break;
000046  e008              B        |L59.90|
                  |L59.72|
;;;926    
;;;927        case TIM_CHANNEL_4:
;;;928        {
;;;929          /* Disable the TIM Capture/Compare 4 interrupt */
;;;930          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000048  6820              LDR      r0,[r4,#0]
00004a  68c0              LDR      r0,[r0,#0xc]
00004c  2101              MOVS     r1,#1
00004e  0309              LSLS     r1,r1,#12
000050  4388              BICS     r0,r0,r1
000052  6821              LDR      r1,[r4,#0]
000054  60c8              STR      r0,[r1,#0xc]
;;;931        }
;;;932        break;
000056  e000              B        |L59.90|
                  |L59.88|
;;;933    
;;;934        default:
;;;935        break;
000058  bf00              NOP      
                  |L59.90|
00005a  bf00              NOP                            ;911
;;;936      }
;;;937    
;;;938      /* Disable the Output compare channel */
;;;939      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00005c  2200              MOVS     r2,#0
00005e  4629              MOV      r1,r5
000060  6820              LDR      r0,[r4,#0]
000062  f7fffffe          BL       TIM_CCxChannelCmd
;;;940    
;;;941      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000066  4921              LDR      r1,|L59.236|
000068  6820              LDR      r0,[r4,#0]
00006a  4288              CMP      r0,r1
00006c  d00b              BEQ      |L59.134|
00006e  4920              LDR      r1,|L59.240|
000070  6820              LDR      r0,[r4,#0]
000072  4288              CMP      r0,r1
000074  d007              BEQ      |L59.134|
000076  491f              LDR      r1,|L59.244|
000078  6820              LDR      r0,[r4,#0]
00007a  4288              CMP      r0,r1
00007c  d003              BEQ      |L59.134|
00007e  491e              LDR      r1,|L59.248|
000080  6820              LDR      r0,[r4,#0]
000082  4288              CMP      r0,r1
000084  d101              BNE      |L59.138|
                  |L59.134|
000086  2001              MOVS     r0,#1
000088  e000              B        |L59.140|
                  |L59.138|
00008a  2000              MOVS     r0,#0
                  |L59.140|
00008c  2800              CMP      r0,#0
00008e  d014              BEQ      |L59.186|
;;;942      {
;;;943        /* Disable the Main Ouput */
;;;944        __HAL_TIM_MOE_DISABLE(htim);
000090  bf00              NOP      
000092  6820              LDR      r0,[r4,#0]
000094  6a00              LDR      r0,[r0,#0x20]
000096  4919              LDR      r1,|L59.252|
000098  4008              ANDS     r0,r0,r1
00009a  2800              CMP      r0,#0
00009c  d10c              BNE      |L59.184|
00009e  6820              LDR      r0,[r4,#0]
0000a0  6a00              LDR      r0,[r0,#0x20]
0000a2  1089              ASRS     r1,r1,#2
0000a4  4008              ANDS     r0,r0,r1
0000a6  2800              CMP      r0,#0
0000a8  d106              BNE      |L59.184|
0000aa  6820              LDR      r0,[r4,#0]
0000ac  6c40              LDR      r0,[r0,#0x44]
0000ae  2101              MOVS     r1,#1
0000b0  03c9              LSLS     r1,r1,#15
0000b2  4388              BICS     r0,r0,r1
0000b4  6821              LDR      r1,[r4,#0]
0000b6  6448              STR      r0,[r1,#0x44]
                  |L59.184|
0000b8  bf00              NOP      
                  |L59.186|
;;;945      }
;;;946    
;;;947      /* Disable the Peripheral */
;;;948      __HAL_TIM_DISABLE(htim);
0000ba  bf00              NOP      
0000bc  6820              LDR      r0,[r4,#0]
0000be  6a00              LDR      r0,[r0,#0x20]
0000c0  490e              LDR      r1,|L59.252|
0000c2  4008              ANDS     r0,r0,r1
0000c4  2800              CMP      r0,#0
0000c6  d10b              BNE      |L59.224|
0000c8  6820              LDR      r0,[r4,#0]
0000ca  6a00              LDR      r0,[r0,#0x20]
0000cc  1089              ASRS     r1,r1,#2
0000ce  4008              ANDS     r0,r0,r1
0000d0  2800              CMP      r0,#0
0000d2  d105              BNE      |L59.224|
0000d4  6820              LDR      r0,[r4,#0]
0000d6  6800              LDR      r0,[r0,#0]
0000d8  0840              LSRS     r0,r0,#1
0000da  0040              LSLS     r0,r0,#1
0000dc  6821              LDR      r1,[r4,#0]
0000de  6008              STR      r0,[r1,#0]
                  |L59.224|
0000e0  bf00              NOP      
;;;949    
;;;950      /* Change the htim state */
;;;951      htim->State = HAL_TIM_STATE_READY;
0000e2  2101              MOVS     r1,#1
0000e4  203d              MOVS     r0,#0x3d
0000e6  5501              STRB     r1,[r0,r4]
;;;952    
;;;953      /* Return function status */
;;;954      return HAL_OK;
0000e8  2000              MOVS     r0,#0
;;;955    }
0000ea  bd30              POP      {r4,r5,pc}
;;;956    
                          ENDP

                  |L59.236|
                          DCD      0x40012c00
                  |L59.240|
                          DCD      0x40014000
                  |L59.244|
                          DCD      0x40014400
                  |L59.248|
                          DCD      0x40014800
                  |L59.252|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_IT PROC
;;;713    */
;;;714    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;715    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;716      /* Check the parameters */
;;;717      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;718    
;;;719      switch (Channel)
000006  2d00              CMP      r5,#0
000008  d006              BEQ      |L60.24|
00000a  2d04              CMP      r5,#4
00000c  d00b              BEQ      |L60.38|
00000e  2d08              CMP      r5,#8
000010  d010              BEQ      |L60.52|
000012  2d0c              CMP      r5,#0xc
000014  d11c              BNE      |L60.80|
000016  e014              B        |L60.66|
                  |L60.24|
;;;720      {
;;;721        case TIM_CHANNEL_1:
;;;722        {
;;;723          /* Disable the TIM Capture/Compare 1 interrupt */
;;;724          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000018  6820              LDR      r0,[r4,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  2102              MOVS     r1,#2
00001e  4388              BICS     r0,r0,r1
000020  6821              LDR      r1,[r4,#0]
000022  60c8              STR      r0,[r1,#0xc]
;;;725        }
;;;726        break;
000024  e015              B        |L60.82|
                  |L60.38|
;;;727    
;;;728        case TIM_CHANNEL_2:
;;;729        {
;;;730          /* Disable the TIM Capture/Compare 2 interrupt */
;;;731          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000026  6820              LDR      r0,[r4,#0]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  2104              MOVS     r1,#4
00002c  4388              BICS     r0,r0,r1
00002e  6821              LDR      r1,[r4,#0]
000030  60c8              STR      r0,[r1,#0xc]
;;;732        }
;;;733        break;
000032  e00e              B        |L60.82|
                  |L60.52|
;;;734    
;;;735        case TIM_CHANNEL_3:
;;;736        {
;;;737          /* Disable the TIM Capture/Compare 3 interrupt */
;;;738          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000034  6820              LDR      r0,[r4,#0]
000036  68c0              LDR      r0,[r0,#0xc]
000038  2108              MOVS     r1,#8
00003a  4388              BICS     r0,r0,r1
00003c  6821              LDR      r1,[r4,#0]
00003e  60c8              STR      r0,[r1,#0xc]
;;;739        }
;;;740        break;
000040  e007              B        |L60.82|
                  |L60.66|
;;;741    
;;;742        case TIM_CHANNEL_4:
;;;743        {
;;;744          /* Disable the TIM Capture/Compare 4 interrupt */
;;;745          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000042  6820              LDR      r0,[r4,#0]
000044  68c0              LDR      r0,[r0,#0xc]
000046  2110              MOVS     r1,#0x10
000048  4388              BICS     r0,r0,r1
00004a  6821              LDR      r1,[r4,#0]
00004c  60c8              STR      r0,[r1,#0xc]
;;;746        }
;;;747        break;
00004e  e000              B        |L60.82|
                  |L60.80|
;;;748    
;;;749        default:
;;;750        break;
000050  bf00              NOP      
                  |L60.82|
000052  bf00              NOP                            ;726
;;;751      }
;;;752    
;;;753      /* Disable the Output compare channel */
;;;754      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000054  2200              MOVS     r2,#0
000056  4629              MOV      r1,r5
000058  6820              LDR      r0,[r4,#0]
00005a  f7fffffe          BL       TIM_CCxChannelCmd
;;;755    
;;;756      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00005e  4920              LDR      r1,|L60.224|
000060  6820              LDR      r0,[r4,#0]
000062  4288              CMP      r0,r1
000064  d00b              BEQ      |L60.126|
000066  491f              LDR      r1,|L60.228|
000068  6820              LDR      r0,[r4,#0]
00006a  4288              CMP      r0,r1
00006c  d007              BEQ      |L60.126|
00006e  491e              LDR      r1,|L60.232|
000070  6820              LDR      r0,[r4,#0]
000072  4288              CMP      r0,r1
000074  d003              BEQ      |L60.126|
000076  491d              LDR      r1,|L60.236|
000078  6820              LDR      r0,[r4,#0]
00007a  4288              CMP      r0,r1
00007c  d101              BNE      |L60.130|
                  |L60.126|
00007e  2001              MOVS     r0,#1
000080  e000              B        |L60.132|
                  |L60.130|
000082  2000              MOVS     r0,#0
                  |L60.132|
000084  2800              CMP      r0,#0
000086  d014              BEQ      |L60.178|
;;;757      {
;;;758        /* Disable the Main Ouput */
;;;759        __HAL_TIM_MOE_DISABLE(htim);
000088  bf00              NOP      
00008a  6820              LDR      r0,[r4,#0]
00008c  6a00              LDR      r0,[r0,#0x20]
00008e  4918              LDR      r1,|L60.240|
000090  4008              ANDS     r0,r0,r1
000092  2800              CMP      r0,#0
000094  d10c              BNE      |L60.176|
000096  6820              LDR      r0,[r4,#0]
000098  6a00              LDR      r0,[r0,#0x20]
00009a  1089              ASRS     r1,r1,#2
00009c  4008              ANDS     r0,r0,r1
00009e  2800              CMP      r0,#0
0000a0  d106              BNE      |L60.176|
0000a2  6820              LDR      r0,[r4,#0]
0000a4  6c40              LDR      r0,[r0,#0x44]
0000a6  2101              MOVS     r1,#1
0000a8  03c9              LSLS     r1,r1,#15
0000aa  4388              BICS     r0,r0,r1
0000ac  6821              LDR      r1,[r4,#0]
0000ae  6448              STR      r0,[r1,#0x44]
                  |L60.176|
0000b0  bf00              NOP      
                  |L60.178|
;;;760      }
;;;761    
;;;762      /* Disable the Peripheral */
;;;763      __HAL_TIM_DISABLE(htim);
0000b2  bf00              NOP      
0000b4  6820              LDR      r0,[r4,#0]
0000b6  6a00              LDR      r0,[r0,#0x20]
0000b8  490d              LDR      r1,|L60.240|
0000ba  4008              ANDS     r0,r0,r1
0000bc  2800              CMP      r0,#0
0000be  d10b              BNE      |L60.216|
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6a00              LDR      r0,[r0,#0x20]
0000c4  1089              ASRS     r1,r1,#2
0000c6  4008              ANDS     r0,r0,r1
0000c8  2800              CMP      r0,#0
0000ca  d105              BNE      |L60.216|
0000cc  6820              LDR      r0,[r4,#0]
0000ce  6800              LDR      r0,[r0,#0]
0000d0  0840              LSRS     r0,r0,#1
0000d2  0040              LSLS     r0,r0,#1
0000d4  6821              LDR      r1,[r4,#0]
0000d6  6008              STR      r0,[r1,#0]
                  |L60.216|
0000d8  bf00              NOP      
;;;764    
;;;765      /* Return function status */
;;;766      return HAL_OK;
0000da  2000              MOVS     r0,#0
;;;767    }
0000dc  bd30              POP      {r4,r5,pc}
;;;768    
                          ENDP

0000de  0000              DCW      0x0000
                  |L60.224|
                          DCD      0x40012c00
                  |L60.228|
                          DCD      0x40014000
                  |L60.232|
                          DCD      0x40014400
                  |L60.236|
                          DCD      0x40014800
                  |L60.240|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3196     */
;;;3197   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;3198   {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;3199     TIM_OC_InitTypeDef temp1;
;;;3200   
;;;3201     /* Check the parameters */
;;;3202     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3203     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3204   
;;;3205     if(OutputChannel != InputChannel)
00000c  42be              CMP      r6,r7
00000e  d07d              BEQ      |L61.268|
;;;3206     {
;;;3207     __HAL_LOCK(htim);
000010  bf00              NOP      
000012  203c              MOVS     r0,#0x3c
000014  5d00              LDRB     r0,[r0,r4]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L61.32|
00001a  2002              MOVS     r0,#2
                  |L61.28|
;;;3208   
;;;3209     htim->State = HAL_TIM_STATE_BUSY;
;;;3210   
;;;3211     /* Extract the Ouput compare configuration from sConfig structure */
;;;3212     temp1.OCMode = sConfig->OCMode;
;;;3213     temp1.Pulse = sConfig->Pulse;
;;;3214     temp1.OCPolarity = sConfig->OCPolarity;
;;;3215     temp1.OCNPolarity = sConfig->OCNPolarity;
;;;3216     temp1.OCIdleState = sConfig->OCIdleState;
;;;3217     temp1.OCNIdleState = sConfig->OCNIdleState;
;;;3218   
;;;3219       switch (OutputChannel)
;;;3220     {
;;;3221       case TIM_CHANNEL_1:
;;;3222       {
;;;3223           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3224   
;;;3225         TIM_OC1_SetConfig(htim->Instance, &temp1);
;;;3226       }
;;;3227       break;
;;;3228       case TIM_CHANNEL_2:
;;;3229       {
;;;3230           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3231   
;;;3232         TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3233       }
;;;3234       break;
;;;3235       default:
;;;3236       break;
;;;3237     }
;;;3238     switch (InputChannel)
;;;3239     {
;;;3240       case TIM_CHANNEL_1:
;;;3241       {
;;;3242         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3243   
;;;3244         TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3245                           sConfig->ICSelection, sConfig->ICFilter);
;;;3246   
;;;3247         /* Reset the IC1PSC Bits */
;;;3248       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3249   
;;;3250         /* Select the Trigger source */
;;;3251           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3252         htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3253   
;;;3254         /* Select the Slave Mode */
;;;3255           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3256         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3257       }
;;;3258       break;
;;;3259       case TIM_CHANNEL_2:
;;;3260       {
;;;3261         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3262   
;;;3263         TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3264                    sConfig->ICSelection, sConfig->ICFilter);
;;;3265   
;;;3266         /* Reset the IC2PSC Bits */
;;;3267           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3268   
;;;3269         /* Select the Trigger source */
;;;3270           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3271         htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3272   
;;;3273         /* Select the Slave Mode */
;;;3274           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3275         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3276       }
;;;3277       break;
;;;3278   
;;;3279       default:
;;;3280       break;
;;;3281     }
;;;3282   
;;;3283     htim->State = HAL_TIM_STATE_READY;
;;;3284   
;;;3285     __HAL_UNLOCK(htim);
;;;3286   
;;;3287     return HAL_OK;
;;;3288   }
;;;3289     else
;;;3290     {
;;;3291       return HAL_ERROR;
;;;3292     }
;;;3293   }
00001c  b009              ADD      sp,sp,#0x24
00001e  bdf0              POP      {r4-r7,pc}
                  |L61.32|
000020  2101              MOVS     r1,#1                 ;3207
000022  203c              MOVS     r0,#0x3c              ;3207
000024  5501              STRB     r1,[r0,r4]            ;3207
000026  bf00              NOP                            ;3207
000028  2102              MOVS     r1,#2                 ;3209
00002a  203d              MOVS     r0,#0x3d              ;3209
00002c  5501              STRB     r1,[r0,r4]            ;3209
00002e  6828              LDR      r0,[r5,#0]            ;3212
000030  9002              STR      r0,[sp,#8]            ;3212
000032  6868              LDR      r0,[r5,#4]            ;3213
000034  9003              STR      r0,[sp,#0xc]          ;3213
000036  68a8              LDR      r0,[r5,#8]            ;3214
000038  9004              STR      r0,[sp,#0x10]         ;3214
00003a  68e8              LDR      r0,[r5,#0xc]          ;3215
00003c  9005              STR      r0,[sp,#0x14]         ;3215
00003e  6928              LDR      r0,[r5,#0x10]         ;3216
000040  9007              STR      r0,[sp,#0x1c]         ;3216
000042  6968              LDR      r0,[r5,#0x14]         ;3217
000044  9008              STR      r0,[sp,#0x20]         ;3217
000046  2e00              CMP      r6,#0                 ;3219
000048  d002              BEQ      |L61.80|
00004a  2e04              CMP      r6,#4                 ;3219
00004c  d10a              BNE      |L61.100|
00004e  e004              B        |L61.90|
                  |L61.80|
000050  a902              ADD      r1,sp,#8              ;3225
000052  6820              LDR      r0,[r4,#0]            ;3225
000054  f7fffffe          BL       TIM_OC1_SetConfig
000058  e005              B        |L61.102|
                  |L61.90|
00005a  a902              ADD      r1,sp,#8              ;3232
00005c  6820              LDR      r0,[r4,#0]            ;3232
00005e  f7fffffe          BL       TIM_OC2_SetConfig
000062  e000              B        |L61.102|
                  |L61.100|
000064  bf00              NOP                            ;3236
                  |L61.102|
000066  bf00              NOP                            ;3227
000068  2f00              CMP      r7,#0                 ;3238
00006a  d002              BEQ      |L61.114|
00006c  2f04              CMP      r7,#4                 ;3238
00006e  d14e              BNE      |L61.270|
000070  e025              B        |L61.190|
                  |L61.114|
000072  6a2b              LDR      r3,[r5,#0x20]         ;3244
000074  69ea              LDR      r2,[r5,#0x1c]         ;3244
000076  69a9              LDR      r1,[r5,#0x18]         ;3244
000078  6820              LDR      r0,[r4,#0]            ;3244
00007a  9001              STR      r0,[sp,#4]            ;3244
00007c  f7fffffe          BL       TIM_TI1_SetConfig
000080  6820              LDR      r0,[r4,#0]            ;3248
000082  6980              LDR      r0,[r0,#0x18]         ;3248
000084  210c              MOVS     r1,#0xc               ;3248
000086  4388              BICS     r0,r0,r1              ;3248
000088  6821              LDR      r1,[r4,#0]            ;3248
00008a  6188              STR      r0,[r1,#0x18]         ;3248
00008c  6820              LDR      r0,[r4,#0]            ;3251
00008e  6880              LDR      r0,[r0,#8]            ;3251
000090  2170              MOVS     r1,#0x70              ;3251
000092  4388              BICS     r0,r0,r1              ;3251
000094  6821              LDR      r1,[r4,#0]            ;3251
000096  6088              STR      r0,[r1,#8]            ;3251
000098  6820              LDR      r0,[r4,#0]            ;3252
00009a  6880              LDR      r0,[r0,#8]            ;3252
00009c  2150              MOVS     r1,#0x50              ;3252
00009e  4308              ORRS     r0,r0,r1              ;3252
0000a0  6821              LDR      r1,[r4,#0]            ;3252
0000a2  6088              STR      r0,[r1,#8]            ;3252
0000a4  6820              LDR      r0,[r4,#0]            ;3255
0000a6  6880              LDR      r0,[r0,#8]            ;3255
0000a8  08c0              LSRS     r0,r0,#3              ;3255
0000aa  00c0              LSLS     r0,r0,#3              ;3255
0000ac  6821              LDR      r1,[r4,#0]            ;3255
0000ae  6088              STR      r0,[r1,#8]            ;3255
0000b0  6820              LDR      r0,[r4,#0]            ;3256
0000b2  6880              LDR      r0,[r0,#8]            ;3256
0000b4  2106              MOVS     r1,#6                 ;3256
0000b6  4308              ORRS     r0,r0,r1              ;3256
0000b8  6821              LDR      r1,[r4,#0]            ;3256
0000ba  6088              STR      r0,[r1,#8]            ;3256
0000bc  e028              B        |L61.272|
                  |L61.190|
0000be  6a2b              LDR      r3,[r5,#0x20]         ;3263
0000c0  69ea              LDR      r2,[r5,#0x1c]         ;3263
0000c2  69a9              LDR      r1,[r5,#0x18]         ;3263
0000c4  6820              LDR      r0,[r4,#0]            ;3263
0000c6  9001              STR      r0,[sp,#4]            ;3263
0000c8  f7fffffe          BL       TIM_TI2_SetConfig
0000cc  6820              LDR      r0,[r4,#0]            ;3267
0000ce  6980              LDR      r0,[r0,#0x18]         ;3267
0000d0  2103              MOVS     r1,#3                 ;3267
0000d2  0289              LSLS     r1,r1,#10             ;3267
0000d4  4388              BICS     r0,r0,r1              ;3267
0000d6  6821              LDR      r1,[r4,#0]            ;3267
0000d8  6188              STR      r0,[r1,#0x18]         ;3267
0000da  6820              LDR      r0,[r4,#0]            ;3270
0000dc  6880              LDR      r0,[r0,#8]            ;3270
0000de  2170              MOVS     r1,#0x70              ;3270
0000e0  4388              BICS     r0,r0,r1              ;3270
0000e2  6821              LDR      r1,[r4,#0]            ;3270
0000e4  6088              STR      r0,[r1,#8]            ;3270
0000e6  6820              LDR      r0,[r4,#0]            ;3271
0000e8  6880              LDR      r0,[r0,#8]            ;3271
0000ea  2160              MOVS     r1,#0x60              ;3271
0000ec  4308              ORRS     r0,r0,r1              ;3271
0000ee  6821              LDR      r1,[r4,#0]            ;3271
0000f0  6088              STR      r0,[r1,#8]            ;3271
0000f2  6820              LDR      r0,[r4,#0]            ;3274
0000f4  6880              LDR      r0,[r0,#8]            ;3274
0000f6  08c0              LSRS     r0,r0,#3              ;3274
0000f8  00c0              LSLS     r0,r0,#3              ;3274
0000fa  6821              LDR      r1,[r4,#0]            ;3274
0000fc  6088              STR      r0,[r1,#8]            ;3274
0000fe  6820              LDR      r0,[r4,#0]            ;3275
000100  6880              LDR      r0,[r0,#8]            ;3275
000102  2106              MOVS     r1,#6                 ;3275
000104  4308              ORRS     r0,r0,r1              ;3275
000106  6821              LDR      r1,[r4,#0]            ;3275
000108  6088              STR      r0,[r1,#8]            ;3275
00010a  e001              B        |L61.272|
                  |L61.268|
00010c  e00b              B        |L61.294|
                  |L61.270|
00010e  bf00              NOP                            ;3280
                  |L61.272|
000110  bf00              NOP                            ;3258
000112  2101              MOVS     r1,#1                 ;3283
000114  203d              MOVS     r0,#0x3d              ;3283
000116  5501              STRB     r1,[r0,r4]            ;3283
000118  bf00              NOP                            ;3285
00011a  2100              MOVS     r1,#0                 ;3285
00011c  203c              MOVS     r0,#0x3c              ;3285
00011e  5501              STRB     r1,[r0,r4]            ;3285
000120  bf00              NOP                            ;3285
000122  2000              MOVS     r0,#0                 ;3287
000124  e77a              B        |L61.28|
                  |L61.294|
000126  2001              MOVS     r0,#1                 ;3291
000128  e778              B        |L61.28|
;;;3294   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_DeInit PROC
;;;2020     */
;;;2021   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2022   {
000002  4604              MOV      r4,r0
;;;2023     /* Check the parameters */
;;;2024     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2025   
;;;2026     htim->State = HAL_TIM_STATE_BUSY;
000004  2102              MOVS     r1,#2
000006  203d              MOVS     r0,#0x3d
000008  5501              STRB     r1,[r0,r4]
;;;2027   
;;;2028     /* Disable the TIM Peripheral Clock */
;;;2029     __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  490e              LDR      r1,|L62.76|
000012  4008              ANDS     r0,r0,r1
000014  2800              CMP      r0,#0
000016  d10b              BNE      |L62.48|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  2800              CMP      r0,#0
000022  d105              BNE      |L62.48|
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  0840              LSRS     r0,r0,#1
00002a  0040              LSLS     r0,r0,#1
00002c  6821              LDR      r1,[r4,#0]
00002e  6008              STR      r0,[r1,#0]
                  |L62.48|
000030  bf00              NOP      
;;;2030   
;;;2031     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2032     HAL_TIM_OnePulse_MspDeInit(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2033   
;;;2034     /* Change TIM state */
;;;2035     htim->State = HAL_TIM_STATE_RESET;
000038  2100              MOVS     r1,#0
00003a  203d              MOVS     r0,#0x3d
00003c  5501              STRB     r1,[r0,r4]
;;;2036   
;;;2037     /* Release Lock */
;;;2038     __HAL_UNLOCK(htim);
00003e  bf00              NOP      
000040  203c              MOVS     r0,#0x3c
000042  5501              STRB     r1,[r0,r4]
000044  bf00              NOP      
;;;2039   
;;;2040     return HAL_OK;
000046  2000              MOVS     r0,#0
;;;2041   }
000048  bd10              POP      {r4,pc}
;;;2042   
                          ENDP

00004a  0000              DCW      0x0000
                  |L62.76|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;4532     */
;;;4533   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4534   {
;;;4535     return htim->State;
000002  203d              MOVS     r0,#0x3d
000004  5c40              LDRB     r0,[r0,r1]
;;;4536   }
000006  4770              BX       lr
;;;4537   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;1973     */
;;;1974   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  b570              PUSH     {r4-r6,lr}
;;;1975   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1976     /* Check the TIM handle allocation */
;;;1977     if(htim == NULL)
000006  2c00              CMP      r4,#0
000008  d101              BNE      |L64.14|
;;;1978     {
;;;1979       return HAL_ERROR;
00000a  2001              MOVS     r0,#1
                  |L64.12|
;;;1980     }
;;;1981   
;;;1982     /* Check the parameters */
;;;1983     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1984     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1985     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1986     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;1987     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1988   
;;;1989     if(htim->State == HAL_TIM_STATE_RESET)
;;;1990     {
;;;1991       /* Allocate lock resource and initialize it */
;;;1992       htim->Lock = HAL_UNLOCKED;
;;;1993   
;;;1994       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1995       HAL_TIM_OnePulse_MspInit(htim);
;;;1996     }
;;;1997   
;;;1998     /* Set the TIM state */
;;;1999     htim->State= HAL_TIM_STATE_BUSY;
;;;2000   
;;;2001     /* Configure the Time base in the One Pulse Mode */
;;;2002     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2003   
;;;2004     /* Reset the OPM Bit */
;;;2005     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;2006   
;;;2007     /* Configure the OPM Mode */
;;;2008     htim->Instance->CR1 |= OnePulseMode;
;;;2009   
;;;2010     /* Initialize the TIM state*/
;;;2011     htim->State= HAL_TIM_STATE_READY;
;;;2012   
;;;2013     return HAL_OK;
;;;2014   }
00000c  bd70              POP      {r4-r6,pc}
                  |L64.14|
00000e  203d              MOVS     r0,#0x3d              ;1989
000010  5d00              LDRB     r0,[r0,r4]            ;1989
000012  2800              CMP      r0,#0                 ;1989
000014  d105              BNE      |L64.34|
000016  2100              MOVS     r1,#0                 ;1992
000018  203c              MOVS     r0,#0x3c              ;1992
00001a  5501              STRB     r1,[r0,r4]            ;1992
00001c  4620              MOV      r0,r4                 ;1995
00001e  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L64.34|
000022  2102              MOVS     r1,#2                 ;1999
000024  203d              MOVS     r0,#0x3d              ;1999
000026  5501              STRB     r1,[r0,r4]            ;1999
000028  1d21              ADDS     r1,r4,#4              ;2002
00002a  6820              LDR      r0,[r4,#0]            ;2002
00002c  f7fffffe          BL       TIM_Base_SetConfig
000030  6820              LDR      r0,[r4,#0]            ;2005
000032  6800              LDR      r0,[r0,#0]            ;2005
000034  2108              MOVS     r1,#8                 ;2005
000036  4388              BICS     r0,r0,r1              ;2005
000038  6821              LDR      r1,[r4,#0]            ;2005
00003a  6008              STR      r0,[r1,#0]            ;2005
00003c  6820              LDR      r0,[r4,#0]            ;2008
00003e  6800              LDR      r0,[r0,#0]            ;2008
000040  4328              ORRS     r0,r0,r5              ;2008
000042  6821              LDR      r1,[r4,#0]            ;2008
000044  6008              STR      r0,[r1,#0]            ;2008
000046  2101              MOVS     r1,#1                 ;2011
000048  203d              MOVS     r0,#0x3d              ;2011
00004a  5501              STRB     r1,[r0,r4]            ;2011
00004c  2000              MOVS     r0,#0                 ;2013
00004e  e7dd              B        |L64.12|
;;;2015   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2062     */
;;;2063   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2064   {
;;;2065     /* Prevent unused argument(s) compilation warning */
;;;2066     UNUSED(htim);
;;;2067   
;;;2068     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2069               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2070      */
;;;2071   }
;;;2072   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2047     */
;;;2048   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2049   {
;;;2050     /* Prevent unused argument(s) compilation warning */
;;;2051     UNUSED(htim);
;;;2052   
;;;2053     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2054               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2055      */
;;;2056   }
;;;2057   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start PROC
;;;2081   */
;;;2082   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2083   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2084     /* Enable the Capture compare and the Input Capture channels 
;;;2085       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2086       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2087       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2088       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2089   
;;;2090       No need to enable the counter, it's enabled automatically by hardware 
;;;2091       (the counter starts in response to a stimulus and generate a pulse */
;;;2092   
;;;2093     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  2100              MOVS     r1,#0
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2094     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000010  2201              MOVS     r2,#1
000012  2104              MOVS     r1,#4
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;2095   
;;;2096     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00001a  490f              LDR      r1,|L67.88|
00001c  6820              LDR      r0,[r4,#0]
00001e  4288              CMP      r0,r1
000020  d00b              BEQ      |L67.58|
000022  490e              LDR      r1,|L67.92|
000024  6820              LDR      r0,[r4,#0]
000026  4288              CMP      r0,r1
000028  d007              BEQ      |L67.58|
00002a  490d              LDR      r1,|L67.96|
00002c  6820              LDR      r0,[r4,#0]
00002e  4288              CMP      r0,r1
000030  d003              BEQ      |L67.58|
000032  490c              LDR      r1,|L67.100|
000034  6820              LDR      r0,[r4,#0]
000036  4288              CMP      r0,r1
000038  d101              BNE      |L67.62|
                  |L67.58|
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L67.64|
                  |L67.62|
00003e  2000              MOVS     r0,#0
                  |L67.64|
000040  2800              CMP      r0,#0
000042  d006              BEQ      |L67.82|
;;;2097     {
;;;2098       /* Enable the main output */
;;;2099       __HAL_TIM_MOE_ENABLE(htim);
000044  6820              LDR      r0,[r4,#0]
000046  6c40              LDR      r0,[r0,#0x44]
000048  2101              MOVS     r1,#1
00004a  03c9              LSLS     r1,r1,#15
00004c  4308              ORRS     r0,r0,r1
00004e  6821              LDR      r1,[r4,#0]
000050  6448              STR      r0,[r1,#0x44]
                  |L67.82|
;;;2100     }
;;;2101   
;;;2102     /* Return function status */
;;;2103     return HAL_OK;
000052  2000              MOVS     r0,#0
;;;2104   }
000054  bd30              POP      {r4,r5,pc}
;;;2105   
                          ENDP

000056  0000              DCW      0x0000
                  |L67.88|
                          DCD      0x40012c00
                  |L67.92|
                          DCD      0x40014000
                  |L67.96|
                          DCD      0x40014400
                  |L67.100|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2147   */
;;;2148   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2149   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2150     /* Enable the Capture compare and the Input Capture channels 
;;;2151       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2152       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2153       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2154       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2155   
;;;2156       No need to enable the counter, it's enabled automatically by hardware 
;;;2157       (the counter starts in response to a stimulus and generate a pulse */
;;;2158   
;;;2159     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2160     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  2102              MOVS     r1,#2
00000c  4308              ORRS     r0,r0,r1
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;2161   
;;;2162     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2163     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  2104              MOVS     r1,#4
000018  4308              ORRS     r0,r0,r1
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;2164   
;;;2165     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00001e  2201              MOVS     r2,#1
000020  2100              MOVS     r1,#0
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       TIM_CCxChannelCmd
;;;2166     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000028  2201              MOVS     r2,#1
00002a  2104              MOVS     r1,#4
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2167   
;;;2168     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000032  490f              LDR      r1,|L68.112|
000034  6820              LDR      r0,[r4,#0]
000036  4288              CMP      r0,r1
000038  d00b              BEQ      |L68.82|
00003a  490e              LDR      r1,|L68.116|
00003c  6820              LDR      r0,[r4,#0]
00003e  4288              CMP      r0,r1
000040  d007              BEQ      |L68.82|
000042  490d              LDR      r1,|L68.120|
000044  6820              LDR      r0,[r4,#0]
000046  4288              CMP      r0,r1
000048  d003              BEQ      |L68.82|
00004a  490c              LDR      r1,|L68.124|
00004c  6820              LDR      r0,[r4,#0]
00004e  4288              CMP      r0,r1
000050  d101              BNE      |L68.86|
                  |L68.82|
000052  2001              MOVS     r0,#1
000054  e000              B        |L68.88|
                  |L68.86|
000056  2000              MOVS     r0,#0
                  |L68.88|
000058  2800              CMP      r0,#0
00005a  d006              BEQ      |L68.106|
;;;2169     {
;;;2170       /* Enable the main output */
;;;2171       __HAL_TIM_MOE_ENABLE(htim);
00005c  6820              LDR      r0,[r4,#0]
00005e  6c40              LDR      r0,[r0,#0x44]
000060  2101              MOVS     r1,#1
000062  03c9              LSLS     r1,r1,#15
000064  4308              ORRS     r0,r0,r1
000066  6821              LDR      r1,[r4,#0]
000068  6448              STR      r0,[r1,#0x44]
                  |L68.106|
;;;2172     }
;;;2173   
;;;2174     /* Return function status */
;;;2175     return HAL_OK;
00006a  2000              MOVS     r0,#0
;;;2176   }
00006c  bd30              POP      {r4,r5,pc}
;;;2177   
                          ENDP

00006e  0000              DCW      0x0000
                  |L68.112|
                          DCD      0x40012c00
                  |L68.116|
                          DCD      0x40014000
                  |L68.120|
                          DCD      0x40014400
                  |L68.124|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop PROC
;;;2114   */
;;;2115   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2116   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2117     /* Disable the Capture compare and the Input Capture channels 
;;;2118     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2119     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2120     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2121     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2122   
;;;2123     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4611              MOV      r1,r2
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2124     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000010  2200              MOVS     r2,#0
000012  2104              MOVS     r1,#4
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;2125   
;;;2126     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00001a  4920              LDR      r1,|L69.156|
00001c  6820              LDR      r0,[r4,#0]
00001e  4288              CMP      r0,r1
000020  d00b              BEQ      |L69.58|
000022  491f              LDR      r1,|L69.160|
000024  6820              LDR      r0,[r4,#0]
000026  4288              CMP      r0,r1
000028  d007              BEQ      |L69.58|
00002a  491e              LDR      r1,|L69.164|
00002c  6820              LDR      r0,[r4,#0]
00002e  4288              CMP      r0,r1
000030  d003              BEQ      |L69.58|
000032  491d              LDR      r1,|L69.168|
000034  6820              LDR      r0,[r4,#0]
000036  4288              CMP      r0,r1
000038  d101              BNE      |L69.62|
                  |L69.58|
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L69.64|
                  |L69.62|
00003e  2000              MOVS     r0,#0
                  |L69.64|
000040  2800              CMP      r0,#0
000042  d014              BEQ      |L69.110|
;;;2127     {
;;;2128       /* Disable the Main Ouput */
;;;2129       __HAL_TIM_MOE_DISABLE(htim);
000044  bf00              NOP      
000046  6820              LDR      r0,[r4,#0]
000048  6a00              LDR      r0,[r0,#0x20]
00004a  4918              LDR      r1,|L69.172|
00004c  4008              ANDS     r0,r0,r1
00004e  2800              CMP      r0,#0
000050  d10c              BNE      |L69.108|
000052  6820              LDR      r0,[r4,#0]
000054  6a00              LDR      r0,[r0,#0x20]
000056  1089              ASRS     r1,r1,#2
000058  4008              ANDS     r0,r0,r1
00005a  2800              CMP      r0,#0
00005c  d106              BNE      |L69.108|
00005e  6820              LDR      r0,[r4,#0]
000060  6c40              LDR      r0,[r0,#0x44]
000062  2101              MOVS     r1,#1
000064  03c9              LSLS     r1,r1,#15
000066  4388              BICS     r0,r0,r1
000068  6821              LDR      r1,[r4,#0]
00006a  6448              STR      r0,[r1,#0x44]
                  |L69.108|
00006c  bf00              NOP      
                  |L69.110|
;;;2130     }
;;;2131   
;;;2132     /* Disable the Peripheral */
;;;2133     __HAL_TIM_DISABLE(htim);
00006e  bf00              NOP      
000070  6820              LDR      r0,[r4,#0]
000072  6a00              LDR      r0,[r0,#0x20]
000074  490d              LDR      r1,|L69.172|
000076  4008              ANDS     r0,r0,r1
000078  2800              CMP      r0,#0
00007a  d10b              BNE      |L69.148|
00007c  6820              LDR      r0,[r4,#0]
00007e  6a00              LDR      r0,[r0,#0x20]
000080  1089              ASRS     r1,r1,#2
000082  4008              ANDS     r0,r0,r1
000084  2800              CMP      r0,#0
000086  d105              BNE      |L69.148|
000088  6820              LDR      r0,[r4,#0]
00008a  6800              LDR      r0,[r0,#0]
00008c  0840              LSRS     r0,r0,#1
00008e  0040              LSLS     r0,r0,#1
000090  6821              LDR      r1,[r4,#0]
000092  6008              STR      r0,[r1,#0]
                  |L69.148|
000094  bf00              NOP      
;;;2134   
;;;2135     /* Return function status */
;;;2136     return HAL_OK;
000096  2000              MOVS     r0,#0
;;;2137   }
000098  bd30              POP      {r4,r5,pc}
;;;2138   
                          ENDP

00009a  0000              DCW      0x0000
                  |L69.156|
                          DCD      0x40012c00
                  |L69.160|
                          DCD      0x40014000
                  |L69.164|
                          DCD      0x40014400
                  |L69.168|
                          DCD      0x40014800
                  |L69.172|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2186   */
;;;2187   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2188   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2189     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2190     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  2102              MOVS     r1,#2
00000c  4388              BICS     r0,r0,r1
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;2191   
;;;2192     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2193     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  2104              MOVS     r1,#4
000018  4388              BICS     r0,r0,r1
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;2194   
;;;2195     /* Disable the Capture compare and the Input Capture channels 
;;;2196     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2197     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2198     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2199     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2200     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00001e  2200              MOVS     r2,#0
000020  4611              MOV      r1,r2
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       TIM_CCxChannelCmd
;;;2201     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000028  2200              MOVS     r2,#0
00002a  2104              MOVS     r1,#4
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2202   
;;;2203     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000032  4920              LDR      r1,|L70.180|
000034  6820              LDR      r0,[r4,#0]
000036  4288              CMP      r0,r1
000038  d00b              BEQ      |L70.82|
00003a  491f              LDR      r1,|L70.184|
00003c  6820              LDR      r0,[r4,#0]
00003e  4288              CMP      r0,r1
000040  d007              BEQ      |L70.82|
000042  491e              LDR      r1,|L70.188|
000044  6820              LDR      r0,[r4,#0]
000046  4288              CMP      r0,r1
000048  d003              BEQ      |L70.82|
00004a  491d              LDR      r1,|L70.192|
00004c  6820              LDR      r0,[r4,#0]
00004e  4288              CMP      r0,r1
000050  d101              BNE      |L70.86|
                  |L70.82|
000052  2001              MOVS     r0,#1
000054  e000              B        |L70.88|
                  |L70.86|
000056  2000              MOVS     r0,#0
                  |L70.88|
000058  2800              CMP      r0,#0
00005a  d014              BEQ      |L70.134|
;;;2204     {
;;;2205       /* Disable the Main Ouput */
;;;2206       __HAL_TIM_MOE_DISABLE(htim);
00005c  bf00              NOP      
00005e  6820              LDR      r0,[r4,#0]
000060  6a00              LDR      r0,[r0,#0x20]
000062  4918              LDR      r1,|L70.196|
000064  4008              ANDS     r0,r0,r1
000066  2800              CMP      r0,#0
000068  d10c              BNE      |L70.132|
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  1089              ASRS     r1,r1,#2
000070  4008              ANDS     r0,r0,r1
000072  2800              CMP      r0,#0
000074  d106              BNE      |L70.132|
000076  6820              LDR      r0,[r4,#0]
000078  6c40              LDR      r0,[r0,#0x44]
00007a  2101              MOVS     r1,#1
00007c  03c9              LSLS     r1,r1,#15
00007e  4388              BICS     r0,r0,r1
000080  6821              LDR      r1,[r4,#0]
000082  6448              STR      r0,[r1,#0x44]
                  |L70.132|
000084  bf00              NOP      
                  |L70.134|
;;;2207     }
;;;2208   
;;;2209     /* Disable the Peripheral */
;;;2210      __HAL_TIM_DISABLE(htim);
000086  bf00              NOP      
000088  6820              LDR      r0,[r4,#0]
00008a  6a00              LDR      r0,[r0,#0x20]
00008c  490d              LDR      r1,|L70.196|
00008e  4008              ANDS     r0,r0,r1
000090  2800              CMP      r0,#0
000092  d10b              BNE      |L70.172|
000094  6820              LDR      r0,[r4,#0]
000096  6a00              LDR      r0,[r0,#0x20]
000098  1089              ASRS     r1,r1,#2
00009a  4008              ANDS     r0,r0,r1
00009c  2800              CMP      r0,#0
00009e  d105              BNE      |L70.172|
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6800              LDR      r0,[r0,#0]
0000a4  0840              LSRS     r0,r0,#1
0000a6  0040              LSLS     r0,r0,#1
0000a8  6821              LDR      r1,[r4,#0]
0000aa  6008              STR      r0,[r1,#0]
                  |L70.172|
0000ac  bf00              NOP      
;;;2211   
;;;2212     /* Return function status */
;;;2213     return HAL_OK;
0000ae  2000              MOVS     r0,#0
;;;2214   }
0000b0  bd30              POP      {r4,r5,pc}
;;;2215   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L70.180|
                          DCD      0x40012c00
                  |L70.184|
                          DCD      0x40014000
                  |L70.188|
                          DCD      0x40014400
                  |L70.192|
                          DCD      0x40014800
                  |L70.196|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3096     */
;;;3097   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3098   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3099     __HAL_LOCK(htim);
000008  bf00              NOP      
00000a  203c              MOVS     r0,#0x3c
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L71.22|
000012  2002              MOVS     r0,#2
                  |L71.20|
;;;3100   
;;;3101     /* Check the parameters */
;;;3102     assert_param(IS_TIM_CHANNELS(Channel));
;;;3103     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3104     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3105     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;3106   
;;;3107     htim->State = HAL_TIM_STATE_BUSY;
;;;3108   
;;;3109     switch (Channel)
;;;3110     {
;;;3111       case TIM_CHANNEL_1:
;;;3112       {
;;;3113         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3114         /* Configure the Channel 1 in PWM mode */
;;;3115         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3116   
;;;3117         /* Set the Preload enable bit for channel1 */
;;;3118         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3119   
;;;3120         /* Configure the Output Fast mode */
;;;3121         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3122         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3123       }
;;;3124       break;
;;;3125   
;;;3126       case TIM_CHANNEL_2:
;;;3127       {
;;;3128         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3129         /* Configure the Channel 2 in PWM mode */
;;;3130         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3131   
;;;3132         /* Set the Preload enable bit for channel2 */
;;;3133         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3134   
;;;3135         /* Configure the Output Fast mode */
;;;3136         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3137         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
;;;3138       }
;;;3139       break;
;;;3140   
;;;3141       case TIM_CHANNEL_3:
;;;3142       {
;;;3143         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3144         /* Configure the Channel 3 in PWM mode */
;;;3145         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3146   
;;;3147         /* Set the Preload enable bit for channel3 */
;;;3148         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3149   
;;;3150        /* Configure the Output Fast mode */
;;;3151         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3152         htim->Instance->CCMR2 |= sConfig->OCFastMode;
;;;3153       }
;;;3154       break;
;;;3155   
;;;3156       case TIM_CHANNEL_4:
;;;3157       {
;;;3158         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3159         /* Configure the Channel 4 in PWM mode */
;;;3160         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3161   
;;;3162         /* Set the Preload enable bit for channel4 */
;;;3163         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3164   
;;;3165        /* Configure the Output Fast mode */
;;;3166         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3167         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
;;;3168       }
;;;3169       break;
;;;3170   
;;;3171       default:
;;;3172       break;
;;;3173     }
;;;3174   
;;;3175     htim->State = HAL_TIM_STATE_READY;
;;;3176   
;;;3177     __HAL_UNLOCK(htim);
;;;3178   
;;;3179     return HAL_OK;
;;;3180   }
000014  bd70              POP      {r4-r6,pc}
                  |L71.22|
000016  2101              MOVS     r1,#1                 ;3099
000018  203c              MOVS     r0,#0x3c              ;3099
00001a  5501              STRB     r1,[r0,r4]            ;3099
00001c  bf00              NOP                            ;3099
00001e  2102              MOVS     r1,#2                 ;3107
000020  203d              MOVS     r0,#0x3d              ;3107
000022  5501              STRB     r1,[r0,r4]            ;3107
000024  2e00              CMP      r6,#0                 ;3109
000026  d006              BEQ      |L71.54|
000028  2e04              CMP      r6,#4                 ;3109
00002a  d01b              BEQ      |L71.100|
00002c  2e08              CMP      r6,#8                 ;3109
00002e  d033              BEQ      |L71.152|
000030  2e0c              CMP      r6,#0xc               ;3109
000032  d162              BNE      |L71.250|
000034  e047              B        |L71.198|
                  |L71.54|
000036  4629              MOV      r1,r5                 ;3115
000038  6820              LDR      r0,[r4,#0]            ;3115
00003a  f7fffffe          BL       TIM_OC1_SetConfig
00003e  6820              LDR      r0,[r4,#0]            ;3118
000040  6980              LDR      r0,[r0,#0x18]         ;3118
000042  2108              MOVS     r1,#8                 ;3118
000044  4308              ORRS     r0,r0,r1              ;3118
000046  6821              LDR      r1,[r4,#0]            ;3118
000048  6188              STR      r0,[r1,#0x18]         ;3118
00004a  6820              LDR      r0,[r4,#0]            ;3121
00004c  6980              LDR      r0,[r0,#0x18]         ;3121
00004e  2104              MOVS     r1,#4                 ;3121
000050  4388              BICS     r0,r0,r1              ;3121
000052  6821              LDR      r1,[r4,#0]            ;3121
000054  6188              STR      r0,[r1,#0x18]         ;3121
000056  6820              LDR      r0,[r4,#0]            ;3122
000058  6980              LDR      r0,[r0,#0x18]         ;3122
00005a  6929              LDR      r1,[r5,#0x10]         ;3122
00005c  4308              ORRS     r0,r0,r1              ;3122
00005e  6821              LDR      r1,[r4,#0]            ;3122
000060  6188              STR      r0,[r1,#0x18]         ;3122
000062  e04b              B        |L71.252|
                  |L71.100|
000064  4629              MOV      r1,r5                 ;3130
000066  6820              LDR      r0,[r4,#0]            ;3130
000068  f7fffffe          BL       TIM_OC2_SetConfig
00006c  6820              LDR      r0,[r4,#0]            ;3133
00006e  6980              LDR      r0,[r0,#0x18]         ;3133
000070  2101              MOVS     r1,#1                 ;3133
000072  02c9              LSLS     r1,r1,#11             ;3133
000074  4308              ORRS     r0,r0,r1              ;3133
000076  6821              LDR      r1,[r4,#0]            ;3133
000078  6188              STR      r0,[r1,#0x18]         ;3133
00007a  6820              LDR      r0,[r4,#0]            ;3136
00007c  6980              LDR      r0,[r0,#0x18]         ;3136
00007e  2101              MOVS     r1,#1                 ;3136
000080  0289              LSLS     r1,r1,#10             ;3136
000082  4388              BICS     r0,r0,r1              ;3136
000084  6821              LDR      r1,[r4,#0]            ;3136
000086  6188              STR      r0,[r1,#0x18]         ;3136
000088  6820              LDR      r0,[r4,#0]            ;3137
00008a  6980              LDR      r0,[r0,#0x18]         ;3137
00008c  6929              LDR      r1,[r5,#0x10]         ;3137
00008e  0209              LSLS     r1,r1,#8              ;3137
000090  4308              ORRS     r0,r0,r1              ;3137
000092  6821              LDR      r1,[r4,#0]            ;3137
000094  6188              STR      r0,[r1,#0x18]         ;3137
000096  e031              B        |L71.252|
                  |L71.152|
000098  4629              MOV      r1,r5                 ;3145
00009a  6820              LDR      r0,[r4,#0]            ;3145
00009c  f7fffffe          BL       TIM_OC3_SetConfig
0000a0  6820              LDR      r0,[r4,#0]            ;3148
0000a2  69c0              LDR      r0,[r0,#0x1c]         ;3148
0000a4  2108              MOVS     r1,#8                 ;3148
0000a6  4308              ORRS     r0,r0,r1              ;3148
0000a8  6821              LDR      r1,[r4,#0]            ;3148
0000aa  61c8              STR      r0,[r1,#0x1c]         ;3148
0000ac  6820              LDR      r0,[r4,#0]            ;3151
0000ae  69c0              LDR      r0,[r0,#0x1c]         ;3151
0000b0  2104              MOVS     r1,#4                 ;3151
0000b2  4388              BICS     r0,r0,r1              ;3151
0000b4  6821              LDR      r1,[r4,#0]            ;3151
0000b6  61c8              STR      r0,[r1,#0x1c]         ;3151
0000b8  6820              LDR      r0,[r4,#0]            ;3152
0000ba  69c0              LDR      r0,[r0,#0x1c]         ;3152
0000bc  6929              LDR      r1,[r5,#0x10]         ;3152
0000be  4308              ORRS     r0,r0,r1              ;3152
0000c0  6821              LDR      r1,[r4,#0]            ;3152
0000c2  61c8              STR      r0,[r1,#0x1c]         ;3152
0000c4  e01a              B        |L71.252|
                  |L71.198|
0000c6  4629              MOV      r1,r5                 ;3160
0000c8  6820              LDR      r0,[r4,#0]            ;3160
0000ca  f7fffffe          BL       TIM_OC4_SetConfig
0000ce  6820              LDR      r0,[r4,#0]            ;3163
0000d0  69c0              LDR      r0,[r0,#0x1c]         ;3163
0000d2  2101              MOVS     r1,#1                 ;3163
0000d4  02c9              LSLS     r1,r1,#11             ;3163
0000d6  4308              ORRS     r0,r0,r1              ;3163
0000d8  6821              LDR      r1,[r4,#0]            ;3163
0000da  61c8              STR      r0,[r1,#0x1c]         ;3163
0000dc  6820              LDR      r0,[r4,#0]            ;3166
0000de  69c0              LDR      r0,[r0,#0x1c]         ;3166
0000e0  2101              MOVS     r1,#1                 ;3166
0000e2  0289              LSLS     r1,r1,#10             ;3166
0000e4  4388              BICS     r0,r0,r1              ;3166
0000e6  6821              LDR      r1,[r4,#0]            ;3166
0000e8  61c8              STR      r0,[r1,#0x1c]         ;3166
0000ea  6820              LDR      r0,[r4,#0]            ;3167
0000ec  69c0              LDR      r0,[r0,#0x1c]         ;3167
0000ee  6929              LDR      r1,[r5,#0x10]         ;3167
0000f0  0209              LSLS     r1,r1,#8              ;3167
0000f2  4308              ORRS     r0,r0,r1              ;3167
0000f4  6821              LDR      r1,[r4,#0]            ;3167
0000f6  61c8              STR      r0,[r1,#0x1c]         ;3167
0000f8  e000              B        |L71.252|
                  |L71.250|
0000fa  bf00              NOP                            ;3172
                  |L71.252|
0000fc  bf00              NOP                            ;3124
0000fe  2101              MOVS     r1,#1                 ;3175
000100  203d              MOVS     r0,#0x3d              ;3175
000102  5501              STRB     r1,[r0,r4]            ;3175
000104  bf00              NOP                            ;3177
000106  2100              MOVS     r1,#0                 ;3177
000108  203c              MOVS     r0,#0x3c              ;3177
00010a  5501              STRB     r1,[r0,r4]            ;3177
00010c  bf00              NOP                            ;3177
00010e  2000              MOVS     r0,#0                 ;3179
000110  e780              B        |L71.20|
;;;3181   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_DeInit PROC
;;;1027     */
;;;1028   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1029   {
000002  4604              MOV      r4,r0
;;;1030     /* Check the parameters */
;;;1031     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1032   
;;;1033     htim->State = HAL_TIM_STATE_BUSY;
000004  2102              MOVS     r1,#2
000006  203d              MOVS     r0,#0x3d
000008  5501              STRB     r1,[r0,r4]
;;;1034   
;;;1035     /* Disable the TIM Peripheral Clock */
;;;1036     __HAL_TIM_DISABLE(htim);
00000a  bf00              NOP      
00000c  6820              LDR      r0,[r4,#0]
00000e  6a00              LDR      r0,[r0,#0x20]
000010  490e              LDR      r1,|L72.76|
000012  4008              ANDS     r0,r0,r1
000014  2800              CMP      r0,#0
000016  d10b              BNE      |L72.48|
000018  6820              LDR      r0,[r4,#0]
00001a  6a00              LDR      r0,[r0,#0x20]
00001c  1089              ASRS     r1,r1,#2
00001e  4008              ANDS     r0,r0,r1
000020  2800              CMP      r0,#0
000022  d105              BNE      |L72.48|
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  0840              LSRS     r0,r0,#1
00002a  0040              LSLS     r0,r0,#1
00002c  6821              LDR      r1,[r4,#0]
00002e  6008              STR      r0,[r1,#0]
                  |L72.48|
000030  bf00              NOP      
;;;1037   
;;;1038     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1039     HAL_TIM_PWM_MspDeInit(htim);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1040   
;;;1041     /* Change TIM state */
;;;1042     htim->State = HAL_TIM_STATE_RESET;
000038  2100              MOVS     r1,#0
00003a  203d              MOVS     r0,#0x3d
00003c  5501              STRB     r1,[r0,r4]
;;;1043   
;;;1044     /* Release Lock */
;;;1045     __HAL_UNLOCK(htim);
00003e  bf00              NOP      
000040  203c              MOVS     r0,#0x3c
000042  5501              STRB     r1,[r0,r4]
000044  bf00              NOP      
;;;1046   
;;;1047     return HAL_OK;
000046  2000              MOVS     r0,#0
;;;1048   }
000048  bd10              POP      {r4,pc}
;;;1049   
                          ENDP

00004a  0000              DCW      0x0000
                  |L72.76|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;4512     */
;;;4513   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;4514   {
;;;4515     return htim->State;
000002  203d              MOVS     r0,#0x3d
000004  5c40              LDRB     r0,[r0,r1]
;;;4516   }
000006  4770              BX       lr
;;;4517   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;987      */
;;;988    HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;989    {
000002  4604              MOV      r4,r0
;;;990      /* Check the TIM handle allocation */
;;;991      if(htim == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L74.12|
;;;992      {
;;;993        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L74.10|
;;;994      }
;;;995    
;;;996      /* Check the parameters */
;;;997      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;998      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;999      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1000     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1001   
;;;1002     if(htim->State == HAL_TIM_STATE_RESET)
;;;1003     {
;;;1004       /* Allocate lock resource and initialize it */
;;;1005       htim->Lock = HAL_UNLOCKED;
;;;1006   
;;;1007       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1008       HAL_TIM_PWM_MspInit(htim);
;;;1009     }
;;;1010   
;;;1011     /* Set the TIM state */
;;;1012     htim->State= HAL_TIM_STATE_BUSY;
;;;1013   
;;;1014     /* Init the base time for the PWM */
;;;1015     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1016   
;;;1017     /* Initialize the TIM state*/
;;;1018     htim->State= HAL_TIM_STATE_READY;
;;;1019   
;;;1020     return HAL_OK;
;;;1021   }
00000a  bd10              POP      {r4,pc}
                  |L74.12|
00000c  203d              MOVS     r0,#0x3d              ;1002
00000e  5d00              LDRB     r0,[r0,r4]            ;1002
000010  2800              CMP      r0,#0                 ;1002
000012  d105              BNE      |L74.32|
000014  2100              MOVS     r1,#0                 ;1005
000016  203c              MOVS     r0,#0x3c              ;1005
000018  5501              STRB     r1,[r0,r4]            ;1005
00001a  4620              MOV      r0,r4                 ;1008
00001c  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L74.32|
000020  2102              MOVS     r1,#2                 ;1012
000022  203d              MOVS     r0,#0x3d              ;1012
000024  5501              STRB     r1,[r0,r4]            ;1012
000026  1d21              ADDS     r1,r4,#4              ;1015
000028  6820              LDR      r0,[r4,#0]            ;1015
00002a  f7fffffe          BL       TIM_Base_SetConfig
00002e  2101              MOVS     r1,#1                 ;1018
000030  203d              MOVS     r0,#0x3d              ;1018
000032  5501              STRB     r1,[r0,r4]            ;1018
000034  2000              MOVS     r0,#0                 ;1020
000036  e7e8              B        |L74.10|
;;;1022   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1069     */
;;;1070   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1071   {
;;;1072     /* Prevent unused argument(s) compilation warning */
;;;1073     UNUSED(htim);
;;;1074   
;;;1075     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1076               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1077      */
;;;1078   }
;;;1079   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1054     */
;;;1055   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1056   {
;;;1057     /* Prevent unused argument(s) compilation warning */
;;;1058     UNUSED(htim);
;;;1059   
;;;1060     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1061               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1062      */
;;;1063   }
;;;1064   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4428     */
;;;4429   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4430   {
;;;4431     /* Prevent unused argument(s) compilation warning */
;;;4432     UNUSED(htim);
;;;4433   
;;;4434     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4435               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4436      */
;;;4437   }
;;;4438   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start PROC
;;;1090   */
;;;1091   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1092   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1093     /* Check the parameters */
;;;1094     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1095   
;;;1096     /* Enable the Capture compare channel */
;;;1097     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1098   
;;;1099     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000010  4911              LDR      r1,|L78.88|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d00b              BEQ      |L78.48|
000018  4910              LDR      r1,|L78.92|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d007              BEQ      |L78.48|
000020  490f              LDR      r1,|L78.96|
000022  6820              LDR      r0,[r4,#0]
000024  4288              CMP      r0,r1
000026  d003              BEQ      |L78.48|
000028  490e              LDR      r1,|L78.100|
00002a  6820              LDR      r0,[r4,#0]
00002c  4288              CMP      r0,r1
00002e  d101              BNE      |L78.52|
                  |L78.48|
000030  2001              MOVS     r0,#1
000032  e000              B        |L78.54|
                  |L78.52|
000034  2000              MOVS     r0,#0
                  |L78.54|
000036  2800              CMP      r0,#0
000038  d006              BEQ      |L78.72|
;;;1100     {
;;;1101       /* Enable the main output */
;;;1102       __HAL_TIM_MOE_ENABLE(htim);
00003a  6820              LDR      r0,[r4,#0]
00003c  6c40              LDR      r0,[r0,#0x44]
00003e  2101              MOVS     r1,#1
000040  03c9              LSLS     r1,r1,#15
000042  4308              ORRS     r0,r0,r1
000044  6821              LDR      r1,[r4,#0]
000046  6448              STR      r0,[r1,#0x44]
                  |L78.72|
;;;1103     }
;;;1104   
;;;1105     /* Enable the Peripheral */
;;;1106     __HAL_TIM_ENABLE(htim);
000048  6820              LDR      r0,[r4,#0]
00004a  6800              LDR      r0,[r0,#0]
00004c  2101              MOVS     r1,#1
00004e  4308              ORRS     r0,r0,r1
000050  6821              LDR      r1,[r4,#0]
000052  6008              STR      r0,[r1,#0]
;;;1107   
;;;1108     /* Return function status */
;;;1109     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1110   }
000056  bd30              POP      {r4,r5,pc}
;;;1111   
                          ENDP

                  |L78.88|
                          DCD      0x40012c00
                  |L78.92|
                          DCD      0x40014000
                  |L78.96|
                          DCD      0x40014400
                  |L78.100|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1291   */
;;;1292   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1293   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
000008  461f              MOV      r7,r3
;;;1294     /* Check the parameters */
;;;1295     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1296   
;;;1297     if((htim->State == HAL_TIM_STATE_BUSY))
00000a  203d              MOVS     r0,#0x3d
00000c  5d00              LDRB     r0,[r0,r4]
00000e  2802              CMP      r0,#2
000010  d100              BNE      |L79.20|
                  |L79.18|
;;;1298     {
;;;1299        return HAL_BUSY;
;;;1300     }
;;;1301     else if((htim->State == HAL_TIM_STATE_READY))
;;;1302     {
;;;1303       if(((uint32_t)pData == 0U ) && (Length > 0U))
;;;1304       {
;;;1305         return HAL_ERROR;
;;;1306       }
;;;1307       else
;;;1308       {
;;;1309         htim->State = HAL_TIM_STATE_BUSY;
;;;1310       }
;;;1311     }
;;;1312     switch (Channel)
;;;1313     {
;;;1314       case TIM_CHANNEL_1:
;;;1315       {
;;;1316         /* Set the DMA Period elapsed callback */
;;;1317         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1318   
;;;1319         /* Set the DMA error callback */
;;;1320         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1321   
;;;1322         /* Enable the DMA channel */
;;;1323         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1324   
;;;1325         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1326         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1327       }
;;;1328       break;
;;;1329   
;;;1330       case TIM_CHANNEL_2:
;;;1331       {
;;;1332         /* Set the DMA Period elapsed callback */
;;;1333         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1334   
;;;1335         /* Set the DMA error callback */
;;;1336         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1337   
;;;1338         /* Enable the DMA channel */
;;;1339         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1340   
;;;1341         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1342         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1343       }
;;;1344       break;
;;;1345   
;;;1346       case TIM_CHANNEL_3:
;;;1347       {
;;;1348         /* Set the DMA Period elapsed callback */
;;;1349         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1350   
;;;1351         /* Set the DMA error callback */
;;;1352         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1353   
;;;1354         /* Enable the DMA channel */
;;;1355         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1356   
;;;1357         /* Enable the TIM Output Capture/Compare 3 request */
;;;1358         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1359       }
;;;1360       break;
;;;1361   
;;;1362       case TIM_CHANNEL_4:
;;;1363       {
;;;1364        /* Set the DMA Period elapsed callback */
;;;1365         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1366   
;;;1367         /* Set the DMA error callback */
;;;1368         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1369   
;;;1370         /* Enable the DMA channel */
;;;1371         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1372   
;;;1373         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1374         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1375       }
;;;1376       break;
;;;1377   
;;;1378       default:
;;;1379       break;
;;;1380     }
;;;1381   
;;;1382     /* Enable the Capture compare channel */
;;;1383     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1384   
;;;1385     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1386     {
;;;1387       /* Enable the main output */
;;;1388       __HAL_TIM_MOE_ENABLE(htim);
;;;1389     }
;;;1390   
;;;1391     /* Enable the Peripheral */
;;;1392     __HAL_TIM_ENABLE(htim);
;;;1393   
;;;1394     /* Return function status */
;;;1395     return HAL_OK;
;;;1396   }
000012  bdf8              POP      {r3-r7,pc}
                  |L79.20|
000014  203d              MOVS     r0,#0x3d              ;1301
000016  5d00              LDRB     r0,[r0,r4]            ;1301
000018  2801              CMP      r0,#1                 ;1301
00001a  d107              BNE      |L79.44|
00001c  2d00              CMP      r5,#0                 ;1303
00001e  d102              BNE      |L79.38|
000020  2f00              CMP      r7,#0                 ;1303
000022  d000              BEQ      |L79.38|
000024  e7f5              B        |L79.18|
                  |L79.38|
000026  2102              MOVS     r1,#2                 ;1309
000028  203d              MOVS     r0,#0x3d              ;1309
00002a  5501              STRB     r1,[r0,r4]            ;1309
                  |L79.44|
00002c  2e00              CMP      r6,#0                 ;1312
00002e  d006              BEQ      |L79.62|
000030  2e04              CMP      r6,#4                 ;1312
000032  d01a              BEQ      |L79.106|
000034  2e08              CMP      r6,#8                 ;1312
000036  d02e              BEQ      |L79.150|
000038  2e0c              CMP      r6,#0xc               ;1312
00003a  d158              BNE      |L79.238|
00003c  e041              B        |L79.194|
                  |L79.62|
00003e  4941              LDR      r1,|L79.324|
000040  6a60              LDR      r0,[r4,#0x24]         ;1317
000042  6281              STR      r1,[r0,#0x28]         ;1317
000044  4940              LDR      r1,|L79.328|
000046  6a60              LDR      r0,[r4,#0x24]         ;1320
000048  6301              STR      r1,[r0,#0x30]         ;1320
00004a  6821              LDR      r1,[r4,#0]            ;1323
00004c  460a              MOV      r2,r1                 ;1323
00004e  3234              ADDS     r2,r2,#0x34           ;1323
000050  463b              MOV      r3,r7                 ;1323
000052  4629              MOV      r1,r5                 ;1323
000054  6a60              LDR      r0,[r4,#0x24]         ;1323
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6820              LDR      r0,[r4,#0]            ;1326
00005c  68c0              LDR      r0,[r0,#0xc]          ;1326
00005e  2101              MOVS     r1,#1                 ;1326
000060  0249              LSLS     r1,r1,#9              ;1326
000062  4308              ORRS     r0,r0,r1              ;1326
000064  6821              LDR      r1,[r4,#0]            ;1326
000066  60c8              STR      r0,[r1,#0xc]          ;1326
000068  e042              B        |L79.240|
                  |L79.106|
00006a  4936              LDR      r1,|L79.324|
00006c  6aa0              LDR      r0,[r4,#0x28]         ;1333
00006e  6281              STR      r1,[r0,#0x28]         ;1333
000070  4935              LDR      r1,|L79.328|
000072  6aa0              LDR      r0,[r4,#0x28]         ;1336
000074  6301              STR      r1,[r0,#0x30]         ;1336
000076  6821              LDR      r1,[r4,#0]            ;1339
000078  460a              MOV      r2,r1                 ;1339
00007a  3238              ADDS     r2,r2,#0x38           ;1339
00007c  463b              MOV      r3,r7                 ;1339
00007e  4629              MOV      r1,r5                 ;1339
000080  6aa0              LDR      r0,[r4,#0x28]         ;1339
000082  f7fffffe          BL       HAL_DMA_Start_IT
000086  6820              LDR      r0,[r4,#0]            ;1342
000088  68c0              LDR      r0,[r0,#0xc]          ;1342
00008a  2101              MOVS     r1,#1                 ;1342
00008c  0289              LSLS     r1,r1,#10             ;1342
00008e  4308              ORRS     r0,r0,r1              ;1342
000090  6821              LDR      r1,[r4,#0]            ;1342
000092  60c8              STR      r0,[r1,#0xc]          ;1342
000094  e02c              B        |L79.240|
                  |L79.150|
000096  492b              LDR      r1,|L79.324|
000098  6ae0              LDR      r0,[r4,#0x2c]         ;1349
00009a  6281              STR      r1,[r0,#0x28]         ;1349
00009c  492a              LDR      r1,|L79.328|
00009e  6ae0              LDR      r0,[r4,#0x2c]         ;1352
0000a0  6301              STR      r1,[r0,#0x30]         ;1352
0000a2  6821              LDR      r1,[r4,#0]            ;1355
0000a4  460a              MOV      r2,r1                 ;1355
0000a6  323c              ADDS     r2,r2,#0x3c           ;1355
0000a8  463b              MOV      r3,r7                 ;1355
0000aa  4629              MOV      r1,r5                 ;1355
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;1355
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  6820              LDR      r0,[r4,#0]            ;1358
0000b4  68c0              LDR      r0,[r0,#0xc]          ;1358
0000b6  2101              MOVS     r1,#1                 ;1358
0000b8  02c9              LSLS     r1,r1,#11             ;1358
0000ba  4308              ORRS     r0,r0,r1              ;1358
0000bc  6821              LDR      r1,[r4,#0]            ;1358
0000be  60c8              STR      r0,[r1,#0xc]          ;1358
0000c0  e016              B        |L79.240|
                  |L79.194|
0000c2  4920              LDR      r1,|L79.324|
0000c4  6b20              LDR      r0,[r4,#0x30]         ;1365
0000c6  6281              STR      r1,[r0,#0x28]         ;1365
0000c8  491f              LDR      r1,|L79.328|
0000ca  6b20              LDR      r0,[r4,#0x30]         ;1368
0000cc  6301              STR      r1,[r0,#0x30]         ;1368
0000ce  6821              LDR      r1,[r4,#0]            ;1371
0000d0  460a              MOV      r2,r1                 ;1371
0000d2  3240              ADDS     r2,r2,#0x40           ;1371
0000d4  463b              MOV      r3,r7                 ;1371
0000d6  4629              MOV      r1,r5                 ;1371
0000d8  6b20              LDR      r0,[r4,#0x30]         ;1371
0000da  f7fffffe          BL       HAL_DMA_Start_IT
0000de  6820              LDR      r0,[r4,#0]            ;1374
0000e0  68c0              LDR      r0,[r0,#0xc]          ;1374
0000e2  2101              MOVS     r1,#1                 ;1374
0000e4  0309              LSLS     r1,r1,#12             ;1374
0000e6  4308              ORRS     r0,r0,r1              ;1374
0000e8  6821              LDR      r1,[r4,#0]            ;1374
0000ea  60c8              STR      r0,[r1,#0xc]          ;1374
0000ec  e000              B        |L79.240|
                  |L79.238|
0000ee  bf00              NOP                            ;1379
                  |L79.240|
0000f0  bf00              NOP                            ;1328
0000f2  2201              MOVS     r2,#1                 ;1383
0000f4  4631              MOV      r1,r6                 ;1383
0000f6  6820              LDR      r0,[r4,#0]            ;1383
0000f8  f7fffffe          BL       TIM_CCxChannelCmd
0000fc  4913              LDR      r1,|L79.332|
0000fe  6820              LDR      r0,[r4,#0]            ;1385
000100  4288              CMP      r0,r1                 ;1385
000102  d00b              BEQ      |L79.284|
000104  4912              LDR      r1,|L79.336|
000106  6820              LDR      r0,[r4,#0]            ;1385
000108  4288              CMP      r0,r1                 ;1385
00010a  d007              BEQ      |L79.284|
00010c  4911              LDR      r1,|L79.340|
00010e  6820              LDR      r0,[r4,#0]            ;1385
000110  4288              CMP      r0,r1                 ;1385
000112  d003              BEQ      |L79.284|
000114  4910              LDR      r1,|L79.344|
000116  6820              LDR      r0,[r4,#0]            ;1385
000118  4288              CMP      r0,r1                 ;1385
00011a  d101              BNE      |L79.288|
                  |L79.284|
00011c  2001              MOVS     r0,#1                 ;1385
00011e  e000              B        |L79.290|
                  |L79.288|
000120  2000              MOVS     r0,#0                 ;1385
                  |L79.290|
000122  2800              CMP      r0,#0                 ;1385
000124  d006              BEQ      |L79.308|
000126  6820              LDR      r0,[r4,#0]            ;1388
000128  6c40              LDR      r0,[r0,#0x44]         ;1388
00012a  2101              MOVS     r1,#1                 ;1388
00012c  03c9              LSLS     r1,r1,#15             ;1388
00012e  4308              ORRS     r0,r0,r1              ;1388
000130  6821              LDR      r1,[r4,#0]            ;1388
000132  6448              STR      r0,[r1,#0x44]         ;1388
                  |L79.308|
000134  6820              LDR      r0,[r4,#0]            ;1392
000136  6800              LDR      r0,[r0,#0]            ;1392
000138  2101              MOVS     r1,#1                 ;1392
00013a  4308              ORRS     r0,r0,r1              ;1392
00013c  6821              LDR      r1,[r4,#0]            ;1392
00013e  6008              STR      r0,[r1,#0]            ;1392
000140  2000              MOVS     r0,#0                 ;1395
000142  e766              B        |L79.18|
;;;1397   
                          ENDP

                  |L79.324|
                          DCD      TIM_DMADelayPulseCplt
                  |L79.328|
                          DCD      TIM_DMAError
                  |L79.332|
                          DCD      0x40012c00
                  |L79.336|
                          DCD      0x40014000
                  |L79.340|
                          DCD      0x40014400
                  |L79.344|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_IT PROC
;;;1157   */
;;;1158   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1159   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1160     /* Check the parameters */
;;;1161     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1162   
;;;1163     switch (Channel)
000006  2d00              CMP      r5,#0
000008  d006              BEQ      |L80.24|
00000a  2d04              CMP      r5,#4
00000c  d00b              BEQ      |L80.38|
00000e  2d08              CMP      r5,#8
000010  d010              BEQ      |L80.52|
000012  2d0c              CMP      r5,#0xc
000014  d11c              BNE      |L80.80|
000016  e014              B        |L80.66|
                  |L80.24|
;;;1164     {
;;;1165       case TIM_CHANNEL_1:
;;;1166       {
;;;1167         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1168         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000018  6820              LDR      r0,[r4,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  2102              MOVS     r1,#2
00001e  4308              ORRS     r0,r0,r1
000020  6821              LDR      r1,[r4,#0]
000022  60c8              STR      r0,[r1,#0xc]
;;;1169       }
;;;1170       break;
000024  e015              B        |L80.82|
                  |L80.38|
;;;1171   
;;;1172       case TIM_CHANNEL_2:
;;;1173       {
;;;1174         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1175         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000026  6820              LDR      r0,[r4,#0]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  2104              MOVS     r1,#4
00002c  4308              ORRS     r0,r0,r1
00002e  6821              LDR      r1,[r4,#0]
000030  60c8              STR      r0,[r1,#0xc]
;;;1176       }
;;;1177       break;
000032  e00e              B        |L80.82|
                  |L80.52|
;;;1178   
;;;1179       case TIM_CHANNEL_3:
;;;1180       {
;;;1181         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1182         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000034  6820              LDR      r0,[r4,#0]
000036  68c0              LDR      r0,[r0,#0xc]
000038  2108              MOVS     r1,#8
00003a  4308              ORRS     r0,r0,r1
00003c  6821              LDR      r1,[r4,#0]
00003e  60c8              STR      r0,[r1,#0xc]
;;;1183       }
;;;1184       break;
000040  e007              B        |L80.82|
                  |L80.66|
;;;1185   
;;;1186       case TIM_CHANNEL_4:
;;;1187       {
;;;1188         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1189         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000042  6820              LDR      r0,[r4,#0]
000044  68c0              LDR      r0,[r0,#0xc]
000046  2110              MOVS     r1,#0x10
000048  4308              ORRS     r0,r0,r1
00004a  6821              LDR      r1,[r4,#0]
00004c  60c8              STR      r0,[r1,#0xc]
;;;1190       }
;;;1191       break;
00004e  e000              B        |L80.82|
                  |L80.80|
;;;1192   
;;;1193       default:
;;;1194       break;
000050  bf00              NOP      
                  |L80.82|
000052  bf00              NOP                            ;1170
;;;1195     }
;;;1196   
;;;1197     /* Enable the Capture compare channel */
;;;1198     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000054  2201              MOVS     r2,#1
000056  4629              MOV      r1,r5
000058  6820              LDR      r0,[r4,#0]
00005a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1199   
;;;1200     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00005e  4912              LDR      r1,|L80.168|
000060  6820              LDR      r0,[r4,#0]
000062  4288              CMP      r0,r1
000064  d00b              BEQ      |L80.126|
000066  4911              LDR      r1,|L80.172|
000068  6820              LDR      r0,[r4,#0]
00006a  4288              CMP      r0,r1
00006c  d007              BEQ      |L80.126|
00006e  4910              LDR      r1,|L80.176|
000070  6820              LDR      r0,[r4,#0]
000072  4288              CMP      r0,r1
000074  d003              BEQ      |L80.126|
000076  490f              LDR      r1,|L80.180|
000078  6820              LDR      r0,[r4,#0]
00007a  4288              CMP      r0,r1
00007c  d101              BNE      |L80.130|
                  |L80.126|
00007e  2001              MOVS     r0,#1
000080  e000              B        |L80.132|
                  |L80.130|
000082  2000              MOVS     r0,#0
                  |L80.132|
000084  2800              CMP      r0,#0
000086  d006              BEQ      |L80.150|
;;;1201     {
;;;1202       /* Enable the main output */
;;;1203       __HAL_TIM_MOE_ENABLE(htim);
000088  6820              LDR      r0,[r4,#0]
00008a  6c40              LDR      r0,[r0,#0x44]
00008c  2101              MOVS     r1,#1
00008e  03c9              LSLS     r1,r1,#15
000090  4308              ORRS     r0,r0,r1
000092  6821              LDR      r1,[r4,#0]
000094  6448              STR      r0,[r1,#0x44]
                  |L80.150|
;;;1204     }
;;;1205   
;;;1206     /* Enable the Peripheral */
;;;1207     __HAL_TIM_ENABLE(htim);
000096  6820              LDR      r0,[r4,#0]
000098  6800              LDR      r0,[r0,#0]
00009a  2101              MOVS     r1,#1
00009c  4308              ORRS     r0,r0,r1
00009e  6821              LDR      r1,[r4,#0]
0000a0  6008              STR      r0,[r1,#0]
;;;1208   
;;;1209     /* Return function status */
;;;1210     return HAL_OK;
0000a2  2000              MOVS     r0,#0
;;;1211   }
0000a4  bd30              POP      {r4,r5,pc}
;;;1212   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L80.168|
                          DCD      0x40012c00
                  |L80.172|
                          DCD      0x40014000
                  |L80.176|
                          DCD      0x40014400
                  |L80.180|
                          DCD      0x40014800

                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop PROC
;;;1122   */
;;;1123   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1124   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1125     /* Check the parameters */
;;;1126     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1127   
;;;1128     /* Disable the Capture compare channel */
;;;1129     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1130   
;;;1131     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000010  4921              LDR      r1,|L81.152|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d00b              BEQ      |L81.48|
000018  4920              LDR      r1,|L81.156|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d007              BEQ      |L81.48|
000020  491f              LDR      r1,|L81.160|
000022  6820              LDR      r0,[r4,#0]
000024  4288              CMP      r0,r1
000026  d003              BEQ      |L81.48|
000028  491e              LDR      r1,|L81.164|
00002a  6820              LDR      r0,[r4,#0]
00002c  4288              CMP      r0,r1
00002e  d101              BNE      |L81.52|
                  |L81.48|
000030  2001              MOVS     r0,#1
000032  e000              B        |L81.54|
                  |L81.52|
000034  2000              MOVS     r0,#0
                  |L81.54|
000036  2800              CMP      r0,#0
000038  d014              BEQ      |L81.100|
;;;1132     {
;;;1133       /* Disable the Main Ouput */
;;;1134       __HAL_TIM_MOE_DISABLE(htim);
00003a  bf00              NOP      
00003c  6820              LDR      r0,[r4,#0]
00003e  6a00              LDR      r0,[r0,#0x20]
000040  4919              LDR      r1,|L81.168|
000042  4008              ANDS     r0,r0,r1
000044  2800              CMP      r0,#0
000046  d10c              BNE      |L81.98|
000048  6820              LDR      r0,[r4,#0]
00004a  6a00              LDR      r0,[r0,#0x20]
00004c  1089              ASRS     r1,r1,#2
00004e  4008              ANDS     r0,r0,r1
000050  2800              CMP      r0,#0
000052  d106              BNE      |L81.98|
000054  6820              LDR      r0,[r4,#0]
000056  6c40              LDR      r0,[r0,#0x44]
000058  2101              MOVS     r1,#1
00005a  03c9              LSLS     r1,r1,#15
00005c  4388              BICS     r0,r0,r1
00005e  6821              LDR      r1,[r4,#0]
000060  6448              STR      r0,[r1,#0x44]
                  |L81.98|
000062  bf00              NOP      
                  |L81.100|
;;;1135     }
;;;1136   
;;;1137     /* Disable the Peripheral */
;;;1138     __HAL_TIM_DISABLE(htim);
000064  bf00              NOP      
000066  6820              LDR      r0,[r4,#0]
000068  6a00              LDR      r0,[r0,#0x20]
00006a  490f              LDR      r1,|L81.168|
00006c  4008              ANDS     r0,r0,r1
00006e  2800              CMP      r0,#0
000070  d10b              BNE      |L81.138|
000072  6820              LDR      r0,[r4,#0]
000074  6a00              LDR      r0,[r0,#0x20]
000076  1089              ASRS     r1,r1,#2
000078  4008              ANDS     r0,r0,r1
00007a  2800              CMP      r0,#0
00007c  d105              BNE      |L81.138|
00007e  6820              LDR      r0,[r4,#0]
000080  6800              LDR      r0,[r0,#0]
000082  0840              LSRS     r0,r0,#1
000084  0040              LSLS     r0,r0,#1
000086  6821              LDR      r1,[r4,#0]
000088  6008              STR      r0,[r1,#0]
                  |L81.138|
00008a  bf00              NOP      
;;;1139   
;;;1140     /* Change the htim state */
;;;1141     htim->State = HAL_TIM_STATE_READY;
00008c  2101              MOVS     r1,#1
00008e  203d              MOVS     r0,#0x3d
000090  5501              STRB     r1,[r0,r4]
;;;1142   
;;;1143     /* Return function status */
;;;1144     return HAL_OK;
000092  2000              MOVS     r0,#0
;;;1145   }
000094  bd30              POP      {r4,r5,pc}
;;;1146   
                          ENDP

000096  0000              DCW      0x0000
                  |L81.152|
                          DCD      0x40012c00
                  |L81.156|
                          DCD      0x40014000
                  |L81.160|
                          DCD      0x40014400
                  |L81.164|
                          DCD      0x40014800
                  |L81.168|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1408   */
;;;1409   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1410   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1411     /* Check the parameters */
;;;1412     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1413   
;;;1414     switch (Channel)
000006  2d00              CMP      r5,#0
000008  d006              BEQ      |L82.24|
00000a  2d04              CMP      r5,#4
00000c  d00c              BEQ      |L82.40|
00000e  2d08              CMP      r5,#8
000010  d012              BEQ      |L82.56|
000012  2d0c              CMP      r5,#0xc
000014  d120              BNE      |L82.88|
000016  e017              B        |L82.72|
                  |L82.24|
;;;1415     {
;;;1416       case TIM_CHANNEL_1:
;;;1417       {
;;;1418         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1419         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000018  6820              LDR      r0,[r4,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  2101              MOVS     r1,#1
00001e  0249              LSLS     r1,r1,#9
000020  4388              BICS     r0,r0,r1
000022  6821              LDR      r1,[r4,#0]
000024  60c8              STR      r0,[r1,#0xc]
;;;1420       }
;;;1421       break;
000026  e018              B        |L82.90|
                  |L82.40|
;;;1422   
;;;1423       case TIM_CHANNEL_2:
;;;1424       {
;;;1425         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1426         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000028  6820              LDR      r0,[r4,#0]
00002a  68c0              LDR      r0,[r0,#0xc]
00002c  2101              MOVS     r1,#1
00002e  0289              LSLS     r1,r1,#10
000030  4388              BICS     r0,r0,r1
000032  6821              LDR      r1,[r4,#0]
000034  60c8              STR      r0,[r1,#0xc]
;;;1427       }
;;;1428       break;
000036  e010              B        |L82.90|
                  |L82.56|
;;;1429   
;;;1430       case TIM_CHANNEL_3:
;;;1431       {
;;;1432         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1433         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000038  6820              LDR      r0,[r4,#0]
00003a  68c0              LDR      r0,[r0,#0xc]
00003c  2101              MOVS     r1,#1
00003e  02c9              LSLS     r1,r1,#11
000040  4388              BICS     r0,r0,r1
000042  6821              LDR      r1,[r4,#0]
000044  60c8              STR      r0,[r1,#0xc]
;;;1434       }
;;;1435       break;
000046  e008              B        |L82.90|
                  |L82.72|
;;;1436   
;;;1437       case TIM_CHANNEL_4:
;;;1438       {
;;;1439         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1440         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000048  6820              LDR      r0,[r4,#0]
00004a  68c0              LDR      r0,[r0,#0xc]
00004c  2101              MOVS     r1,#1
00004e  0309              LSLS     r1,r1,#12
000050  4388              BICS     r0,r0,r1
000052  6821              LDR      r1,[r4,#0]
000054  60c8              STR      r0,[r1,#0xc]
;;;1441       }
;;;1442       break;
000056  e000              B        |L82.90|
                  |L82.88|
;;;1443   
;;;1444       default:
;;;1445       break;
000058  bf00              NOP      
                  |L82.90|
00005a  bf00              NOP                            ;1421
;;;1446     }
;;;1447   
;;;1448     /* Disable the Capture compare channel */
;;;1449     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00005c  2200              MOVS     r2,#0
00005e  4629              MOV      r1,r5
000060  6820              LDR      r0,[r4,#0]
000062  f7fffffe          BL       TIM_CCxChannelCmd
;;;1450   
;;;1451     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000066  4921              LDR      r1,|L82.236|
000068  6820              LDR      r0,[r4,#0]
00006a  4288              CMP      r0,r1
00006c  d00b              BEQ      |L82.134|
00006e  4920              LDR      r1,|L82.240|
000070  6820              LDR      r0,[r4,#0]
000072  4288              CMP      r0,r1
000074  d007              BEQ      |L82.134|
000076  491f              LDR      r1,|L82.244|
000078  6820              LDR      r0,[r4,#0]
00007a  4288              CMP      r0,r1
00007c  d003              BEQ      |L82.134|
00007e  491e              LDR      r1,|L82.248|
000080  6820              LDR      r0,[r4,#0]
000082  4288              CMP      r0,r1
000084  d101              BNE      |L82.138|
                  |L82.134|
000086  2001              MOVS     r0,#1
000088  e000              B        |L82.140|
                  |L82.138|
00008a  2000              MOVS     r0,#0
                  |L82.140|
00008c  2800              CMP      r0,#0
00008e  d014              BEQ      |L82.186|
;;;1452     {
;;;1453       /* Disable the Main Ouput */
;;;1454       __HAL_TIM_MOE_DISABLE(htim);
000090  bf00              NOP      
000092  6820              LDR      r0,[r4,#0]
000094  6a00              LDR      r0,[r0,#0x20]
000096  4919              LDR      r1,|L82.252|
000098  4008              ANDS     r0,r0,r1
00009a  2800              CMP      r0,#0
00009c  d10c              BNE      |L82.184|
00009e  6820              LDR      r0,[r4,#0]
0000a0  6a00              LDR      r0,[r0,#0x20]
0000a2  1089              ASRS     r1,r1,#2
0000a4  4008              ANDS     r0,r0,r1
0000a6  2800              CMP      r0,#0
0000a8  d106              BNE      |L82.184|
0000aa  6820              LDR      r0,[r4,#0]
0000ac  6c40              LDR      r0,[r0,#0x44]
0000ae  2101              MOVS     r1,#1
0000b0  03c9              LSLS     r1,r1,#15
0000b2  4388              BICS     r0,r0,r1
0000b4  6821              LDR      r1,[r4,#0]
0000b6  6448              STR      r0,[r1,#0x44]
                  |L82.184|
0000b8  bf00              NOP      
                  |L82.186|
;;;1455     }
;;;1456   
;;;1457     /* Disable the Peripheral */
;;;1458     __HAL_TIM_DISABLE(htim);
0000ba  bf00              NOP      
0000bc  6820              LDR      r0,[r4,#0]
0000be  6a00              LDR      r0,[r0,#0x20]
0000c0  490e              LDR      r1,|L82.252|
0000c2  4008              ANDS     r0,r0,r1
0000c4  2800              CMP      r0,#0
0000c6  d10b              BNE      |L82.224|
0000c8  6820              LDR      r0,[r4,#0]
0000ca  6a00              LDR      r0,[r0,#0x20]
0000cc  1089              ASRS     r1,r1,#2
0000ce  4008              ANDS     r0,r0,r1
0000d0  2800              CMP      r0,#0
0000d2  d105              BNE      |L82.224|
0000d4  6820              LDR      r0,[r4,#0]
0000d6  6800              LDR      r0,[r0,#0]
0000d8  0840              LSRS     r0,r0,#1
0000da  0040              LSLS     r0,r0,#1
0000dc  6821              LDR      r1,[r4,#0]
0000de  6008              STR      r0,[r1,#0]
                  |L82.224|
0000e0  bf00              NOP      
;;;1459   
;;;1460     /* Change the htim state */
;;;1461     htim->State = HAL_TIM_STATE_READY;
0000e2  2101              MOVS     r1,#1
0000e4  203d              MOVS     r0,#0x3d
0000e6  5501              STRB     r1,[r0,r4]
;;;1462   
;;;1463     /* Return function status */
;;;1464     return HAL_OK;
0000e8  2000              MOVS     r0,#0
;;;1465   }
0000ea  bd30              POP      {r4,r5,pc}
;;;1466   
                          ENDP

                  |L82.236|
                          DCD      0x40012c00
                  |L82.240|
                          DCD      0x40014000
                  |L82.244|
                          DCD      0x40014400
                  |L82.248|
                          DCD      0x40014800
                  |L82.252|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_IT PROC
;;;1223   */
;;;1224   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1225   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1226     /* Check the parameters */
;;;1227     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1228   
;;;1229     switch (Channel)
000006  2d00              CMP      r5,#0
000008  d006              BEQ      |L83.24|
00000a  2d04              CMP      r5,#4
00000c  d00b              BEQ      |L83.38|
00000e  2d08              CMP      r5,#8
000010  d010              BEQ      |L83.52|
000012  2d0c              CMP      r5,#0xc
000014  d11c              BNE      |L83.80|
000016  e014              B        |L83.66|
                  |L83.24|
;;;1230     {
;;;1231       case TIM_CHANNEL_1:
;;;1232       {
;;;1233         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1234         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000018  6820              LDR      r0,[r4,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  2102              MOVS     r1,#2
00001e  4388              BICS     r0,r0,r1
000020  6821              LDR      r1,[r4,#0]
000022  60c8              STR      r0,[r1,#0xc]
;;;1235       }
;;;1236       break;
000024  e015              B        |L83.82|
                  |L83.38|
;;;1237   
;;;1238       case TIM_CHANNEL_2:
;;;1239       {
;;;1240         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1241         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000026  6820              LDR      r0,[r4,#0]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  2104              MOVS     r1,#4
00002c  4388              BICS     r0,r0,r1
00002e  6821              LDR      r1,[r4,#0]
000030  60c8              STR      r0,[r1,#0xc]
;;;1242       }
;;;1243       break;
000032  e00e              B        |L83.82|
                  |L83.52|
;;;1244   
;;;1245       case TIM_CHANNEL_3:
;;;1246       {
;;;1247         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1248         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000034  6820              LDR      r0,[r4,#0]
000036  68c0              LDR      r0,[r0,#0xc]
000038  2108              MOVS     r1,#8
00003a  4388              BICS     r0,r0,r1
00003c  6821              LDR      r1,[r4,#0]
00003e  60c8              STR      r0,[r1,#0xc]
;;;1249       }
;;;1250       break;
000040  e007              B        |L83.82|
                  |L83.66|
;;;1251   
;;;1252       case TIM_CHANNEL_4:
;;;1253       {
;;;1254         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1255         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000042  6820              LDR      r0,[r4,#0]
000044  68c0              LDR      r0,[r0,#0xc]
000046  2110              MOVS     r1,#0x10
000048  4388              BICS     r0,r0,r1
00004a  6821              LDR      r1,[r4,#0]
00004c  60c8              STR      r0,[r1,#0xc]
;;;1256       }
;;;1257       break;
00004e  e000              B        |L83.82|
                  |L83.80|
;;;1258   
;;;1259       default:
;;;1260       break;
000050  bf00              NOP      
                  |L83.82|
000052  bf00              NOP                            ;1236
;;;1261     }
;;;1262   
;;;1263     /* Disable the Capture compare channel */
;;;1264     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000054  2200              MOVS     r2,#0
000056  4629              MOV      r1,r5
000058  6820              LDR      r0,[r4,#0]
00005a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1265   
;;;1266     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00005e  4920              LDR      r1,|L83.224|
000060  6820              LDR      r0,[r4,#0]
000062  4288              CMP      r0,r1
000064  d00b              BEQ      |L83.126|
000066  491f              LDR      r1,|L83.228|
000068  6820              LDR      r0,[r4,#0]
00006a  4288              CMP      r0,r1
00006c  d007              BEQ      |L83.126|
00006e  491e              LDR      r1,|L83.232|
000070  6820              LDR      r0,[r4,#0]
000072  4288              CMP      r0,r1
000074  d003              BEQ      |L83.126|
000076  491d              LDR      r1,|L83.236|
000078  6820              LDR      r0,[r4,#0]
00007a  4288              CMP      r0,r1
00007c  d101              BNE      |L83.130|
                  |L83.126|
00007e  2001              MOVS     r0,#1
000080  e000              B        |L83.132|
                  |L83.130|
000082  2000              MOVS     r0,#0
                  |L83.132|
000084  2800              CMP      r0,#0
000086  d014              BEQ      |L83.178|
;;;1267     {
;;;1268       /* Disable the Main Ouput */
;;;1269       __HAL_TIM_MOE_DISABLE(htim);
000088  bf00              NOP      
00008a  6820              LDR      r0,[r4,#0]
00008c  6a00              LDR      r0,[r0,#0x20]
00008e  4918              LDR      r1,|L83.240|
000090  4008              ANDS     r0,r0,r1
000092  2800              CMP      r0,#0
000094  d10c              BNE      |L83.176|
000096  6820              LDR      r0,[r4,#0]
000098  6a00              LDR      r0,[r0,#0x20]
00009a  1089              ASRS     r1,r1,#2
00009c  4008              ANDS     r0,r0,r1
00009e  2800              CMP      r0,#0
0000a0  d106              BNE      |L83.176|
0000a2  6820              LDR      r0,[r4,#0]
0000a4  6c40              LDR      r0,[r0,#0x44]
0000a6  2101              MOVS     r1,#1
0000a8  03c9              LSLS     r1,r1,#15
0000aa  4388              BICS     r0,r0,r1
0000ac  6821              LDR      r1,[r4,#0]
0000ae  6448              STR      r0,[r1,#0x44]
                  |L83.176|
0000b0  bf00              NOP      
                  |L83.178|
;;;1270     }
;;;1271   
;;;1272     /* Disable the Peripheral */
;;;1273     __HAL_TIM_DISABLE(htim);
0000b2  bf00              NOP      
0000b4  6820              LDR      r0,[r4,#0]
0000b6  6a00              LDR      r0,[r0,#0x20]
0000b8  490d              LDR      r1,|L83.240|
0000ba  4008              ANDS     r0,r0,r1
0000bc  2800              CMP      r0,#0
0000be  d10b              BNE      |L83.216|
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6a00              LDR      r0,[r0,#0x20]
0000c4  1089              ASRS     r1,r1,#2
0000c6  4008              ANDS     r0,r0,r1
0000c8  2800              CMP      r0,#0
0000ca  d105              BNE      |L83.216|
0000cc  6820              LDR      r0,[r4,#0]
0000ce  6800              LDR      r0,[r0,#0]
0000d0  0840              LSRS     r0,r0,#1
0000d2  0040              LSLS     r0,r0,#1
0000d4  6821              LDR      r1,[r4,#0]
0000d6  6008              STR      r0,[r1,#0]
                  |L83.216|
0000d8  bf00              NOP      
;;;1274   
;;;1275     /* Return function status */
;;;1276     return HAL_OK;
0000da  2000              MOVS     r0,#0
;;;1277   }
0000dc  bd30              POP      {r4,r5,pc}
;;;1278   
                          ENDP

0000de  0000              DCW      0x0000
                  |L83.224|
                          DCD      0x40012c00
                  |L83.228|
                          DCD      0x40014000
                  |L83.232|
                          DCD      0x40014400
                  |L83.236|
                          DCD      0x40014800
                  |L83.240|
                          DCD      0x00001111

                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4384     */
;;;4385   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4386   {
;;;4387     /* Prevent unused argument(s) compilation warning */
;;;4388     UNUSED(htim);
;;;4389   
;;;4390     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4391               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4392      */
;;;4393   
;;;4394   }
;;;4395   /**
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4297     */
;;;4298   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;4299   {
000002  4602              MOV      r2,r0
;;;4300     uint32_t tmpreg = 0U;
000004  2300              MOVS     r3,#0
;;;4301   
;;;4302     __HAL_LOCK(htim);
000006  bf00              NOP      
000008  203c              MOVS     r0,#0x3c
00000a  5c80              LDRB     r0,[r0,r2]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L85.20|
000010  2002              MOVS     r0,#2
                  |L85.18|
;;;4303   
;;;4304     switch (Channel)
;;;4305     {
;;;4306     case TIM_CHANNEL_1:
;;;4307       {
;;;4308         /* Check the parameters */
;;;4309         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4310   
;;;4311         /* Return the capture 1 value */
;;;4312         tmpreg =  htim->Instance->CCR1;
;;;4313   
;;;4314         break;
;;;4315       }
;;;4316     case TIM_CHANNEL_2:
;;;4317       {
;;;4318         /* Check the parameters */
;;;4319         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4320   
;;;4321         /* Return the capture 2 value */
;;;4322         tmpreg =   htim->Instance->CCR2;
;;;4323   
;;;4324         break;
;;;4325       }
;;;4326   
;;;4327     case TIM_CHANNEL_3:
;;;4328       {
;;;4329         /* Check the parameters */
;;;4330         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4331   
;;;4332         /* Return the capture 3 value */
;;;4333         tmpreg =   htim->Instance->CCR3;
;;;4334   
;;;4335         break;
;;;4336       }
;;;4337   
;;;4338     case TIM_CHANNEL_4:
;;;4339       {
;;;4340         /* Check the parameters */
;;;4341         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4342   
;;;4343         /* Return the capture 4 value */
;;;4344         tmpreg =   htim->Instance->CCR4;
;;;4345   
;;;4346         break;
;;;4347       }
;;;4348   
;;;4349     default:
;;;4350       break;
;;;4351     }
;;;4352   
;;;4353     __HAL_UNLOCK(htim);
;;;4354     return tmpreg;
;;;4355   }
000012  bd10              POP      {r4,pc}
                  |L85.20|
000014  2401              MOVS     r4,#1                 ;4302
000016  203c              MOVS     r0,#0x3c              ;4302
000018  5484              STRB     r4,[r0,r2]            ;4302
00001a  bf00              NOP                            ;4302
00001c  2900              CMP      r1,#0                 ;4304
00001e  d006              BEQ      |L85.46|
000020  2904              CMP      r1,#4                 ;4304
000022  d007              BEQ      |L85.52|
000024  2908              CMP      r1,#8                 ;4304
000026  d008              BEQ      |L85.58|
000028  290c              CMP      r1,#0xc               ;4304
00002a  d10c              BNE      |L85.70|
00002c  e008              B        |L85.64|
                  |L85.46|
00002e  6810              LDR      r0,[r2,#0]            ;4312
000030  6b43              LDR      r3,[r0,#0x34]         ;4312
000032  e009              B        |L85.72|
                  |L85.52|
000034  6810              LDR      r0,[r2,#0]            ;4322
000036  6b83              LDR      r3,[r0,#0x38]         ;4322
000038  e006              B        |L85.72|
                  |L85.58|
00003a  6810              LDR      r0,[r2,#0]            ;4333
00003c  6bc3              LDR      r3,[r0,#0x3c]         ;4333
00003e  e003              B        |L85.72|
                  |L85.64|
000040  6810              LDR      r0,[r2,#0]            ;4344
000042  6c03              LDR      r3,[r0,#0x40]         ;4344
000044  e000              B        |L85.72|
                  |L85.70|
000046  bf00              NOP                            ;4350
                  |L85.72|
000048  bf00              NOP                            ;4314
00004a  bf00              NOP                            ;4353
00004c  2400              MOVS     r4,#0                 ;4353
00004e  203c              MOVS     r0,#0x3c              ;4353
000050  5484              STRB     r4,[r0,r2]            ;4353
000052  bf00              NOP                            ;4353
000054  4618              MOV      r0,r3                 ;4354
000056  e7dc              B        |L85.18|
;;;4356   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4224     */
;;;4225   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;4226   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4227     /* Check the parameters */
;;;4228     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4229     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4230     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4231   
;;;4232     __HAL_LOCK(htim);
000006  bf00              NOP      
000008  203c              MOVS     r0,#0x3c
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L86.20|
000010  2002              MOVS     r0,#2
                  |L86.18|
;;;4233   
;;;4234     htim->State = HAL_TIM_STATE_BUSY;
;;;4235   
;;;4236     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
;;;4237   
;;;4238     /* Disable Trigger Interrupt */
;;;4239     __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
;;;4240   
;;;4241     /* Disable Trigger DMA request */
;;;4242     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4243   
;;;4244     htim->State = HAL_TIM_STATE_READY;
;;;4245   
;;;4246     __HAL_UNLOCK(htim);
;;;4247   
;;;4248     return HAL_OK;
;;;4249       }
000012  bd70              POP      {r4-r6,pc}
                  |L86.20|
000014  2101              MOVS     r1,#1                 ;4232
000016  203c              MOVS     r0,#0x3c              ;4232
000018  5501              STRB     r1,[r0,r4]            ;4232
00001a  bf00              NOP                            ;4232
00001c  2102              MOVS     r1,#2                 ;4234
00001e  203d              MOVS     r0,#0x3d              ;4234
000020  5501              STRB     r1,[r0,r4]            ;4234
000022  4629              MOV      r1,r5                 ;4236
000024  4620              MOV      r0,r4                 ;4236
000026  f7fffffe          BL       TIM_SlaveTimer_SetConfig
00002a  6820              LDR      r0,[r4,#0]            ;4239
00002c  68c0              LDR      r0,[r0,#0xc]          ;4239
00002e  2140              MOVS     r1,#0x40              ;4239
000030  4388              BICS     r0,r0,r1              ;4239
000032  6821              LDR      r1,[r4,#0]            ;4239
000034  60c8              STR      r0,[r1,#0xc]          ;4239
000036  6820              LDR      r0,[r4,#0]            ;4242
000038  68c0              LDR      r0,[r0,#0xc]          ;4242
00003a  2101              MOVS     r1,#1                 ;4242
00003c  0389              LSLS     r1,r1,#14             ;4242
00003e  4388              BICS     r0,r0,r1              ;4242
000040  6821              LDR      r1,[r4,#0]            ;4242
000042  60c8              STR      r0,[r1,#0xc]          ;4242
000044  2101              MOVS     r1,#1                 ;4244
000046  203d              MOVS     r0,#0x3d              ;4244
000048  5501              STRB     r1,[r0,r4]            ;4244
00004a  bf00              NOP                            ;4246
00004c  2100              MOVS     r1,#0                 ;4246
00004e  203c              MOVS     r0,#0x3c              ;4246
000050  5501              STRB     r1,[r0,r4]            ;4246
000052  bf00              NOP                            ;4246
000054  2000              MOVS     r0,#0                 ;4248
000056  e7dc              B        |L86.18|
;;;4250   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4259     */
;;;4260   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim,
000000  b570              PUSH     {r4-r6,lr}
;;;4261                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4262       {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4263         /* Check the parameters */
;;;4264     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4265     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4266     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4267   
;;;4268     __HAL_LOCK(htim);
000006  bf00              NOP      
000008  203c              MOVS     r0,#0x3c
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L87.20|
000010  2002              MOVS     r0,#2
                  |L87.18|
;;;4269   
;;;4270     htim->State = HAL_TIM_STATE_BUSY;
;;;4271   
;;;4272     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
;;;4273   
;;;4274     /* Enable Trigger Interrupt */
;;;4275     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
;;;4276   
;;;4277     /* Disable Trigger DMA request */
;;;4278     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4279   
;;;4280     htim->State = HAL_TIM_STATE_READY;
;;;4281   
;;;4282     __HAL_UNLOCK(htim);
;;;4283   
;;;4284     return HAL_OK;
;;;4285   }
000012  bd70              POP      {r4-r6,pc}
                  |L87.20|
000014  2101              MOVS     r1,#1                 ;4268
000016  203c              MOVS     r0,#0x3c              ;4268
000018  5501              STRB     r1,[r0,r4]            ;4268
00001a  bf00              NOP                            ;4268
00001c  2102              MOVS     r1,#2                 ;4270
00001e  203d              MOVS     r0,#0x3d              ;4270
000020  5501              STRB     r1,[r0,r4]            ;4270
000022  4629              MOV      r1,r5                 ;4272
000024  4620              MOV      r0,r4                 ;4272
000026  f7fffffe          BL       TIM_SlaveTimer_SetConfig
00002a  6820              LDR      r0,[r4,#0]            ;4275
00002c  68c0              LDR      r0,[r0,#0xc]          ;4275
00002e  2140              MOVS     r1,#0x40              ;4275
000030  4308              ORRS     r0,r0,r1              ;4275
000032  6821              LDR      r1,[r4,#0]            ;4275
000034  60c8              STR      r0,[r1,#0xc]          ;4275
000036  6820              LDR      r0,[r4,#0]            ;4278
000038  68c0              LDR      r0,[r0,#0xc]          ;4278
00003a  2101              MOVS     r1,#1                 ;4278
00003c  0389              LSLS     r1,r1,#14             ;4278
00003e  4388              BICS     r0,r0,r1              ;4278
000040  6821              LDR      r1,[r4,#0]            ;4278
000042  60c8              STR      r0,[r1,#0xc]          ;4278
000044  2101              MOVS     r1,#1                 ;4280
000046  203d              MOVS     r0,#0x3d              ;4280
000048  5501              STRB     r1,[r0,r4]            ;4280
00004a  bf00              NOP                            ;4282
00004c  2100              MOVS     r1,#0                 ;4282
00004e  203c              MOVS     r0,#0x3c              ;4282
000050  5501              STRB     r1,[r0,r4]            ;4282
000052  bf00              NOP                            ;4282
000054  2000              MOVS     r0,#0                 ;4284
000056  e7dc              B        |L87.18|
;;;4286   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4443     */
;;;4444   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4445   {
;;;4446     /* Prevent unused argument(s) compilation warning */
;;;4447     UNUSED(htim);
;;;4448   
;;;4449     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4450               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4451      */
;;;4452   }
;;;4453   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;4672     */
;;;4673   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  b510              PUSH     {r4,lr}
;;;4674   {
;;;4675     uint32_t tmpcr1 = 0U;
000002  2200              MOVS     r2,#0
;;;4676     tmpcr1 = TIMx->CR1;
000004  6802              LDR      r2,[r0,#0]
;;;4677   
;;;4678     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;4679     if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
000006  4b20              LDR      r3,|L89.136|
000008  4298              CMP      r0,r3
00000a  d002              BEQ      |L89.18|
00000c  4b1f              LDR      r3,|L89.140|
00000e  4298              CMP      r0,r3
000010  d105              BNE      |L89.30|
                  |L89.18|
;;;4680     {
;;;4681       /* Select the Counter Mode */
;;;4682       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
000012  2470              MOVS     r4,#0x70
000014  4613              MOV      r3,r2
000016  43a3              BICS     r3,r3,r4
000018  461a              MOV      r2,r3
;;;4683       tmpcr1 |= Structure->CounterMode;
00001a  684b              LDR      r3,[r1,#4]
00001c  431a              ORRS     r2,r2,r3
                  |L89.30|
;;;4684     }
;;;4685   
;;;4686     if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
00001e  4b1a              LDR      r3,|L89.136|
000020  4298              CMP      r0,r3
000022  d00e              BEQ      |L89.66|
000024  4b19              LDR      r3,|L89.140|
000026  4298              CMP      r0,r3
000028  d00b              BEQ      |L89.66|
00002a  4b19              LDR      r3,|L89.144|
00002c  4298              CMP      r0,r3
00002e  d008              BEQ      |L89.66|
000030  4b18              LDR      r3,|L89.148|
000032  4298              CMP      r0,r3
000034  d005              BEQ      |L89.66|
000036  4b18              LDR      r3,|L89.152|
000038  4298              CMP      r0,r3
00003a  d002              BEQ      |L89.66|
00003c  4b17              LDR      r3,|L89.156|
00003e  4298              CMP      r0,r3
000040  d106              BNE      |L89.80|
                  |L89.66|
;;;4687     {
;;;4688       /* Set the clock division */
;;;4689       tmpcr1 &= ~TIM_CR1_CKD;
000042  2403              MOVS     r4,#3
000044  0224              LSLS     r4,r4,#8
000046  4613              MOV      r3,r2
000048  43a3              BICS     r3,r3,r4
00004a  461a              MOV      r2,r3
;;;4690       tmpcr1 |= (uint32_t)Structure->ClockDivision;
00004c  68cb              LDR      r3,[r1,#0xc]
00004e  431a              ORRS     r2,r2,r3
                  |L89.80|
;;;4691     }
;;;4692   
;;;4693     /* Set the auto-reload preload */
;;;4694     MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
000050  2480              MOVS     r4,#0x80
000052  4613              MOV      r3,r2
000054  43a3              BICS     r3,r3,r4
000056  694c              LDR      r4,[r1,#0x14]
000058  4323              ORRS     r3,r3,r4
00005a  461a              MOV      r2,r3
;;;4695   
;;;4696     TIMx->CR1 = tmpcr1;
00005c  6002              STR      r2,[r0,#0]
;;;4697   
;;;4698     /* Set the Autoreload value */
;;;4699     TIMx->ARR = (uint32_t)Structure->Period ;
00005e  688b              LDR      r3,[r1,#8]
000060  62c3              STR      r3,[r0,#0x2c]
;;;4700   
;;;4701     /* Set the Prescaler value */
;;;4702     TIMx->PSC = (uint32_t)Structure->Prescaler;
000062  680b              LDR      r3,[r1,#0]
000064  6283              STR      r3,[r0,#0x28]
;;;4703   
;;;4704     if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
000066  4b08              LDR      r3,|L89.136|
000068  4298              CMP      r0,r3
00006a  d008              BEQ      |L89.126|
00006c  4b09              LDR      r3,|L89.148|
00006e  4298              CMP      r0,r3
000070  d005              BEQ      |L89.126|
000072  4b09              LDR      r3,|L89.152|
000074  4298              CMP      r0,r3
000076  d002              BEQ      |L89.126|
000078  4b08              LDR      r3,|L89.156|
00007a  4298              CMP      r0,r3
00007c  d101              BNE      |L89.130|
                  |L89.126|
;;;4705     {
;;;4706       /* Set the Repetition Counter value */
;;;4707       TIMx->RCR = Structure->RepetitionCounter;
00007e  690b              LDR      r3,[r1,#0x10]
000080  6303              STR      r3,[r0,#0x30]
                  |L89.130|
;;;4708     }
;;;4709   
;;;4710     /* Generate an update event to reload the Prescaler 
;;;4711        and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;4712     TIMx->EGR = TIM_EGR_UG;
000082  2301              MOVS     r3,#1
000084  6143              STR      r3,[r0,#0x14]
;;;4713   }
000086  bd10              POP      {r4,pc}
;;;4714   
                          ENDP

                  |L89.136|
                          DCD      0x40012c00
                  |L89.140|
                          DCD      0x40000400
                  |L89.144|
                          DCD      0x40002000
                  |L89.148|
                          DCD      0x40014000
                  |L89.152|
                          DCD      0x40014400
                  |L89.156|
                          DCD      0x40014800

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;5464     */
;;;5465   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
000000  b530              PUSH     {r4,r5,lr}
;;;5466   {
;;;5467     uint32_t tmp = 0U;
000002  2300              MOVS     r3,#0
;;;5468   
;;;5469     /* Check the parameters */
;;;5470     assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;5471     assert_param(IS_TIM_CHANNELS(Channel));
;;;5472   
;;;5473     tmp = TIM_CCER_CC1E << Channel;
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  4623              MOV      r3,r4
;;;5474   
;;;5475     /* Reset the CCxE Bit */
;;;5476     TIMx->CCER &= ~tmp;
00000a  6a04              LDR      r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  6204              STR      r4,[r0,#0x20]
;;;5477   
;;;5478     /* Set or reset the CCxE Bit */
;;;5479     TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
000010  6a04              LDR      r4,[r0,#0x20]
000012  4615              MOV      r5,r2
000014  408d              LSLS     r5,r5,r1
000016  432c              ORRS     r4,r4,r5
000018  6204              STR      r4,[r0,#0x20]
;;;5480   }
00001a  bd30              POP      {r4,r5,pc}
;;;5481   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;4610     */
;;;4611   void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4612   {
000002  4605              MOV      r5,r0
;;;4613     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a6c              LDR      r4,[r5,#0x24]
;;;4614   
;;;4615     htim->State= HAL_TIM_STATE_READY;
000006  2101              MOVS     r1,#1
000008  203d              MOVS     r0,#0x3d
00000a  5501              STRB     r1,[r0,r4]
;;;4616   
;;;4617     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000c  6a60              LDR      r0,[r4,#0x24]
00000e  42a8              CMP      r0,r5
000010  d102              BNE      |L91.24|
;;;4618     {
;;;4619       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000012  2001              MOVS     r0,#1
000014  7720              STRB     r0,[r4,#0x1c]
000016  e010              B        |L91.58|
                  |L91.24|
;;;4620     }
;;;4621     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000018  6aa0              LDR      r0,[r4,#0x28]
00001a  42a8              CMP      r0,r5
00001c  d102              BNE      |L91.36|
;;;4622     {
;;;4623       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001e  2002              MOVS     r0,#2
000020  7720              STRB     r0,[r4,#0x1c]
000022  e00a              B        |L91.58|
                  |L91.36|
;;;4624     }
;;;4625     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000024  6ae0              LDR      r0,[r4,#0x2c]
000026  42a8              CMP      r0,r5
000028  d102              BNE      |L91.48|
;;;4626     {
;;;4627       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00002a  2004              MOVS     r0,#4
00002c  7720              STRB     r0,[r4,#0x1c]
00002e  e004              B        |L91.58|
                  |L91.48|
;;;4628     }
;;;4629     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000030  6b20              LDR      r0,[r4,#0x30]
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L91.58|
;;;4630     {
;;;4631       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000036  2008              MOVS     r0,#8
000038  7720              STRB     r0,[r4,#0x1c]
                  |L91.58|
;;;4632     }
;;;4633   
;;;4634     HAL_TIM_IC_CaptureCallback(htim);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;4635   
;;;4636     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000040  2000              MOVS     r0,#0
000042  7720              STRB     r0,[r4,#0x1c]
;;;4637   }
000044  bd70              POP      {r4-r6,pc}
;;;4638   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;4578     */
;;;4579   void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4580   {
000002  4605              MOV      r5,r0
;;;4581     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a6c              LDR      r4,[r5,#0x24]
;;;4582   
;;;4583     htim->State= HAL_TIM_STATE_READY;
000006  2101              MOVS     r1,#1
000008  203d              MOVS     r0,#0x3d
00000a  5501              STRB     r1,[r0,r4]
;;;4584   
;;;4585     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000c  6a60              LDR      r0,[r4,#0x24]
00000e  42a8              CMP      r0,r5
000010  d102              BNE      |L92.24|
;;;4586     {
;;;4587       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000012  2001              MOVS     r0,#1
000014  7720              STRB     r0,[r4,#0x1c]
000016  e010              B        |L92.58|
                  |L92.24|
;;;4588     }
;;;4589     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000018  6aa0              LDR      r0,[r4,#0x28]
00001a  42a8              CMP      r0,r5
00001c  d102              BNE      |L92.36|
;;;4590     {
;;;4591       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001e  2002              MOVS     r0,#2
000020  7720              STRB     r0,[r4,#0x1c]
000022  e00a              B        |L92.58|
                  |L92.36|
;;;4592     }
;;;4593     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000024  6ae0              LDR      r0,[r4,#0x2c]
000026  42a8              CMP      r0,r5
000028  d102              BNE      |L92.48|
;;;4594     {
;;;4595       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00002a  2004              MOVS     r0,#4
00002c  7720              STRB     r0,[r4,#0x1c]
00002e  e004              B        |L92.58|
                  |L92.48|
;;;4596     }
;;;4597     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000030  6b20              LDR      r0,[r4,#0x30]
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L92.58|
;;;4598     {
;;;4599       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000036  2008              MOVS     r0,#8
000038  7720              STRB     r0,[r4,#0x1c]
                  |L92.58|
;;;4600     }
;;;4601   
;;;4602     HAL_TIM_PWM_PulseFinishedCallback(htim);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;4603   
;;;4604     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000040  2000              MOVS     r0,#0
000042  7720              STRB     r0,[r4,#0x1c]
;;;4605   }
000044  bd70              POP      {r4-r6,pc}
;;;4606   /**
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;4564     */
;;;4565   void TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4566   {
000002  4604              MOV      r4,r0
;;;4567     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a65              LDR      r5,[r4,#0x24]
;;;4568   
;;;4569     htim->State= HAL_TIM_STATE_READY;
000006  2101              MOVS     r1,#1
000008  203d              MOVS     r0,#0x3d
00000a  5541              STRB     r1,[r0,r5]
;;;4570   
;;;4571     HAL_TIM_ErrorCallback(htim);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;4572   }
000012  bd70              POP      {r4-r6,pc}
;;;4573   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;4643     */
;;;4644   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4645   {
000002  4604              MOV      r4,r0
;;;4646     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a65              LDR      r5,[r4,#0x24]
;;;4647   
;;;4648     htim->State= HAL_TIM_STATE_READY;
000006  2101              MOVS     r1,#1
000008  203d              MOVS     r0,#0x3d
00000a  5541              STRB     r1,[r0,r5]
;;;4649   
;;;4650     HAL_TIM_PeriodElapsedCallback(htim);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;4651   }
000012  bd70              POP      {r4-r6,pc}
;;;4652   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;4657     */
;;;4658   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;4659   {
000002  4604              MOV      r4,r0
;;;4660     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a65              LDR      r5,[r4,#0x24]
;;;4661   
;;;4662     htim->State= HAL_TIM_STATE_READY;
000006  2101              MOVS     r1,#1
000008  203d              MOVS     r0,#0x3d
00000a  5541              STRB     r1,[r0,r5]
;;;4663   
;;;4664     HAL_TIM_TriggerCallback(htim);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;4665   }
000012  bd70              POP      {r4-r6,pc}
;;;4666   
                          ENDP


                          AREA ||i.TIM_ETR_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETR_SetConfig PROC
;;;5434     */
;;;5435   void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
000000  b570              PUSH     {r4-r6,lr}
;;;5436                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;5437   {
000002  460c              MOV      r4,r1
;;;5438     uint32_t tmpsmcr = 0U;
000004  2100              MOVS     r1,#0
;;;5439   
;;;5440     tmpsmcr = TIMx->SMCR;
000006  6881              LDR      r1,[r0,#8]
;;;5441   
;;;5442     /* Reset the ETR Bits */
;;;5443     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000008  26ff              MOVS     r6,#0xff
00000a  0236              LSLS     r6,r6,#8
00000c  460d              MOV      r5,r1
00000e  43b5              BICS     r5,r5,r6
000010  4629              MOV      r1,r5
;;;5444   
;;;5445     /* Set the Prescaler, the Filter value and the Polarity */
;;;5446     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
000012  021d              LSLS     r5,r3,#8
000014  4315              ORRS     r5,r5,r2
000016  4325              ORRS     r5,r5,r4
000018  4329              ORRS     r1,r1,r5
;;;5447   
;;;5448     /* Write to TIMx SMCR */
;;;5449     TIMx->SMCR = tmpsmcr;
00001a  6081              STR      r1,[r0,#8]
;;;5450   }
00001c  bd70              POP      {r4-r6,pc}
;;;5451   
                          ENDP


                          AREA ||i.TIM_ITRx_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRx_SetConfig PROC
;;;5404     */
;;;5405   static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
000000  b510              PUSH     {r4,lr}
;;;5406   {
000002  460a              MOV      r2,r1
;;;5407     uint32_t tmpsmcr = 0U;
000004  2100              MOVS     r1,#0
;;;5408   
;;;5409      /* Get the TIMx SMCR register value */
;;;5410      tmpsmcr = TIMx->SMCR;
000006  6881              LDR      r1,[r0,#8]
;;;5411      /* Reset the TS Bits */
;;;5412      tmpsmcr &= ~TIM_SMCR_TS;
000008  2470              MOVS     r4,#0x70
00000a  460b              MOV      r3,r1
00000c  43a3              BICS     r3,r3,r4
00000e  4619              MOV      r1,r3
;;;5413      /* Set the Input Trigger source and the slave mode*/
;;;5414      tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
000010  2307              MOVS     r3,#7
000012  4313              ORRS     r3,r3,r2
000014  4319              ORRS     r1,r1,r3
;;;5415      /* Write to TIMx SMCR */
;;;5416      TIMx->SMCR = tmpsmcr;
000016  6081              STR      r1,[r0,#8]
;;;5417   }
000018  bd10              POP      {r4,pc}
;;;5418   /**
                          ENDP


                          AREA ||i.TIM_OC1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1_SetConfig PROC
;;;4720     */
;;;4721   static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b570              PUSH     {r4-r6,lr}
;;;4722   {
;;;4723     uint32_t tmpccmrx = 0U;
000002  2400              MOVS     r4,#0
;;;4724     uint32_t tmpccer = 0U;
000004  2200              MOVS     r2,#0
;;;4725     uint32_t tmpcr2 = 0U;
000006  2300              MOVS     r3,#0
;;;4726   
;;;4727      /* Disable the Channel 1: Reset the CC1E Bit */
;;;4728     TIMx->CCER &= ~TIM_CCER_CC1E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  086d              LSRS     r5,r5,#1
00000c  006d              LSLS     r5,r5,#1
00000e  6205              STR      r5,[r0,#0x20]
;;;4729   
;;;4730     /* Get the TIMx CCER register value */
;;;4731     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;4732     /* Get the TIMx CR2 register value */
;;;4733     tmpcr2 =  TIMx->CR2;
000012  6843              LDR      r3,[r0,#4]
;;;4734   
;;;4735     /* Get the TIMx CCMR1 register value */
;;;4736     tmpccmrx = TIMx->CCMR1;
000014  6984              LDR      r4,[r0,#0x18]
;;;4737   
;;;4738     /* Reset the Output Compare Mode Bits */
;;;4739     tmpccmrx &= ~TIM_CCMR1_OC1M;
000016  2670              MOVS     r6,#0x70
000018  4625              MOV      r5,r4
00001a  43b5              BICS     r5,r5,r6
00001c  462c              MOV      r4,r5
;;;4740     tmpccmrx &= ~TIM_CCMR1_CC1S;
00001e  08a4              LSRS     r4,r4,#2
000020  00a4              LSLS     r4,r4,#2
;;;4741     /* Select the Output Compare Mode */
;;;4742     tmpccmrx |= OC_Config->OCMode;
000022  680d              LDR      r5,[r1,#0]
000024  432c              ORRS     r4,r4,r5
;;;4743   
;;;4744     /* Reset the Output Polarity level */
;;;4745     tmpccer &= ~TIM_CCER_CC1P;
000026  2602              MOVS     r6,#2
000028  4615              MOV      r5,r2
00002a  43b5              BICS     r5,r5,r6
00002c  462a              MOV      r2,r5
;;;4746     /* Set the Output Compare Polarity */
;;;4747     tmpccer |= OC_Config->OCPolarity;
00002e  688d              LDR      r5,[r1,#8]
000030  432a              ORRS     r2,r2,r5
;;;4748   
;;;4749     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
000032  4d1c              LDR      r5,|L98.164|
000034  42a8              CMP      r0,r5
000036  d100              BNE      |L98.58|
000038  e00b              B        |L98.82|
                  |L98.58|
00003a  4d1b              LDR      r5,|L98.168|
00003c  42a8              CMP      r0,r5
00003e  d100              BNE      |L98.66|
000040  e007              B        |L98.82|
                  |L98.66|
000042  4d1a              LDR      r5,|L98.172|
000044  42a8              CMP      r0,r5
000046  d100              BNE      |L98.74|
000048  e003              B        |L98.82|
                  |L98.74|
00004a  4d19              LDR      r5,|L98.176|
00004c  42a8              CMP      r0,r5
00004e  d10a              BNE      |L98.102|
000050  bf00              NOP      
                  |L98.82|
;;;4750     {
;;;4751       /* Check parameters */
;;;4752       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4753   
;;;4754       /* Reset the Output N Polarity level */
;;;4755       tmpccer &= ~TIM_CCER_CC1NP;
000052  2608              MOVS     r6,#8
000054  4615              MOV      r5,r2
000056  43b5              BICS     r5,r5,r6
000058  462a              MOV      r2,r5
;;;4756       /* Set the Output N Polarity */
;;;4757       tmpccer |= OC_Config->OCNPolarity;
00005a  68cd              LDR      r5,[r1,#0xc]
00005c  432a              ORRS     r2,r2,r5
;;;4758       /* Reset the Output N State */
;;;4759       tmpccer &= ~TIM_CCER_CC1NE;
00005e  2604              MOVS     r6,#4
000060  4615              MOV      r5,r2
000062  43b5              BICS     r5,r5,r6
000064  462a              MOV      r2,r5
                  |L98.102|
;;;4760     }
;;;4761   
;;;4762     if(IS_TIM_BREAK_INSTANCE(TIMx))
000066  4d0f              LDR      r5,|L98.164|
000068  42a8              CMP      r0,r5
00006a  d008              BEQ      |L98.126|
00006c  4d0e              LDR      r5,|L98.168|
00006e  42a8              CMP      r0,r5
000070  d005              BEQ      |L98.126|
000072  4d0e              LDR      r5,|L98.172|
000074  42a8              CMP      r0,r5
000076  d002              BEQ      |L98.126|
000078  4d0d              LDR      r5,|L98.176|
00007a  42a8              CMP      r0,r5
00007c  d10c              BNE      |L98.152|
                  |L98.126|
;;;4763     {
;;;4764       /* Check parameters */
;;;4765       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4766       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4767   
;;;4768       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4769       tmpcr2 &= ~TIM_CR2_OIS1;
00007e  26ff              MOVS     r6,#0xff
000080  3601              ADDS     r6,#1
000082  461d              MOV      r5,r3
000084  43b5              BICS     r5,r5,r6
000086  462b              MOV      r3,r5
;;;4770       tmpcr2 &= ~TIM_CR2_OIS1N;
000088  0076              LSLS     r6,r6,#1
00008a  461d              MOV      r5,r3
00008c  43b5              BICS     r5,r5,r6
00008e  462b              MOV      r3,r5
;;;4771       /* Set the Output Idle state */
;;;4772       tmpcr2 |= OC_Config->OCIdleState;
000090  694d              LDR      r5,[r1,#0x14]
000092  432b              ORRS     r3,r3,r5
;;;4773       /* Set the Output N Idle state */
;;;4774       tmpcr2 |= OC_Config->OCNIdleState;
000094  698d              LDR      r5,[r1,#0x18]
000096  432b              ORRS     r3,r3,r5
                  |L98.152|
;;;4775     }
;;;4776     /* Write to TIMx CR2 */
;;;4777     TIMx->CR2 = tmpcr2;
000098  6043              STR      r3,[r0,#4]
;;;4778   
;;;4779     /* Write to TIMx CCMR1 */
;;;4780     TIMx->CCMR1 = tmpccmrx;
00009a  6184              STR      r4,[r0,#0x18]
;;;4781   
;;;4782     /* Set the Capture Compare Register value */
;;;4783     TIMx->CCR1 = OC_Config->Pulse;
00009c  684d              LDR      r5,[r1,#4]
00009e  6345              STR      r5,[r0,#0x34]
;;;4784   
;;;4785     /* Write to TIMx CCER */
;;;4786     TIMx->CCER = tmpccer;
0000a0  6202              STR      r2,[r0,#0x20]
;;;4787   }
0000a2  bd70              POP      {r4-r6,pc}
;;;4788   
                          ENDP

                  |L98.164|
                          DCD      0x40012c00
                  |L98.168|
                          DCD      0x40014000
                  |L98.172|
                          DCD      0x40014400
                  |L98.176|
                          DCD      0x40014800

                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2_SetConfig PROC
;;;4794     */
;;;4795   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b570              PUSH     {r4-r6,lr}
;;;4796   {
;;;4797     uint32_t tmpccmrx = 0U;
000002  2400              MOVS     r4,#0
;;;4798     uint32_t tmpccer = 0U;
000004  2200              MOVS     r2,#0
;;;4799     uint32_t tmpcr2 = 0U;
000006  2300              MOVS     r3,#0
;;;4800   
;;;4801     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4802     TIMx->CCER &= ~TIM_CCER_CC2E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  2610              MOVS     r6,#0x10
00000c  43b5              BICS     r5,r5,r6
00000e  6205              STR      r5,[r0,#0x20]
;;;4803   
;;;4804     /* Get the TIMx CCER register value */
;;;4805     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;4806     /* Get the TIMx CR2 register value */
;;;4807     tmpcr2 =  TIMx->CR2;
000012  6843              LDR      r3,[r0,#4]
;;;4808   
;;;4809     /* Get the TIMx CCMR1 register value */
;;;4810     tmpccmrx = TIMx->CCMR1;
000014  6984              LDR      r4,[r0,#0x18]
;;;4811   
;;;4812     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4813     tmpccmrx &= ~TIM_CCMR1_OC2M;
000016  2607              MOVS     r6,#7
000018  0336              LSLS     r6,r6,#12
00001a  4625              MOV      r5,r4
00001c  43b5              BICS     r5,r5,r6
00001e  462c              MOV      r4,r5
;;;4814     tmpccmrx &= ~TIM_CCMR1_CC2S;
000020  2603              MOVS     r6,#3
000022  0236              LSLS     r6,r6,#8
000024  4625              MOV      r5,r4
000026  43b5              BICS     r5,r5,r6
000028  462c              MOV      r4,r5
;;;4815   
;;;4816     /* Select the Output Compare Mode */
;;;4817     tmpccmrx |= (OC_Config->OCMode << 8U);
00002a  680d              LDR      r5,[r1,#0]
00002c  022d              LSLS     r5,r5,#8
00002e  432c              ORRS     r4,r4,r5
;;;4818   
;;;4819     /* Reset the Output Polarity level */
;;;4820     tmpccer &= ~TIM_CCER_CC2P;
000030  2620              MOVS     r6,#0x20
000032  4615              MOV      r5,r2
000034  43b5              BICS     r5,r5,r6
000036  462a              MOV      r2,r5
;;;4821     /* Set the Output Compare Polarity */
;;;4822     tmpccer |= (OC_Config->OCPolarity << 4U);
000038  688d              LDR      r5,[r1,#8]
00003a  012d              LSLS     r5,r5,#4
00003c  432a              ORRS     r2,r2,r5
;;;4823   
;;;4824     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
00003e  4d1e              LDR      r5,|L99.184|
000040  42a8              CMP      r0,r5
000042  d100              BNE      |L99.70|
000044  e00b              B        |L99.94|
                  |L99.70|
000046  4d1d              LDR      r5,|L99.188|
000048  42a8              CMP      r0,r5
00004a  d100              BNE      |L99.78|
00004c  bf00              NOP      
                  |L99.78|
00004e  4d1c              LDR      r5,|L99.192|
000050  42a8              CMP      r0,r5
000052  d100              BNE      |L99.86|
000054  bf00              NOP      
                  |L99.86|
000056  4d1b              LDR      r5,|L99.196|
000058  42a8              CMP      r0,r5
00005a  d10b              BNE      |L99.116|
00005c  e00a              B        |L99.116|
                  |L99.94|
;;;4825     {
;;;4826       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4827   
;;;4828       /* Reset the Output N Polarity level */
;;;4829       tmpccer &= ~TIM_CCER_CC2NP;
00005e  2680              MOVS     r6,#0x80
000060  4615              MOV      r5,r2
000062  43b5              BICS     r5,r5,r6
000064  462a              MOV      r2,r5
;;;4830       /* Set the Output N Polarity */
;;;4831       tmpccer |= (OC_Config->OCNPolarity << 4U);
000066  68cd              LDR      r5,[r1,#0xc]
000068  012d              LSLS     r5,r5,#4
00006a  432a              ORRS     r2,r2,r5
;;;4832       /* Reset the Output N State */
;;;4833       tmpccer &= ~TIM_CCER_CC2NE;
00006c  2640              MOVS     r6,#0x40
00006e  4615              MOV      r5,r2
000070  43b5              BICS     r5,r5,r6
000072  462a              MOV      r2,r5
                  |L99.116|
;;;4834   
;;;4835     }
;;;4836   
;;;4837     if(IS_TIM_BREAK_INSTANCE(TIMx))
000074  4d10              LDR      r5,|L99.184|
000076  42a8              CMP      r0,r5
000078  d008              BEQ      |L99.140|
00007a  4d10              LDR      r5,|L99.188|
00007c  42a8              CMP      r0,r5
00007e  d005              BEQ      |L99.140|
000080  4d0f              LDR      r5,|L99.192|
000082  42a8              CMP      r0,r5
000084  d002              BEQ      |L99.140|
000086  4d0f              LDR      r5,|L99.196|
000088  42a8              CMP      r0,r5
00008a  d10e              BNE      |L99.170|
                  |L99.140|
;;;4838     {
;;;4839       /* Check parameters */
;;;4840       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4841       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4842   
;;;4843       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4844       tmpcr2 &= ~TIM_CR2_OIS2;
00008c  2601              MOVS     r6,#1
00008e  02b6              LSLS     r6,r6,#10
000090  461d              MOV      r5,r3
000092  43b5              BICS     r5,r5,r6
000094  462b              MOV      r3,r5
;;;4845       tmpcr2 &= ~TIM_CR2_OIS2N;
000096  0076              LSLS     r6,r6,#1
000098  461d              MOV      r5,r3
00009a  43b5              BICS     r5,r5,r6
00009c  462b              MOV      r3,r5
;;;4846       /* Set the Output Idle state */
;;;4847       tmpcr2 |= (OC_Config->OCIdleState << 2U);
00009e  694d              LDR      r5,[r1,#0x14]
0000a0  00ad              LSLS     r5,r5,#2
0000a2  432b              ORRS     r3,r3,r5
;;;4848       /* Set the Output N Idle state */
;;;4849       tmpcr2 |= (OC_Config->OCNIdleState << 2U);
0000a4  698d              LDR      r5,[r1,#0x18]
0000a6  00ad              LSLS     r5,r5,#2
0000a8  432b              ORRS     r3,r3,r5
                  |L99.170|
;;;4850     }
;;;4851   
;;;4852     /* Write to TIMx CR2 */
;;;4853     TIMx->CR2 = tmpcr2;
0000aa  6043              STR      r3,[r0,#4]
;;;4854   
;;;4855     /* Write to TIMx CCMR1 */
;;;4856     TIMx->CCMR1 = tmpccmrx;
0000ac  6184              STR      r4,[r0,#0x18]
;;;4857   
;;;4858     /* Set the Capture Compare Register value */
;;;4859     TIMx->CCR2 = OC_Config->Pulse;
0000ae  684d              LDR      r5,[r1,#4]
0000b0  6385              STR      r5,[r0,#0x38]
;;;4860   
;;;4861     /* Write to TIMx CCER */
;;;4862     TIMx->CCER = tmpccer;
0000b2  6202              STR      r2,[r0,#0x20]
;;;4863   }
0000b4  bd70              POP      {r4-r6,pc}
;;;4864   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L99.184|
                          DCD      0x40012c00
                  |L99.188|
                          DCD      0x40014000
                  |L99.192|
                          DCD      0x40014400
                  |L99.196|
                          DCD      0x40014800

                          AREA ||i.TIM_OC3_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3_SetConfig PROC
;;;4870     */
;;;4871   static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b570              PUSH     {r4-r6,lr}
;;;4872   {
;;;4873     uint32_t tmpccmrx = 0U;
000002  2400              MOVS     r4,#0
;;;4874     uint32_t tmpccer = 0U;
000004  2200              MOVS     r2,#0
;;;4875     uint32_t tmpcr2 = 0U;
000006  2300              MOVS     r3,#0
;;;4876   
;;;4877     /* Disable the Channel 3: Reset the CC2E Bit */
;;;4878     TIMx->CCER &= ~TIM_CCER_CC3E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  26ff              MOVS     r6,#0xff
00000c  3601              ADDS     r6,#1
00000e  43b5              BICS     r5,r5,r6
000010  6205              STR      r5,[r0,#0x20]
;;;4879   
;;;4880     /* Get the TIMx CCER register value */
;;;4881     tmpccer = TIMx->CCER;
000012  6a02              LDR      r2,[r0,#0x20]
;;;4882     /* Get the TIMx CR2 register value */
;;;4883     tmpcr2 =  TIMx->CR2;
000014  6843              LDR      r3,[r0,#4]
;;;4884   
;;;4885     /* Get the TIMx CCMR2 register value */
;;;4886     tmpccmrx = TIMx->CCMR2;
000016  69c4              LDR      r4,[r0,#0x1c]
;;;4887   
;;;4888     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4889     tmpccmrx &= ~TIM_CCMR2_OC3M;
000018  2670              MOVS     r6,#0x70
00001a  4625              MOV      r5,r4
00001c  43b5              BICS     r5,r5,r6
00001e  462c              MOV      r4,r5
;;;4890     tmpccmrx &= ~TIM_CCMR2_CC3S;
000020  08a4              LSRS     r4,r4,#2
000022  00a4              LSLS     r4,r4,#2
;;;4891     /* Select the Output Compare Mode */
;;;4892     tmpccmrx |= OC_Config->OCMode;
000024  680d              LDR      r5,[r1,#0]
000026  432c              ORRS     r4,r4,r5
;;;4893   
;;;4894     /* Reset the Output Polarity level */
;;;4895     tmpccer &= ~TIM_CCER_CC3P;
000028  2601              MOVS     r6,#1
00002a  0276              LSLS     r6,r6,#9
00002c  4615              MOV      r5,r2
00002e  43b5              BICS     r5,r5,r6
000030  462a              MOV      r2,r5
;;;4896     /* Set the Output Compare Polarity */
;;;4897     tmpccer |= (OC_Config->OCPolarity << 8U);
000032  688d              LDR      r5,[r1,#8]
000034  022d              LSLS     r5,r5,#8
000036  432a              ORRS     r2,r2,r5
;;;4898   
;;;4899     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
000038  4d1e              LDR      r5,|L100.180|
00003a  42a8              CMP      r0,r5
00003c  d100              BNE      |L100.64|
00003e  e00b              B        |L100.88|
                  |L100.64|
000040  4d1d              LDR      r5,|L100.184|
000042  42a8              CMP      r0,r5
000044  d100              BNE      |L100.72|
000046  bf00              NOP      
                  |L100.72|
000048  4d1c              LDR      r5,|L100.188|
00004a  42a8              CMP      r0,r5
00004c  d100              BNE      |L100.80|
00004e  bf00              NOP      
                  |L100.80|
000050  4d1b              LDR      r5,|L100.192|
000052  42a8              CMP      r0,r5
000054  d10c              BNE      |L100.112|
000056  e00b              B        |L100.112|
                  |L100.88|
;;;4900     {
;;;4901       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4902   
;;;4903       /* Reset the Output N Polarity level */
;;;4904       tmpccer &= ~TIM_CCER_CC3NP;
000058  2601              MOVS     r6,#1
00005a  02f6              LSLS     r6,r6,#11
00005c  4615              MOV      r5,r2
00005e  43b5              BICS     r5,r5,r6
000060  462a              MOV      r2,r5
;;;4905       /* Set the Output N Polarity */
;;;4906       tmpccer |= (OC_Config->OCNPolarity << 8U);
000062  68cd              LDR      r5,[r1,#0xc]
000064  022d              LSLS     r5,r5,#8
000066  432a              ORRS     r2,r2,r5
;;;4907       /* Reset the Output N State */
;;;4908       tmpccer &= ~TIM_CCER_CC3NE;
000068  1076              ASRS     r6,r6,#1
00006a  4615              MOV      r5,r2
00006c  43b5              BICS     r5,r5,r6
00006e  462a              MOV      r2,r5
                  |L100.112|
;;;4909     }
;;;4910   
;;;4911     if(IS_TIM_BREAK_INSTANCE(TIMx))
000070  4d10              LDR      r5,|L100.180|
000072  42a8              CMP      r0,r5
000074  d008              BEQ      |L100.136|
000076  4d10              LDR      r5,|L100.184|
000078  42a8              CMP      r0,r5
00007a  d005              BEQ      |L100.136|
00007c  4d0f              LDR      r5,|L100.188|
00007e  42a8              CMP      r0,r5
000080  d002              BEQ      |L100.136|
000082  4d0f              LDR      r5,|L100.192|
000084  42a8              CMP      r0,r5
000086  d10e              BNE      |L100.166|
                  |L100.136|
;;;4912     {
;;;4913       /* Check parameters */
;;;4914       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4915       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4916   
;;;4917       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4918       tmpcr2 &= ~TIM_CR2_OIS3;
000088  2601              MOVS     r6,#1
00008a  0336              LSLS     r6,r6,#12
00008c  461d              MOV      r5,r3
00008e  43b5              BICS     r5,r5,r6
000090  462b              MOV      r3,r5
;;;4919       tmpcr2 &= ~TIM_CR2_OIS3N;
000092  0076              LSLS     r6,r6,#1
000094  461d              MOV      r5,r3
000096  43b5              BICS     r5,r5,r6
000098  462b              MOV      r3,r5
;;;4920       /* Set the Output Idle state */
;;;4921       tmpcr2 |= (OC_Config->OCIdleState << 4U);
00009a  694d              LDR      r5,[r1,#0x14]
00009c  012d              LSLS     r5,r5,#4
00009e  432b              ORRS     r3,r3,r5
;;;4922       /* Set the Output N Idle state */
;;;4923       tmpcr2 |= (OC_Config->OCNIdleState << 4U);
0000a0  698d              LDR      r5,[r1,#0x18]
0000a2  012d              LSLS     r5,r5,#4
0000a4  432b              ORRS     r3,r3,r5
                  |L100.166|
;;;4924     }
;;;4925   
;;;4926     /* Write to TIMx CR2 */
;;;4927     TIMx->CR2 = tmpcr2;
0000a6  6043              STR      r3,[r0,#4]
;;;4928   
;;;4929     /* Write to TIMx CCMR2 */
;;;4930     TIMx->CCMR2 = tmpccmrx;
0000a8  61c4              STR      r4,[r0,#0x1c]
;;;4931   
;;;4932     /* Set the Capture Compare Register value */
;;;4933     TIMx->CCR3 = OC_Config->Pulse;
0000aa  684d              LDR      r5,[r1,#4]
0000ac  63c5              STR      r5,[r0,#0x3c]
;;;4934   
;;;4935     /* Write to TIMx CCER */
;;;4936     TIMx->CCER = tmpccer;
0000ae  6202              STR      r2,[r0,#0x20]
;;;4937   }
0000b0  bd70              POP      {r4-r6,pc}
;;;4938   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L100.180|
                          DCD      0x40012c00
                  |L100.184|
                          DCD      0x40014000
                  |L100.188|
                          DCD      0x40014400
                  |L100.192|
                          DCD      0x40014800

                          AREA ||i.TIM_OC4_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4_SetConfig PROC
;;;4944     */
;;;4945   static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b570              PUSH     {r4-r6,lr}
;;;4946   {
;;;4947     uint32_t tmpccmrx = 0U;
000002  2200              MOVS     r2,#0
;;;4948     uint32_t tmpccer = 0U;
000004  2300              MOVS     r3,#0
;;;4949     uint32_t tmpcr2 = 0U;
000006  2400              MOVS     r4,#0
;;;4950   
;;;4951     /* Disable the Channel 4: Reset the CC4E Bit */
;;;4952     TIMx->CCER &= ~TIM_CCER_CC4E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  2601              MOVS     r6,#1
00000c  0336              LSLS     r6,r6,#12
00000e  43b5              BICS     r5,r5,r6
000010  6205              STR      r5,[r0,#0x20]
;;;4953   
;;;4954     /* Get the TIMx CCER register value */
;;;4955     tmpccer = TIMx->CCER;
000012  6a03              LDR      r3,[r0,#0x20]
;;;4956     /* Get the TIMx CR2 register value */
;;;4957     tmpcr2 =  TIMx->CR2;
000014  6844              LDR      r4,[r0,#4]
;;;4958   
;;;4959     /* Get the TIMx CCMR2 register value */
;;;4960     tmpccmrx = TIMx->CCMR2;
000016  69c2              LDR      r2,[r0,#0x1c]
;;;4961   
;;;4962     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4963     tmpccmrx &= ~TIM_CCMR2_OC4M;
000018  2607              MOVS     r6,#7
00001a  0336              LSLS     r6,r6,#12
00001c  4615              MOV      r5,r2
00001e  43b5              BICS     r5,r5,r6
000020  462a              MOV      r2,r5
;;;4964     tmpccmrx &= ~TIM_CCMR2_CC4S;
000022  2603              MOVS     r6,#3
000024  0236              LSLS     r6,r6,#8
000026  4615              MOV      r5,r2
000028  43b5              BICS     r5,r5,r6
00002a  462a              MOV      r2,r5
;;;4965   
;;;4966     /* Select the Output Compare Mode */
;;;4967     tmpccmrx |= (OC_Config->OCMode << 8U);
00002c  680d              LDR      r5,[r1,#0]
00002e  022d              LSLS     r5,r5,#8
000030  432a              ORRS     r2,r2,r5
;;;4968   
;;;4969     /* Reset the Output Polarity level */
;;;4970     tmpccer &= ~TIM_CCER_CC4P;
000032  2601              MOVS     r6,#1
000034  0376              LSLS     r6,r6,#13
000036  461d              MOV      r5,r3
000038  43b5              BICS     r5,r5,r6
00003a  462b              MOV      r3,r5
;;;4971     /* Set the Output Compare Polarity */
;;;4972     tmpccer |= (OC_Config->OCPolarity << 12U);
00003c  688d              LDR      r5,[r1,#8]
00003e  032d              LSLS     r5,r5,#12
000040  432b              ORRS     r3,r3,r5
;;;4973   
;;;4974     if(IS_TIM_BREAK_INSTANCE(TIMx))
000042  4d0d              LDR      r5,|L101.120|
000044  42a8              CMP      r0,r5
000046  d008              BEQ      |L101.90|
000048  4d0c              LDR      r5,|L101.124|
00004a  42a8              CMP      r0,r5
00004c  d005              BEQ      |L101.90|
00004e  4d0c              LDR      r5,|L101.128|
000050  42a8              CMP      r0,r5
000052  d002              BEQ      |L101.90|
000054  4d0b              LDR      r5,|L101.132|
000056  42a8              CMP      r0,r5
000058  d107              BNE      |L101.106|
                  |L101.90|
;;;4975     {
;;;4976       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4977   
;;;4978      /* Reset the Output Compare IDLE State */
;;;4979       tmpcr2 &= ~TIM_CR2_OIS4;
00005a  2601              MOVS     r6,#1
00005c  03b6              LSLS     r6,r6,#14
00005e  4625              MOV      r5,r4
000060  43b5              BICS     r5,r5,r6
000062  462c              MOV      r4,r5
;;;4980       /* Set the Output Idle state */
;;;4981       tmpcr2 |= (OC_Config->OCIdleState << 6U);
000064  694d              LDR      r5,[r1,#0x14]
000066  01ad              LSLS     r5,r5,#6
000068  432c              ORRS     r4,r4,r5
                  |L101.106|
;;;4982     }
;;;4983   
;;;4984     /* Write to TIMx CR2 */
;;;4985     TIMx->CR2 = tmpcr2;
00006a  6044              STR      r4,[r0,#4]
;;;4986   
;;;4987     /* Write to TIMx CCMR2 */
;;;4988     TIMx->CCMR2 = tmpccmrx;
00006c  61c2              STR      r2,[r0,#0x1c]
;;;4989   
;;;4990     /* Set the Capture Compare Register value */
;;;4991     TIMx->CCR4 = OC_Config->Pulse;
00006e  684d              LDR      r5,[r1,#4]
000070  6405              STR      r5,[r0,#0x40]
;;;4992   
;;;4993     /* Write to TIMx CCER */
;;;4994     TIMx->CCER = tmpccer;
000072  6203              STR      r3,[r0,#0x20]
;;;4995   }
000074  bd70              POP      {r4-r6,pc}
;;;4996   
                          ENDP

000076  0000              DCW      0x0000
                  |L101.120|
                          DCD      0x40012c00
                  |L101.124|
                          DCD      0x40014000
                  |L101.128|
                          DCD      0x40014400
                  |L101.132|
                          DCD      0x40014800

                          AREA ||i.TIM_SlaveTimer_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_SlaveTimer_SetConfig PROC
;;;4996   
;;;4997   static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
000000  b5fe              PUSH     {r1-r7,lr}
;;;4998                                 TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4999   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;5000     uint32_t tmpsmcr = 0U;
000006  2600              MOVS     r6,#0
;;;5001     uint32_t tmpccmr1 = 0U;
000008  2700              MOVS     r7,#0
;;;5002     uint32_t tmpccer = 0U;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;5003   
;;;5004     /* Get the TIMx SMCR register value */
;;;5005     tmpsmcr = htim->Instance->SMCR;
00000e  6820              LDR      r0,[r4,#0]
000010  6886              LDR      r6,[r0,#8]
;;;5006   
;;;5007     /* Reset the Trigger Selection Bits */
;;;5008     tmpsmcr &= ~TIM_SMCR_TS;
000012  2170              MOVS     r1,#0x70
000014  4630              MOV      r0,r6
000016  4388              BICS     r0,r0,r1
000018  4606              MOV      r6,r0
;;;5009     /* Set the Input Trigger source */
;;;5010     tmpsmcr |= sSlaveConfig->InputTrigger;
00001a  6868              LDR      r0,[r5,#4]
00001c  4306              ORRS     r6,r6,r0
;;;5011   
;;;5012     /* Reset the slave mode Bits */
;;;5013     tmpsmcr &= ~TIM_SMCR_SMS;
00001e  08f6              LSRS     r6,r6,#3
000020  00f6              LSLS     r6,r6,#3
;;;5014     /* Set the slave mode */
;;;5015     tmpsmcr |= sSlaveConfig->SlaveMode;
000022  6828              LDR      r0,[r5,#0]
000024  4306              ORRS     r6,r6,r0
;;;5016   
;;;5017     /* Write to TIMx SMCR */
;;;5018     htim->Instance->SMCR = tmpsmcr;
000026  6820              LDR      r0,[r4,#0]
000028  6086              STR      r6,[r0,#8]
;;;5019   
;;;5020     /* Configure the trigger prescaler, filter, and polarity */
;;;5021     switch (sSlaveConfig->InputTrigger)
00002a  6868              LDR      r0,[r5,#4]
00002c  0701              LSLS     r1,r0,#28
00002e  0f09              LSRS     r1,r1,#28
000030  2900              CMP      r1,#0
000032  d138              BNE      |L102.166|
000034  1100              ASRS     r0,r0,#4
000036  0003              MOVS     r3,r0
000038  f7fffffe          BL       __ARM_common_switch8
00003c  08313233          DCB      0x08,0x31,0x32,0x33
000040  340d252b          DCB      0x34,0x0d,0x25,0x2b
000044  0535              DCB      0x05,0x35
;;;5022     {
;;;5023     case TIM_TS_ETRF:
;;;5024       {
;;;5025         /* Check the parameters */
;;;5026         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;5027         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;5028         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5029         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5030         /* Configure the ETR Trigger source */
;;;5031         TIM_ETR_SetConfig(htim->Instance,
000046  692b              LDR      r3,[r5,#0x10]
000048  68aa              LDR      r2,[r5,#8]
00004a  68e9              LDR      r1,[r5,#0xc]
00004c  6820              LDR      r0,[r4,#0]
00004e  9000              STR      r0,[sp,#0]
000050  f7fffffe          BL       TIM_ETR_SetConfig
;;;5032                           sSlaveConfig->TriggerPrescaler,
;;;5033                           sSlaveConfig->TriggerPolarity,
;;;5034                           sSlaveConfig->TriggerFilter);
;;;5035       }
;;;5036       break;
000054  e028              B        |L102.168|
;;;5037   
;;;5038     case TIM_TS_TI1F_ED:
;;;5039       {
;;;5040         /* Check the parameters */
;;;5041         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5042         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5043   
;;;5044         /* Disable the Channel 1: Reset the CC1E Bit */
;;;5045         tmpccer = htim->Instance->CCER;
000056  6820              LDR      r0,[r4,#0]
000058  6a00              LDR      r0,[r0,#0x20]
00005a  9001              STR      r0,[sp,#4]
;;;5046         htim->Instance->CCER &= ~TIM_CCER_CC1E;
00005c  6820              LDR      r0,[r4,#0]
00005e  6a00              LDR      r0,[r0,#0x20]
000060  0840              LSRS     r0,r0,#1
000062  0040              LSLS     r0,r0,#1
000064  6821              LDR      r1,[r4,#0]
000066  6208              STR      r0,[r1,#0x20]
;;;5047         tmpccmr1 = htim->Instance->CCMR1;
000068  6820              LDR      r0,[r4,#0]
00006a  6987              LDR      r7,[r0,#0x18]
;;;5048   
;;;5049         /* Set the filter */
;;;5050         tmpccmr1 &= ~TIM_CCMR1_IC1F;
00006c  21f0              MOVS     r1,#0xf0
00006e  4638              MOV      r0,r7
000070  4388              BICS     r0,r0,r1
000072  4607              MOV      r7,r0
;;;5051         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
000074  6928              LDR      r0,[r5,#0x10]
000076  0100              LSLS     r0,r0,#4
000078  4307              ORRS     r7,r7,r0
;;;5052   
;;;5053         /* Write to TIMx CCMR1 and CCER registers */
;;;5054         htim->Instance->CCMR1 = tmpccmr1;
00007a  6820              LDR      r0,[r4,#0]
00007c  6187              STR      r7,[r0,#0x18]
;;;5055         htim->Instance->CCER = tmpccer;
00007e  9801              LDR      r0,[sp,#4]
000080  6821              LDR      r1,[r4,#0]
000082  6208              STR      r0,[r1,#0x20]
;;;5056   
;;;5057       }
;;;5058       break;
000084  e010              B        |L102.168|
;;;5059   
;;;5060     case TIM_TS_TI1FP1:
;;;5061       {
;;;5062         /* Check the parameters */
;;;5063         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5064         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5065         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5066   
;;;5067         /* Configure TI1 Filter and Polarity */
;;;5068         TIM_TI1_ConfigInputStage(htim->Instance,
000086  692a              LDR      r2,[r5,#0x10]
000088  68a9              LDR      r1,[r5,#8]
00008a  6820              LDR      r0,[r4,#0]
00008c  f7fffffe          BL       TIM_TI1_ConfigInputStage
;;;5069                                  sSlaveConfig->TriggerPolarity,
;;;5070                                  sSlaveConfig->TriggerFilter);
;;;5071       }
;;;5072       break;
000090  e00a              B        |L102.168|
;;;5073   
;;;5074     case TIM_TS_TI2FP2:
;;;5075       {
;;;5076         /* Check the parameters */
;;;5077         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5078         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5079         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5080   
;;;5081         /* Configure TI2 Filter and Polarity */
;;;5082         TIM_TI2_ConfigInputStage(htim->Instance,
000092  692a              LDR      r2,[r5,#0x10]
000094  68a9              LDR      r1,[r5,#8]
000096  6820              LDR      r0,[r4,#0]
000098  f7fffffe          BL       TIM_TI2_ConfigInputStage
;;;5083                                   sSlaveConfig->TriggerPolarity,
;;;5084                                   sSlaveConfig->TriggerFilter);
;;;5085       }
;;;5086       break;
00009c  e004              B        |L102.168|
;;;5087   
;;;5088     case TIM_TS_ITR0:
;;;5089       {
;;;5090         /* Check the parameter */
;;;5091         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5092       }
;;;5093       break;
00009e  e003              B        |L102.168|
;;;5094   
;;;5095     case TIM_TS_ITR1:
;;;5096       {
;;;5097         /* Check the parameter */
;;;5098         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5099       }
;;;5100       break;
0000a0  e002              B        |L102.168|
;;;5101   
;;;5102     case TIM_TS_ITR2:
;;;5103       {
;;;5104         /* Check the parameter */
;;;5105         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5106       }
;;;5107       break;
0000a2  e001              B        |L102.168|
;;;5108   
;;;5109     case TIM_TS_ITR3:
;;;5110       {
;;;5111         /* Check the parameter */
;;;5112         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5113       }
;;;5114       break;
0000a4  e000              B        |L102.168|
                  |L102.166|
;;;5115   
;;;5116     default:
;;;5117       break;
0000a6  bf00              NOP      
                  |L102.168|
0000a8  bf00              NOP                            ;5036
;;;5118     }
;;;5119   }
0000aa  bdfe              POP      {r1-r7,pc}
;;;5120   
                          ENDP


                          AREA ||i.TIM_TI1_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI1_ConfigInputStage PROC
;;;5187     */
;;;5188   static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b570              PUSH     {r4-r6,lr}
;;;5189   {
000002  460b              MOV      r3,r1
000004  4614              MOV      r4,r2
;;;5190     uint32_t tmpccmr1 = 0U;
000006  2100              MOVS     r1,#0
;;;5191     uint32_t tmpccer = 0U;
000008  2200              MOVS     r2,#0
;;;5192   
;;;5193     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5194     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;5195     TIMx->CCER &= ~TIM_CCER_CC1E;
00000c  6a05              LDR      r5,[r0,#0x20]
00000e  086d              LSRS     r5,r5,#1
000010  006d              LSLS     r5,r5,#1
000012  6205              STR      r5,[r0,#0x20]
;;;5196     tmpccmr1 = TIMx->CCMR1;
000014  6981              LDR      r1,[r0,#0x18]
;;;5197   
;;;5198     /* Set the filter */
;;;5199     tmpccmr1 &= ~TIM_CCMR1_IC1F;
000016  26f0              MOVS     r6,#0xf0
000018  460d              MOV      r5,r1
00001a  43b5              BICS     r5,r5,r6
00001c  4629              MOV      r1,r5
;;;5200     tmpccmr1 |= (TIM_ICFilter << 4U);
00001e  0125              LSLS     r5,r4,#4
000020  4329              ORRS     r1,r1,r5
;;;5201   
;;;5202     /* Select the Polarity and set the CC1E Bit */
;;;5203     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000022  260a              MOVS     r6,#0xa
000024  4615              MOV      r5,r2
000026  43b5              BICS     r5,r5,r6
000028  462a              MOV      r2,r5
;;;5204     tmpccer |= TIM_ICPolarity;
00002a  4615              MOV      r5,r2
00002c  431d              ORRS     r5,r5,r3
00002e  462a              MOV      r2,r5
;;;5205   
;;;5206     /* Write to TIMx CCMR1 and CCER registers */
;;;5207     TIMx->CCMR1 = tmpccmr1;
000030  6181              STR      r1,[r0,#0x18]
;;;5208     TIMx->CCER = tmpccer;
000032  6202              STR      r2,[r0,#0x20]
;;;5209   }
000034  bd70              POP      {r4-r6,pc}
;;;5210   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_TI1_SetConfig PROC
;;;5140     */
;;;5141   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;5142                          uint32_t TIM_ICFilter)
;;;5143   {
000002  460c              MOV      r4,r1
;;;5144     uint32_t tmpccmr1 = 0U;
000004  2100              MOVS     r1,#0
;;;5145     uint32_t tmpccer = 0U;
000006  2500              MOVS     r5,#0
;;;5146   
;;;5147     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5148     TIMx->CCER &= ~TIM_CCER_CC1E;
000008  6a06              LDR      r6,[r0,#0x20]
00000a  0876              LSRS     r6,r6,#1
00000c  0076              LSLS     r6,r6,#1
00000e  6206              STR      r6,[r0,#0x20]
;;;5149     tmpccmr1 = TIMx->CCMR1;
000010  6981              LDR      r1,[r0,#0x18]
;;;5150     tmpccer = TIMx->CCER;
000012  6a05              LDR      r5,[r0,#0x20]
;;;5151   
;;;5152     /* Select the Input */
;;;5153     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
000014  4e13              LDR      r6,|L104.100|
000016  42b0              CMP      r0,r6
000018  d005              BEQ      |L104.38|
00001a  4e13              LDR      r6,|L104.104|
00001c  42b0              CMP      r0,r6
00001e  d002              BEQ      |L104.38|
000020  4e12              LDR      r6,|L104.108|
000022  42b0              CMP      r0,r6
000024  d101              BNE      |L104.42|
                  |L104.38|
000026  2601              MOVS     r6,#1
000028  e000              B        |L104.44|
                  |L104.42|
00002a  2600              MOVS     r6,#0
                  |L104.44|
00002c  2e00              CMP      r6,#0
00002e  d005              BEQ      |L104.60|
;;;5154     {
;;;5155       tmpccmr1 &= ~TIM_CCMR1_CC1S;
000030  0889              LSRS     r1,r1,#2
000032  0089              LSLS     r1,r1,#2
;;;5156       tmpccmr1 |= TIM_ICSelection;
000034  460e              MOV      r6,r1
000036  4316              ORRS     r6,r6,r2
000038  4631              MOV      r1,r6
00003a  e001              B        |L104.64|
                  |L104.60|
;;;5157     }
;;;5158     else
;;;5159     {
;;;5160       tmpccmr1 |= TIM_CCMR1_CC1S_0;
00003c  2601              MOVS     r6,#1
00003e  4331              ORRS     r1,r1,r6
                  |L104.64|
;;;5161     }
;;;5162   
;;;5163     /* Set the filter */
;;;5164     tmpccmr1 &= ~TIM_CCMR1_IC1F;
000040  26f0              MOVS     r6,#0xf0
000042  460f              MOV      r7,r1
000044  43b7              BICS     r7,r7,r6
000046  4639              MOV      r1,r7
;;;5165     tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
000048  011e              LSLS     r6,r3,#4
00004a  27f0              MOVS     r7,#0xf0
00004c  403e              ANDS     r6,r6,r7
00004e  4331              ORRS     r1,r1,r6
;;;5166   
;;;5167     /* Select the Polarity and set the CC1E Bit */
;;;5168     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000050  260a              MOVS     r6,#0xa
000052  462f              MOV      r7,r5
000054  43b7              BICS     r7,r7,r6
000056  463d              MOV      r5,r7
;;;5169     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
000058  4026              ANDS     r6,r6,r4
00005a  4335              ORRS     r5,r5,r6
;;;5170   
;;;5171     /* Write to TIMx CCMR1 and CCER registers */
;;;5172     TIMx->CCMR1 = tmpccmr1;
00005c  6181              STR      r1,[r0,#0x18]
;;;5173     TIMx->CCER = tmpccer;
00005e  6205              STR      r5,[r0,#0x20]
;;;5174   }
000060  bdf0              POP      {r4-r7,pc}
;;;5175   
                          ENDP

000062  0000              DCW      0x0000
                  |L104.100|
                          DCD      0x40012c00
                  |L104.104|
                          DCD      0x40000400
                  |L104.108|
                          DCD      0x40014000

                          AREA ||i.TIM_TI2_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI2_ConfigInputStage PROC
;;;5270     */
;;;5271   static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b570              PUSH     {r4-r6,lr}
;;;5272   {
000002  460b              MOV      r3,r1
000004  4614              MOV      r4,r2
;;;5273     uint32_t tmpccmr1 = 0U;
000006  2100              MOVS     r1,#0
;;;5274     uint32_t tmpccer = 0U;
000008  2200              MOVS     r2,#0
;;;5275   
;;;5276     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5277     TIMx->CCER &= ~TIM_CCER_CC2E;
00000a  6a05              LDR      r5,[r0,#0x20]
00000c  2610              MOVS     r6,#0x10
00000e  43b5              BICS     r5,r5,r6
000010  6205              STR      r5,[r0,#0x20]
;;;5278     tmpccmr1 = TIMx->CCMR1;
000012  6981              LDR      r1,[r0,#0x18]
;;;5279     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;5280   
;;;5281     /* Set the filter */
;;;5282     tmpccmr1 &= ~TIM_CCMR1_IC2F;
000016  260f              MOVS     r6,#0xf
000018  0336              LSLS     r6,r6,#12
00001a  460d              MOV      r5,r1
00001c  43b5              BICS     r5,r5,r6
00001e  4629              MOV      r1,r5
;;;5283     tmpccmr1 |= (TIM_ICFilter << 12U);
000020  0325              LSLS     r5,r4,#12
000022  4329              ORRS     r1,r1,r5
;;;5284   
;;;5285     /* Select the Polarity and set the CC2E Bit */
;;;5286     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000024  26a0              MOVS     r6,#0xa0
000026  4615              MOV      r5,r2
000028  43b5              BICS     r5,r5,r6
00002a  462a              MOV      r2,r5
;;;5287     tmpccer |= (TIM_ICPolarity << 4U);
00002c  011d              LSLS     r5,r3,#4
00002e  432a              ORRS     r2,r2,r5
;;;5288   
;;;5289     /* Write to TIMx CCMR1 and CCER registers */
;;;5290     TIMx->CCMR1 = tmpccmr1 ;
000030  6181              STR      r1,[r0,#0x18]
;;;5291     TIMx->CCER = tmpccer;
000032  6202              STR      r2,[r0,#0x20]
;;;5292   }
000034  bd70              POP      {r4-r6,pc}
;;;5293   
                          ENDP


                          AREA ||i.TIM_TI2_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI2_SetConfig PROC
;;;5230     */
;;;5231   static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;5232                          uint32_t TIM_ICFilter)
;;;5233   {
000002  460c              MOV      r4,r1
;;;5234     uint32_t tmpccmr1 = 0U;
000004  2100              MOVS     r1,#0
;;;5235     uint32_t tmpccer = 0U;
000006  2500              MOVS     r5,#0
;;;5236   
;;;5237     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5238     TIMx->CCER &= ~TIM_CCER_CC2E;
000008  6a06              LDR      r6,[r0,#0x20]
00000a  2710              MOVS     r7,#0x10
00000c  43be              BICS     r6,r6,r7
00000e  6206              STR      r6,[r0,#0x20]
;;;5239     tmpccmr1 = TIMx->CCMR1;
000010  6981              LDR      r1,[r0,#0x18]
;;;5240     tmpccer = TIMx->CCER;
000012  6a05              LDR      r5,[r0,#0x20]
;;;5241   
;;;5242     /* Select the Input */
;;;5243     tmpccmr1 &= ~TIM_CCMR1_CC2S;
000014  2603              MOVS     r6,#3
000016  0236              LSLS     r6,r6,#8
000018  460f              MOV      r7,r1
00001a  43b7              BICS     r7,r7,r6
00001c  4639              MOV      r1,r7
;;;5244     tmpccmr1 |= (TIM_ICSelection << 8U);
00001e  0216              LSLS     r6,r2,#8
000020  4331              ORRS     r1,r1,r6
;;;5245   
;;;5246     /* Set the filter */
;;;5247     tmpccmr1 &= ~TIM_CCMR1_IC2F;
000022  260f              MOVS     r6,#0xf
000024  0336              LSLS     r6,r6,#12
000026  460f              MOV      r7,r1
000028  43b7              BICS     r7,r7,r6
00002a  4639              MOV      r1,r7
;;;5248     tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
00002c  031e              LSLS     r6,r3,#12
00002e  270f              MOVS     r7,#0xf
000030  033f              LSLS     r7,r7,#12
000032  403e              ANDS     r6,r6,r7
000034  4331              ORRS     r1,r1,r6
;;;5249   
;;;5250     /* Select the Polarity and set the CC2E Bit */
;;;5251     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000036  26a0              MOVS     r6,#0xa0
000038  462f              MOV      r7,r5
00003a  43b7              BICS     r7,r7,r6
00003c  463d              MOV      r5,r7
;;;5252     tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
00003e  0126              LSLS     r6,r4,#4
000040  27a0              MOVS     r7,#0xa0
000042  403e              ANDS     r6,r6,r7
000044  4335              ORRS     r5,r5,r6
;;;5253   
;;;5254     /* Write to TIMx CCMR1 and CCER registers */
;;;5255     TIMx->CCMR1 = tmpccmr1 ;
000046  6181              STR      r1,[r0,#0x18]
;;;5256     TIMx->CCER = tmpccer;
000048  6205              STR      r5,[r0,#0x20]
;;;5257   }
00004a  bdf0              POP      {r4-r7,pc}
;;;5258   
                          ENDP


                          AREA ||i.TIM_TI3_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI3_SetConfig PROC
;;;5313     */
;;;5314   static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;5315                          uint32_t TIM_ICFilter)
;;;5316   {
000002  460c              MOV      r4,r1
;;;5317     uint32_t tmpccmr2 = 0U;
000004  2100              MOVS     r1,#0
;;;5318     uint32_t tmpccer = 0U;
000006  2500              MOVS     r5,#0
;;;5319   
;;;5320     /* Disable the Channel 3: Reset the CC3E Bit */
;;;5321     TIMx->CCER &= ~TIM_CCER_CC3E;
000008  6a06              LDR      r6,[r0,#0x20]
00000a  27ff              MOVS     r7,#0xff
00000c  3701              ADDS     r7,#1
00000e  43be              BICS     r6,r6,r7
000010  6206              STR      r6,[r0,#0x20]
;;;5322     tmpccmr2 = TIMx->CCMR2;
000012  69c1              LDR      r1,[r0,#0x1c]
;;;5323     tmpccer = TIMx->CCER;
000014  6a05              LDR      r5,[r0,#0x20]
;;;5324   
;;;5325     /* Select the Input */
;;;5326     tmpccmr2 &= ~TIM_CCMR2_CC3S;
000016  0889              LSRS     r1,r1,#2
000018  0089              LSLS     r1,r1,#2
;;;5327     tmpccmr2 |= TIM_ICSelection;
00001a  460e              MOV      r6,r1
00001c  4316              ORRS     r6,r6,r2
00001e  4631              MOV      r1,r6
;;;5328   
;;;5329     /* Set the filter */
;;;5330     tmpccmr2 &= ~TIM_CCMR2_IC3F;
000020  26f0              MOVS     r6,#0xf0
000022  460f              MOV      r7,r1
000024  43b7              BICS     r7,r7,r6
000026  4639              MOV      r1,r7
;;;5331     tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
000028  011e              LSLS     r6,r3,#4
00002a  27f0              MOVS     r7,#0xf0
00002c  403e              ANDS     r6,r6,r7
00002e  4331              ORRS     r1,r1,r6
;;;5332   
;;;5333     /* Select the Polarity and set the CC3E Bit */
;;;5334     tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
000030  2605              MOVS     r6,#5
000032  0276              LSLS     r6,r6,#9
000034  462f              MOV      r7,r5
000036  43b7              BICS     r7,r7,r6
000038  463d              MOV      r5,r7
;;;5335     tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
00003a  0226              LSLS     r6,r4,#8
00003c  2705              MOVS     r7,#5
00003e  027f              LSLS     r7,r7,#9
000040  403e              ANDS     r6,r6,r7
000042  4335              ORRS     r5,r5,r6
;;;5336   
;;;5337     /* Write to TIMx CCMR2 and CCER registers */
;;;5338     TIMx->CCMR2 = tmpccmr2;
000044  61c1              STR      r1,[r0,#0x1c]
;;;5339     TIMx->CCER = tmpccer;
000046  6205              STR      r5,[r0,#0x20]
;;;5340   }
000048  bdf0              POP      {r4-r7,pc}
;;;5341   
                          ENDP


                          AREA ||i.TIM_TI4_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI4_SetConfig PROC
;;;5361     */
;;;5362   static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;5363                          uint32_t TIM_ICFilter)
;;;5364   {
000002  460c              MOV      r4,r1
;;;5365     uint32_t tmpccmr2 = 0U;
000004  2100              MOVS     r1,#0
;;;5366     uint32_t tmpccer = 0U;
000006  2500              MOVS     r5,#0
;;;5367   
;;;5368     /* Disable the Channel 4: Reset the CC4E Bit */
;;;5369     TIMx->CCER &= ~TIM_CCER_CC4E;
000008  6a06              LDR      r6,[r0,#0x20]
00000a  2701              MOVS     r7,#1
00000c  033f              LSLS     r7,r7,#12
00000e  43be              BICS     r6,r6,r7
000010  6206              STR      r6,[r0,#0x20]
;;;5370     tmpccmr2 = TIMx->CCMR2;
000012  69c1              LDR      r1,[r0,#0x1c]
;;;5371     tmpccer = TIMx->CCER;
000014  6a05              LDR      r5,[r0,#0x20]
;;;5372   
;;;5373     /* Select the Input */
;;;5374     tmpccmr2 &= ~TIM_CCMR2_CC4S;
000016  2603              MOVS     r6,#3
000018  0236              LSLS     r6,r6,#8
00001a  460f              MOV      r7,r1
00001c  43b7              BICS     r7,r7,r6
00001e  4639              MOV      r1,r7
;;;5375     tmpccmr2 |= (TIM_ICSelection << 8U);
000020  0216              LSLS     r6,r2,#8
000022  4331              ORRS     r1,r1,r6
;;;5376   
;;;5377     /* Set the filter */
;;;5378     tmpccmr2 &= ~TIM_CCMR2_IC4F;
000024  260f              MOVS     r6,#0xf
000026  0336              LSLS     r6,r6,#12
000028  460f              MOV      r7,r1
00002a  43b7              BICS     r7,r7,r6
00002c  4639              MOV      r1,r7
;;;5379     tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
00002e  031e              LSLS     r6,r3,#12
000030  270f              MOVS     r7,#0xf
000032  033f              LSLS     r7,r7,#12
000034  403e              ANDS     r6,r6,r7
000036  4331              ORRS     r1,r1,r6
;;;5380   
;;;5381     /* Select the Polarity and set the CC4E Bit */
;;;5382     tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
000038  2605              MOVS     r6,#5
00003a  0376              LSLS     r6,r6,#13
00003c  462f              MOV      r7,r5
00003e  43b7              BICS     r7,r7,r6
000040  463d              MOV      r5,r7
;;;5383     tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
000042  0326              LSLS     r6,r4,#12
000044  2705              MOVS     r7,#5
000046  037f              LSLS     r7,r7,#13
000048  403e              ANDS     r6,r6,r7
00004a  4335              ORRS     r5,r5,r6
;;;5384   
;;;5385     /* Write to TIMx CCMR2 and CCER registers */
;;;5386     TIMx->CCMR2 = tmpccmr2;
00004c  61c1              STR      r1,[r0,#0x1c]
;;;5387     TIMx->CCER = tmpccer ;
00004e  6205              STR      r5,[r0,#0x20]
;;;5388   }
000050  bdf0              POP      {r4-r7,pc}
;;;5389   
                          ENDP


                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L643.24|
                  |L643.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L643.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L643.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\stm32f03xx_HAL\\Src\\stm32f0xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f0xx_hal_tim_c_a9d95b52____REV16|
#line 388 "..\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f0xx_hal_tim_c_a9d95b52____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f0xx_hal_tim_c_a9d95b52____REVSH|
#line 402
|__asm___19_stm32f0xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
