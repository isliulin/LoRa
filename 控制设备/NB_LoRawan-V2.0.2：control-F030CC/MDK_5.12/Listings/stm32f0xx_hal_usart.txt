; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f0xx_hal_usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f0xx_hal_usart.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\CMSIS\Device\ST\STM32F0xx\Include -I..\CMSIS\Include -I..\stm32f03xx_HAL\Inc -I..\USER -I..\HAL\inc -I..\HAL\system -I..\Lib\LoRawan-node\misc -I..\Lib\LoRawan-node\crypto -I..\Lib\LoRawan-node\mac -I..\Lib\LoRawan-node\radio -I..\Lib\LoRawan-node\radio\sx1276 -I..\Lib -IE:\NBI项目\NBI_LoRa\LoRa版本备份\NB_LoRawan-V2.0.2：control-F030CC\MDK_5.12\RTE -ID:\mysaftware\keil_5.12\ARM\PACK\Keil\STM32F0xx_DFP\1.5.0\Device\Include -ID:\mysaftware\keil_5.12\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=518 -DSTM32F030xC -DUSE_HAL_DRIVER -DSTM32F030xC -DUSE_MODEM_LORA -DUSE_BAND_433 --omf_browse=.\objects\stm32f0xx_hal_usart.crf ..\stm32f03xx_HAL\Src\stm32f0xx_hal_usart.c]
                          THUMB

                          AREA ||i.HAL_USART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_USART_Abort PROC
;;;1365   */
;;;1366   HAL_StatusTypeDef HAL_USART_Abort(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;1367   {
000002  4604              MOV      r4,r0
;;;1368     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1369     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  21ff              MOVS     r1,#0xff
00000a  31e1              ADDS     r1,r1,#0xe1
00000c  4388              BICS     r0,r0,r1
00000e  6821              LDR      r1,[r4,#0]
000010  6008              STR      r0,[r1,#0]
;;;1370     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000012  6820              LDR      r0,[r4,#0]
000014  6880              LDR      r0,[r0,#8]
000016  0840              LSRS     r0,r0,#1
000018  0040              LSLS     r0,r0,#1
00001a  6821              LDR      r1,[r4,#0]
00001c  6088              STR      r0,[r1,#8]
;;;1371   
;;;1372     /* Disable the USART DMA Tx request if enabled */
;;;1373     if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
00001e  6820              LDR      r0,[r4,#0]
000020  6880              LDR      r0,[r0,#8]
000022  2180              MOVS     r1,#0x80
000024  4008              ANDS     r0,r0,r1
000026  2800              CMP      r0,#0
000028  d00d              BEQ      |L1.70|
;;;1374     {
;;;1375       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00002a  6820              LDR      r0,[r4,#0]
00002c  6880              LDR      r0,[r0,#8]
00002e  4388              BICS     r0,r0,r1
000030  6821              LDR      r1,[r4,#0]
000032  6088              STR      r0,[r1,#8]
;;;1376   
;;;1377       /* Abort the USART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1378       if(husart->hdmatx != NULL)
000034  6ba0              LDR      r0,[r4,#0x38]
000036  2800              CMP      r0,#0
000038  d005              BEQ      |L1.70|
;;;1379       {
;;;1380         /* Set the USART DMA Abort callback to Null. 
;;;1381            No call back execution at end of DMA abort procedure */
;;;1382         husart->hdmatx->XferAbortCallback = NULL;
00003a  2000              MOVS     r0,#0
00003c  6ba1              LDR      r1,[r4,#0x38]
00003e  6348              STR      r0,[r1,#0x34]
;;;1383   
;;;1384         HAL_DMA_Abort(husart->hdmatx);
000040  6ba0              LDR      r0,[r4,#0x38]
000042  f7fffffe          BL       HAL_DMA_Abort
                  |L1.70|
;;;1385       }
;;;1386     }
;;;1387   
;;;1388     /* Disable the USART DMA Rx request if enabled */
;;;1389     if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
000046  6820              LDR      r0,[r4,#0]
000048  6880              LDR      r0,[r0,#8]
00004a  2140              MOVS     r1,#0x40
00004c  4008              ANDS     r0,r0,r1
00004e  2800              CMP      r0,#0
000050  d00d              BEQ      |L1.110|
;;;1390     {
;;;1391       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000052  6820              LDR      r0,[r4,#0]
000054  6880              LDR      r0,[r0,#8]
000056  4388              BICS     r0,r0,r1
000058  6821              LDR      r1,[r4,#0]
00005a  6088              STR      r0,[r1,#8]
;;;1392   
;;;1393       /* Abort the USART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1394       if(husart->hdmarx != NULL)
00005c  6be0              LDR      r0,[r4,#0x3c]
00005e  2800              CMP      r0,#0
000060  d005              BEQ      |L1.110|
;;;1395       {
;;;1396         /* Set the USART DMA Abort callback to Null. 
;;;1397            No call back execution at end of DMA abort procedure */
;;;1398         husart->hdmarx->XferAbortCallback = NULL;
000062  2000              MOVS     r0,#0
000064  6be1              LDR      r1,[r4,#0x3c]
000066  6348              STR      r0,[r1,#0x34]
;;;1399   
;;;1400         HAL_DMA_Abort(husart->hdmarx);
000068  6be0              LDR      r0,[r4,#0x3c]
00006a  f7fffffe          BL       HAL_DMA_Abort
                  |L1.110|
;;;1401       }
;;;1402     }
;;;1403   
;;;1404     /* Reset Tx and Rx transfer counters */
;;;1405     husart->TxXferCount = 0U; 
00006e  2000              MOVS     r0,#0
000070  8560              STRH     r0,[r4,#0x2a]
;;;1406     husart->RxXferCount = 0U; 
000072  8660              STRH     r0,[r4,#0x32]
;;;1407   
;;;1408     /* Clear the Error flags in the ICR register */
;;;1409     __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
000074  200f              MOVS     r0,#0xf
000076  6821              LDR      r1,[r4,#0]
000078  6208              STR      r0,[r1,#0x20]
;;;1410   
;;;1411     /* Restore husart->State to Ready */
;;;1412     husart->State  = HAL_USART_STATE_READY;
00007a  2101              MOVS     r1,#1
00007c  2041              MOVS     r0,#0x41
00007e  5501              STRB     r1,[r0,r4]
;;;1413   
;;;1414     /* Reset Handle ErrorCode to No Error */
;;;1415     husart->ErrorCode = HAL_USART_ERROR_NONE;
000080  2000              MOVS     r0,#0
000082  6460              STR      r0,[r4,#0x44]
;;;1416   
;;;1417     return HAL_OK;
;;;1418   }
000084  bd10              POP      {r4,pc}
;;;1419   
                          ENDP


                          AREA ||i.HAL_USART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_AbortCpltCallback PROC
;;;1812     */
;;;1813   __weak void HAL_USART_AbortCpltCallback (USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1814   {
;;;1815     /* Prevent unused argument(s) compilation warning */
;;;1816     UNUSED(husart);
;;;1817   
;;;1818     /* NOTE : This function should not be modified, when the callback is needed,
;;;1819               the HAL_USART_AbortCpltCallback can be implemented in the user file.
;;;1820      */
;;;1821   }
;;;1822   
                          ENDP


                          AREA ||i.HAL_USART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_USART_Abort_IT PROC
;;;1433   */
;;;1434   HAL_StatusTypeDef HAL_USART_Abort_IT(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1435   {
000002  4604              MOV      r4,r0
;;;1436     uint32_t abortcplt = 1U;
000004  2501              MOVS     r5,#1
;;;1437     
;;;1438     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1439     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000006  6820              LDR      r0,[r4,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  21ff              MOVS     r1,#0xff
00000c  31e1              ADDS     r1,r1,#0xe1
00000e  4388              BICS     r0,r0,r1
000010  6821              LDR      r1,[r4,#0]
000012  6008              STR      r0,[r1,#0]
;;;1440     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000014  6820              LDR      r0,[r4,#0]
000016  6880              LDR      r0,[r0,#8]
000018  43a8              BICS     r0,r0,r5
00001a  6821              LDR      r1,[r4,#0]
00001c  6088              STR      r0,[r1,#8]
;;;1441   
;;;1442     /* If DMA Tx and/or DMA Rx Handles are associated to USART Handle, DMA Abort complete callbacks should be initialised
;;;1443        before any call to DMA Abort functions */
;;;1444     /* DMA Tx Handle is valid */
;;;1445     if(husart->hdmatx != NULL)
00001e  6ba0              LDR      r0,[r4,#0x38]
000020  2800              CMP      r0,#0
000022  d00c              BEQ      |L3.62|
;;;1446     {
;;;1447       /* Set DMA Abort Complete callback if USART DMA Tx request if enabled.
;;;1448          Otherwise, set it to NULL */
;;;1449       if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
000024  6820              LDR      r0,[r4,#0]
000026  6880              LDR      r0,[r0,#8]
000028  2180              MOVS     r1,#0x80
00002a  4008              ANDS     r0,r0,r1
00002c  2800              CMP      r0,#0
00002e  d003              BEQ      |L3.56|
;;;1450       {
;;;1451         husart->hdmatx->XferAbortCallback = USART_DMATxAbortCallback;
000030  482c              LDR      r0,|L3.228|
000032  6ba1              LDR      r1,[r4,#0x38]
000034  6348              STR      r0,[r1,#0x34]
000036  e002              B        |L3.62|
                  |L3.56|
;;;1452       }
;;;1453       else
;;;1454       {
;;;1455         husart->hdmatx->XferAbortCallback = NULL;
000038  2000              MOVS     r0,#0
00003a  6ba1              LDR      r1,[r4,#0x38]
00003c  6348              STR      r0,[r1,#0x34]
                  |L3.62|
;;;1456       }
;;;1457     }
;;;1458     /* DMA Rx Handle is valid */
;;;1459     if(husart->hdmarx != NULL)
00003e  6be0              LDR      r0,[r4,#0x3c]
000040  2800              CMP      r0,#0
000042  d00c              BEQ      |L3.94|
;;;1460     {
;;;1461       /* Set DMA Abort Complete callback if USART DMA Rx request if enabled.
;;;1462          Otherwise, set it to NULL */
;;;1463       if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
000044  6820              LDR      r0,[r4,#0]
000046  6880              LDR      r0,[r0,#8]
000048  2140              MOVS     r1,#0x40
00004a  4008              ANDS     r0,r0,r1
00004c  2800              CMP      r0,#0
00004e  d003              BEQ      |L3.88|
;;;1464       {
;;;1465         husart->hdmarx->XferAbortCallback = USART_DMARxAbortCallback;
000050  4825              LDR      r0,|L3.232|
000052  6be1              LDR      r1,[r4,#0x3c]
000054  6348              STR      r0,[r1,#0x34]
000056  e002              B        |L3.94|
                  |L3.88|
;;;1466       }
;;;1467       else
;;;1468       {
;;;1469         husart->hdmarx->XferAbortCallback = NULL;
000058  2000              MOVS     r0,#0
00005a  6be1              LDR      r1,[r4,#0x3c]
00005c  6348              STR      r0,[r1,#0x34]
                  |L3.94|
;;;1470       }
;;;1471     }
;;;1472     
;;;1473     /* Disable the USART DMA Tx request if enabled */
;;;1474     if(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
00005e  6820              LDR      r0,[r4,#0]
000060  6880              LDR      r0,[r0,#8]
000062  2180              MOVS     r1,#0x80
000064  4008              ANDS     r0,r0,r1
000066  2800              CMP      r0,#0
000068  d011              BEQ      |L3.142|
;;;1475     {
;;;1476       /* Disable DMA Tx at USART level */
;;;1477       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00006a  6820              LDR      r0,[r4,#0]
00006c  6880              LDR      r0,[r0,#8]
00006e  4388              BICS     r0,r0,r1
000070  6821              LDR      r1,[r4,#0]
000072  6088              STR      r0,[r1,#8]
;;;1478   
;;;1479       /* Abort the USART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1480       if(husart->hdmatx != NULL)
000074  6ba0              LDR      r0,[r4,#0x38]
000076  2800              CMP      r0,#0
000078  d009              BEQ      |L3.142|
;;;1481       {
;;;1482         /* USART Tx DMA Abort callback has already been initialised : 
;;;1483            will lead to call HAL_USART_AbortCpltCallback() at end of DMA abort procedure */
;;;1484   
;;;1485         /* Abort DMA TX */
;;;1486         if(HAL_DMA_Abort_IT(husart->hdmatx) != HAL_OK)
00007a  6ba0              LDR      r0,[r4,#0x38]
00007c  f7fffffe          BL       HAL_DMA_Abort_IT
000080  2800              CMP      r0,#0
000082  d003              BEQ      |L3.140|
;;;1487         {
;;;1488           husart->hdmatx->XferAbortCallback = NULL;
000084  2000              MOVS     r0,#0
000086  6ba1              LDR      r1,[r4,#0x38]
000088  6348              STR      r0,[r1,#0x34]
00008a  e000              B        |L3.142|
                  |L3.140|
;;;1489         }
;;;1490         else
;;;1491         {
;;;1492           abortcplt = 0U;
00008c  2500              MOVS     r5,#0
                  |L3.142|
;;;1493         }
;;;1494       }
;;;1495     }
;;;1496   
;;;1497     /* Disable the USART DMA Rx request if enabled */
;;;1498     if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
00008e  6820              LDR      r0,[r4,#0]
000090  6880              LDR      r0,[r0,#8]
000092  2140              MOVS     r1,#0x40
000094  4008              ANDS     r0,r0,r1
000096  2800              CMP      r0,#0
000098  d012              BEQ      |L3.192|
;;;1499     {
;;;1500       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
00009a  6820              LDR      r0,[r4,#0]
00009c  6880              LDR      r0,[r0,#8]
00009e  4388              BICS     r0,r0,r1
0000a0  6821              LDR      r1,[r4,#0]
0000a2  6088              STR      r0,[r1,#8]
;;;1501   
;;;1502       /* Abort the USART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1503       if(husart->hdmarx != NULL)
0000a4  6be0              LDR      r0,[r4,#0x3c]
0000a6  2800              CMP      r0,#0
0000a8  d00a              BEQ      |L3.192|
;;;1504       {
;;;1505         /* USART Rx DMA Abort callback has already been initialised : 
;;;1506            will lead to call HAL_USART_AbortCpltCallback() at end of DMA abort procedure */
;;;1507   
;;;1508         /* Abort DMA RX */
;;;1509         if(HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
0000aa  6be0              LDR      r0,[r4,#0x3c]
0000ac  f7fffffe          BL       HAL_DMA_Abort_IT
0000b0  2800              CMP      r0,#0
0000b2  d004              BEQ      |L3.190|
;;;1510         {
;;;1511           husart->hdmarx->XferAbortCallback = NULL;
0000b4  2000              MOVS     r0,#0
0000b6  6be1              LDR      r1,[r4,#0x3c]
0000b8  6348              STR      r0,[r1,#0x34]
;;;1512           abortcplt = 1U;
0000ba  2501              MOVS     r5,#1
0000bc  e000              B        |L3.192|
                  |L3.190|
;;;1513         }
;;;1514         else
;;;1515         {
;;;1516           abortcplt = 0U;
0000be  2500              MOVS     r5,#0
                  |L3.192|
;;;1517         }
;;;1518       }
;;;1519     }
;;;1520   
;;;1521     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1522     if (abortcplt == 1U)
0000c0  2d01              CMP      r5,#1
0000c2  d10c              BNE      |L3.222|
;;;1523     {
;;;1524       /* Reset Tx and Rx transfer counters */
;;;1525       husart->TxXferCount = 0U; 
0000c4  2000              MOVS     r0,#0
0000c6  8560              STRH     r0,[r4,#0x2a]
;;;1526       husart->RxXferCount = 0U;
0000c8  8660              STRH     r0,[r4,#0x32]
;;;1527   
;;;1528       /* Reset errorCode */
;;;1529       husart->ErrorCode = HAL_USART_ERROR_NONE;
0000ca  6460              STR      r0,[r4,#0x44]
;;;1530   
;;;1531       /* Clear the Error flags in the ICR register */
;;;1532       __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
0000cc  200f              MOVS     r0,#0xf
0000ce  6821              LDR      r1,[r4,#0]
0000d0  6208              STR      r0,[r1,#0x20]
;;;1533   
;;;1534       /* Restore husart->State to Ready */
;;;1535       husart->State  = HAL_USART_STATE_READY;
0000d2  2101              MOVS     r1,#1
0000d4  2041              MOVS     r0,#0x41
0000d6  5501              STRB     r1,[r0,r4]
;;;1536   
;;;1537       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1538       HAL_USART_AbortCpltCallback(husart);
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       HAL_USART_AbortCpltCallback
                  |L3.222|
;;;1539     }
;;;1540   
;;;1541     return HAL_OK;
0000de  2000              MOVS     r0,#0
;;;1542   }
0000e0  bd70              POP      {r4-r6,pc}
;;;1543   
                          ENDP

0000e2  0000              DCW      0x0000
                  |L3.228|
                          DCD      USART_DMATxAbortCallback
                  |L3.232|
                          DCD      USART_DMARxAbortCallback

                          AREA ||i.HAL_USART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAPause PROC
;;;1243     */
;;;1244   HAL_StatusTypeDef HAL_USART_DMAPause(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1245   {
;;;1246     /* Process Locked */
;;;1247     __HAL_LOCK(husart);
000002  bf00              NOP      
000004  2040              MOVS     r0,#0x40
000006  5c40              LDRB     r0,[r0,r1]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L4.16|
00000c  2002              MOVS     r0,#2
                  |L4.14|
;;;1248   
;;;1249     if( (husart->State == HAL_USART_STATE_BUSY_TX) &&
;;;1250         (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT)))
;;;1251     {
;;;1252       /* Disable the USART DMA Tx request */
;;;1253       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1254     }
;;;1255     else if( (husart->State == HAL_USART_STATE_BUSY_RX) ||
;;;1256              (husart->State == HAL_USART_STATE_BUSY_TX_RX) )
;;;1257     {
;;;1258       if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT))
;;;1259       {
;;;1260         /* Disable the USART DMA Tx request */
;;;1261         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1262       }
;;;1263       if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
;;;1264       {
;;;1265         /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1266         CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1267         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1268   
;;;1269         /* Disable the USART DMA Rx request */
;;;1270         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1271       }
;;;1272     }
;;;1273   
;;;1274     /* Process Unlocked */
;;;1275     __HAL_UNLOCK(husart);
;;;1276   
;;;1277     return HAL_OK;
;;;1278   }
00000e  4770              BX       lr
                  |L4.16|
000010  2201              MOVS     r2,#1                 ;1247
000012  2040              MOVS     r0,#0x40              ;1247
000014  5442              STRB     r2,[r0,r1]            ;1247
000016  bf00              NOP                            ;1247
000018  2041              MOVS     r0,#0x41              ;1249
00001a  5c40              LDRB     r0,[r0,r1]            ;1249
00001c  2812              CMP      r0,#0x12              ;1249
00001e  d10b              BNE      |L4.56|
000020  6808              LDR      r0,[r1,#0]            ;1250
000022  6880              LDR      r0,[r0,#8]            ;1250
000024  2280              MOVS     r2,#0x80              ;1250
000026  4010              ANDS     r0,r0,r2              ;1250
000028  2800              CMP      r0,#0                 ;1250
00002a  d005              BEQ      |L4.56|
00002c  6808              LDR      r0,[r1,#0]            ;1253
00002e  6880              LDR      r0,[r0,#8]            ;1253
000030  4390              BICS     r0,r0,r2              ;1253
000032  680a              LDR      r2,[r1,#0]            ;1253
000034  6090              STR      r0,[r2,#8]            ;1253
000036  e02a              B        |L4.142|
                  |L4.56|
000038  2041              MOVS     r0,#0x41              ;1255
00003a  5c40              LDRB     r0,[r0,r1]            ;1255
00003c  2822              CMP      r0,#0x22              ;1255
00003e  d003              BEQ      |L4.72|
000040  2041              MOVS     r0,#0x41              ;1256
000042  5c40              LDRB     r0,[r0,r1]            ;1256
000044  2832              CMP      r0,#0x32              ;1256
000046  d122              BNE      |L4.142|
                  |L4.72|
000048  6808              LDR      r0,[r1,#0]            ;1258
00004a  6880              LDR      r0,[r0,#8]            ;1258
00004c  2280              MOVS     r2,#0x80              ;1258
00004e  4010              ANDS     r0,r0,r2              ;1258
000050  2800              CMP      r0,#0                 ;1258
000052  d004              BEQ      |L4.94|
000054  6808              LDR      r0,[r1,#0]            ;1261
000056  6880              LDR      r0,[r0,#8]            ;1261
000058  4390              BICS     r0,r0,r2              ;1261
00005a  680a              LDR      r2,[r1,#0]            ;1261
00005c  6090              STR      r0,[r2,#8]            ;1261
                  |L4.94|
00005e  6808              LDR      r0,[r1,#0]            ;1263
000060  6880              LDR      r0,[r0,#8]            ;1263
000062  2240              MOVS     r2,#0x40              ;1263
000064  4010              ANDS     r0,r0,r2              ;1263
000066  2800              CMP      r0,#0                 ;1263
000068  d011              BEQ      |L4.142|
00006a  6808              LDR      r0,[r1,#0]            ;1266
00006c  6800              LDR      r0,[r0,#0]            ;1266
00006e  0092              LSLS     r2,r2,#2              ;1266
000070  4390              BICS     r0,r0,r2              ;1266
000072  680a              LDR      r2,[r1,#0]            ;1266
000074  6010              STR      r0,[r2,#0]            ;1266
000076  6808              LDR      r0,[r1,#0]            ;1267
000078  6880              LDR      r0,[r0,#8]            ;1267
00007a  0840              LSRS     r0,r0,#1              ;1267
00007c  0040              LSLS     r0,r0,#1              ;1267
00007e  680a              LDR      r2,[r1,#0]            ;1267
000080  6090              STR      r0,[r2,#8]            ;1267
000082  6808              LDR      r0,[r1,#0]            ;1270
000084  6880              LDR      r0,[r0,#8]            ;1270
000086  2240              MOVS     r2,#0x40              ;1270
000088  4390              BICS     r0,r0,r2              ;1270
00008a  680a              LDR      r2,[r1,#0]            ;1270
00008c  6090              STR      r0,[r2,#8]            ;1270
                  |L4.142|
00008e  bf00              NOP                            ;1275
000090  2200              MOVS     r2,#0                 ;1275
000092  2040              MOVS     r0,#0x40              ;1275
000094  5442              STRB     r2,[r0,r1]            ;1275
000096  bf00              NOP                            ;1275
000098  2000              MOVS     r0,#0                 ;1277
00009a  e7b8              B        |L4.14|
;;;1279   
                          ENDP


                          AREA ||i.HAL_USART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAResume PROC
;;;1284     */
;;;1285   HAL_StatusTypeDef HAL_USART_DMAResume(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1286   {
;;;1287     /* Process Locked */
;;;1288     __HAL_LOCK(husart);
000002  bf00              NOP      
000004  2040              MOVS     r0,#0x40
000006  5c40              LDRB     r0,[r0,r1]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L5.16|
00000c  2002              MOVS     r0,#2
                  |L5.14|
;;;1289   
;;;1290     if(husart->State == HAL_USART_STATE_BUSY_TX)
;;;1291     {
;;;1292       /* Enable the USART DMA Tx request */
;;;1293       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1294     }
;;;1295     else if( (husart->State == HAL_USART_STATE_BUSY_RX) ||
;;;1296              (husart->State == HAL_USART_STATE_BUSY_TX_RX) )
;;;1297     {
;;;1298       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1299       __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF);
;;;1300   
;;;1301       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1302       SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1303       SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1304   
;;;1305       /* Enable the USART DMA Rx request  before the DMA Tx request */
;;;1306       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1307   
;;;1308       /* Enable the USART DMA Tx request */
;;;1309       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1310     }
;;;1311   
;;;1312     /* Process Unlocked */
;;;1313     __HAL_UNLOCK(husart);
;;;1314   
;;;1315     return HAL_OK;
;;;1316   }
00000e  4770              BX       lr
                  |L5.16|
000010  2201              MOVS     r2,#1                 ;1288
000012  2040              MOVS     r0,#0x40              ;1288
000014  5442              STRB     r2,[r0,r1]            ;1288
000016  bf00              NOP                            ;1288
000018  2041              MOVS     r0,#0x41              ;1290
00001a  5c40              LDRB     r0,[r0,r1]            ;1290
00001c  2812              CMP      r0,#0x12              ;1290
00001e  d106              BNE      |L5.46|
000020  6808              LDR      r0,[r1,#0]            ;1293
000022  6880              LDR      r0,[r0,#8]            ;1293
000024  2280              MOVS     r2,#0x80              ;1293
000026  4310              ORRS     r0,r0,r2              ;1293
000028  680a              LDR      r2,[r1,#0]            ;1293
00002a  6090              STR      r0,[r2,#8]            ;1293
00002c  e023              B        |L5.118|
                  |L5.46|
00002e  2041              MOVS     r0,#0x41              ;1295
000030  5c40              LDRB     r0,[r0,r1]            ;1295
000032  2822              CMP      r0,#0x22              ;1295
000034  d003              BEQ      |L5.62|
000036  2041              MOVS     r0,#0x41              ;1296
000038  5c40              LDRB     r0,[r0,r1]            ;1296
00003a  2832              CMP      r0,#0x32              ;1296
00003c  d11b              BNE      |L5.118|
                  |L5.62|
00003e  2008              MOVS     r0,#8                 ;1299
000040  680a              LDR      r2,[r1,#0]            ;1299
000042  6210              STR      r0,[r2,#0x20]         ;1299
000044  6808              LDR      r0,[r1,#0]            ;1302
000046  6800              LDR      r0,[r0,#0]            ;1302
000048  22ff              MOVS     r2,#0xff              ;1302
00004a  3201              ADDS     r2,#1                 ;1302
00004c  4310              ORRS     r0,r0,r2              ;1302
00004e  680a              LDR      r2,[r1,#0]            ;1302
000050  6010              STR      r0,[r2,#0]            ;1302
000052  6808              LDR      r0,[r1,#0]            ;1303
000054  6880              LDR      r0,[r0,#8]            ;1303
000056  2201              MOVS     r2,#1                 ;1303
000058  4310              ORRS     r0,r0,r2              ;1303
00005a  680a              LDR      r2,[r1,#0]            ;1303
00005c  6090              STR      r0,[r2,#8]            ;1303
00005e  6808              LDR      r0,[r1,#0]            ;1306
000060  6880              LDR      r0,[r0,#8]            ;1306
000062  2240              MOVS     r2,#0x40              ;1306
000064  4310              ORRS     r0,r0,r2              ;1306
000066  680a              LDR      r2,[r1,#0]            ;1306
000068  6090              STR      r0,[r2,#8]            ;1306
00006a  6808              LDR      r0,[r1,#0]            ;1309
00006c  6880              LDR      r0,[r0,#8]            ;1309
00006e  2280              MOVS     r2,#0x80              ;1309
000070  4310              ORRS     r0,r0,r2              ;1309
000072  680a              LDR      r2,[r1,#0]            ;1309
000074  6090              STR      r0,[r2,#8]            ;1309
                  |L5.118|
000076  bf00              NOP                            ;1313
000078  2200              MOVS     r2,#0                 ;1313
00007a  2040              MOVS     r0,#0x40              ;1313
00007c  5442              STRB     r2,[r0,r1]            ;1313
00007e  bf00              NOP                            ;1313
000080  2000              MOVS     r0,#0                 ;1315
000082  e7c4              B        |L5.14|
;;;1317   
                          ENDP


                          AREA ||i.HAL_USART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAStop PROC
;;;1322     */
;;;1323   HAL_StatusTypeDef HAL_USART_DMAStop(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;1324   {
000002  4604              MOV      r4,r0
;;;1325     /* The Lock is not implemented on this API to allow the user application
;;;1326        to call the HAL USART API under callbacks HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback() /
;;;1327        HAL_USART_TxHalfCpltCallback() / HAL_USART_RxHalfCpltCallback (): 
;;;1328        indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete interrupt is 
;;;1329        generated if the DMA transfer interruption occurs at the middle or at the end of the stream
;;;1330        and the corresponding call back is executed. 
;;;1331        */
;;;1332   
;;;1333     /* Disable the USART Tx/Rx DMA requests */
;;;1334     CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
000004  6820              LDR      r0,[r4,#0]
000006  6880              LDR      r0,[r0,#8]
000008  2180              MOVS     r1,#0x80
00000a  4388              BICS     r0,r0,r1
00000c  6821              LDR      r1,[r4,#0]
00000e  6088              STR      r0,[r1,#8]
;;;1335     CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000010  6820              LDR      r0,[r4,#0]
000012  6880              LDR      r0,[r0,#8]
000014  2140              MOVS     r1,#0x40
000016  4388              BICS     r0,r0,r1
000018  6821              LDR      r1,[r4,#0]
00001a  6088              STR      r0,[r1,#8]
;;;1336   
;;;1337     /* Abort the USART DMA tx channel */
;;;1338     if(husart->hdmatx != NULL)
00001c  6ba0              LDR      r0,[r4,#0x38]
00001e  2800              CMP      r0,#0
000020  d002              BEQ      |L6.40|
;;;1339     {
;;;1340       HAL_DMA_Abort(husart->hdmatx);
000022  6ba0              LDR      r0,[r4,#0x38]
000024  f7fffffe          BL       HAL_DMA_Abort
                  |L6.40|
;;;1341     }
;;;1342     /* Abort the USART DMA rx channel */
;;;1343     if(husart->hdmarx != NULL)
000028  6be0              LDR      r0,[r4,#0x3c]
00002a  2800              CMP      r0,#0
00002c  d002              BEQ      |L6.52|
;;;1344     {
;;;1345       HAL_DMA_Abort(husart->hdmarx);
00002e  6be0              LDR      r0,[r4,#0x3c]
000030  f7fffffe          BL       HAL_DMA_Abort
                  |L6.52|
;;;1346     }
;;;1347   
;;;1348     USART_EndTransfer(husart);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       USART_EndTransfer
;;;1349     husart->State = HAL_USART_STATE_READY;
00003a  2101              MOVS     r1,#1
00003c  2041              MOVS     r0,#0x41
00003e  5501              STRB     r1,[r0,r4]
;;;1350   
;;;1351     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1352   }
000042  bd10              POP      {r4,pc}
;;;1353   
                          ENDP


                          AREA ||i.HAL_USART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_DeInit PROC
;;;338      */
;;;339    HAL_StatusTypeDef HAL_USART_DeInit(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;340    {
000002  4604              MOV      r4,r0
;;;341      /* Check the USART handle allocation */
;;;342      if(husart == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L7.12|
;;;343      {
;;;344        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L7.10|
;;;345      }
;;;346    
;;;347      /* Check the parameters */
;;;348      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;349    
;;;350      husart->State = HAL_USART_STATE_BUSY;
;;;351    
;;;352      husart->Instance->CR1 = 0x0U;
;;;353      husart->Instance->CR2 = 0x0U;
;;;354      husart->Instance->CR3 = 0x0U;
;;;355    
;;;356      /* DeInit the low level hardware */
;;;357      HAL_USART_MspDeInit(husart);
;;;358    
;;;359      husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;360      husart->State = HAL_USART_STATE_RESET;
;;;361    
;;;362      /* Process Unlock */
;;;363      __HAL_UNLOCK(husart);
;;;364    
;;;365      return HAL_OK;
;;;366    }
00000a  bd10              POP      {r4,pc}
                  |L7.12|
00000c  2102              MOVS     r1,#2                 ;350
00000e  2041              MOVS     r0,#0x41              ;350
000010  5501              STRB     r1,[r0,r4]            ;350
000012  2000              MOVS     r0,#0                 ;352
000014  6821              LDR      r1,[r4,#0]            ;352
000016  6008              STR      r0,[r1,#0]            ;352
000018  6821              LDR      r1,[r4,#0]            ;353
00001a  6048              STR      r0,[r1,#4]            ;353
00001c  6821              LDR      r1,[r4,#0]            ;354
00001e  6088              STR      r0,[r1,#8]            ;354
000020  4620              MOV      r0,r4                 ;357
000022  f7fffffe          BL       HAL_USART_MspDeInit
000026  2000              MOVS     r0,#0                 ;359
000028  6460              STR      r0,[r4,#0x44]         ;359
00002a  2100              MOVS     r1,#0                 ;360
00002c  2041              MOVS     r0,#0x41              ;360
00002e  5501              STRB     r1,[r0,r4]            ;360
000030  bf00              NOP                            ;363
000032  2040              MOVS     r0,#0x40              ;363
000034  5501              STRB     r1,[r0,r4]            ;363
000036  bf00              NOP                            ;363
000038  2000              MOVS     r0,#0                 ;365
00003a  e7e6              B        |L7.10|
;;;367    
                          ENDP


                          AREA ||i.HAL_USART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_ErrorCallback PROC
;;;1797     */
;;;1798   __weak void HAL_USART_ErrorCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1799   {
;;;1800     /* Prevent unused argument(s) compilation warning */
;;;1801     UNUSED(husart);
;;;1802   
;;;1803     /* NOTE : This function should not be modified, when the callback is needed,
;;;1804               the HAL_USART_ErrorCallback can be implemented in the user file.
;;;1805      */
;;;1806   }
;;;1807   
                          ENDP


                          AREA ||i.HAL_USART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetError PROC
;;;1860     */
;;;1861   uint32_t HAL_USART_GetError(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1862   {
;;;1863     return husart->ErrorCode;
000002  6c48              LDR      r0,[r1,#0x44]
;;;1864   }
000004  4770              BX       lr
;;;1865   
                          ENDP


                          AREA ||i.HAL_USART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetState PROC
;;;1849     */
;;;1850   HAL_USART_StateTypeDef HAL_USART_GetState(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1851   {
;;;1852     return husart->State;
000002  2041              MOVS     r0,#0x41
000004  5c40              LDRB     r0,[r0,r1]
;;;1853   }
000006  4770              BX       lr
;;;1854   
                          ENDP


                          AREA ||i.HAL_USART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_USART_IRQHandler PROC
;;;1548     */
;;;1549   void HAL_USART_IRQHandler(USART_HandleTypeDef *husart)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1550   {
000002  4604              MOV      r4,r0
;;;1551     uint32_t isrflags   = READ_REG(husart->Instance->ISR);
000004  6820              LDR      r0,[r4,#0]
000006  69c5              LDR      r5,[r0,#0x1c]
;;;1552     uint32_t cr1its     = READ_REG(husart->Instance->CR1);
000008  6820              LDR      r0,[r4,#0]
00000a  6806              LDR      r6,[r0,#0]
;;;1553     uint32_t cr3its;
;;;1554     uint32_t errorflags;
;;;1555   
;;;1556     /* If no error occurs */
;;;1557     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
00000c  0728              LSLS     r0,r5,#28
00000e  0f00              LSRS     r0,r0,#28
000010  9000              STR      r0,[sp,#0]
;;;1558     if (errorflags == RESET)
000012  9800              LDR      r0,[sp,#0]
000014  2800              CMP      r0,#0
000016  d113              BNE      |L11.64|
;;;1559     {
;;;1560       /* USART in mode Receiver ---------------------------------------------------*/
;;;1561       if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000018  2020              MOVS     r0,#0x20
00001a  4028              ANDS     r0,r0,r5
00001c  2800              CMP      r0,#0
00001e  d00f              BEQ      |L11.64|
000020  2020              MOVS     r0,#0x20
000022  4030              ANDS     r0,r0,r6
000024  2800              CMP      r0,#0
000026  d00b              BEQ      |L11.64|
;;;1562       {
;;;1563         if(husart->State == HAL_USART_STATE_BUSY_RX)
000028  2041              MOVS     r0,#0x41
00002a  5d00              LDRB     r0,[r0,r4]
00002c  2822              CMP      r0,#0x22
00002e  d103              BNE      |L11.56|
;;;1564         {
;;;1565           USART_Receive_IT(husart);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       USART_Receive_IT
000036  e002              B        |L11.62|
                  |L11.56|
;;;1566         }
;;;1567         else
;;;1568         {
;;;1569           USART_TransmitReceive_IT(husart);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       USART_TransmitReceive_IT
                  |L11.62|
;;;1570         }
;;;1571         return;
;;;1572       }
;;;1573     }
;;;1574   
;;;1575     /* If some errors occur */
;;;1576     cr3its = READ_REG(husart->Instance->CR3);
;;;1577     if(   (errorflags != RESET)
;;;1578        && (   ((cr3its & USART_CR3_EIE) != RESET)
;;;1579            || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
;;;1580     {
;;;1581       /* USART parity error interrupt occurred -------------------------------------*/
;;;1582       if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
;;;1583       {
;;;1584         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_PEF);
;;;1585   
;;;1586         husart->ErrorCode |= HAL_USART_ERROR_PE;
;;;1587       }
;;;1588   
;;;1589       /* USART frame error interrupt occurred --------------------------------------*/
;;;1590       if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;1591       {
;;;1592         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_FEF);
;;;1593   
;;;1594         husart->ErrorCode |= HAL_USART_ERROR_FE;
;;;1595       }
;;;1596   
;;;1597       /* USART noise error interrupt occurred --------------------------------------*/
;;;1598       if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;1599       {
;;;1600         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_NEF);
;;;1601   
;;;1602         husart->ErrorCode |= HAL_USART_ERROR_NE;
;;;1603       }
;;;1604   
;;;1605       /* USART Over-Run interrupt occurred -----------------------------------------*/
;;;1606       if(((isrflags & USART_ISR_ORE) != RESET) &&
;;;1607          (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
;;;1608       {
;;;1609         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_OREF);
;;;1610   
;;;1611         husart->ErrorCode |= HAL_USART_ERROR_ORE;
;;;1612       }
;;;1613   
;;;1614       /* Call USART Error Call back function if need be --------------------------*/
;;;1615       if(husart->ErrorCode != HAL_USART_ERROR_NONE)
;;;1616       {
;;;1617         /* USART in mode Receiver ---------------------------------------------------*/
;;;1618         if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1619         {
;;;1620           if(husart->State == HAL_USART_STATE_BUSY_RX)
;;;1621           {
;;;1622             USART_Receive_IT(husart);
;;;1623           }
;;;1624           else
;;;1625           {
;;;1626             USART_TransmitReceive_IT(husart);
;;;1627           }
;;;1628         }
;;;1629   
;;;1630         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1631            consider error as blocking */
;;;1632         if (((husart->ErrorCode & HAL_USART_ERROR_ORE) != RESET) ||
;;;1633             (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR)))
;;;1634         {  
;;;1635           /* Blocking error : transfer is aborted
;;;1636              Set the USART state ready to be able to start again the process,
;;;1637              Disable Interrupts, and disable DMA requests, if ongoing */
;;;1638           USART_EndTransfer(husart);
;;;1639   
;;;1640           /* Disable the USART DMA Rx request if enabled */
;;;1641           if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
;;;1642           {
;;;1643             CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR | USART_CR3_DMAR);
;;;1644   
;;;1645             /* Abort the USART DMA Tx channel */
;;;1646             if(husart->hdmatx != NULL)
;;;1647             {
;;;1648               /* Set the USART Tx DMA Abort callback to NULL : no callback
;;;1649                  executed at end of DMA abort procedure */
;;;1650               husart->hdmatx->XferAbortCallback = NULL;
;;;1651               
;;;1652               /* Abort DMA TX */
;;;1653               HAL_DMA_Abort_IT(husart->hdmatx);
;;;1654             }
;;;1655   
;;;1656             /* Abort the USART DMA Rx channel */
;;;1657             if(husart->hdmarx != NULL)
;;;1658             {
;;;1659               /* Set the USART Rx DMA Abort callback : 
;;;1660                  will lead to call HAL_USART_ErrorCallback() at end of DMA abort procedure */
;;;1661               husart->hdmarx->XferAbortCallback = USART_DMAAbortOnError;
;;;1662   
;;;1663               /* Abort DMA RX */
;;;1664               if(HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
;;;1665               {
;;;1666                 /* Call Directly husart->hdmarx->XferAbortCallback function in case of error */
;;;1667                 husart->hdmarx->XferAbortCallback(husart->hdmarx);
;;;1668               }
;;;1669             }
;;;1670             else
;;;1671             {
;;;1672               /* Call user error callback */
;;;1673               HAL_USART_ErrorCallback(husart);
;;;1674             }
;;;1675           }
;;;1676           else
;;;1677           {
;;;1678             /* Call user error callback */
;;;1679             HAL_USART_ErrorCallback(husart);
;;;1680           }
;;;1681         }
;;;1682         else
;;;1683         {
;;;1684           /* Non Blocking error : transfer could go on. 
;;;1685              Error is notified to user through user error callback */
;;;1686           HAL_USART_ErrorCallback(husart);
;;;1687           husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1688         }
;;;1689       }
;;;1690       return;
;;;1691   
;;;1692     } /* End if some error occurs */
;;;1693   
;;;1694   
;;;1695     /* USART in mode Transmitter ------------------------------------------------*/
;;;1696     if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1697     {
;;;1698       if(husart->State == HAL_USART_STATE_BUSY_TX)
;;;1699       {
;;;1700         USART_Transmit_IT(husart);
;;;1701       }
;;;1702       else
;;;1703       {
;;;1704         USART_TransmitReceive_IT(husart);
;;;1705       }
;;;1706       return;
;;;1707     }
;;;1708   
;;;1709     /* USART in mode Transmitter (transmission end) -----------------------------*/
;;;1710     if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1711     {
;;;1712       USART_EndTransmit_IT(husart);
;;;1713       return;
;;;1714     }
;;;1715   
;;;1716   }
00003e  bdf8              POP      {r3-r7,pc}
                  |L11.64|
000040  6820              LDR      r0,[r4,#0]            ;1576
000042  6887              LDR      r7,[r0,#8]            ;1576
000044  9800              LDR      r0,[sp,#0]            ;1577
000046  2800              CMP      r0,#0                 ;1577
                  |L11.72|
000048  d07e              BEQ      |L11.328|
00004a  07f8              LSLS     r0,r7,#31             ;1578
00004c  0fc0              LSRS     r0,r0,#31             ;1578
00004e  2800              CMP      r0,#0                 ;1578
000050  d104              BNE      |L11.92|
000052  20ff              MOVS     r0,#0xff              ;1579
000054  3021              ADDS     r0,r0,#0x21           ;1579
000056  4030              ANDS     r0,r0,r6              ;1579
000058  2800              CMP      r0,#0                 ;1579
00005a  d0f5              BEQ      |L11.72|
                  |L11.92|
00005c  07e8              LSLS     r0,r5,#31             ;1582
00005e  0fc0              LSRS     r0,r0,#31             ;1582
000060  2800              CMP      r0,#0                 ;1582
000062  d00b              BEQ      |L11.124|
000064  20ff              MOVS     r0,#0xff              ;1582
000066  3001              ADDS     r0,#1                 ;1582
000068  4030              ANDS     r0,r0,r6              ;1582
00006a  2800              CMP      r0,#0                 ;1582
00006c  d006              BEQ      |L11.124|
00006e  2001              MOVS     r0,#1                 ;1584
000070  6821              LDR      r1,[r4,#0]            ;1584
000072  6208              STR      r0,[r1,#0x20]         ;1584
000074  6c60              LDR      r0,[r4,#0x44]         ;1586
000076  2101              MOVS     r1,#1                 ;1586
000078  4308              ORRS     r0,r0,r1              ;1586
00007a  6460              STR      r0,[r4,#0x44]         ;1586
                  |L11.124|
00007c  2002              MOVS     r0,#2                 ;1590
00007e  4028              ANDS     r0,r0,r5              ;1590
000080  2800              CMP      r0,#0                 ;1590
000082  d00a              BEQ      |L11.154|
000084  07f8              LSLS     r0,r7,#31             ;1590
000086  0fc0              LSRS     r0,r0,#31             ;1590
000088  2800              CMP      r0,#0                 ;1590
00008a  d006              BEQ      |L11.154|
00008c  2002              MOVS     r0,#2                 ;1592
00008e  6821              LDR      r1,[r4,#0]            ;1592
000090  6208              STR      r0,[r1,#0x20]         ;1592
000092  6c60              LDR      r0,[r4,#0x44]         ;1594
000094  2104              MOVS     r1,#4                 ;1594
000096  4308              ORRS     r0,r0,r1              ;1594
000098  6460              STR      r0,[r4,#0x44]         ;1594
                  |L11.154|
00009a  2004              MOVS     r0,#4                 ;1598
00009c  4028              ANDS     r0,r0,r5              ;1598
00009e  2800              CMP      r0,#0                 ;1598
0000a0  d00a              BEQ      |L11.184|
0000a2  07f8              LSLS     r0,r7,#31             ;1598
0000a4  0fc0              LSRS     r0,r0,#31             ;1598
0000a6  2800              CMP      r0,#0                 ;1598
0000a8  d006              BEQ      |L11.184|
0000aa  2004              MOVS     r0,#4                 ;1600
0000ac  6821              LDR      r1,[r4,#0]            ;1600
0000ae  6208              STR      r0,[r1,#0x20]         ;1600
0000b0  6c60              LDR      r0,[r4,#0x44]         ;1602
0000b2  2102              MOVS     r1,#2                 ;1602
0000b4  4308              ORRS     r0,r0,r1              ;1602
0000b6  6460              STR      r0,[r4,#0x44]         ;1602
                  |L11.184|
0000b8  2008              MOVS     r0,#8                 ;1606
0000ba  4028              ANDS     r0,r0,r5              ;1606
0000bc  2800              CMP      r0,#0                 ;1606
0000be  d00e              BEQ      |L11.222|
0000c0  2020              MOVS     r0,#0x20              ;1607
0000c2  4030              ANDS     r0,r0,r6              ;1607
0000c4  2800              CMP      r0,#0                 ;1607
0000c6  d103              BNE      |L11.208|
0000c8  07f8              LSLS     r0,r7,#31             ;1607
0000ca  0fc0              LSRS     r0,r0,#31             ;1607
0000cc  2800              CMP      r0,#0                 ;1607
0000ce  d006              BEQ      |L11.222|
                  |L11.208|
0000d0  2008              MOVS     r0,#8                 ;1609
0000d2  6821              LDR      r1,[r4,#0]            ;1609
0000d4  6208              STR      r0,[r1,#0x20]         ;1609
0000d6  6c60              LDR      r0,[r4,#0x44]         ;1611
0000d8  2108              MOVS     r1,#8                 ;1611
0000da  4308              ORRS     r0,r0,r1              ;1611
0000dc  6460              STR      r0,[r4,#0x44]         ;1611
                  |L11.222|
0000de  6c60              LDR      r0,[r4,#0x44]         ;1615
0000e0  2800              CMP      r0,#0                 ;1615
0000e2  d052              BEQ      |L11.394|
0000e4  2020              MOVS     r0,#0x20              ;1618
0000e6  4028              ANDS     r0,r0,r5              ;1618
0000e8  2800              CMP      r0,#0                 ;1618
0000ea  d00e              BEQ      |L11.266|
0000ec  2020              MOVS     r0,#0x20              ;1618
0000ee  4030              ANDS     r0,r0,r6              ;1618
0000f0  2800              CMP      r0,#0                 ;1618
0000f2  d00a              BEQ      |L11.266|
0000f4  2041              MOVS     r0,#0x41              ;1620
0000f6  5d00              LDRB     r0,[r0,r4]            ;1620
0000f8  2822              CMP      r0,#0x22              ;1620
0000fa  d103              BNE      |L11.260|
0000fc  4620              MOV      r0,r4                 ;1622
0000fe  f7fffffe          BL       USART_Receive_IT
000102  e002              B        |L11.266|
                  |L11.260|
000104  4620              MOV      r0,r4                 ;1626
000106  f7fffffe          BL       USART_TransmitReceive_IT
                  |L11.266|
00010a  6c60              LDR      r0,[r4,#0x44]         ;1632
00010c  2108              MOVS     r1,#8                 ;1632
00010e  4008              ANDS     r0,r0,r1              ;1632
000110  2800              CMP      r0,#0                 ;1632
000112  d105              BNE      |L11.288|
000114  6820              LDR      r0,[r4,#0]            ;1633
000116  6880              LDR      r0,[r0,#8]            ;1633
000118  2140              MOVS     r1,#0x40              ;1633
00011a  4008              ANDS     r0,r0,r1              ;1633
00011c  2800              CMP      r0,#0                 ;1633
00011e  d02f              BEQ      |L11.384|
                  |L11.288|
000120  4620              MOV      r0,r4                 ;1638
000122  f7fffffe          BL       USART_EndTransfer
000126  6820              LDR      r0,[r4,#0]            ;1641
000128  6880              LDR      r0,[r0,#8]            ;1641
00012a  2140              MOVS     r1,#0x40              ;1641
00012c  4008              ANDS     r0,r0,r1              ;1641
00012e  2800              CMP      r0,#0                 ;1641
000130  d022              BEQ      |L11.376|
000132  6820              LDR      r0,[r4,#0]            ;1643
000134  6880              LDR      r0,[r0,#8]            ;1643
000136  4388              BICS     r0,r0,r1              ;1643
000138  6821              LDR      r1,[r4,#0]            ;1643
00013a  6088              STR      r0,[r1,#8]            ;1643
00013c  6ba0              LDR      r0,[r4,#0x38]         ;1646
00013e  2800              CMP      r0,#0                 ;1646
000140  d007              BEQ      |L11.338|
000142  2000              MOVS     r0,#0                 ;1650
000144  6ba1              LDR      r1,[r4,#0x38]         ;1650
000146  e000              B        |L11.330|
                  |L11.328|
000148  e020              B        |L11.396|
                  |L11.330|
00014a  6348              STR      r0,[r1,#0x34]         ;1650
00014c  6ba0              LDR      r0,[r4,#0x38]         ;1653
00014e  f7fffffe          BL       HAL_DMA_Abort_IT
                  |L11.338|
000152  6be0              LDR      r0,[r4,#0x3c]         ;1657
000154  2800              CMP      r0,#0                 ;1657
000156  d00b              BEQ      |L11.368|
000158  481d              LDR      r0,|L11.464|
00015a  6be1              LDR      r1,[r4,#0x3c]         ;1661
00015c  6348              STR      r0,[r1,#0x34]         ;1661
00015e  6be0              LDR      r0,[r4,#0x3c]         ;1664
000160  f7fffffe          BL       HAL_DMA_Abort_IT
000164  2800              CMP      r0,#0                 ;1664
000166  d010              BEQ      |L11.394|
000168  6be0              LDR      r0,[r4,#0x3c]         ;1667
00016a  6b41              LDR      r1,[r0,#0x34]         ;1667
00016c  4788              BLX      r1                    ;1667
00016e  e00c              B        |L11.394|
                  |L11.368|
000170  4620              MOV      r0,r4                 ;1673
000172  f7fffffe          BL       HAL_USART_ErrorCallback
000176  e008              B        |L11.394|
                  |L11.376|
000178  4620              MOV      r0,r4                 ;1679
00017a  f7fffffe          BL       HAL_USART_ErrorCallback
00017e  e004              B        |L11.394|
                  |L11.384|
000180  4620              MOV      r0,r4                 ;1686
000182  f7fffffe          BL       HAL_USART_ErrorCallback
000186  2000              MOVS     r0,#0                 ;1687
000188  6460              STR      r0,[r4,#0x44]         ;1687
                  |L11.394|
00018a  e758              B        |L11.62|
                  |L11.396|
00018c  2080              MOVS     r0,#0x80              ;1696
00018e  4028              ANDS     r0,r0,r5              ;1696
000190  2800              CMP      r0,#0                 ;1696
000192  d00f              BEQ      |L11.436|
000194  2080              MOVS     r0,#0x80              ;1696
000196  4030              ANDS     r0,r0,r6              ;1696
000198  2800              CMP      r0,#0                 ;1696
00019a  d00b              BEQ      |L11.436|
00019c  2041              MOVS     r0,#0x41              ;1698
00019e  5d00              LDRB     r0,[r0,r4]            ;1698
0001a0  2812              CMP      r0,#0x12              ;1698
0001a2  d103              BNE      |L11.428|
0001a4  4620              MOV      r0,r4                 ;1700
0001a6  f7fffffe          BL       USART_Transmit_IT
0001aa  e002              B        |L11.434|
                  |L11.428|
0001ac  4620              MOV      r0,r4                 ;1704
0001ae  f7fffffe          BL       USART_TransmitReceive_IT
                  |L11.434|
0001b2  e744              B        |L11.62|
                  |L11.436|
0001b4  2040              MOVS     r0,#0x40              ;1710
0001b6  4028              ANDS     r0,r0,r5              ;1710
0001b8  2800              CMP      r0,#0                 ;1710
0001ba  d007              BEQ      |L11.460|
0001bc  2040              MOVS     r0,#0x40              ;1710
0001be  4030              ANDS     r0,r0,r6              ;1710
0001c0  2800              CMP      r0,#0                 ;1710
0001c2  d003              BEQ      |L11.460|
0001c4  4620              MOV      r0,r4                 ;1712
0001c6  f7fffffe          BL       USART_EndTransmit_IT
0001ca  e738              B        |L11.62|
                  |L11.460|
0001cc  bf00              NOP      
0001ce  e736              B        |L11.62|
;;;1717   
                          ENDP

                  |L11.464|
                          DCD      USART_DMAAbortOnError

                          AREA ||i.HAL_USART_Init||, CODE, READONLY, ALIGN=1

                  HAL_USART_Init PROC
;;;275      */
;;;276    HAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;277    {
000002  4604              MOV      r4,r0
;;;278      /* Check the USART handle allocation */
;;;279      if(husart == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L12.12|
;;;280      {
;;;281        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L12.10|
;;;282      }
;;;283    
;;;284      /* Check the parameters */
;;;285      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;286    
;;;287      if(husart->State == HAL_USART_STATE_RESET)
;;;288      {
;;;289        /* Allocate lock resource and initialize it */
;;;290        husart->Lock = HAL_UNLOCKED;
;;;291    
;;;292        /* Init the low level hardware : GPIO, CLOCK */
;;;293        HAL_USART_MspInit(husart);
;;;294      }
;;;295    
;;;296      husart->State = HAL_USART_STATE_BUSY;
;;;297    
;;;298      /* Disable the Peripheral */
;;;299      __HAL_USART_DISABLE(husart);
;;;300    
;;;301      /* Set the Usart Communication parameters */
;;;302      if (USART_SetConfig(husart) == HAL_ERROR)
;;;303      {
;;;304        return HAL_ERROR;
;;;305      }
;;;306    
;;;307      /* In Synchronous mode, the following bits must be kept cleared:
;;;308      - LINEN bit (if LIN is supported) in the USART_CR2 register
;;;309      - SCEN (if Smartcard is supported), HDSEL and IREN (if IrDA is supported) bits in the USART_CR3 register. */
;;;310    #if defined (USART_CR2_LINEN)
;;;311      husart->Instance->CR2 &= ~USART_CR2_LINEN;
;;;312    #endif
;;;313    #if defined (USART_CR3_SCEN)
;;;314    #if defined (USART_CR3_IREN)
;;;315      husart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
;;;316    #else
;;;317      husart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL);
;;;318    #endif
;;;319    #else
;;;320    #if defined (USART_CR3_IREN)
;;;321      husart->Instance->CR3 &= ~(USART_CR3_HDSEL | USART_CR3_IREN);
;;;322    #else
;;;323      husart->Instance->CR3 &= ~(USART_CR3_HDSEL);
;;;324    #endif
;;;325    #endif
;;;326    
;;;327      /* Enable the Peripheral */
;;;328      __HAL_USART_ENABLE(husart);
;;;329    
;;;330      /* TEACK and/or REACK to check before moving husart->State to Ready */
;;;331      return (USART_CheckIdleState(husart));
;;;332    }
00000a  bd10              POP      {r4,pc}
                  |L12.12|
00000c  2041              MOVS     r0,#0x41              ;287
00000e  5d00              LDRB     r0,[r0,r4]            ;287
000010  2800              CMP      r0,#0                 ;287
000012  d105              BNE      |L12.32|
000014  2100              MOVS     r1,#0                 ;290
000016  2040              MOVS     r0,#0x40              ;290
000018  5501              STRB     r1,[r0,r4]            ;290
00001a  4620              MOV      r0,r4                 ;293
00001c  f7fffffe          BL       HAL_USART_MspInit
                  |L12.32|
000020  2102              MOVS     r1,#2                 ;296
000022  2041              MOVS     r0,#0x41              ;296
000024  5501              STRB     r1,[r0,r4]            ;296
000026  6820              LDR      r0,[r4,#0]            ;299
000028  6800              LDR      r0,[r0,#0]            ;299
00002a  0840              LSRS     r0,r0,#1              ;299
00002c  0040              LSLS     r0,r0,#1              ;299
00002e  6821              LDR      r1,[r4,#0]            ;299
000030  6008              STR      r0,[r1,#0]            ;299
000032  4620              MOV      r0,r4                 ;302
000034  f7fffffe          BL       USART_SetConfig
000038  2801              CMP      r0,#1                 ;302
00003a  d100              BNE      |L12.62|
00003c  e7e5              B        |L12.10|
                  |L12.62|
00003e  6820              LDR      r0,[r4,#0]            ;323
000040  6880              LDR      r0,[r0,#8]            ;323
000042  2108              MOVS     r1,#8                 ;323
000044  4388              BICS     r0,r0,r1              ;323
000046  6821              LDR      r1,[r4,#0]            ;323
000048  6088              STR      r0,[r1,#8]            ;323
00004a  6820              LDR      r0,[r4,#0]            ;328
00004c  6800              LDR      r0,[r0,#0]            ;328
00004e  2101              MOVS     r1,#1                 ;328
000050  4308              ORRS     r0,r0,r1              ;328
000052  6821              LDR      r1,[r4,#0]            ;328
000054  6008              STR      r0,[r1,#0]            ;328
000056  4620              MOV      r0,r4                 ;331
000058  f7fffffe          BL       USART_CheckIdleState
00005c  e7d5              B        |L12.10|
;;;333    
                          ENDP


                          AREA ||i.HAL_USART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspDeInit PROC
;;;387      */
;;;388    __weak void HAL_USART_MspDeInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;389    {
;;;390      /* Prevent unused argument(s) compilation warning */
;;;391      UNUSED(husart);
;;;392    
;;;393      /* NOTE : This function should not be modified, when the callback is needed,
;;;394                the HAL_USART_MspDeInit can be implemented in the user file
;;;395       */
;;;396    }
;;;397    
                          ENDP


                          AREA ||i.HAL_USART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspInit PROC
;;;372      */
;;;373    __weak void HAL_USART_MspInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;374    {
;;;375      /* Prevent unused argument(s) compilation warning */
;;;376      UNUSED(husart);
;;;377    
;;;378      /* NOTE : This function should not be modified, when the callback is needed,
;;;379                the HAL_USART_MspInit can be implemented in the user file
;;;380       */
;;;381    }
;;;382    
                          ENDP


                          AREA ||i.HAL_USART_Receive||, CODE, READONLY, ALIGN=2

                  HAL_USART_Receive PROC
;;;575      */
;;;576    HAL_StatusTypeDef HAL_USART_Receive(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  b5f0              PUSH     {r4-r7,lr}
;;;577    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;578      uint16_t* tmp=0U;
00000c  2000              MOVS     r0,#0
00000e  9003              STR      r0,[sp,#0xc]
;;;579      uint16_t uhMask;
;;;580      uint32_t tickstart = 0U;
000010  9001              STR      r0,[sp,#4]
;;;581    
;;;582      if(husart->State == HAL_USART_STATE_READY)
000012  2041              MOVS     r0,#0x41
000014  5d00              LDRB     r0,[r0,r4]
000016  2801              CMP      r0,#1
000018  d171              BNE      |L15.254|
;;;583      {
;;;584        if((pRxData == NULL) || (Size == 0U))
00001a  2d00              CMP      r5,#0
00001c  d001              BEQ      |L15.34|
00001e  2e00              CMP      r6,#0
000020  d102              BNE      |L15.40|
                  |L15.34|
;;;585        {
;;;586          return  HAL_ERROR;
000022  2001              MOVS     r0,#1
                  |L15.36|
;;;587        }
;;;588    
;;;589        /* In case of 9bits/No Parity transfer, pRxData buffer provided as input paramter 
;;;590           should be aligned on a u16 frontier, as data to be received from RDR will be 
;;;591           handled through a u16 cast. */
;;;592        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;593        {
;;;594          if((((uint32_t)pRxData)&1U) != 0U)
;;;595          {
;;;596            return  HAL_ERROR;
;;;597          }
;;;598        }
;;;599    
;;;600        /* Process Locked */
;;;601        __HAL_LOCK(husart);
;;;602    
;;;603        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;604        husart->State = HAL_USART_STATE_BUSY_RX;
;;;605    
;;;606        /* Init tickstart for timeout managment*/
;;;607        tickstart = HAL_GetTick();
;;;608    
;;;609        husart->RxXferSize = Size;
;;;610        husart->RxXferCount = Size;
;;;611    
;;;612        /* Computation of USART mask to apply to RDR register */
;;;613        USART_MASK_COMPUTATION(husart);
;;;614        uhMask = husart->Mask;
;;;615    
;;;616        /* as long as data have to be received */
;;;617        while(husart->RxXferCount > 0U)
;;;618        {
;;;619          husart->RxXferCount--;
;;;620    
;;;621          /* Wait until TC flag is set to send dummy byte in order to generate the
;;;622          * clock for the slave to send data.
;;;623           * Whatever the frame length (7, 8 or 9-bit long), the same dummy value
;;;624           * can be written for all the cases. */
;;;625          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;626          {
;;;627            return HAL_TIMEOUT;
;;;628          }
;;;629          husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x0FFU);
;;;630    
;;;631          /* Wait for RXNE Flag */
;;;632          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;633          {
;;;634            return HAL_TIMEOUT;
;;;635          }
;;;636    
;;;637          if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;638          {
;;;639            tmp = (uint16_t*) pRxData ;
;;;640            *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
;;;641            pRxData +=2;
;;;642          }
;;;643          else
;;;644          {
;;;645            *pRxData++ = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
;;;646          }
;;;647        }
;;;648    
;;;649        /* At end of Rx process, restore husart->State to Ready */
;;;650        husart->State = HAL_USART_STATE_READY;
;;;651    
;;;652        /* Process Unlocked */
;;;653        __HAL_UNLOCK(husart);
;;;654    
;;;655        return HAL_OK;
;;;656      }
;;;657      else
;;;658      {
;;;659        return HAL_BUSY;
;;;660      }
;;;661    }
000024  b005              ADD      sp,sp,#0x14
000026  bdf0              POP      {r4-r7,pc}
                  |L15.40|
000028  2101              MOVS     r1,#1                 ;592
00002a  0309              LSLS     r1,r1,#12             ;592
00002c  68a0              LDR      r0,[r4,#8]            ;592
00002e  4288              CMP      r0,r1                 ;592
000030  d108              BNE      |L15.68|
000032  6920              LDR      r0,[r4,#0x10]         ;592
000034  2800              CMP      r0,#0                 ;592
000036  d105              BNE      |L15.68|
000038  07e8              LSLS     r0,r5,#31             ;594
00003a  0fc0              LSRS     r0,r0,#31             ;594
00003c  2800              CMP      r0,#0                 ;594
00003e  d001              BEQ      |L15.68|
000040  2001              MOVS     r0,#1                 ;596
000042  e7ef              B        |L15.36|
                  |L15.68|
000044  bf00              NOP                            ;601
000046  2040              MOVS     r0,#0x40              ;601
000048  5d00              LDRB     r0,[r0,r4]            ;601
00004a  2801              CMP      r0,#1                 ;601
00004c  d101              BNE      |L15.82|
00004e  2002              MOVS     r0,#2                 ;601
000050  e7e8              B        |L15.36|
                  |L15.82|
000052  2101              MOVS     r1,#1                 ;601
000054  2040              MOVS     r0,#0x40              ;601
000056  5501              STRB     r1,[r0,r4]            ;601
000058  bf00              NOP                            ;601
00005a  2000              MOVS     r0,#0                 ;603
00005c  6460              STR      r0,[r4,#0x44]         ;603
00005e  2122              MOVS     r1,#0x22              ;604
000060  2041              MOVS     r0,#0x41              ;604
000062  5501              STRB     r1,[r0,r4]            ;604
000064  f7fffffe          BL       HAL_GetTick
000068  9001              STR      r0,[sp,#4]            ;607
00006a  8626              STRH     r6,[r4,#0x30]         ;609
00006c  8666              STRH     r6,[r4,#0x32]         ;610
00006e  bf00              NOP                            ;613
000070  2101              MOVS     r1,#1                 ;613
000072  0309              LSLS     r1,r1,#12             ;613
000074  68a0              LDR      r0,[r4,#8]            ;613
000076  4288              CMP      r0,r1                 ;613
000078  d108              BNE      |L15.140|
00007a  6920              LDR      r0,[r4,#0x10]         ;613
00007c  2800              CMP      r0,#0                 ;613
00007e  d102              BNE      |L15.134|
000080  4833              LDR      r0,|L15.336|
000082  86a0              STRH     r0,[r4,#0x34]         ;613
000084  e01b              B        |L15.190|
                  |L15.134|
000086  20ff              MOVS     r0,#0xff              ;613
000088  86a0              STRH     r0,[r4,#0x34]         ;613
00008a  e018              B        |L15.190|
                  |L15.140|
00008c  68a0              LDR      r0,[r4,#8]            ;613
00008e  2800              CMP      r0,#0                 ;613
000090  d108              BNE      |L15.164|
000092  6920              LDR      r0,[r4,#0x10]         ;613
000094  2800              CMP      r0,#0                 ;613
000096  d102              BNE      |L15.158|
000098  20ff              MOVS     r0,#0xff              ;613
00009a  86a0              STRH     r0,[r4,#0x34]         ;613
00009c  e00f              B        |L15.190|
                  |L15.158|
00009e  207f              MOVS     r0,#0x7f              ;613
0000a0  86a0              STRH     r0,[r4,#0x34]         ;613
0000a2  e00c              B        |L15.190|
                  |L15.164|
0000a4  2101              MOVS     r1,#1                 ;613
0000a6  0709              LSLS     r1,r1,#28             ;613
0000a8  68a0              LDR      r0,[r4,#8]            ;613
0000aa  4288              CMP      r0,r1                 ;613
0000ac  d107              BNE      |L15.190|
0000ae  6920              LDR      r0,[r4,#0x10]         ;613
0000b0  2800              CMP      r0,#0                 ;613
0000b2  d102              BNE      |L15.186|
0000b4  207f              MOVS     r0,#0x7f              ;613
0000b6  86a0              STRH     r0,[r4,#0x34]         ;613
0000b8  e001              B        |L15.190|
                  |L15.186|
0000ba  203f              MOVS     r0,#0x3f              ;613
0000bc  86a0              STRH     r0,[r4,#0x34]         ;613
                  |L15.190|
0000be  bf00              NOP                            ;613
0000c0  8ea0              LDRH     r0,[r4,#0x34]         ;614
0000c2  9002              STR      r0,[sp,#8]            ;614
0000c4  e034              B        |L15.304|
                  |L15.198|
0000c6  8e60              LDRH     r0,[r4,#0x32]         ;619
0000c8  1e40              SUBS     r0,r0,#1              ;619
0000ca  8660              STRH     r0,[r4,#0x32]         ;619
0000cc  9700              STR      r7,[sp,#0]            ;625
0000ce  2200              MOVS     r2,#0                 ;625
0000d0  2140              MOVS     r1,#0x40              ;625
0000d2  4620              MOV      r0,r4                 ;625
0000d4  9b01              LDR      r3,[sp,#4]            ;625
0000d6  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000da  2800              CMP      r0,#0                 ;625
0000dc  d001              BEQ      |L15.226|
0000de  2003              MOVS     r0,#3                 ;627
0000e0  e7a0              B        |L15.36|
                  |L15.226|
0000e2  20ff              MOVS     r0,#0xff              ;629
0000e4  6821              LDR      r1,[r4,#0]            ;629
0000e6  8508              STRH     r0,[r1,#0x28]         ;629
0000e8  9700              STR      r7,[sp,#0]            ;632
0000ea  2200              MOVS     r2,#0                 ;632
0000ec  2120              MOVS     r1,#0x20              ;632
0000ee  4620              MOV      r0,r4                 ;632
0000f0  9b01              LDR      r3,[sp,#4]            ;632
0000f2  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000f6  2800              CMP      r0,#0                 ;632
0000f8  d002              BEQ      |L15.256|
0000fa  2003              MOVS     r0,#3                 ;634
0000fc  e792              B        |L15.36|
                  |L15.254|
0000fe  e024              B        |L15.330|
                  |L15.256|
000100  2101              MOVS     r1,#1                 ;637
000102  0309              LSLS     r1,r1,#12             ;637
000104  68a0              LDR      r0,[r4,#8]            ;637
000106  4288              CMP      r0,r1                 ;637
000108  d10b              BNE      |L15.290|
00010a  6920              LDR      r0,[r4,#0x10]         ;637
00010c  2800              CMP      r0,#0                 ;637
00010e  d108              BNE      |L15.290|
000110  9503              STR      r5,[sp,#0xc]          ;639
000112  6820              LDR      r0,[r4,#0]            ;640
000114  8c80              LDRH     r0,[r0,#0x24]         ;640
000116  9902              LDR      r1,[sp,#8]            ;640
000118  4008              ANDS     r0,r0,r1              ;640
00011a  9d03              LDR      r5,[sp,#0xc]          ;640
00011c  8028              STRH     r0,[r5,#0]            ;640
00011e  1cad              ADDS     r5,r5,#2              ;641
000120  e006              B        |L15.304|
                  |L15.290|
000122  6820              LDR      r0,[r4,#0]            ;645
000124  8c80              LDRH     r0,[r0,#0x24]         ;645
000126  9902              LDR      r1,[sp,#8]            ;645
000128  b2c9              UXTB     r1,r1                 ;645
00012a  4008              ANDS     r0,r0,r1              ;645
00012c  7028              STRB     r0,[r5,#0]            ;645
00012e  1c6d              ADDS     r5,r5,#1              ;645
                  |L15.304|
000130  8e60              LDRH     r0,[r4,#0x32]         ;617
000132  2800              CMP      r0,#0                 ;617
000134  d1c7              BNE      |L15.198|
000136  2101              MOVS     r1,#1                 ;650
000138  2041              MOVS     r0,#0x41              ;650
00013a  5501              STRB     r1,[r0,r4]            ;650
00013c  bf00              NOP                            ;653
00013e  2100              MOVS     r1,#0                 ;653
000140  2040              MOVS     r0,#0x40              ;653
000142  5501              STRB     r1,[r0,r4]            ;653
000144  bf00              NOP                            ;653
000146  2000              MOVS     r0,#0                 ;655
000148  e76c              B        |L15.36|
                  |L15.330|
00014a  2002              MOVS     r0,#2                 ;659
00014c  e76a              B        |L15.36|
;;;662    
                          ENDP

00014e  0000              DCW      0x0000
                  |L15.336|
                          DCD      0x000001ff

                          AREA ||i.HAL_USART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Receive_DMA PROC
;;;1058     */
;;;1059   HAL_StatusTypeDef HAL_USART_Receive_DMA(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1060   {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;1061     uint32_t *tmp;
;;;1062   
;;;1063     /* Check that a Rx process is not already ongoing */
;;;1064     if(husart->State == HAL_USART_STATE_READY)
000006  2041              MOVS     r0,#0x41
000008  5d00              LDRB     r0,[r0,r4]
00000a  2801              CMP      r0,#1
00000c  d16c              BNE      |L16.232|
;;;1065     {
;;;1066       if((pRxData == NULL) || (Size == 0U))
00000e  9801              LDR      r0,[sp,#4]
000010  2800              CMP      r0,#0
000012  d001              BEQ      |L16.24|
000014  2d00              CMP      r5,#0
000016  d101              BNE      |L16.28|
                  |L16.24|
;;;1067       {
;;;1068         return HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L16.26|
;;;1069       }
;;;1070   
;;;1071       /* In case of 9bits/No Parity transfer, pRxData buffer provided as input paramter 
;;;1072          should be aligned on a u16 frontier, as data copy from RDR will be 
;;;1073          handled by DMA from a u16 frontier. */
;;;1074       if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;1075       {
;;;1076         if((((uint32_t)pRxData)&1U) != 0U)
;;;1077         {
;;;1078           return  HAL_ERROR;
;;;1079         }
;;;1080       }
;;;1081   
;;;1082       /* Process Locked */
;;;1083       __HAL_LOCK(husart);
;;;1084   
;;;1085       husart->pRxBuffPtr = pRxData;
;;;1086       husart->RxXferSize = Size;
;;;1087       husart->pTxBuffPtr = pRxData;
;;;1088       husart->TxXferSize = Size;
;;;1089   
;;;1090       husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1091       husart->State = HAL_USART_STATE_BUSY_RX;
;;;1092   
;;;1093       /* Set the USART DMA Rx transfer complete callback */
;;;1094       husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;1095   
;;;1096       /* Set the USART DMA Half transfer complete callback */
;;;1097       husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;1098   
;;;1099       /* Set the USART DMA Rx transfer error callback */
;;;1100       husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;1101   
;;;1102       /* Enable the USART receive DMA channel */
;;;1103       tmp = (uint32_t*)&pRxData;
;;;1104       HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(uint32_t*)tmp, Size);
;;;1105   
;;;1106       /* Enable the USART transmit DMA channel: the transmit channel is used in order
;;;1107          to generate in the non-blocking mode the clock to the slave device,
;;;1108          this mode isn't a simplex receive mode but a full-duplex receive mode */
;;;1109       /* Set the USART DMA Tx Complete and Error callback to Null */
;;;1110       husart->hdmatx->XferErrorCallback = NULL;
;;;1111       husart->hdmatx->XferHalfCpltCallback = NULL;
;;;1112       husart->hdmatx->XferCpltCallback = NULL;
;;;1113       HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->TDR, Size);
;;;1114   
;;;1115       /* Process Unlocked */
;;;1116       __HAL_UNLOCK(husart);
;;;1117   
;;;1118       /* Enable the USART Parity Error Interrupt */
;;;1119       SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1120   
;;;1121       /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1122       SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1123   
;;;1124       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1125          in the USART CR3 register */
;;;1126       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1127   
;;;1128       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1129          in the USART CR3 register */
;;;1130       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1131   
;;;1132       return HAL_OK;
;;;1133     }
;;;1134     else
;;;1135     {
;;;1136       return HAL_BUSY;
;;;1137     }
;;;1138   }
00001a  bdfe              POP      {r1-r7,pc}
                  |L16.28|
00001c  2101              MOVS     r1,#1                 ;1074
00001e  0309              LSLS     r1,r1,#12             ;1074
000020  68a0              LDR      r0,[r4,#8]            ;1074
000022  4288              CMP      r0,r1                 ;1074
000024  d109              BNE      |L16.58|
000026  6920              LDR      r0,[r4,#0x10]         ;1074
000028  2800              CMP      r0,#0                 ;1074
00002a  d106              BNE      |L16.58|
00002c  9801              LDR      r0,[sp,#4]            ;1076
00002e  07c0              LSLS     r0,r0,#31             ;1076
000030  0fc0              LSRS     r0,r0,#31             ;1076
000032  2800              CMP      r0,#0                 ;1076
000034  d001              BEQ      |L16.58|
000036  2001              MOVS     r0,#1                 ;1078
000038  e7ef              B        |L16.26|
                  |L16.58|
00003a  bf00              NOP                            ;1083
00003c  2040              MOVS     r0,#0x40              ;1083
00003e  5d00              LDRB     r0,[r0,r4]            ;1083
000040  2801              CMP      r0,#1                 ;1083
000042  d101              BNE      |L16.72|
000044  2002              MOVS     r0,#2                 ;1083
000046  e7e8              B        |L16.26|
                  |L16.72|
000048  2101              MOVS     r1,#1                 ;1083
00004a  2040              MOVS     r0,#0x40              ;1083
00004c  5501              STRB     r1,[r0,r4]            ;1083
00004e  bf00              NOP                            ;1083
000050  9801              LDR      r0,[sp,#4]            ;1085
000052  62e0              STR      r0,[r4,#0x2c]         ;1085
000054  8625              STRH     r5,[r4,#0x30]         ;1086
000056  9801              LDR      r0,[sp,#4]            ;1087
000058  6260              STR      r0,[r4,#0x24]         ;1087
00005a  8525              STRH     r5,[r4,#0x28]         ;1088
00005c  2000              MOVS     r0,#0                 ;1090
00005e  6460              STR      r0,[r4,#0x44]         ;1090
000060  2122              MOVS     r1,#0x22              ;1091
000062  2041              MOVS     r0,#0x41              ;1091
000064  5501              STRB     r1,[r0,r4]            ;1091
000066  4821              LDR      r0,|L16.236|
000068  6be1              LDR      r1,[r4,#0x3c]         ;1094
00006a  6288              STR      r0,[r1,#0x28]         ;1094
00006c  4820              LDR      r0,|L16.240|
00006e  6be1              LDR      r1,[r4,#0x3c]         ;1097
000070  62c8              STR      r0,[r1,#0x2c]         ;1097
000072  4820              LDR      r0,|L16.244|
000074  6be1              LDR      r1,[r4,#0x3c]         ;1100
000076  6308              STR      r0,[r1,#0x30]         ;1100
000078  ae01              ADD      r6,sp,#4              ;1103
00007a  6832              LDR      r2,[r6,#0]            ;1104
00007c  6823              LDR      r3,[r4,#0]            ;1104
00007e  4619              MOV      r1,r3                 ;1104
000080  3124              ADDS     r1,r1,#0x24           ;1104
000082  462b              MOV      r3,r5                 ;1104
000084  6be0              LDR      r0,[r4,#0x3c]         ;1104
000086  f7fffffe          BL       HAL_DMA_Start_IT
00008a  2000              MOVS     r0,#0                 ;1110
00008c  6ba1              LDR      r1,[r4,#0x38]         ;1110
00008e  6308              STR      r0,[r1,#0x30]         ;1110
000090  6ba1              LDR      r1,[r4,#0x38]         ;1111
000092  62c8              STR      r0,[r1,#0x2c]         ;1111
000094  6ba1              LDR      r1,[r4,#0x38]         ;1112
000096  6288              STR      r0,[r1,#0x28]         ;1112
000098  6823              LDR      r3,[r4,#0]            ;1113
00009a  461a              MOV      r2,r3                 ;1113
00009c  3228              ADDS     r2,r2,#0x28           ;1113
00009e  6831              LDR      r1,[r6,#0]            ;1113
0000a0  462b              MOV      r3,r5                 ;1113
0000a2  6ba0              LDR      r0,[r4,#0x38]         ;1113
0000a4  f7fffffe          BL       HAL_DMA_Start_IT
0000a8  bf00              NOP                            ;1116
0000aa  2100              MOVS     r1,#0                 ;1116
0000ac  2040              MOVS     r0,#0x40              ;1116
0000ae  5501              STRB     r1,[r0,r4]            ;1116
0000b0  bf00              NOP                            ;1116
0000b2  6820              LDR      r0,[r4,#0]            ;1119
0000b4  6800              LDR      r0,[r0,#0]            ;1119
0000b6  21ff              MOVS     r1,#0xff              ;1119
0000b8  3101              ADDS     r1,#1                 ;1119
0000ba  4308              ORRS     r0,r0,r1              ;1119
0000bc  6821              LDR      r1,[r4,#0]            ;1119
0000be  6008              STR      r0,[r1,#0]            ;1119
0000c0  6820              LDR      r0,[r4,#0]            ;1122
0000c2  6880              LDR      r0,[r0,#8]            ;1122
0000c4  2101              MOVS     r1,#1                 ;1122
0000c6  4308              ORRS     r0,r0,r1              ;1122
0000c8  6821              LDR      r1,[r4,#0]            ;1122
0000ca  6088              STR      r0,[r1,#8]            ;1122
0000cc  6820              LDR      r0,[r4,#0]            ;1126
0000ce  6880              LDR      r0,[r0,#8]            ;1126
0000d0  2140              MOVS     r1,#0x40              ;1126
0000d2  4308              ORRS     r0,r0,r1              ;1126
0000d4  6821              LDR      r1,[r4,#0]            ;1126
0000d6  6088              STR      r0,[r1,#8]            ;1126
0000d8  6820              LDR      r0,[r4,#0]            ;1130
0000da  6880              LDR      r0,[r0,#8]            ;1130
0000dc  2180              MOVS     r1,#0x80              ;1130
0000de  4308              ORRS     r0,r0,r1              ;1130
0000e0  6821              LDR      r1,[r4,#0]            ;1130
0000e2  6088              STR      r0,[r1,#8]            ;1130
0000e4  2000              MOVS     r0,#0                 ;1132
0000e6  e798              B        |L16.26|
                  |L16.232|
0000e8  2002              MOVS     r0,#2                 ;1136
0000ea  e796              B        |L16.26|
;;;1139   
                          ENDP

                  |L16.236|
                          DCD      USART_DMAReceiveCplt
                  |L16.240|
                          DCD      USART_DMARxHalfCplt
                  |L16.244|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Receive_IT||, CODE, READONLY, ALIGN=2

                  HAL_USART_Receive_IT PROC
;;;844      */
;;;845    HAL_StatusTypeDef HAL_USART_Receive_IT(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;846    {
000002  4603              MOV      r3,r0
;;;847      if(husart->State == HAL_USART_STATE_READY)
000004  2041              MOVS     r0,#0x41
000006  5cc0              LDRB     r0,[r0,r3]
000008  2801              CMP      r0,#1
00000a  d16f              BNE      |L17.236|
;;;848      {
;;;849        if((pRxData == NULL) || (Size == 0U))
00000c  2900              CMP      r1,#0
00000e  d001              BEQ      |L17.20|
000010  2a00              CMP      r2,#0
000012  d101              BNE      |L17.24|
                  |L17.20|
;;;850        {
;;;851          return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L17.22|
;;;852        }
;;;853    
;;;854        /* In case of 9bits/No Parity transfer, pRxData buffer provided as input paramter 
;;;855           should be aligned on a u16 frontier, as data to be received from RDR will be 
;;;856           handled through a u16 cast. */
;;;857        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;858        {
;;;859          if((((uint32_t)pRxData)&1U) != 0U)
;;;860          {
;;;861            return  HAL_ERROR;
;;;862          }
;;;863        }
;;;864    
;;;865        /* Process Locked */
;;;866        __HAL_LOCK(husart);
;;;867    
;;;868        husart->pRxBuffPtr = pRxData;
;;;869        husart->RxXferSize = Size;
;;;870        husart->RxXferCount = Size;
;;;871    
;;;872        USART_MASK_COMPUTATION(husart);
;;;873    
;;;874        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;875        husart->State = HAL_USART_STATE_BUSY_RX;
;;;876    
;;;877        /* Process Unlocked */
;;;878        __HAL_UNLOCK(husart);
;;;879    
;;;880        /* Enable the USART Parity Error and Data Register not empty Interrupts */
;;;881        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;882    
;;;883        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;884        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;885    
;;;886        /* Send dummy byte in order to generate the clock for the Slave to send the next data */
;;;887        if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;888        {
;;;889          husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x01FFU);
;;;890        }
;;;891        else
;;;892        {
;;;893          husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FFU);
;;;894        }
;;;895    
;;;896        return HAL_OK;
;;;897      }
;;;898      else
;;;899      {
;;;900        return HAL_BUSY;
;;;901      }
;;;902    }
000016  bd10              POP      {r4,pc}
                  |L17.24|
000018  2401              MOVS     r4,#1                 ;857
00001a  0324              LSLS     r4,r4,#12             ;857
00001c  6898              LDR      r0,[r3,#8]            ;857
00001e  42a0              CMP      r0,r4                 ;857
000020  d108              BNE      |L17.52|
000022  6918              LDR      r0,[r3,#0x10]         ;857
000024  2800              CMP      r0,#0                 ;857
000026  d105              BNE      |L17.52|
000028  07c8              LSLS     r0,r1,#31             ;859
00002a  0fc0              LSRS     r0,r0,#31             ;859
00002c  2800              CMP      r0,#0                 ;859
00002e  d001              BEQ      |L17.52|
000030  2001              MOVS     r0,#1                 ;861
000032  e7f0              B        |L17.22|
                  |L17.52|
000034  bf00              NOP                            ;866
000036  2040              MOVS     r0,#0x40              ;866
000038  5cc0              LDRB     r0,[r0,r3]            ;866
00003a  2801              CMP      r0,#1                 ;866
00003c  d101              BNE      |L17.66|
00003e  2002              MOVS     r0,#2                 ;866
000040  e7e9              B        |L17.22|
                  |L17.66|
000042  2401              MOVS     r4,#1                 ;866
000044  2040              MOVS     r0,#0x40              ;866
000046  54c4              STRB     r4,[r0,r3]            ;866
000048  bf00              NOP                            ;866
00004a  62d9              STR      r1,[r3,#0x2c]         ;868
00004c  861a              STRH     r2,[r3,#0x30]         ;869
00004e  865a              STRH     r2,[r3,#0x32]         ;870
000050  bf00              NOP                            ;872
000052  0324              LSLS     r4,r4,#12             ;872
000054  6898              LDR      r0,[r3,#8]            ;872
000056  42a0              CMP      r0,r4                 ;872
000058  d108              BNE      |L17.108|
00005a  6918              LDR      r0,[r3,#0x10]         ;872
00005c  2800              CMP      r0,#0                 ;872
00005e  d102              BNE      |L17.102|
000060  4823              LDR      r0,|L17.240|
000062  8698              STRH     r0,[r3,#0x34]         ;872
000064  e01b              B        |L17.158|
                  |L17.102|
000066  20ff              MOVS     r0,#0xff              ;872
000068  8698              STRH     r0,[r3,#0x34]         ;872
00006a  e018              B        |L17.158|
                  |L17.108|
00006c  6898              LDR      r0,[r3,#8]            ;872
00006e  2800              CMP      r0,#0                 ;872
000070  d108              BNE      |L17.132|
000072  6918              LDR      r0,[r3,#0x10]         ;872
000074  2800              CMP      r0,#0                 ;872
000076  d102              BNE      |L17.126|
000078  20ff              MOVS     r0,#0xff              ;872
00007a  8698              STRH     r0,[r3,#0x34]         ;872
00007c  e00f              B        |L17.158|
                  |L17.126|
00007e  207f              MOVS     r0,#0x7f              ;872
000080  8698              STRH     r0,[r3,#0x34]         ;872
000082  e00c              B        |L17.158|
                  |L17.132|
000084  2401              MOVS     r4,#1                 ;872
000086  0724              LSLS     r4,r4,#28             ;872
000088  6898              LDR      r0,[r3,#8]            ;872
00008a  42a0              CMP      r0,r4                 ;872
00008c  d107              BNE      |L17.158|
00008e  6918              LDR      r0,[r3,#0x10]         ;872
000090  2800              CMP      r0,#0                 ;872
000092  d102              BNE      |L17.154|
000094  207f              MOVS     r0,#0x7f              ;872
000096  8698              STRH     r0,[r3,#0x34]         ;872
000098  e001              B        |L17.158|
                  |L17.154|
00009a  203f              MOVS     r0,#0x3f              ;872
00009c  8698              STRH     r0,[r3,#0x34]         ;872
                  |L17.158|
00009e  bf00              NOP                            ;872
0000a0  2000              MOVS     r0,#0                 ;874
0000a2  6458              STR      r0,[r3,#0x44]         ;874
0000a4  2422              MOVS     r4,#0x22              ;875
0000a6  2041              MOVS     r0,#0x41              ;875
0000a8  54c4              STRB     r4,[r0,r3]            ;875
0000aa  bf00              NOP                            ;878
0000ac  2400              MOVS     r4,#0                 ;878
0000ae  2040              MOVS     r0,#0x40              ;878
0000b0  54c4              STRB     r4,[r0,r3]            ;878
0000b2  bf00              NOP                            ;878
0000b4  6818              LDR      r0,[r3,#0]            ;881
0000b6  6800              LDR      r0,[r0,#0]            ;881
0000b8  24ff              MOVS     r4,#0xff              ;881
0000ba  3421              ADDS     r4,r4,#0x21           ;881
0000bc  4320              ORRS     r0,r0,r4              ;881
0000be  681c              LDR      r4,[r3,#0]            ;881
0000c0  6020              STR      r0,[r4,#0]            ;881
0000c2  6818              LDR      r0,[r3,#0]            ;884
0000c4  6880              LDR      r0,[r0,#8]            ;884
0000c6  2401              MOVS     r4,#1                 ;884
0000c8  4320              ORRS     r0,r0,r4              ;884
0000ca  681c              LDR      r4,[r3,#0]            ;884
0000cc  60a0              STR      r0,[r4,#8]            ;884
0000ce  2401              MOVS     r4,#1                 ;887
0000d0  0324              LSLS     r4,r4,#12             ;887
0000d2  6898              LDR      r0,[r3,#8]            ;887
0000d4  42a0              CMP      r0,r4                 ;887
0000d6  d103              BNE      |L17.224|
0000d8  4805              LDR      r0,|L17.240|
0000da  681c              LDR      r4,[r3,#0]            ;889
0000dc  8520              STRH     r0,[r4,#0x28]         ;889
0000de  e002              B        |L17.230|
                  |L17.224|
0000e0  20ff              MOVS     r0,#0xff              ;893
0000e2  681c              LDR      r4,[r3,#0]            ;893
0000e4  8520              STRH     r0,[r4,#0x28]         ;893
                  |L17.230|
0000e6  2000              MOVS     r0,#0                 ;896
0000e8  e795              B        |L17.22|
0000ea  e7ff              B        |L17.236|
                  |L17.236|
0000ec  2002              MOVS     r0,#2                 ;900
0000ee  e792              B        |L17.22|
;;;903    
                          ENDP

                  |L17.240|
                          DCD      0x000001ff

                          AREA ||i.HAL_USART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxCpltCallback PROC
;;;1752     */
;;;1753   __weak void HAL_USART_RxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1754   {
;;;1755     /* Prevent unused argument(s) compilation warning */
;;;1756     UNUSED(husart);
;;;1757   
;;;1758     /* NOTE: This function should not be modified, when the callback is needed,
;;;1759              the HAL_USART_RxCpltCallback can be implemented in the user file.
;;;1760      */
;;;1761   }
;;;1762   
                          ENDP


                          AREA ||i.HAL_USART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxHalfCpltCallback PROC
;;;1767     */
;;;1768   __weak void HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1769   {
;;;1770     /* Prevent unused argument(s) compilation warning */
;;;1771     UNUSED(husart);
;;;1772   
;;;1773     /* NOTE : This function should not be modified, when the callback is needed,
;;;1774               the HAL_USART_RxHalfCpltCallback can be implemented in the user file
;;;1775      */
;;;1776   }
;;;1777   
                          ENDP


                          AREA ||i.HAL_USART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit PROC
;;;488      */
;;;489    HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
000000  b5fe              PUSH     {r1-r7,lr}
;;;490    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;491      uint16_t* tmp=0U;
00000a  2000              MOVS     r0,#0
00000c  9002              STR      r0,[sp,#8]
;;;492      uint32_t tickstart = 0U;
00000e  9001              STR      r0,[sp,#4]
;;;493    
;;;494      if(husart->State == HAL_USART_STATE_READY)
000010  2041              MOVS     r0,#0x41
000012  5d00              LDRB     r0,[r0,r4]
000014  2801              CMP      r0,#1
000016  d164              BNE      |L20.226|
;;;495      {
;;;496        if((pTxData == NULL) || (Size == 0U))
000018  2d00              CMP      r5,#0
00001a  d001              BEQ      |L20.32|
00001c  2e00              CMP      r6,#0
00001e  d101              BNE      |L20.36|
                  |L20.32|
;;;497        {
;;;498          return  HAL_ERROR;
000020  2001              MOVS     r0,#1
                  |L20.34|
;;;499        }
;;;500    
;;;501        /* In case of 9bits/No Parity transfer, pTxData buffer provided as input paramter 
;;;502           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;503           handled through a u16 cast. */
;;;504        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;505        {
;;;506          if((((uint32_t)pTxData)&1U) != 0U)
;;;507          {
;;;508            return  HAL_ERROR;
;;;509          }
;;;510        }
;;;511    
;;;512        /* Process Locked */
;;;513        __HAL_LOCK(husart);
;;;514    
;;;515        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;516        husart->State = HAL_USART_STATE_BUSY_TX;
;;;517    
;;;518        /* Init tickstart for timeout managment*/
;;;519        tickstart = HAL_GetTick();
;;;520    
;;;521        husart->TxXferSize = Size;
;;;522        husart->TxXferCount = Size;
;;;523    
;;;524        /* Check the remaining data to be sent */
;;;525        while(husart->TxXferCount > 0)
;;;526        {
;;;527          husart->TxXferCount--;
;;;528          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;529          {
;;;530            return HAL_TIMEOUT;
;;;531          }
;;;532          if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;533          {
;;;534            tmp = (uint16_t*) pTxData;
;;;535            husart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;536            pTxData += 2U;
;;;537          }
;;;538          else
;;;539          {
;;;540            husart->Instance->TDR = (*pTxData++ & (uint8_t)0xFFU);
;;;541          }
;;;542        }
;;;543    
;;;544        if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;545        {
;;;546          return HAL_TIMEOUT;
;;;547        }
;;;548    
;;;549        /* At end of Tx process, restore husart->State to Ready */
;;;550        husart->State = HAL_USART_STATE_READY;
;;;551    
;;;552        /* Process Unlocked */
;;;553        __HAL_UNLOCK(husart);
;;;554    
;;;555        return HAL_OK;
;;;556      }
;;;557      else
;;;558      {
;;;559        return HAL_BUSY;
;;;560      }
;;;561    }
000022  bdfe              POP      {r1-r7,pc}
                  |L20.36|
000024  2101              MOVS     r1,#1                 ;504
000026  0309              LSLS     r1,r1,#12             ;504
000028  68a0              LDR      r0,[r4,#8]            ;504
00002a  4288              CMP      r0,r1                 ;504
00002c  d108              BNE      |L20.64|
00002e  6920              LDR      r0,[r4,#0x10]         ;504
000030  2800              CMP      r0,#0                 ;504
000032  d105              BNE      |L20.64|
000034  07e8              LSLS     r0,r5,#31             ;506
000036  0fc0              LSRS     r0,r0,#31             ;506
000038  2800              CMP      r0,#0                 ;506
00003a  d001              BEQ      |L20.64|
00003c  2001              MOVS     r0,#1                 ;508
00003e  e7f0              B        |L20.34|
                  |L20.64|
000040  bf00              NOP                            ;513
000042  2040              MOVS     r0,#0x40              ;513
000044  5d00              LDRB     r0,[r0,r4]            ;513
000046  2801              CMP      r0,#1                 ;513
000048  d101              BNE      |L20.78|
00004a  2002              MOVS     r0,#2                 ;513
00004c  e7e9              B        |L20.34|
                  |L20.78|
00004e  2101              MOVS     r1,#1                 ;513
000050  2040              MOVS     r0,#0x40              ;513
000052  5501              STRB     r1,[r0,r4]            ;513
000054  bf00              NOP                            ;513
000056  2000              MOVS     r0,#0                 ;515
000058  6460              STR      r0,[r4,#0x44]         ;515
00005a  2112              MOVS     r1,#0x12              ;516
00005c  2041              MOVS     r0,#0x41              ;516
00005e  5501              STRB     r1,[r0,r4]            ;516
000060  f7fffffe          BL       HAL_GetTick
000064  9001              STR      r0,[sp,#4]            ;519
000066  8526              STRH     r6,[r4,#0x28]         ;521
000068  8566              STRH     r6,[r4,#0x2a]         ;522
00006a  e022              B        |L20.178|
                  |L20.108|
00006c  8d60              LDRH     r0,[r4,#0x2a]         ;527
00006e  1e40              SUBS     r0,r0,#1              ;527
000070  8560              STRH     r0,[r4,#0x2a]         ;527
000072  9700              STR      r7,[sp,#0]            ;528
000074  2200              MOVS     r2,#0                 ;528
000076  2140              MOVS     r1,#0x40              ;528
000078  4620              MOV      r0,r4                 ;528
00007a  9b01              LDR      r3,[sp,#4]            ;528
00007c  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000080  2800              CMP      r0,#0                 ;528
000082  d001              BEQ      |L20.136|
000084  2003              MOVS     r0,#3                 ;530
000086  e7cc              B        |L20.34|
                  |L20.136|
000088  2101              MOVS     r1,#1                 ;532
00008a  0309              LSLS     r1,r1,#12             ;532
00008c  68a0              LDR      r0,[r4,#8]            ;532
00008e  4288              CMP      r0,r1                 ;532
000090  d10b              BNE      |L20.170|
000092  6920              LDR      r0,[r4,#0x10]         ;532
000094  2800              CMP      r0,#0                 ;532
000096  d108              BNE      |L20.170|
000098  9502              STR      r5,[sp,#8]            ;534
00009a  9d02              LDR      r5,[sp,#8]            ;535
00009c  8828              LDRH     r0,[r5,#0]            ;535
00009e  05c0              LSLS     r0,r0,#23             ;535
0000a0  0dc0              LSRS     r0,r0,#23             ;535
0000a2  6821              LDR      r1,[r4,#0]            ;535
0000a4  8508              STRH     r0,[r1,#0x28]         ;535
0000a6  1cad              ADDS     r5,r5,#2              ;536
0000a8  e003              B        |L20.178|
                  |L20.170|
0000aa  7828              LDRB     r0,[r5,#0]            ;540
0000ac  1c6d              ADDS     r5,r5,#1              ;540
0000ae  6821              LDR      r1,[r4,#0]            ;540
0000b0  8508              STRH     r0,[r1,#0x28]         ;540
                  |L20.178|
0000b2  8d60              LDRH     r0,[r4,#0x2a]         ;525
0000b4  2800              CMP      r0,#0                 ;525
0000b6  dcd9              BGT      |L20.108|
0000b8  9700              STR      r7,[sp,#0]            ;544
0000ba  2200              MOVS     r2,#0                 ;544
0000bc  2140              MOVS     r1,#0x40              ;544
0000be  4620              MOV      r0,r4                 ;544
0000c0  9b01              LDR      r3,[sp,#4]            ;544
0000c2  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000c6  2800              CMP      r0,#0                 ;544
0000c8  d001              BEQ      |L20.206|
0000ca  2003              MOVS     r0,#3                 ;546
0000cc  e7a9              B        |L20.34|
                  |L20.206|
0000ce  2101              MOVS     r1,#1                 ;550
0000d0  2041              MOVS     r0,#0x41              ;550
0000d2  5501              STRB     r1,[r0,r4]            ;550
0000d4  bf00              NOP                            ;553
0000d6  2100              MOVS     r1,#0                 ;553
0000d8  2040              MOVS     r0,#0x40              ;553
0000da  5501              STRB     r1,[r0,r4]            ;553
0000dc  bf00              NOP                            ;553
0000de  2000              MOVS     r0,#0                 ;555
0000e0  e79f              B        |L20.34|
                  |L20.226|
0000e2  2002              MOVS     r0,#2                 ;559
0000e4  e79d              B        |L20.34|
;;;562    
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive||, CODE, READONLY, ALIGN=2

                  HAL_USART_TransmitReceive PROC
;;;675      */
;;;676    HAL_StatusTypeDef HAL_USART_TransmitReceive(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  b5f0              PUSH     {r4-r7,lr}
;;;677    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;678      uint16_t* tmp=0U;
00000c  2000              MOVS     r0,#0
00000e  9003              STR      r0,[sp,#0xc]
;;;679      uint16_t uhMask;
;;;680      uint32_t tickstart = 0U;
000010  9001              STR      r0,[sp,#4]
;;;681    
;;;682      if(husart->State == HAL_USART_STATE_READY)
000012  2041              MOVS     r0,#0x41
000014  5d00              LDRB     r0,[r0,r4]
000016  2801              CMP      r0,#1
000018  d16f              BNE      |L21.250|
;;;683      {
;;;684        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
00001a  2d00              CMP      r5,#0
00001c  d003              BEQ      |L21.38|
00001e  2e00              CMP      r6,#0
000020  d001              BEQ      |L21.38|
000022  2f00              CMP      r7,#0
000024  d102              BNE      |L21.44|
                  |L21.38|
;;;685        {
;;;686          return  HAL_ERROR;
000026  2001              MOVS     r0,#1
                  |L21.40|
;;;687        }
;;;688    
;;;689        /* In case of 9bits/No Parity transfer, pTxData and pRxData buffers provided as input paramter 
;;;690           should be aligned on a u16 frontier, as data to be filled into TDR/retrieved from RDR will be 
;;;691           handled through a u16 cast. */
;;;692        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;693        {
;;;694          if(((((uint32_t)pTxData)&1U) != 0U) || ((((uint32_t)pRxData)&1U) != 0U))
;;;695          {
;;;696            return  HAL_ERROR;
;;;697          }
;;;698        }
;;;699    
;;;700        /* Process Locked */
;;;701        __HAL_LOCK(husart);
;;;702    
;;;703        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;704        husart->State = HAL_USART_STATE_BUSY_RX;
;;;705    
;;;706        /* Init tickstart for timeout managment*/
;;;707        tickstart = HAL_GetTick();
;;;708    
;;;709        husart->RxXferSize = Size;
;;;710        husart->TxXferSize = Size;
;;;711        husart->TxXferCount = Size;
;;;712        husart->RxXferCount = Size;
;;;713    
;;;714        /* Computation of USART mask to apply to RDR register */
;;;715        USART_MASK_COMPUTATION(husart);
;;;716        uhMask = husart->Mask;
;;;717    
;;;718        /* Check the remain data to be sent */
;;;719        while(husart->TxXferCount > 0U)
;;;720        {
;;;721          husart->TxXferCount--;
;;;722          husart->RxXferCount--;
;;;723    
;;;724          /* Wait until TC flag is set to send data */
;;;725          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;726          {
;;;727            return HAL_TIMEOUT;
;;;728          }
;;;729          if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;730          {
;;;731            tmp = (uint16_t*) pTxData;
;;;732            husart->Instance->TDR = (*tmp & uhMask);
;;;733            pTxData += 2U;
;;;734          }
;;;735          else
;;;736          {
;;;737            husart->Instance->TDR = (*pTxData++ & (uint8_t)uhMask);
;;;738          }
;;;739    
;;;740          /* Wait for RXNE Flag */
;;;741          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;742          {
;;;743            return HAL_TIMEOUT;
;;;744          }
;;;745    
;;;746          if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;747          {
;;;748            tmp = (uint16_t*) pRxData ;
;;;749            *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
;;;750            pRxData +=2U;
;;;751          }
;;;752          else
;;;753          {
;;;754            *pRxData++ = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
;;;755          }
;;;756        }
;;;757    
;;;758        /* At end of TxRx process, restore husart->State to Ready */
;;;759        husart->State = HAL_USART_STATE_READY;
;;;760    
;;;761        /* Process Unlocked */
;;;762        __HAL_UNLOCK(husart);
;;;763    
;;;764        return HAL_OK;
;;;765      }
;;;766      else
;;;767      {
;;;768        return HAL_BUSY;
;;;769      }
;;;770    }
000028  b005              ADD      sp,sp,#0x14
00002a  bdf0              POP      {r4-r7,pc}
                  |L21.44|
00002c  2101              MOVS     r1,#1                 ;692
00002e  0309              LSLS     r1,r1,#12             ;692
000030  68a0              LDR      r0,[r4,#8]            ;692
000032  4288              CMP      r0,r1                 ;692
000034  d10c              BNE      |L21.80|
000036  6920              LDR      r0,[r4,#0x10]         ;692
000038  2800              CMP      r0,#0                 ;692
00003a  d109              BNE      |L21.80|
00003c  07e8              LSLS     r0,r5,#31             ;694
00003e  0fc0              LSRS     r0,r0,#31             ;694
000040  2800              CMP      r0,#0                 ;694
000042  d103              BNE      |L21.76|
000044  07f0              LSLS     r0,r6,#31             ;694
000046  0fc0              LSRS     r0,r0,#31             ;694
000048  2800              CMP      r0,#0                 ;694
00004a  d001              BEQ      |L21.80|
                  |L21.76|
00004c  2001              MOVS     r0,#1                 ;696
00004e  e7eb              B        |L21.40|
                  |L21.80|
000050  bf00              NOP                            ;701
000052  2040              MOVS     r0,#0x40              ;701
000054  5d00              LDRB     r0,[r0,r4]            ;701
000056  2801              CMP      r0,#1                 ;701
000058  d101              BNE      |L21.94|
00005a  2002              MOVS     r0,#2                 ;701
00005c  e7e4              B        |L21.40|
                  |L21.94|
00005e  2101              MOVS     r1,#1                 ;701
000060  2040              MOVS     r0,#0x40              ;701
000062  5501              STRB     r1,[r0,r4]            ;701
000064  bf00              NOP                            ;701
000066  2000              MOVS     r0,#0                 ;703
000068  6460              STR      r0,[r4,#0x44]         ;703
00006a  2122              MOVS     r1,#0x22              ;704
00006c  2041              MOVS     r0,#0x41              ;704
00006e  5501              STRB     r1,[r0,r4]            ;704
000070  f7fffffe          BL       HAL_GetTick
000074  9001              STR      r0,[sp,#4]            ;707
000076  8627              STRH     r7,[r4,#0x30]         ;709
000078  8527              STRH     r7,[r4,#0x28]         ;710
00007a  8567              STRH     r7,[r4,#0x2a]         ;711
00007c  8667              STRH     r7,[r4,#0x32]         ;712
00007e  bf00              NOP                            ;715
000080  2101              MOVS     r1,#1                 ;715
000082  0309              LSLS     r1,r1,#12             ;715
000084  68a0              LDR      r0,[r4,#8]            ;715
000086  4288              CMP      r0,r1                 ;715
000088  d108              BNE      |L21.156|
00008a  6920              LDR      r0,[r4,#0x10]         ;715
00008c  2800              CMP      r0,#0                 ;715
00008e  d102              BNE      |L21.150|
000090  483f              LDR      r0,|L21.400|
000092  86a0              STRH     r0,[r4,#0x34]         ;715
000094  e01b              B        |L21.206|
                  |L21.150|
000096  20ff              MOVS     r0,#0xff              ;715
000098  86a0              STRH     r0,[r4,#0x34]         ;715
00009a  e018              B        |L21.206|
                  |L21.156|
00009c  68a0              LDR      r0,[r4,#8]            ;715
00009e  2800              CMP      r0,#0                 ;715
0000a0  d108              BNE      |L21.180|
0000a2  6920              LDR      r0,[r4,#0x10]         ;715
0000a4  2800              CMP      r0,#0                 ;715
0000a6  d102              BNE      |L21.174|
0000a8  20ff              MOVS     r0,#0xff              ;715
0000aa  86a0              STRH     r0,[r4,#0x34]         ;715
0000ac  e00f              B        |L21.206|
                  |L21.174|
0000ae  207f              MOVS     r0,#0x7f              ;715
0000b0  86a0              STRH     r0,[r4,#0x34]         ;715
0000b2  e00c              B        |L21.206|
                  |L21.180|
0000b4  2101              MOVS     r1,#1                 ;715
0000b6  0709              LSLS     r1,r1,#28             ;715
0000b8  68a0              LDR      r0,[r4,#8]            ;715
0000ba  4288              CMP      r0,r1                 ;715
0000bc  d107              BNE      |L21.206|
0000be  6920              LDR      r0,[r4,#0x10]         ;715
0000c0  2800              CMP      r0,#0                 ;715
0000c2  d102              BNE      |L21.202|
0000c4  207f              MOVS     r0,#0x7f              ;715
0000c6  86a0              STRH     r0,[r4,#0x34]         ;715
0000c8  e001              B        |L21.206|
                  |L21.202|
0000ca  203f              MOVS     r0,#0x3f              ;715
0000cc  86a0              STRH     r0,[r4,#0x34]         ;715
                  |L21.206|
0000ce  bf00              NOP                            ;715
0000d0  8ea0              LDRH     r0,[r4,#0x34]         ;716
0000d2  9002              STR      r0,[sp,#8]            ;716
0000d4  e04d              B        |L21.370|
                  |L21.214|
0000d6  8d60              LDRH     r0,[r4,#0x2a]         ;721
0000d8  1e40              SUBS     r0,r0,#1              ;721
0000da  8560              STRH     r0,[r4,#0x2a]         ;721
0000dc  8e60              LDRH     r0,[r4,#0x32]         ;722
0000de  1e40              SUBS     r0,r0,#1              ;722
0000e0  8660              STRH     r0,[r4,#0x32]         ;722
0000e2  980a              LDR      r0,[sp,#0x28]         ;725
0000e4  9000              STR      r0,[sp,#0]            ;725
0000e6  2200              MOVS     r2,#0                 ;725
0000e8  2140              MOVS     r1,#0x40              ;725
0000ea  4620              MOV      r0,r4                 ;725
0000ec  9b01              LDR      r3,[sp,#4]            ;725
0000ee  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000f2  2800              CMP      r0,#0                 ;725
0000f4  d002              BEQ      |L21.252|
0000f6  2003              MOVS     r0,#3                 ;727
0000f8  e796              B        |L21.40|
                  |L21.250|
0000fa  e047              B        |L21.396|
                  |L21.252|
0000fc  2101              MOVS     r1,#1                 ;729
0000fe  0309              LSLS     r1,r1,#12             ;729
000100  68a0              LDR      r0,[r4,#8]            ;729
000102  4288              CMP      r0,r1                 ;729
000104  d10b              BNE      |L21.286|
000106  6920              LDR      r0,[r4,#0x10]         ;729
000108  2800              CMP      r0,#0                 ;729
00010a  d108              BNE      |L21.286|
00010c  9503              STR      r5,[sp,#0xc]          ;731
00010e  9d03              LDR      r5,[sp,#0xc]          ;732
000110  8828              LDRH     r0,[r5,#0]            ;732
000112  9902              LDR      r1,[sp,#8]            ;732
000114  4008              ANDS     r0,r0,r1              ;732
000116  6821              LDR      r1,[r4,#0]            ;732
000118  8508              STRH     r0,[r1,#0x28]         ;732
00011a  1cad              ADDS     r5,r5,#2              ;733
00011c  e005              B        |L21.298|
                  |L21.286|
00011e  7828              LDRB     r0,[r5,#0]            ;737
000120  1c6d              ADDS     r5,r5,#1              ;737
000122  9902              LDR      r1,[sp,#8]            ;737
000124  4008              ANDS     r0,r0,r1              ;737
000126  6821              LDR      r1,[r4,#0]            ;737
000128  8508              STRH     r0,[r1,#0x28]         ;737
                  |L21.298|
00012a  980a              LDR      r0,[sp,#0x28]         ;741
00012c  9000              STR      r0,[sp,#0]            ;741
00012e  2200              MOVS     r2,#0                 ;741
000130  2120              MOVS     r1,#0x20              ;741
000132  4620              MOV      r0,r4                 ;741
000134  9b01              LDR      r3,[sp,#4]            ;741
000136  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00013a  2800              CMP      r0,#0                 ;741
00013c  d001              BEQ      |L21.322|
00013e  2003              MOVS     r0,#3                 ;743
000140  e772              B        |L21.40|
                  |L21.322|
000142  2101              MOVS     r1,#1                 ;746
000144  0309              LSLS     r1,r1,#12             ;746
000146  68a0              LDR      r0,[r4,#8]            ;746
000148  4288              CMP      r0,r1                 ;746
00014a  d10b              BNE      |L21.356|
00014c  6920              LDR      r0,[r4,#0x10]         ;746
00014e  2800              CMP      r0,#0                 ;746
000150  d108              BNE      |L21.356|
000152  9603              STR      r6,[sp,#0xc]          ;748
000154  6820              LDR      r0,[r4,#0]            ;749
000156  8c80              LDRH     r0,[r0,#0x24]         ;749
000158  9902              LDR      r1,[sp,#8]            ;749
00015a  4008              ANDS     r0,r0,r1              ;749
00015c  9e03              LDR      r6,[sp,#0xc]          ;749
00015e  8030              STRH     r0,[r6,#0]            ;749
000160  1cb6              ADDS     r6,r6,#2              ;750
000162  e006              B        |L21.370|
                  |L21.356|
000164  6820              LDR      r0,[r4,#0]            ;754
000166  8c80              LDRH     r0,[r0,#0x24]         ;754
000168  9902              LDR      r1,[sp,#8]            ;754
00016a  b2c9              UXTB     r1,r1                 ;754
00016c  4008              ANDS     r0,r0,r1              ;754
00016e  7030              STRB     r0,[r6,#0]            ;754
000170  1c76              ADDS     r6,r6,#1              ;754
                  |L21.370|
000172  8d60              LDRH     r0,[r4,#0x2a]         ;719
000174  2800              CMP      r0,#0                 ;719
000176  d1ae              BNE      |L21.214|
000178  2101              MOVS     r1,#1                 ;759
00017a  2041              MOVS     r0,#0x41              ;759
00017c  5501              STRB     r1,[r0,r4]            ;759
00017e  bf00              NOP                            ;762
000180  2100              MOVS     r1,#0                 ;762
000182  2040              MOVS     r0,#0x40              ;762
000184  5501              STRB     r1,[r0,r4]            ;762
000186  bf00              NOP                            ;762
000188  2000              MOVS     r0,#0                 ;764
00018a  e74d              B        |L21.40|
                  |L21.396|
00018c  2002              MOVS     r0,#2                 ;768
00018e  e74b              B        |L21.40|
;;;771    
                          ENDP

                  |L21.400|
                          DCD      0x000001ff

                          AREA ||i.HAL_USART_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_TransmitReceive_DMA PROC
;;;1151     */
;;;1152   HAL_StatusTypeDef HAL_USART_TransmitReceive_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  b57f              PUSH     {r0-r6,lr}
;;;1153   {
000002  4604              MOV      r4,r0
000004  461d              MOV      r5,r3
;;;1154     uint32_t *tmp;
;;;1155   
;;;1156     if(husart->State == HAL_USART_STATE_READY)
000006  2041              MOVS     r0,#0x41
000008  5d00              LDRB     r0,[r0,r4]
00000a  2801              CMP      r0,#1
00000c  d17b              BNE      |L22.262|
;;;1157     {
;;;1158       if((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
00000e  9801              LDR      r0,[sp,#4]
000010  2800              CMP      r0,#0
000012  d004              BEQ      |L22.30|
000014  9802              LDR      r0,[sp,#8]
000016  2800              CMP      r0,#0
000018  d001              BEQ      |L22.30|
00001a  2d00              CMP      r5,#0
00001c  d102              BNE      |L22.36|
                  |L22.30|
;;;1159       {
;;;1160         return HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L22.32|
;;;1161       }
;;;1162   
;;;1163       /* In case of 9bits/No Parity transfer, pTxData and pRxData buffers provided as input paramter 
;;;1164          should be aligned on a u16 frontier, as data copy to/from TDR/RDR will be 
;;;1165          handled by DMA from a u16 frontier. */
;;;1166       if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;1167       {
;;;1168         if(((((uint32_t)pTxData)&1U) != 0U) || ((((uint32_t)pRxData)&1U) != 0U))
;;;1169         {
;;;1170           return  HAL_ERROR;
;;;1171         }
;;;1172       }
;;;1173   
;;;1174       /* Process Locked */
;;;1175       __HAL_LOCK(husart);
;;;1176   
;;;1177       husart->pRxBuffPtr = pRxData;
;;;1178       husart->RxXferSize = Size;
;;;1179       husart->pTxBuffPtr = pTxData;
;;;1180       husart->TxXferSize = Size;
;;;1181   
;;;1182       husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1183       husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;1184   
;;;1185       /* Set the USART DMA Rx transfer complete callback */
;;;1186       husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;1187   
;;;1188       /* Set the USART DMA Half transfer complete callback */
;;;1189       husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;1190   
;;;1191       /* Set the USART DMA Tx transfer complete callback */
;;;1192       husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;1193   
;;;1194       /* Set the USART DMA Half transfer complete callback */
;;;1195       husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;1196   
;;;1197       /* Set the USART DMA Tx transfer error callback */
;;;1198       husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;1199   
;;;1200       /* Set the USART DMA Rx transfer error callback */
;;;1201       husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;1202   
;;;1203       /* Enable the USART receive DMA channel */
;;;1204       tmp = (uint32_t*)&pRxData;
;;;1205       HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(uint32_t*)tmp, Size);
;;;1206   
;;;1207       /* Enable the USART transmit DMA channel */
;;;1208       tmp = (uint32_t*)&pTxData;
;;;1209       HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->TDR, Size);
;;;1210   
;;;1211       /* Process Unlocked */
;;;1212       __HAL_UNLOCK(husart);
;;;1213   
;;;1214       /* Enable the USART Parity Error Interrupt */
;;;1215       SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;1216   
;;;1217       /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1218       SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1219   
;;;1220       /* Clear the TC flag in the ICR register */
;;;1221       __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
;;;1222   
;;;1223       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1224          in the USART CR3 register */
;;;1225       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1226   
;;;1227       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1228          in the USART CR3 register */
;;;1229       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1230   
;;;1231       return HAL_OK;
;;;1232     }
;;;1233     else
;;;1234     {
;;;1235       return HAL_BUSY;
;;;1236     }
;;;1237   }
000020  b004              ADD      sp,sp,#0x10
000022  bd70              POP      {r4-r6,pc}
                  |L22.36|
000024  2101              MOVS     r1,#1                 ;1166
000026  0309              LSLS     r1,r1,#12             ;1166
000028  68a0              LDR      r0,[r4,#8]            ;1166
00002a  4288              CMP      r0,r1                 ;1166
00002c  d10e              BNE      |L22.76|
00002e  6920              LDR      r0,[r4,#0x10]         ;1166
000030  2800              CMP      r0,#0                 ;1166
000032  d10b              BNE      |L22.76|
000034  9801              LDR      r0,[sp,#4]            ;1168
000036  07c0              LSLS     r0,r0,#31             ;1168
000038  0fc0              LSRS     r0,r0,#31             ;1168
00003a  2800              CMP      r0,#0                 ;1168
00003c  d104              BNE      |L22.72|
00003e  9802              LDR      r0,[sp,#8]            ;1168
000040  07c0              LSLS     r0,r0,#31             ;1168
000042  0fc0              LSRS     r0,r0,#31             ;1168
000044  2800              CMP      r0,#0                 ;1168
000046  d001              BEQ      |L22.76|
                  |L22.72|
000048  2001              MOVS     r0,#1                 ;1170
00004a  e7e9              B        |L22.32|
                  |L22.76|
00004c  bf00              NOP                            ;1175
00004e  2040              MOVS     r0,#0x40              ;1175
000050  5d00              LDRB     r0,[r0,r4]            ;1175
000052  2801              CMP      r0,#1                 ;1175
000054  d101              BNE      |L22.90|
000056  2002              MOVS     r0,#2                 ;1175
000058  e7e2              B        |L22.32|
                  |L22.90|
00005a  2101              MOVS     r1,#1                 ;1175
00005c  2040              MOVS     r0,#0x40              ;1175
00005e  5501              STRB     r1,[r0,r4]            ;1175
000060  bf00              NOP                            ;1175
000062  9802              LDR      r0,[sp,#8]            ;1177
000064  62e0              STR      r0,[r4,#0x2c]         ;1177
000066  8625              STRH     r5,[r4,#0x30]         ;1178
000068  9801              LDR      r0,[sp,#4]            ;1179
00006a  6260              STR      r0,[r4,#0x24]         ;1179
00006c  8525              STRH     r5,[r4,#0x28]         ;1180
00006e  2000              MOVS     r0,#0                 ;1182
000070  6460              STR      r0,[r4,#0x44]         ;1182
000072  2132              MOVS     r1,#0x32              ;1183
000074  2041              MOVS     r0,#0x41              ;1183
000076  5501              STRB     r1,[r0,r4]            ;1183
000078  4824              LDR      r0,|L22.268|
00007a  6be1              LDR      r1,[r4,#0x3c]         ;1186
00007c  6288              STR      r0,[r1,#0x28]         ;1186
00007e  4824              LDR      r0,|L22.272|
000080  6be1              LDR      r1,[r4,#0x3c]         ;1189
000082  62c8              STR      r0,[r1,#0x2c]         ;1189
000084  4823              LDR      r0,|L22.276|
000086  6ba1              LDR      r1,[r4,#0x38]         ;1192
000088  6288              STR      r0,[r1,#0x28]         ;1192
00008a  4823              LDR      r0,|L22.280|
00008c  6ba1              LDR      r1,[r4,#0x38]         ;1195
00008e  62c8              STR      r0,[r1,#0x2c]         ;1195
000090  4822              LDR      r0,|L22.284|
000092  6ba1              LDR      r1,[r4,#0x38]         ;1198
000094  6308              STR      r0,[r1,#0x30]         ;1198
000096  6be1              LDR      r1,[r4,#0x3c]         ;1201
000098  6308              STR      r0,[r1,#0x30]         ;1201
00009a  ae02              ADD      r6,sp,#8              ;1204
00009c  6832              LDR      r2,[r6,#0]            ;1205
00009e  6823              LDR      r3,[r4,#0]            ;1205
0000a0  4619              MOV      r1,r3                 ;1205
0000a2  3124              ADDS     r1,r1,#0x24           ;1205
0000a4  462b              MOV      r3,r5                 ;1205
0000a6  6be0              LDR      r0,[r4,#0x3c]         ;1205
0000a8  f7fffffe          BL       HAL_DMA_Start_IT
0000ac  ae01              ADD      r6,sp,#4              ;1208
0000ae  6823              LDR      r3,[r4,#0]            ;1209
0000b0  461a              MOV      r2,r3                 ;1209
0000b2  3228              ADDS     r2,r2,#0x28           ;1209
0000b4  6831              LDR      r1,[r6,#0]            ;1209
0000b6  462b              MOV      r3,r5                 ;1209
0000b8  6ba0              LDR      r0,[r4,#0x38]         ;1209
0000ba  f7fffffe          BL       HAL_DMA_Start_IT
0000be  bf00              NOP                            ;1212
0000c0  2100              MOVS     r1,#0                 ;1212
0000c2  2040              MOVS     r0,#0x40              ;1212
0000c4  5501              STRB     r1,[r0,r4]            ;1212
0000c6  bf00              NOP                            ;1212
0000c8  6820              LDR      r0,[r4,#0]            ;1215
0000ca  6800              LDR      r0,[r0,#0]            ;1215
0000cc  21ff              MOVS     r1,#0xff              ;1215
0000ce  3101              ADDS     r1,#1                 ;1215
0000d0  4308              ORRS     r0,r0,r1              ;1215
0000d2  6821              LDR      r1,[r4,#0]            ;1215
0000d4  6008              STR      r0,[r1,#0]            ;1215
0000d6  6820              LDR      r0,[r4,#0]            ;1218
0000d8  6880              LDR      r0,[r0,#8]            ;1218
0000da  2101              MOVS     r1,#1                 ;1218
0000dc  4308              ORRS     r0,r0,r1              ;1218
0000de  6821              LDR      r1,[r4,#0]            ;1218
0000e0  6088              STR      r0,[r1,#8]            ;1218
0000e2  2040              MOVS     r0,#0x40              ;1221
0000e4  6821              LDR      r1,[r4,#0]            ;1221
0000e6  6208              STR      r0,[r1,#0x20]         ;1221
0000e8  6820              LDR      r0,[r4,#0]            ;1225
0000ea  6880              LDR      r0,[r0,#8]            ;1225
0000ec  2140              MOVS     r1,#0x40              ;1225
0000ee  4308              ORRS     r0,r0,r1              ;1225
0000f0  6821              LDR      r1,[r4,#0]            ;1225
0000f2  6088              STR      r0,[r1,#8]            ;1225
0000f4  6820              LDR      r0,[r4,#0]            ;1229
0000f6  6880              LDR      r0,[r0,#8]            ;1229
0000f8  2180              MOVS     r1,#0x80              ;1229
0000fa  4308              ORRS     r0,r0,r1              ;1229
0000fc  6821              LDR      r1,[r4,#0]            ;1229
0000fe  6088              STR      r0,[r1,#8]            ;1229
000100  2000              MOVS     r0,#0                 ;1231
000102  e78d              B        |L22.32|
000104  e7ff              B        |L22.262|
                  |L22.262|
000106  2002              MOVS     r0,#2                 ;1235
000108  e78a              B        |L22.32|
;;;1238   
                          ENDP

00010a  0000              DCW      0x0000
                  |L22.268|
                          DCD      USART_DMAReceiveCplt
                  |L22.272|
                          DCD      USART_DMARxHalfCplt
                  |L22.276|
                          DCD      USART_DMATransmitCplt
                  |L22.280|
                          DCD      USART_DMATxHalfCplt
                  |L22.284|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_USART_TransmitReceive_IT PROC
;;;915      */
;;;916    HAL_StatusTypeDef HAL_USART_TransmitReceive_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData,  uint16_t Size)
000000  b530              PUSH     {r4,r5,lr}
;;;917    {
000002  4604              MOV      r4,r0
;;;918    
;;;919      if(husart->State == HAL_USART_STATE_READY)
000004  2041              MOVS     r0,#0x41
000006  5d00              LDRB     r0,[r0,r4]
000008  2801              CMP      r0,#1
00000a  d172              BNE      |L23.242|
;;;920      {
;;;921        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
00000c  2900              CMP      r1,#0
00000e  d003              BEQ      |L23.24|
000010  2a00              CMP      r2,#0
000012  d001              BEQ      |L23.24|
000014  2b00              CMP      r3,#0
000016  d101              BNE      |L23.28|
                  |L23.24|
;;;922        {
;;;923          return HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L23.26|
;;;924        }
;;;925    
;;;926        /* In case of 9bits/No Parity transfer, pTxData and pRxData buffers provided as input paramter 
;;;927           should be aligned on a u16 frontier, as data to be filled into TDR/retrieved from RDR will be 
;;;928           handled through a u16 cast. */
;;;929        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;930        {
;;;931          if(((((uint32_t)pTxData)&1U) != 0U) || ((((uint32_t)pRxData)&1U) != 0U))
;;;932          {
;;;933            return  HAL_ERROR;
;;;934          }
;;;935        }
;;;936    
;;;937        /* Process Locked */
;;;938        __HAL_LOCK(husart);
;;;939    
;;;940        husart->pRxBuffPtr = pRxData;
;;;941        husart->RxXferSize = Size;
;;;942        husart->RxXferCount = Size;
;;;943        husart->pTxBuffPtr = pTxData;
;;;944        husart->TxXferSize = Size;
;;;945        husart->TxXferCount = Size;
;;;946    
;;;947        /* Computation of USART mask to apply to RDR register */
;;;948        USART_MASK_COMPUTATION(husart);
;;;949    
;;;950        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;951        husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;952    
;;;953        /* Process Unlocked */
;;;954        __HAL_UNLOCK(husart);
;;;955    
;;;956        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;957        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;958    
;;;959        /* Enable the USART Parity Error and USART Data Register not empty Interrupts */
;;;960        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;961    
;;;962        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;963        SET_BIT(husart->Instance->CR1, USART_CR1_TXEIE);
;;;964    
;;;965        return HAL_OK;
;;;966      }
;;;967      else
;;;968      {
;;;969        return HAL_BUSY;
;;;970      }
;;;971    }
00001a  bd30              POP      {r4,r5,pc}
                  |L23.28|
00001c  2501              MOVS     r5,#1                 ;929
00001e  032d              LSLS     r5,r5,#12             ;929
000020  68a0              LDR      r0,[r4,#8]            ;929
000022  42a8              CMP      r0,r5                 ;929
000024  d10c              BNE      |L23.64|
000026  6920              LDR      r0,[r4,#0x10]         ;929
000028  2800              CMP      r0,#0                 ;929
00002a  d109              BNE      |L23.64|
00002c  07c8              LSLS     r0,r1,#31             ;931
00002e  0fc0              LSRS     r0,r0,#31             ;931
000030  2800              CMP      r0,#0                 ;931
000032  d103              BNE      |L23.60|
000034  07d0              LSLS     r0,r2,#31             ;931
000036  0fc0              LSRS     r0,r0,#31             ;931
000038  2800              CMP      r0,#0                 ;931
00003a  d001              BEQ      |L23.64|
                  |L23.60|
00003c  2001              MOVS     r0,#1                 ;933
00003e  e7ec              B        |L23.26|
                  |L23.64|
000040  bf00              NOP                            ;938
000042  2040              MOVS     r0,#0x40              ;938
000044  5d00              LDRB     r0,[r0,r4]            ;938
000046  2801              CMP      r0,#1                 ;938
000048  d101              BNE      |L23.78|
00004a  2002              MOVS     r0,#2                 ;938
00004c  e7e5              B        |L23.26|
                  |L23.78|
00004e  2501              MOVS     r5,#1                 ;938
000050  2040              MOVS     r0,#0x40              ;938
000052  5505              STRB     r5,[r0,r4]            ;938
000054  bf00              NOP                            ;938
000056  62e2              STR      r2,[r4,#0x2c]         ;940
000058  8623              STRH     r3,[r4,#0x30]         ;941
00005a  8663              STRH     r3,[r4,#0x32]         ;942
00005c  6261              STR      r1,[r4,#0x24]         ;943
00005e  8523              STRH     r3,[r4,#0x28]         ;944
000060  8563              STRH     r3,[r4,#0x2a]         ;945
000062  bf00              NOP                            ;948
000064  032d              LSLS     r5,r5,#12             ;948
000066  68a0              LDR      r0,[r4,#8]            ;948
000068  42a8              CMP      r0,r5                 ;948
00006a  d108              BNE      |L23.126|
00006c  6920              LDR      r0,[r4,#0x10]         ;948
00006e  2800              CMP      r0,#0                 ;948
000070  d102              BNE      |L23.120|
000072  4821              LDR      r0,|L23.248|
000074  86a0              STRH     r0,[r4,#0x34]         ;948
000076  e01b              B        |L23.176|
                  |L23.120|
000078  20ff              MOVS     r0,#0xff              ;948
00007a  86a0              STRH     r0,[r4,#0x34]         ;948
00007c  e018              B        |L23.176|
                  |L23.126|
00007e  68a0              LDR      r0,[r4,#8]            ;948
000080  2800              CMP      r0,#0                 ;948
000082  d108              BNE      |L23.150|
000084  6920              LDR      r0,[r4,#0x10]         ;948
000086  2800              CMP      r0,#0                 ;948
000088  d102              BNE      |L23.144|
00008a  20ff              MOVS     r0,#0xff              ;948
00008c  86a0              STRH     r0,[r4,#0x34]         ;948
00008e  e00f              B        |L23.176|
                  |L23.144|
000090  207f              MOVS     r0,#0x7f              ;948
000092  86a0              STRH     r0,[r4,#0x34]         ;948
000094  e00c              B        |L23.176|
                  |L23.150|
000096  2501              MOVS     r5,#1                 ;948
000098  072d              LSLS     r5,r5,#28             ;948
00009a  68a0              LDR      r0,[r4,#8]            ;948
00009c  42a8              CMP      r0,r5                 ;948
00009e  d107              BNE      |L23.176|
0000a0  6920              LDR      r0,[r4,#0x10]         ;948
0000a2  2800              CMP      r0,#0                 ;948
0000a4  d102              BNE      |L23.172|
0000a6  207f              MOVS     r0,#0x7f              ;948
0000a8  86a0              STRH     r0,[r4,#0x34]         ;948
0000aa  e001              B        |L23.176|
                  |L23.172|
0000ac  203f              MOVS     r0,#0x3f              ;948
0000ae  86a0              STRH     r0,[r4,#0x34]         ;948
                  |L23.176|
0000b0  bf00              NOP                            ;948
0000b2  2000              MOVS     r0,#0                 ;950
0000b4  6460              STR      r0,[r4,#0x44]         ;950
0000b6  2532              MOVS     r5,#0x32              ;951
0000b8  2041              MOVS     r0,#0x41              ;951
0000ba  5505              STRB     r5,[r0,r4]            ;951
0000bc  bf00              NOP                            ;954
0000be  2500              MOVS     r5,#0                 ;954
0000c0  2040              MOVS     r0,#0x40              ;954
0000c2  5505              STRB     r5,[r0,r4]            ;954
0000c4  bf00              NOP                            ;954
0000c6  6820              LDR      r0,[r4,#0]            ;957
0000c8  6880              LDR      r0,[r0,#8]            ;957
0000ca  2501              MOVS     r5,#1                 ;957
0000cc  4328              ORRS     r0,r0,r5              ;957
0000ce  6825              LDR      r5,[r4,#0]            ;957
0000d0  60a8              STR      r0,[r5,#8]            ;957
0000d2  6820              LDR      r0,[r4,#0]            ;960
0000d4  6800              LDR      r0,[r0,#0]            ;960
0000d6  25ff              MOVS     r5,#0xff              ;960
0000d8  3521              ADDS     r5,r5,#0x21           ;960
0000da  4328              ORRS     r0,r0,r5              ;960
0000dc  6825              LDR      r5,[r4,#0]            ;960
0000de  6028              STR      r0,[r5,#0]            ;960
0000e0  6820              LDR      r0,[r4,#0]            ;963
0000e2  6800              LDR      r0,[r0,#0]            ;963
0000e4  2580              MOVS     r5,#0x80              ;963
0000e6  4328              ORRS     r0,r0,r5              ;963
0000e8  6825              LDR      r5,[r4,#0]            ;963
0000ea  6028              STR      r0,[r5,#0]            ;963
0000ec  2000              MOVS     r0,#0                 ;965
0000ee  e794              B        |L23.26|
0000f0  e7ff              B        |L23.242|
                  |L23.242|
0000f2  2002              MOVS     r0,#2                 ;969
0000f4  e791              B        |L23.26|
;;;972    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L23.248|
                          DCD      0x000001ff

                          AREA ||i.HAL_USART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Transmit_DMA PROC
;;;983      */
;;;984    HAL_StatusTypeDef HAL_USART_Transmit_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;985    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;986      uint32_t *tmp=0U;
000006  2600              MOVS     r6,#0
;;;987    
;;;988      if(husart->State == HAL_USART_STATE_READY)
000008  2041              MOVS     r0,#0x41
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2801              CMP      r0,#1
00000e  d14a              BNE      |L24.166|
;;;989      {
;;;990        if((pTxData == NULL) || (Size == 0U))
000010  9801              LDR      r0,[sp,#4]
000012  2800              CMP      r0,#0
000014  d001              BEQ      |L24.26|
000016  2d00              CMP      r5,#0
000018  d101              BNE      |L24.30|
                  |L24.26|
;;;991        {
;;;992          return HAL_ERROR;
00001a  2001              MOVS     r0,#1
                  |L24.28|
;;;993        }
;;;994    
;;;995        /* In case of 9bits/No Parity transfer, pTxData buffer provided as input paramter 
;;;996           should be aligned on a u16 frontier, as data copy into TDR will be 
;;;997           handled by DMA from a u16 frontier. */
;;;998        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;999        {
;;;1000         if((((uint32_t)pTxData)&1U) != 0U)
;;;1001         {
;;;1002           return  HAL_ERROR;
;;;1003         }
;;;1004       }
;;;1005   
;;;1006       /* Process Locked */
;;;1007       __HAL_LOCK(husart);
;;;1008   
;;;1009       husart->pTxBuffPtr = pTxData;
;;;1010       husart->TxXferSize = Size;
;;;1011       husart->TxXferCount = Size;
;;;1012   
;;;1013       husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1014       husart->State = HAL_USART_STATE_BUSY_TX;
;;;1015   
;;;1016       /* Set the USART DMA transfer complete callback */
;;;1017       husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;1018   
;;;1019       /* Set the USART DMA Half transfer complete callback */
;;;1020       husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;1021   
;;;1022       /* Set the DMA error callback */
;;;1023       husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;1024   
;;;1025       /* Enable the USART transmit DMA channel */
;;;1026       tmp = (uint32_t*)&pTxData;
;;;1027       HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->TDR, Size);
;;;1028   
;;;1029       /* Clear the TC flag in the ICR register */
;;;1030       __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_TCF);
;;;1031   
;;;1032       /* Process Unlocked */
;;;1033       __HAL_UNLOCK(husart);
;;;1034   
;;;1035       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1036          in the USART CR3 register */
;;;1037       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1038   
;;;1039       return HAL_OK;
;;;1040     }
;;;1041     else
;;;1042     {
;;;1043       return HAL_BUSY;
;;;1044     }
;;;1045   }
00001c  bdfe              POP      {r1-r7,pc}
                  |L24.30|
00001e  2101              MOVS     r1,#1                 ;998
000020  0309              LSLS     r1,r1,#12             ;998
000022  68a0              LDR      r0,[r4,#8]            ;998
000024  4288              CMP      r0,r1                 ;998
000026  d109              BNE      |L24.60|
000028  6920              LDR      r0,[r4,#0x10]         ;998
00002a  2800              CMP      r0,#0                 ;998
00002c  d106              BNE      |L24.60|
00002e  9801              LDR      r0,[sp,#4]            ;1000
000030  07c0              LSLS     r0,r0,#31             ;1000
000032  0fc0              LSRS     r0,r0,#31             ;1000
000034  2800              CMP      r0,#0                 ;1000
000036  d001              BEQ      |L24.60|
000038  2001              MOVS     r0,#1                 ;1002
00003a  e7ef              B        |L24.28|
                  |L24.60|
00003c  bf00              NOP                            ;1007
00003e  2040              MOVS     r0,#0x40              ;1007
000040  5d00              LDRB     r0,[r0,r4]            ;1007
000042  2801              CMP      r0,#1                 ;1007
000044  d101              BNE      |L24.74|
000046  2002              MOVS     r0,#2                 ;1007
000048  e7e8              B        |L24.28|
                  |L24.74|
00004a  2101              MOVS     r1,#1                 ;1007
00004c  2040              MOVS     r0,#0x40              ;1007
00004e  5501              STRB     r1,[r0,r4]            ;1007
000050  bf00              NOP                            ;1007
000052  9801              LDR      r0,[sp,#4]            ;1009
000054  6260              STR      r0,[r4,#0x24]         ;1009
000056  8525              STRH     r5,[r4,#0x28]         ;1010
000058  8565              STRH     r5,[r4,#0x2a]         ;1011
00005a  2000              MOVS     r0,#0                 ;1013
00005c  6460              STR      r0,[r4,#0x44]         ;1013
00005e  2112              MOVS     r1,#0x12              ;1014
000060  2041              MOVS     r0,#0x41              ;1014
000062  5501              STRB     r1,[r0,r4]            ;1014
000064  4811              LDR      r0,|L24.172|
000066  6ba1              LDR      r1,[r4,#0x38]         ;1017
000068  6288              STR      r0,[r1,#0x28]         ;1017
00006a  4811              LDR      r0,|L24.176|
00006c  6ba1              LDR      r1,[r4,#0x38]         ;1020
00006e  62c8              STR      r0,[r1,#0x2c]         ;1020
000070  4810              LDR      r0,|L24.180|
000072  6ba1              LDR      r1,[r4,#0x38]         ;1023
000074  6308              STR      r0,[r1,#0x30]         ;1023
000076  ae01              ADD      r6,sp,#4              ;1026
000078  6823              LDR      r3,[r4,#0]            ;1027
00007a  461a              MOV      r2,r3                 ;1027
00007c  3228              ADDS     r2,r2,#0x28           ;1027
00007e  6831              LDR      r1,[r6,#0]            ;1027
000080  462b              MOV      r3,r5                 ;1027
000082  6ba0              LDR      r0,[r4,#0x38]         ;1027
000084  f7fffffe          BL       HAL_DMA_Start_IT
000088  2040              MOVS     r0,#0x40              ;1030
00008a  6821              LDR      r1,[r4,#0]            ;1030
00008c  6208              STR      r0,[r1,#0x20]         ;1030
00008e  bf00              NOP                            ;1033
000090  2100              MOVS     r1,#0                 ;1033
000092  5501              STRB     r1,[r0,r4]            ;1033
000094  bf00              NOP                            ;1033
000096  6820              LDR      r0,[r4,#0]            ;1037
000098  6880              LDR      r0,[r0,#8]            ;1037
00009a  2180              MOVS     r1,#0x80              ;1037
00009c  4308              ORRS     r0,r0,r1              ;1037
00009e  6821              LDR      r1,[r4,#0]            ;1037
0000a0  6088              STR      r0,[r1,#8]            ;1037
0000a2  2000              MOVS     r0,#0                 ;1039
0000a4  e7ba              B        |L24.28|
                  |L24.166|
0000a6  2002              MOVS     r0,#2                 ;1043
0000a8  e7b8              B        |L24.28|
;;;1046   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L24.172|
                          DCD      USART_DMATransmitCplt
                  |L24.176|
                          DCD      USART_DMATxHalfCplt
                  |L24.180|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit_IT PROC
;;;782      */
;;;783    HAL_StatusTypeDef HAL_USART_Transmit_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;784    {
000002  4603              MOV      r3,r0
;;;785      if(husart->State == HAL_USART_STATE_READY)
000004  2041              MOVS     r0,#0x41
000006  5cc0              LDRB     r0,[r0,r3]
000008  2801              CMP      r0,#1
00000a  d133              BNE      |L25.116|
;;;786      {
;;;787        if((pTxData == NULL) || (Size == 0U))
00000c  2900              CMP      r1,#0
00000e  d001              BEQ      |L25.20|
000010  2a00              CMP      r2,#0
000012  d101              BNE      |L25.24|
                  |L25.20|
;;;788        {
;;;789          return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L25.22|
;;;790        }
;;;791    
;;;792        /* In case of 9bits/No Parity transfer, pTxData buffer provided as input paramter 
;;;793           should be aligned on a u16 frontier, as data to be filled into TDR will be 
;;;794           handled through a u16 cast. */
;;;795        if ((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;796        {
;;;797          if((((uint32_t)pTxData)&1U) != 0U)
;;;798          {
;;;799            return  HAL_ERROR;
;;;800          }
;;;801        }
;;;802    
;;;803        /* Process Locked */
;;;804        __HAL_LOCK(husart);
;;;805    
;;;806        husart->pTxBuffPtr = pTxData;
;;;807        husart->TxXferSize = Size;
;;;808        husart->TxXferCount = Size;
;;;809    
;;;810        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;811        husart->State = HAL_USART_STATE_BUSY_TX;
;;;812    
;;;813        /* The USART Error Interrupts: (Frame error, noise error, overrun error)
;;;814        are not managed by the USART Transmit Process to avoid the overrun interrupt
;;;815        when the usart mode is configured for transmit and receive "USART_MODE_TX_RX"
;;;816        to benefit for the frame error and noise interrupts the usart mode should be
;;;817        configured only for transmit "USART_MODE_TX" */
;;;818    
;;;819        /* Process Unlocked */
;;;820        __HAL_UNLOCK(husart);
;;;821    
;;;822        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;823        __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
;;;824    
;;;825        return HAL_OK;
;;;826      }
;;;827      else
;;;828      {
;;;829        return HAL_BUSY;
;;;830      }
;;;831    }
000016  bd10              POP      {r4,pc}
                  |L25.24|
000018  2401              MOVS     r4,#1                 ;795
00001a  0324              LSLS     r4,r4,#12             ;795
00001c  6898              LDR      r0,[r3,#8]            ;795
00001e  42a0              CMP      r0,r4                 ;795
000020  d108              BNE      |L25.52|
000022  6918              LDR      r0,[r3,#0x10]         ;795
000024  2800              CMP      r0,#0                 ;795
000026  d105              BNE      |L25.52|
000028  07c8              LSLS     r0,r1,#31             ;797
00002a  0fc0              LSRS     r0,r0,#31             ;797
00002c  2800              CMP      r0,#0                 ;797
00002e  d001              BEQ      |L25.52|
000030  2001              MOVS     r0,#1                 ;799
000032  e7f0              B        |L25.22|
                  |L25.52|
000034  bf00              NOP                            ;804
000036  2040              MOVS     r0,#0x40              ;804
000038  5cc0              LDRB     r0,[r0,r3]            ;804
00003a  2801              CMP      r0,#1                 ;804
00003c  d101              BNE      |L25.66|
00003e  2002              MOVS     r0,#2                 ;804
000040  e7e9              B        |L25.22|
                  |L25.66|
000042  2401              MOVS     r4,#1                 ;804
000044  2040              MOVS     r0,#0x40              ;804
000046  54c4              STRB     r4,[r0,r3]            ;804
000048  bf00              NOP                            ;804
00004a  6259              STR      r1,[r3,#0x24]         ;806
00004c  851a              STRH     r2,[r3,#0x28]         ;807
00004e  855a              STRH     r2,[r3,#0x2a]         ;808
000050  2000              MOVS     r0,#0                 ;810
000052  6458              STR      r0,[r3,#0x44]         ;810
000054  2412              MOVS     r4,#0x12              ;811
000056  2041              MOVS     r0,#0x41              ;811
000058  54c4              STRB     r4,[r0,r3]            ;811
00005a  bf00              NOP                            ;820
00005c  2400              MOVS     r4,#0                 ;820
00005e  2040              MOVS     r0,#0x40              ;820
000060  54c4              STRB     r4,[r0,r3]            ;820
000062  bf00              NOP                            ;820
000064  6818              LDR      r0,[r3,#0]            ;823
000066  6800              LDR      r0,[r0,#0]            ;823
000068  2480              MOVS     r4,#0x80              ;823
00006a  4320              ORRS     r0,r0,r4              ;823
00006c  681c              LDR      r4,[r3,#0]            ;823
00006e  6020              STR      r0,[r4,#0]            ;823
000070  2000              MOVS     r0,#0                 ;825
000072  e7d0              B        |L25.22|
                  |L25.116|
000074  2002              MOVS     r0,#2                 ;829
000076  e7ce              B        |L25.22|
;;;832    
                          ENDP


                          AREA ||i.HAL_USART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxCpltCallback PROC
;;;1722     */
;;;1723   __weak void HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1724   {
;;;1725     /* Prevent unused argument(s) compilation warning */
;;;1726     UNUSED(husart);
;;;1727   
;;;1728     /* NOTE : This function should not be modified, when the callback is needed,
;;;1729               the HAL_USART_TxCpltCallback can be implemented in the user file.
;;;1730      */
;;;1731   }
;;;1732   
                          ENDP


                          AREA ||i.HAL_USART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxHalfCpltCallback PROC
;;;1737     */
;;;1738   __weak void HAL_USART_TxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1739   {
;;;1740     /* Prevent unused argument(s) compilation warning */
;;;1741     UNUSED(husart);
;;;1742   
;;;1743     /* NOTE: This function should not be modified, when the callback is needed,
;;;1744              the HAL_USART_TxHalfCpltCallback can be implemented in the user file.
;;;1745      */
;;;1746   }
;;;1747   
                          ENDP


                          AREA ||i.HAL_USART_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxRxCpltCallback PROC
;;;1782     */
;;;1783   __weak void HAL_USART_TxRxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1784   {
;;;1785     /* Prevent unused argument(s) compilation warning */
;;;1786     UNUSED(husart);
;;;1787   
;;;1788     /* NOTE : This function should not be modified, when the callback is needed,
;;;1789               the HAL_USART_TxRxCpltCallback can be implemented in the user file
;;;1790      */
;;;1791   }
;;;1792   
                          ENDP


                          AREA ||i.USART_CheckIdleState||, CODE, READONLY, ALIGN=1

                  USART_CheckIdleState PROC
;;;2246     */
;;;2247   static HAL_StatusTypeDef USART_CheckIdleState(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;2248   {
;;;2249   #if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC)
;;;2250     uint32_t tickstart = 0U;
;;;2251   #endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC) */
;;;2252   
;;;2253     /* Initialize the USART ErrorCode */
;;;2254     husart->ErrorCode = HAL_USART_ERROR_NONE;
000002  2000              MOVS     r0,#0
000004  6448              STR      r0,[r1,#0x44]
;;;2255   
;;;2256   #if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC)
;;;2257     /* Init tickstart for timeout managment*/
;;;2258     tickstart = HAL_GetTick();
;;;2259   
;;;2260     /* TEACK and REACK bits in ISR are checked only when available (not available on all F0 devices).
;;;2261        Bits are defined for some specific devices, and are available only for UART instances supporting WakeUp from Stop Mode feature. 
;;;2262     */
;;;2263     if (IS_UART_WAKEUP_FROMSTOP_INSTANCE(husart->Instance))
;;;2264     {
;;;2265       /* Check if the Transmitter is enabled */
;;;2266       if((husart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
;;;2267       {
;;;2268         /* Wait until TEACK flag is set */
;;;2269         if(USART_WaitOnFlagUntilTimeout(husart, USART_ISR_TEACK, RESET, tickstart, USART_TEACK_REACK_TIMEOUT) != HAL_OK)
;;;2270         {
;;;2271           /* Timeout occurred */
;;;2272           return HAL_TIMEOUT;
;;;2273         }
;;;2274       }
;;;2275   
;;;2276       /* Check if the Receiver is enabled */
;;;2277       if((husart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
;;;2278       {
;;;2279         /* Wait until REACK flag is set */
;;;2280         if(USART_WaitOnFlagUntilTimeout(husart, USART_ISR_REACK, RESET, tickstart, USART_TEACK_REACK_TIMEOUT) != HAL_OK)
;;;2281         {
;;;2282           /* Timeout occurred */
;;;2283           return HAL_TIMEOUT;
;;;2284         }
;;;2285       }
;;;2286     }
;;;2287   #endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&& !defined(STM32F030xC) */
;;;2288   
;;;2289     /* Initialize the USART state*/
;;;2290     husart->State= HAL_USART_STATE_READY;
000006  2201              MOVS     r2,#1
000008  2041              MOVS     r0,#0x41
00000a  5442              STRB     r2,[r0,r1]
;;;2291   
;;;2292     /* Process Unlocked */
;;;2293     __HAL_UNLOCK(husart);
00000c  bf00              NOP      
00000e  2200              MOVS     r2,#0
000010  2040              MOVS     r0,#0x40
000012  5442              STRB     r2,[r0,r1]
000014  bf00              NOP      
;;;2294   
;;;2295     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;2296   }
000018  4770              BX       lr
;;;2297   
                          ENDP


                          AREA ||i.USART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  USART_DMAAbortOnError PROC
;;;2036     */
;;;2037   static void USART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2038   {
000002  4605              MOV      r5,r0
;;;2039     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)(hdma->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2040     husart->RxXferCount = 0U;
000006  2000              MOVS     r0,#0
000008  8660              STRH     r0,[r4,#0x32]
;;;2041     husart->TxXferCount = 0U;
00000a  8560              STRH     r0,[r4,#0x2a]
;;;2042   
;;;2043     HAL_USART_ErrorCallback(husart);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_USART_ErrorCallback
;;;2044   }
000012  bd70              POP      {r4-r6,pc}
;;;2045   
                          ENDP


                          AREA ||i.USART_DMAError||, CODE, READONLY, ALIGN=1

                  USART_DMAError PROC
;;;2016     */
;;;2017   static void USART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2018   {
000002  4605              MOV      r5,r0
;;;2019     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)(hdma->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2020   
;;;2021     husart->RxXferCount = 0U;
000006  2000              MOVS     r0,#0
000008  8660              STRH     r0,[r4,#0x32]
;;;2022     husart->TxXferCount = 0U;
00000a  8560              STRH     r0,[r4,#0x2a]
;;;2023     USART_EndTransfer(husart);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       USART_EndTransfer
;;;2024   
;;;2025     husart->ErrorCode |= HAL_USART_ERROR_DMA;
000012  6c60              LDR      r0,[r4,#0x44]
000014  2110              MOVS     r1,#0x10
000016  4308              ORRS     r0,r0,r1
000018  6460              STR      r0,[r4,#0x44]
;;;2026     husart->State= HAL_USART_STATE_READY;
00001a  2101              MOVS     r1,#1
00001c  2041              MOVS     r0,#0x41
00001e  5501              STRB     r1,[r0,r4]
;;;2027   
;;;2028     HAL_USART_ErrorCallback(husart);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       HAL_USART_ErrorCallback
;;;2029   }
000026  bd70              POP      {r4-r6,pc}
;;;2030   
                          ENDP


                          AREA ||i.USART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  USART_DMAReceiveCplt PROC
;;;1952     */
;;;1953   static void USART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1954   {
000002  4605              MOV      r5,r0
;;;1955     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)(hdma->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;1956   
;;;1957     /* DMA Normal mode */
;;;1958     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  2120              MOVS     r1,#0x20
00000c  4008              ANDS     r0,r0,r1
00000e  2800              CMP      r0,#0
000010  d127              BNE      |L32.98|
;;;1959     {
;;;1960       husart->RxXferCount = 0U;
000012  8660              STRH     r0,[r4,#0x32]
;;;1961   
;;;1962       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1963       CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
000014  6820              LDR      r0,[r4,#0]
000016  6800              LDR      r0,[r0,#0]
000018  00c9              LSLS     r1,r1,#3
00001a  4388              BICS     r0,r0,r1
00001c  6821              LDR      r1,[r4,#0]
00001e  6008              STR      r0,[r1,#0]
;;;1964       CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000020  6820              LDR      r0,[r4,#0]
000022  6880              LDR      r0,[r0,#8]
000024  0840              LSRS     r0,r0,#1
000026  0040              LSLS     r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6088              STR      r0,[r1,#8]
;;;1965   
;;;1966       /* Disable the DMA RX transfer for the receiver request by resetting the DMAR bit
;;;1967          in USART CR3 register */
;;;1968       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
00002c  6820              LDR      r0,[r4,#0]
00002e  6880              LDR      r0,[r0,#8]
000030  2140              MOVS     r1,#0x40
000032  4388              BICS     r0,r0,r1
000034  6821              LDR      r1,[r4,#0]
000036  6088              STR      r0,[r1,#8]
;;;1969       /* similarly, disable the DMA TX transfer that was started to provide the
;;;1970          clock to the slave device */
;;;1971       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
000038  6820              LDR      r0,[r4,#0]
00003a  6880              LDR      r0,[r0,#8]
00003c  2180              MOVS     r1,#0x80
00003e  4388              BICS     r0,r0,r1
000040  6821              LDR      r1,[r4,#0]
000042  6088              STR      r0,[r1,#8]
;;;1972   
;;;1973       if(husart->State == HAL_USART_STATE_BUSY_RX)
000044  2041              MOVS     r0,#0x41
000046  5d00              LDRB     r0,[r0,r4]
000048  2822              CMP      r0,#0x22
00004a  d103              BNE      |L32.84|
;;;1974       {
;;;1975         HAL_USART_RxCpltCallback(husart);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       HAL_USART_RxCpltCallback
000052  e002              B        |L32.90|
                  |L32.84|
;;;1976       }
;;;1977       /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;1978       else
;;;1979       {
;;;1980         HAL_USART_TxRxCpltCallback(husart);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       HAL_USART_TxRxCpltCallback
                  |L32.90|
;;;1981       }
;;;1982       husart->State= HAL_USART_STATE_READY;
00005a  2101              MOVS     r1,#1
00005c  2041              MOVS     r0,#0x41
00005e  5501              STRB     r1,[r0,r4]
000060  e00a              B        |L32.120|
                  |L32.98|
;;;1983     }
;;;1984     /* DMA circular mode */
;;;1985     else
;;;1986     {
;;;1987       if(husart->State == HAL_USART_STATE_BUSY_RX)
000062  2041              MOVS     r0,#0x41
000064  5d00              LDRB     r0,[r0,r4]
000066  2822              CMP      r0,#0x22
000068  d103              BNE      |L32.114|
;;;1988       {
;;;1989         HAL_USART_RxCpltCallback(husart);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       HAL_USART_RxCpltCallback
000070  e002              B        |L32.120|
                  |L32.114|
;;;1990       }
;;;1991       /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;1992       else
;;;1993       {
;;;1994         HAL_USART_TxRxCpltCallback(husart);
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       HAL_USART_TxRxCpltCallback
                  |L32.120|
;;;1995       }
;;;1996     }    
;;;1997   
;;;1998   }
000078  bd70              POP      {r4-r6,pc}
;;;1999   
                          ENDP


                          AREA ||i.USART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  USART_DMARxAbortCallback PROC
;;;2094     */
;;;2095   static void USART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2096   {
000002  4605              MOV      r5,r0
;;;2097     USART_HandleTypeDef* husart = (USART_HandleTypeDef* )(hdma->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2098     
;;;2099     husart->hdmarx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6be1              LDR      r1,[r4,#0x3c]
00000a  6348              STR      r0,[r1,#0x34]
;;;2100   
;;;2101     /* Check if an Abort process is still ongoing */
;;;2102     if(husart->hdmatx != NULL)
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  2800              CMP      r0,#0
000010  d004              BEQ      |L33.28|
;;;2103     {
;;;2104       if(husart->hdmatx->XferAbortCallback != NULL)
000012  6ba0              LDR      r0,[r4,#0x38]
000014  6b40              LDR      r0,[r0,#0x34]
000016  2800              CMP      r0,#0
000018  d000              BEQ      |L33.28|
                  |L33.26|
;;;2105       {
;;;2106         return;
;;;2107       }
;;;2108     }
;;;2109     
;;;2110     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2111     husart->TxXferCount = 0U;
;;;2112     husart->RxXferCount = 0U;
;;;2113   
;;;2114     /* Reset errorCode */
;;;2115     husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;2116   
;;;2117     /* Clear the Error flags in the ICR register */
;;;2118     __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
;;;2119   
;;;2120     /* Restore husart->State to Ready */
;;;2121     husart->State  = HAL_USART_STATE_READY;
;;;2122   
;;;2123     /* Call user Abort complete callback */
;;;2124     HAL_USART_AbortCpltCallback(husart);
;;;2125   }
00001a  bd70              POP      {r4-r6,pc}
                  |L33.28|
00001c  2000              MOVS     r0,#0                 ;2111
00001e  8560              STRH     r0,[r4,#0x2a]         ;2111
000020  8660              STRH     r0,[r4,#0x32]         ;2112
000022  6460              STR      r0,[r4,#0x44]         ;2115
000024  200f              MOVS     r0,#0xf               ;2118
000026  6821              LDR      r1,[r4,#0]            ;2118
000028  6208              STR      r0,[r1,#0x20]         ;2118
00002a  2101              MOVS     r1,#1                 ;2121
00002c  2041              MOVS     r0,#0x41              ;2121
00002e  5501              STRB     r1,[r0,r4]            ;2121
000030  4620              MOV      r0,r4                 ;2124
000032  f7fffffe          BL       HAL_USART_AbortCpltCallback
000036  bf00              NOP      
000038  e7ef              B        |L33.26|
;;;2126   
                          ENDP


                          AREA ||i.USART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMARxHalfCplt PROC
;;;2004     */
;;;2005   static void USART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2006   {
000002  4604              MOV      r4,r0
;;;2007     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)(hdma->Parent);
000004  6a65              LDR      r5,[r4,#0x24]
;;;2008   
;;;2009     HAL_USART_RxHalfCpltCallback(husart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_USART_RxHalfCpltCallback
;;;2010   }
00000c  bd70              POP      {r4-r6,pc}
;;;2011   
                          ENDP


                          AREA ||i.USART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATransmitCplt PROC
;;;1906     */
;;;1907   static void USART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1908   {
000002  4605              MOV      r5,r0
;;;1909     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)(hdma->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;1910   
;;;1911     /* DMA Normal mode */
;;;1912     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  2120              MOVS     r1,#0x20
00000c  4008              ANDS     r0,r0,r1
00000e  2800              CMP      r0,#0
000010  d111              BNE      |L35.54|
;;;1913     {
;;;1914       husart->TxXferCount = 0U;
000012  8560              STRH     r0,[r4,#0x2a]
;;;1915   
;;;1916       if(husart->State == HAL_USART_STATE_BUSY_TX)
000014  2041              MOVS     r0,#0x41
000016  5d00              LDRB     r0,[r0,r4]
000018  2812              CMP      r0,#0x12
00001a  d113              BNE      |L35.68|
;;;1917       {
;;;1918         /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;1919            in the USART CR3 register */
;;;1920         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00001c  6820              LDR      r0,[r4,#0]
00001e  6880              LDR      r0,[r0,#8]
000020  2180              MOVS     r1,#0x80
000022  4388              BICS     r0,r0,r1
000024  6821              LDR      r1,[r4,#0]
000026  6088              STR      r0,[r1,#8]
;;;1921   
;;;1922         /* Enable the USART Transmit Complete Interrupt */
;;;1923         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
000028  6820              LDR      r0,[r4,#0]
00002a  6800              LDR      r0,[r0,#0]
00002c  2140              MOVS     r1,#0x40
00002e  4308              ORRS     r0,r0,r1
000030  6821              LDR      r1,[r4,#0]
000032  6008              STR      r0,[r1,#0]
000034  e006              B        |L35.68|
                  |L35.54|
;;;1924       }
;;;1925     }
;;;1926     /* DMA Circular mode */
;;;1927     else
;;;1928     {
;;;1929       if(husart->State == HAL_USART_STATE_BUSY_TX)
000036  2041              MOVS     r0,#0x41
000038  5d00              LDRB     r0,[r0,r4]
00003a  2812              CMP      r0,#0x12
00003c  d102              BNE      |L35.68|
;;;1930       {
;;;1931         HAL_USART_TxCpltCallback(husart);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_USART_TxCpltCallback
                  |L35.68|
;;;1932       }
;;;1933     }
;;;1934   }
000044  bd70              POP      {r4-r6,pc}
;;;1935   
                          ENDP


                          AREA ||i.USART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  USART_DMATxAbortCallback PROC
;;;2053     */
;;;2054   static void USART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2055   {
000002  4605              MOV      r5,r0
;;;2056     USART_HandleTypeDef* husart = (USART_HandleTypeDef* )(hdma->Parent);
000004  6a6c              LDR      r4,[r5,#0x24]
;;;2057     
;;;2058     husart->hdmatx->XferAbortCallback = NULL;
000006  2000              MOVS     r0,#0
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  6348              STR      r0,[r1,#0x34]
;;;2059   
;;;2060     /* Check if an Abort process is still ongoing */
;;;2061     if(husart->hdmarx != NULL)
00000c  6be0              LDR      r0,[r4,#0x3c]
00000e  2800              CMP      r0,#0
000010  d004              BEQ      |L36.28|
;;;2062     {
;;;2063       if(husart->hdmarx->XferAbortCallback != NULL)
000012  6be0              LDR      r0,[r4,#0x3c]
000014  6b40              LDR      r0,[r0,#0x34]
000016  2800              CMP      r0,#0
000018  d000              BEQ      |L36.28|
                  |L36.26|
;;;2064       {
;;;2065         return;
;;;2066       }
;;;2067     }
;;;2068     
;;;2069     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2070     husart->TxXferCount = 0U;
;;;2071     husart->RxXferCount = 0U;
;;;2072   
;;;2073     /* Reset errorCode */
;;;2074     husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;2075   
;;;2076     /* Clear the Error flags in the ICR register */
;;;2077     __HAL_USART_CLEAR_FLAG(husart, USART_CLEAR_OREF | USART_CLEAR_NEF | USART_CLEAR_PEF | USART_CLEAR_FEF);
;;;2078   
;;;2079     /* Restore husart->State to Ready */
;;;2080     husart->State  = HAL_USART_STATE_READY;
;;;2081   
;;;2082     /* Call user Abort complete callback */
;;;2083     HAL_USART_AbortCpltCallback(husart);
;;;2084   }
00001a  bd70              POP      {r4-r6,pc}
                  |L36.28|
00001c  2000              MOVS     r0,#0                 ;2070
00001e  8560              STRH     r0,[r4,#0x2a]         ;2070
000020  8660              STRH     r0,[r4,#0x32]         ;2071
000022  6460              STR      r0,[r4,#0x44]         ;2074
000024  200f              MOVS     r0,#0xf               ;2077
000026  6821              LDR      r1,[r4,#0]            ;2077
000028  6208              STR      r0,[r1,#0x20]         ;2077
00002a  2101              MOVS     r1,#1                 ;2080
00002c  2041              MOVS     r0,#0x41              ;2080
00002e  5501              STRB     r1,[r0,r4]            ;2080
000030  4620              MOV      r0,r4                 ;2083
000032  f7fffffe          BL       HAL_USART_AbortCpltCallback
000036  bf00              NOP      
000038  e7ef              B        |L36.26|
;;;2085   
                          ENDP


                          AREA ||i.USART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATxHalfCplt PROC
;;;1940     */
;;;1941   static void USART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1942   {
000002  4604              MOV      r4,r0
;;;1943     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)(hdma->Parent);
000004  6a65              LDR      r5,[r4,#0x24]
;;;1944   
;;;1945     HAL_USART_TxHalfCpltCallback(husart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_USART_TxHalfCpltCallback
;;;1946   }
00000c  bd70              POP      {r4-r6,pc}
;;;1947   
                          ENDP


                          AREA ||i.USART_EndTransfer||, CODE, READONLY, ALIGN=1

                  USART_EndTransfer PROC
;;;1890     */
;;;1891   static void USART_EndTransfer(USART_HandleTypeDef *husart)
000000  6801              LDR      r1,[r0,#0]
;;;1892   {
;;;1893     /* Disable TXEIE and TCIE interrupts */
;;;1894     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1895     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE | USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  6809              LDR      r1,[r1,#0]
000004  22ff              MOVS     r2,#0xff
000006  32e1              ADDS     r2,r2,#0xe1
000008  4391              BICS     r1,r1,r2
00000a  6802              LDR      r2,[r0,#0]
00000c  6011              STR      r1,[r2,#0]
;;;1896     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
00000e  6801              LDR      r1,[r0,#0]
000010  6889              LDR      r1,[r1,#8]
000012  0849              LSRS     r1,r1,#1
000014  0049              LSLS     r1,r1,#1
000016  6802              LDR      r2,[r0,#0]
000018  6091              STR      r1,[r2,#8]
;;;1897   
;;;1898     /* At end of process, restore husart->State to Ready */
;;;1899     husart->State = HAL_USART_STATE_READY;
00001a  2201              MOVS     r2,#1
00001c  2141              MOVS     r1,#0x41
00001e  540a              STRB     r2,[r1,r0]
;;;1900   }
000020  4770              BX       lr
;;;1901   
                          ENDP


                          AREA ||i.USART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  USART_EndTransmit_IT PROC
;;;2355     */
;;;2356   static HAL_StatusTypeDef USART_EndTransmit_IT(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;2357   {
000002  4604              MOV      r4,r0
;;;2358     /* Disable the USART Transmit Complete Interrupt */
;;;2359     __HAL_USART_DISABLE_IT(husart, USART_IT_TC);
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  2140              MOVS     r1,#0x40
00000a  4388              BICS     r0,r0,r1
00000c  6821              LDR      r1,[r4,#0]
00000e  6008              STR      r0,[r1,#0]
;;;2360   
;;;2361     /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2362     __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
000010  6820              LDR      r0,[r4,#0]
000012  6880              LDR      r0,[r0,#8]
000014  0840              LSRS     r0,r0,#1
000016  0040              LSLS     r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6088              STR      r0,[r1,#8]
;;;2363   
;;;2364     /* Tx process is ended, restore husart->State to Ready */
;;;2365     husart->State = HAL_USART_STATE_READY;
00001c  2101              MOVS     r1,#1
00001e  2041              MOVS     r0,#0x41
000020  5501              STRB     r1,[r0,r4]
;;;2366   
;;;2367     HAL_USART_TxCpltCallback(husart);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       HAL_USART_TxCpltCallback
;;;2368   
;;;2369     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;2370   }
00002a  bd10              POP      {r4,pc}
;;;2371   
                          ENDP


                          AREA ||i.USART_Receive_IT||, CODE, READONLY, ALIGN=1

                  USART_Receive_IT PROC
;;;2379     */
;;;2380   static HAL_StatusTypeDef USART_Receive_IT(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;2381   {
000002  4604              MOV      r4,r0
;;;2382     uint16_t* tmp=0U;
000004  2600              MOVS     r6,#0
;;;2383     uint16_t uhMask = husart->Mask;
000006  8ea5              LDRH     r5,[r4,#0x34]
;;;2384   
;;;2385     if(husart->State == HAL_USART_STATE_BUSY_RX)
000008  2041              MOVS     r0,#0x41
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2822              CMP      r0,#0x22
00000e  d138              BNE      |L40.130|
;;;2386     {
;;;2387   
;;;2388       if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
000010  2101              MOVS     r1,#1
000012  0309              LSLS     r1,r1,#12
000014  68a0              LDR      r0,[r4,#8]
000016  4288              CMP      r0,r1
000018  d10b              BNE      |L40.50|
00001a  6920              LDR      r0,[r4,#0x10]
00001c  2800              CMP      r0,#0
00001e  d108              BNE      |L40.50|
;;;2389       {
;;;2390         tmp = (uint16_t*) husart->pRxBuffPtr;
000020  6ae6              LDR      r6,[r4,#0x2c]
;;;2391         *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
000022  6820              LDR      r0,[r4,#0]
000024  8c80              LDRH     r0,[r0,#0x24]
000026  4028              ANDS     r0,r0,r5
000028  8030              STRH     r0,[r6,#0]
;;;2392         husart->pRxBuffPtr += 2U;
00002a  6ae0              LDR      r0,[r4,#0x2c]
00002c  1c80              ADDS     r0,r0,#2
00002e  62e0              STR      r0,[r4,#0x2c]
000030  e007              B        |L40.66|
                  |L40.50|
;;;2393       }
;;;2394       else
;;;2395       {
;;;2396         *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
000032  6820              LDR      r0,[r4,#0]
000034  8c80              LDRH     r0,[r0,#0x24]
000036  b2e9              UXTB     r1,r5
000038  4008              ANDS     r0,r0,r1
00003a  6ae2              LDR      r2,[r4,#0x2c]
00003c  1c51              ADDS     r1,r2,#1
00003e  62e1              STR      r1,[r4,#0x2c]
000040  7010              STRB     r0,[r2,#0]
                  |L40.66|
;;;2397       }
;;;2398   
;;;2399       /* Send dummy byte in order to generate the clock for the Slave to Send the next data */
;;;2400       husart->Instance->TDR = (USART_DUMMY_DATA & (uint16_t)0x00FFU);
000042  20ff              MOVS     r0,#0xff
000044  6821              LDR      r1,[r4,#0]
000046  8508              STRH     r0,[r1,#0x28]
;;;2401   
;;;2402       if(--husart->RxXferCount == 0U)
000048  8e60              LDRH     r0,[r4,#0x32]
00004a  1e40              SUBS     r0,r0,#1
00004c  b280              UXTH     r0,r0
00004e  8660              STRH     r0,[r4,#0x32]
000050  2800              CMP      r0,#0
000052  d114              BNE      |L40.126|
;;;2403       {
;;;2404         /* Disable the USART Parity Error Interrupt and RXNE interrupt*/
;;;2405         CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000054  6820              LDR      r0,[r4,#0]
000056  6800              LDR      r0,[r0,#0]
000058  21ff              MOVS     r1,#0xff
00005a  3121              ADDS     r1,r1,#0x21
00005c  4388              BICS     r0,r0,r1
00005e  6821              LDR      r1,[r4,#0]
000060  6008              STR      r0,[r1,#0]
;;;2406   
;;;2407         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2408         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000062  6820              LDR      r0,[r4,#0]
000064  6880              LDR      r0,[r0,#8]
000066  0840              LSRS     r0,r0,#1
000068  0040              LSLS     r0,r0,#1
00006a  6821              LDR      r1,[r4,#0]
00006c  6088              STR      r0,[r1,#8]
;;;2409   
;;;2410         /* Rx process is completed, restore husart->State to Ready */
;;;2411         husart->State = HAL_USART_STATE_READY;
00006e  2101              MOVS     r1,#1
000070  2041              MOVS     r0,#0x41
000072  5501              STRB     r1,[r0,r4]
;;;2412   
;;;2413         HAL_USART_RxCpltCallback(husart);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       HAL_USART_RxCpltCallback
;;;2414   
;;;2415         return HAL_OK;
00007a  2000              MOVS     r0,#0
                  |L40.124|
;;;2416       }
;;;2417   
;;;2418       return HAL_OK;
;;;2419     }
;;;2420     else
;;;2421     {
;;;2422       return HAL_BUSY;
;;;2423     }
;;;2424   }
00007c  bd70              POP      {r4-r6,pc}
                  |L40.126|
00007e  2000              MOVS     r0,#0                 ;2418
000080  e7fc              B        |L40.124|
                  |L40.130|
000082  2002              MOVS     r0,#2                 ;2422
000084  e7fa              B        |L40.124|
;;;2425   
                          ENDP


                          AREA ||i.USART_SetConfig||, CODE, READONLY, ALIGN=2

                  USART_SetConfig PROC
;;;2168     */
;;;2169   static HAL_StatusTypeDef USART_SetConfig(USART_HandleTypeDef *husart)
000000  b5fe              PUSH     {r1-r7,lr}
;;;2170   {
000002  4604              MOV      r4,r0
;;;2171     uint32_t tmpreg                      = 0x0U;
000004  2500              MOVS     r5,#0
;;;2172     USART_ClockSourceTypeDef clocksource = USART_CLOCKSOURCE_UNDEFINED;
000006  2010              MOVS     r0,#0x10
000008  9002              STR      r0,[sp,#8]
;;;2173     HAL_StatusTypeDef ret                = HAL_OK;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;2174     uint16_t brrtemp                     = 0x0000U;
00000e  2600              MOVS     r6,#0
;;;2175     uint16_t usartdiv                    = 0x0000U;  
000010  2700              MOVS     r7,#0
;;;2176   
;;;2177     /* Check the parameters */
;;;2178     assert_param(IS_USART_POLARITY(husart->Init.CLKPolarity));
;;;2179     assert_param(IS_USART_PHASE(husart->Init.CLKPhase));
;;;2180     assert_param(IS_USART_LASTBIT(husart->Init.CLKLastBit));
;;;2181     assert_param(IS_USART_BAUDRATE(husart->Init.BaudRate));
;;;2182     assert_param(IS_USART_WORD_LENGTH(husart->Init.WordLength));
;;;2183     assert_param(IS_USART_STOPBITS(husart->Init.StopBits));
;;;2184     assert_param(IS_USART_PARITY(husart->Init.Parity));
;;;2185     assert_param(IS_USART_MODE(husart->Init.Mode));
;;;2186   
;;;2187   
;;;2188     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2189      /* Clear M, PCE, PS, TE and RE bits and configure
;;;2190      *  the USART Word Length, Parity and Mode:
;;;2191      *  set the M bits according to husart->Init.WordLength value
;;;2192      *  set PCE and PS bits according to husart->Init.Parity value
;;;2193      *  set TE and RE bits according to husart->Init.Mode value 
;;;2194      *  force OVER8 to 1 to allow to reach the maximum speed (Fclock/8)  */
;;;2195     tmpreg = (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8;
000012  6921              LDR      r1,[r4,#0x10]
000014  68a0              LDR      r0,[r4,#8]
000016  4308              ORRS     r0,r0,r1
000018  6961              LDR      r1,[r4,#0x14]
00001a  4308              ORRS     r0,r0,r1
00001c  2101              MOVS     r1,#1
00001e  03c9              LSLS     r1,r1,#15
000020  4308              ORRS     r0,r0,r1
000022  4605              MOV      r5,r0
;;;2196     MODIFY_REG(husart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  4952              LDR      r1,|L41.372|
00002a  4008              ANDS     r0,r0,r1
00002c  4328              ORRS     r0,r0,r5
00002e  6821              LDR      r1,[r4,#0]
000030  6008              STR      r0,[r1,#0]
;;;2197   
;;;2198     /*---------------------------- USART CR2 Configuration ---------------------*/
;;;2199     /* Clear and configure the USART Clock, CPOL, CPHA, LBCL and STOP bits:
;;;2200      * set CPOL bit according to husart->Init.CLKPolarity value
;;;2201      * set CPHA bit according to husart->Init.CLKPhase value
;;;2202      * set LBCL bit according to husart->Init.CLKLastBit value
;;;2203      * set STOP[13:12] bits according to husart->Init.StopBits value */
;;;2204     tmpreg = (uint32_t)(USART_CLOCK_ENABLE);
000032  2501              MOVS     r5,#1
000034  02ed              LSLS     r5,r5,#11
;;;2205     tmpreg |= ((uint32_t)husart->Init.CLKPolarity | (uint32_t)husart->Init.CLKPhase);
000036  69e1              LDR      r1,[r4,#0x1c]
000038  69a0              LDR      r0,[r4,#0x18]
00003a  4308              ORRS     r0,r0,r1
00003c  4305              ORRS     r5,r5,r0
;;;2206     tmpreg |= ((uint32_t)husart->Init.CLKLastBit | (uint32_t)husart->Init.StopBits);
00003e  68e1              LDR      r1,[r4,#0xc]
000040  6a20              LDR      r0,[r4,#0x20]
000042  4308              ORRS     r0,r0,r1
000044  4305              ORRS     r5,r5,r0
;;;2207     MODIFY_REG(husart->Instance->CR2, USART_CR2_FIELDS, tmpreg);
000046  6820              LDR      r0,[r4,#0]
000048  6840              LDR      r0,[r0,#4]
00004a  213f              MOVS     r1,#0x3f
00004c  0209              LSLS     r1,r1,#8
00004e  4388              BICS     r0,r0,r1
000050  4328              ORRS     r0,r0,r5
000052  6821              LDR      r1,[r4,#0]
000054  6048              STR      r0,[r1,#4]
;;;2208   
;;;2209     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;2210     /* no CR3 register configuration                                            */
;;;2211   
;;;2212     /*-------------------------- USART BRR Configuration -----------------------*/
;;;2213     /* BRR is filled-up according to OVER8 bit setting which is forced to 1     */ 
;;;2214     USART_GETCLOCKSOURCE(husart, clocksource);
000056  bf00              NOP      
000058  4947              LDR      r1,|L41.376|
00005a  6820              LDR      r0,[r4,#0]
00005c  4288              CMP      r0,r1
00005e  d11c              BNE      |L41.154|
000060  4846              LDR      r0,|L41.380|
000062  6b00              LDR      r0,[r0,#0x30]
000064  0780              LSLS     r0,r0,#30
000066  0f80              LSRS     r0,r0,#30
000068  2800              CMP      r0,#0
00006a  d006              BEQ      |L41.122|
00006c  2801              CMP      r0,#1
00006e  d00a              BEQ      |L41.134|
000070  2802              CMP      r0,#2
000072  d00b              BEQ      |L41.140|
000074  2803              CMP      r0,#3
000076  d10c              BNE      |L41.146|
000078  e002              B        |L41.128|
                  |L41.122|
00007a  2000              MOVS     r0,#0
00007c  9002              STR      r0,[sp,#8]
00007e  e00b              B        |L41.152|
                  |L41.128|
000080  2002              MOVS     r0,#2
000082  9002              STR      r0,[sp,#8]
000084  e008              B        |L41.152|
                  |L41.134|
000086  2004              MOVS     r0,#4
000088  9002              STR      r0,[sp,#8]
00008a  e005              B        |L41.152|
                  |L41.140|
00008c  2008              MOVS     r0,#8
00008e  9002              STR      r0,[sp,#8]
000090  e002              B        |L41.152|
                  |L41.146|
000092  2010              MOVS     r0,#0x10
000094  9002              STR      r0,[sp,#8]
000096  bf00              NOP      
                  |L41.152|
000098  e024              B        |L41.228|
                  |L41.154|
00009a  4939              LDR      r1,|L41.384|
00009c  6820              LDR      r0,[r4,#0]
00009e  4288              CMP      r0,r1
0000a0  d102              BNE      |L41.168|
0000a2  2000              MOVS     r0,#0
0000a4  9002              STR      r0,[sp,#8]
0000a6  e01d              B        |L41.228|
                  |L41.168|
0000a8  4936              LDR      r1,|L41.388|
0000aa  6820              LDR      r0,[r4,#0]
0000ac  4288              CMP      r0,r1
0000ae  d102              BNE      |L41.182|
0000b0  2000              MOVS     r0,#0
0000b2  9002              STR      r0,[sp,#8]
0000b4  e016              B        |L41.228|
                  |L41.182|
0000b6  4934              LDR      r1,|L41.392|
0000b8  6820              LDR      r0,[r4,#0]
0000ba  4288              CMP      r0,r1
0000bc  d102              BNE      |L41.196|
0000be  2000              MOVS     r0,#0
0000c0  9002              STR      r0,[sp,#8]
0000c2  e00f              B        |L41.228|
                  |L41.196|
0000c4  4931              LDR      r1,|L41.396|
0000c6  6820              LDR      r0,[r4,#0]
0000c8  4288              CMP      r0,r1
0000ca  d102              BNE      |L41.210|
0000cc  2000              MOVS     r0,#0
0000ce  9002              STR      r0,[sp,#8]
0000d0  e008              B        |L41.228|
                  |L41.210|
0000d2  492f              LDR      r1,|L41.400|
0000d4  6820              LDR      r0,[r4,#0]
0000d6  4288              CMP      r0,r1
0000d8  d102              BNE      |L41.224|
0000da  2000              MOVS     r0,#0
0000dc  9002              STR      r0,[sp,#8]
0000de  e001              B        |L41.228|
                  |L41.224|
0000e0  2010              MOVS     r0,#0x10
0000e2  9002              STR      r0,[sp,#8]
                  |L41.228|
0000e4  bf00              NOP      
;;;2215     switch (clocksource)
0000e6  9802              LDR      r0,[sp,#8]
0000e8  2804              CMP      r0,#4
0000ea  d01e              BEQ      |L41.298|
0000ec  dc04              BGT      |L41.248|
0000ee  2800              CMP      r0,#0
0000f0  d007              BEQ      |L41.258|
0000f2  2802              CMP      r0,#2
0000f4  d12e              BNE      |L41.340|
0000f6  e010              B        |L41.282|
                  |L41.248|
0000f8  2808              CMP      r0,#8
0000fa  d022              BEQ      |L41.322|
0000fc  2810              CMP      r0,#0x10
0000fe  d129              BNE      |L41.340|
000100  e029              B        |L41.342|
                  |L41.258|
;;;2216     {
;;;2217       case USART_CLOCKSOURCE_PCLK1:
;;;2218         usartdiv = (uint16_t)(((2*HAL_RCC_GetPCLK1Freq()) + (husart->Init.BaudRate/2)) / husart->Init.BaudRate);
000102  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000106  0040              LSLS     r0,r0,#1
000108  6861              LDR      r1,[r4,#4]
00010a  0849              LSRS     r1,r1,#1
00010c  1840              ADDS     r0,r0,r1
00010e  9000              STR      r0,[sp,#0]
000110  6861              LDR      r1,[r4,#4]
000112  f7fffffe          BL       __aeabi_uidivmod
000116  b287              UXTH     r7,r0
;;;2219         break;
000118  e020              B        |L41.348|
                  |L41.282|
;;;2220       case USART_CLOCKSOURCE_HSI:
;;;2221         usartdiv = (uint16_t)(((2*HSI_VALUE) + (husart->Init.BaudRate/2)) / husart->Init.BaudRate);
00011a  6861              LDR      r1,[r4,#4]
00011c  084a              LSRS     r2,r1,#1
00011e  4b1d              LDR      r3,|L41.404|
000120  18d0              ADDS     r0,r2,r3
000122  f7fffffe          BL       __aeabi_uidivmod
000126  b287              UXTH     r7,r0
;;;2222         break;
000128  e018              B        |L41.348|
                  |L41.298|
;;;2223       case USART_CLOCKSOURCE_SYSCLK:
;;;2224         usartdiv = (uint16_t)(((2*HAL_RCC_GetSysClockFreq()) + (husart->Init.BaudRate/2)) / husart->Init.BaudRate);
00012a  f7fffffe          BL       HAL_RCC_GetSysClockFreq
00012e  0040              LSLS     r0,r0,#1
000130  6861              LDR      r1,[r4,#4]
000132  0849              LSRS     r1,r1,#1
000134  1840              ADDS     r0,r0,r1
000136  9000              STR      r0,[sp,#0]
000138  6861              LDR      r1,[r4,#4]
00013a  f7fffffe          BL       __aeabi_uidivmod
00013e  b287              UXTH     r7,r0
;;;2225         break;
000140  e00c              B        |L41.348|
                  |L41.322|
;;;2226       case USART_CLOCKSOURCE_LSE:
;;;2227         usartdiv = (uint16_t)(((2*LSE_VALUE) + (husart->Init.BaudRate/2)) / husart->Init.BaudRate);
000142  6861              LDR      r1,[r4,#4]
000144  084a              LSRS     r2,r1,#1
000146  2301              MOVS     r3,#1
000148  041b              LSLS     r3,r3,#16
00014a  18d0              ADDS     r0,r2,r3
00014c  f7fffffe          BL       __aeabi_uidivmod
000150  b287              UXTH     r7,r0
;;;2228         break;
000152  e003              B        |L41.348|
                  |L41.340|
;;;2229       case USART_CLOCKSOURCE_UNDEFINED:
000154  bf00              NOP      
                  |L41.342|
;;;2230       default:
;;;2231         ret = HAL_ERROR;
000156  2001              MOVS     r0,#1
000158  9001              STR      r0,[sp,#4]
;;;2232         break;
00015a  bf00              NOP      
                  |L41.348|
00015c  bf00              NOP                            ;2219
;;;2233     }
;;;2234     
;;;2235     brrtemp = usartdiv & 0xFFF0U;
00015e  480e              LDR      r0,|L41.408|
000160  4038              ANDS     r0,r0,r7
000162  4606              MOV      r6,r0
;;;2236     brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
000164  0738              LSLS     r0,r7,#28
000166  0f40              LSRS     r0,r0,#29
000168  4306              ORRS     r6,r6,r0
;;;2237     husart->Instance->BRR = brrtemp;
00016a  6820              LDR      r0,[r4,#0]
00016c  60c6              STR      r6,[r0,#0xc]
;;;2238   
;;;2239     return ret;
00016e  9801              LDR      r0,[sp,#4]
;;;2240   }
000170  bdfe              POP      {r1-r7,pc}
;;;2241   
                          ENDP

000172  0000              DCW      0x0000
                  |L41.372|
                          DCD      0xefff69f3
                  |L41.376|
                          DCD      0x40013800
                  |L41.380|
                          DCD      0x40021000
                  |L41.384|
                          DCD      0x40004400
                  |L41.388|
                          DCD      0x40004800
                  |L41.392|
                          DCD      0x40004c00
                  |L41.396|
                          DCD      0x40005000
                  |L41.400|
                          DCD      0x40011400
                  |L41.404|
                          DCD      0x00f42400
                  |L41.408|
                          DCD      0x0000fff0

                          AREA ||i.USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=1

                  USART_TransmitReceive_IT PROC
;;;2432     */
;;;2433   static HAL_StatusTypeDef USART_TransmitReceive_IT(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;2434   {
000002  4604              MOV      r4,r0
;;;2435     uint16_t* tmp=0U;
000004  2600              MOVS     r6,#0
;;;2436     uint16_t uhMask = husart->Mask;
000006  8ea5              LDRH     r5,[r4,#0x34]
;;;2437   
;;;2438     if(husart->State == HAL_USART_STATE_BUSY_TX_RX)
000008  2041              MOVS     r0,#0x41
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2832              CMP      r0,#0x32
00000e  d16b              BNE      |L42.232|
;;;2439     {
;;;2440   
;;;2441       if(husart->TxXferCount != 0x00U)
000010  8d60              LDRH     r0,[r4,#0x2a]
000012  2800              CMP      r0,#0
000014  d029              BEQ      |L42.106|
;;;2442       {
;;;2443         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_TXE) != RESET)
000016  6820              LDR      r0,[r4,#0]
000018  69c0              LDR      r0,[r0,#0x1c]
00001a  2180              MOVS     r1,#0x80
00001c  4008              ANDS     r0,r0,r1
00001e  09c0              LSRS     r0,r0,#7
000020  2800              CMP      r0,#0
000022  d022              BEQ      |L42.106|
;;;2444         {
;;;2445           if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
000024  0149              LSLS     r1,r1,#5
000026  68a0              LDR      r0,[r4,#8]
000028  4288              CMP      r0,r1
00002a  d10b              BNE      |L42.68|
00002c  6920              LDR      r0,[r4,#0x10]
00002e  2800              CMP      r0,#0
000030  d108              BNE      |L42.68|
;;;2446           {
;;;2447             tmp = (uint16_t*) husart->pTxBuffPtr;
000032  6a66              LDR      r6,[r4,#0x24]
;;;2448             husart->Instance->TDR = (uint16_t)(*tmp & uhMask);
000034  8830              LDRH     r0,[r6,#0]
000036  4028              ANDS     r0,r0,r5
000038  6821              LDR      r1,[r4,#0]
00003a  8508              STRH     r0,[r1,#0x28]
;;;2449             husart->pTxBuffPtr += 2U;
00003c  6a60              LDR      r0,[r4,#0x24]
00003e  1c80              ADDS     r0,r0,#2
000040  6260              STR      r0,[r4,#0x24]
000042  e006              B        |L42.82|
                  |L42.68|
;;;2450           }
;;;2451           else
;;;2452           {
;;;2453             husart->Instance->TDR = (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)uhMask);
000044  6a61              LDR      r1,[r4,#0x24]
000046  1c48              ADDS     r0,r1,#1
000048  6260              STR      r0,[r4,#0x24]
00004a  7808              LDRB     r0,[r1,#0]
00004c  4028              ANDS     r0,r0,r5
00004e  6821              LDR      r1,[r4,#0]
000050  8508              STRH     r0,[r1,#0x28]
                  |L42.82|
;;;2454           }
;;;2455           husart->TxXferCount--;
000052  8d60              LDRH     r0,[r4,#0x2a]
000054  1e40              SUBS     r0,r0,#1
000056  8560              STRH     r0,[r4,#0x2a]
;;;2456   
;;;2457           /* Check the latest data transmitted */
;;;2458           if(husart->TxXferCount == 0U)
000058  8d60              LDRH     r0,[r4,#0x2a]
00005a  2800              CMP      r0,#0
00005c  d105              BNE      |L42.106|
;;;2459           {
;;;2460              __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
00005e  6820              LDR      r0,[r4,#0]
000060  6800              LDR      r0,[r0,#0]
000062  2180              MOVS     r1,#0x80
000064  4388              BICS     r0,r0,r1
000066  6821              LDR      r1,[r4,#0]
000068  6008              STR      r0,[r1,#0]
                  |L42.106|
;;;2461           }
;;;2462         }
;;;2463       }
;;;2464   
;;;2465       if(husart->RxXferCount != 0x00U)
00006a  8e60              LDRH     r0,[r4,#0x32]
00006c  2800              CMP      r0,#0
00006e  d021              BEQ      |L42.180|
;;;2466       {
;;;2467         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_RXNE) != RESET)
000070  6820              LDR      r0,[r4,#0]
000072  69c0              LDR      r0,[r0,#0x1c]
000074  2120              MOVS     r1,#0x20
000076  4008              ANDS     r0,r0,r1
000078  0940              LSRS     r0,r0,#5
00007a  2800              CMP      r0,#0
00007c  d01a              BEQ      |L42.180|
;;;2468         {
;;;2469           if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
00007e  01c9              LSLS     r1,r1,#7
000080  68a0              LDR      r0,[r4,#8]
000082  4288              CMP      r0,r1
000084  d10b              BNE      |L42.158|
000086  6920              LDR      r0,[r4,#0x10]
000088  2800              CMP      r0,#0
00008a  d108              BNE      |L42.158|
;;;2470           {
;;;2471             tmp = (uint16_t*) husart->pRxBuffPtr;
00008c  6ae6              LDR      r6,[r4,#0x2c]
;;;2472             *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
00008e  6820              LDR      r0,[r4,#0]
000090  8c80              LDRH     r0,[r0,#0x24]
000092  4028              ANDS     r0,r0,r5
000094  8030              STRH     r0,[r6,#0]
;;;2473             husart->pRxBuffPtr += 2U;
000096  6ae0              LDR      r0,[r4,#0x2c]
000098  1c80              ADDS     r0,r0,#2
00009a  62e0              STR      r0,[r4,#0x2c]
00009c  e007              B        |L42.174|
                  |L42.158|
;;;2474           }
;;;2475           else
;;;2476           {
;;;2477             *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
00009e  6820              LDR      r0,[r4,#0]
0000a0  8c80              LDRH     r0,[r0,#0x24]
0000a2  b2e9              UXTB     r1,r5
0000a4  4008              ANDS     r0,r0,r1
0000a6  6ae2              LDR      r2,[r4,#0x2c]
0000a8  1c51              ADDS     r1,r2,#1
0000aa  62e1              STR      r1,[r4,#0x2c]
0000ac  7010              STRB     r0,[r2,#0]
                  |L42.174|
;;;2478           }
;;;2479           husart->RxXferCount--;
0000ae  8e60              LDRH     r0,[r4,#0x32]
0000b0  1e40              SUBS     r0,r0,#1
0000b2  8660              STRH     r0,[r4,#0x32]
                  |L42.180|
;;;2480         }
;;;2481       }
;;;2482   
;;;2483       /* Check the latest data received */
;;;2484       if(husart->RxXferCount == 0U)
0000b4  8e60              LDRH     r0,[r4,#0x32]
0000b6  2800              CMP      r0,#0
0000b8  d114              BNE      |L42.228|
;;;2485       {
;;;2486         /* Disable the USART Parity Error Interrupt and RXNE interrupt*/
;;;2487         CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
0000ba  6820              LDR      r0,[r4,#0]
0000bc  6800              LDR      r0,[r0,#0]
0000be  21ff              MOVS     r1,#0xff
0000c0  3121              ADDS     r1,r1,#0x21
0000c2  4388              BICS     r0,r0,r1
0000c4  6821              LDR      r1,[r4,#0]
0000c6  6008              STR      r0,[r1,#0]
;;;2488   
;;;2489         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;2490         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
0000c8  6820              LDR      r0,[r4,#0]
0000ca  6880              LDR      r0,[r0,#8]
0000cc  0840              LSRS     r0,r0,#1
0000ce  0040              LSLS     r0,r0,#1
0000d0  6821              LDR      r1,[r4,#0]
0000d2  6088              STR      r0,[r1,#8]
;;;2491   
;;;2492         /* Rx process is completed, restore husart->State to Ready */
;;;2493         husart->State = HAL_USART_STATE_READY;
0000d4  2101              MOVS     r1,#1
0000d6  2041              MOVS     r0,#0x41
0000d8  5501              STRB     r1,[r0,r4]
;;;2494   
;;;2495         HAL_USART_TxRxCpltCallback(husart);
0000da  4620              MOV      r0,r4
0000dc  f7fffffe          BL       HAL_USART_TxRxCpltCallback
;;;2496   
;;;2497         return HAL_OK;
0000e0  2000              MOVS     r0,#0
                  |L42.226|
;;;2498       }
;;;2499   
;;;2500       return HAL_OK;
;;;2501     }
;;;2502     else
;;;2503     {
;;;2504       return HAL_BUSY;
;;;2505     }
;;;2506   }
0000e2  bd70              POP      {r4-r6,pc}
                  |L42.228|
0000e4  2000              MOVS     r0,#0                 ;2500
0000e6  e7fc              B        |L42.226|
                  |L42.232|
0000e8  2002              MOVS     r0,#2                 ;2504
0000ea  e7fa              B        |L42.226|
;;;2507   
                          ENDP


                          AREA ||i.USART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  USART_Transmit_IT PROC
;;;2306     */
;;;2307   static HAL_StatusTypeDef USART_Transmit_IT(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;2308   {
;;;2309     uint16_t* tmp=0U;
000002  2200              MOVS     r2,#0
;;;2310   
;;;2311     /* Check that a Tx process is ongoing */
;;;2312     if(husart->State == HAL_USART_STATE_BUSY_TX)
000004  2041              MOVS     r0,#0x41
000006  5c40              LDRB     r0,[r0,r1]
000008  2812              CMP      r0,#0x12
00000a  d12d              BNE      |L43.104|
;;;2313     {
;;;2314   
;;;2315       if(husart->TxXferCount == 0U)
00000c  8d48              LDRH     r0,[r1,#0x2a]
00000e  2800              CMP      r0,#0
000010  d10d              BNE      |L43.46|
;;;2316       {
;;;2317         /* Disable the USART Transmit data register empty interrupt */
;;;2318         __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
000012  6808              LDR      r0,[r1,#0]
000014  6800              LDR      r0,[r0,#0]
000016  2380              MOVS     r3,#0x80
000018  4398              BICS     r0,r0,r3
00001a  680b              LDR      r3,[r1,#0]
00001c  6018              STR      r0,[r3,#0]
;;;2319   
;;;2320         /* Enable the USART Transmit Complete Interrupt */
;;;2321         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
00001e  6808              LDR      r0,[r1,#0]
000020  6800              LDR      r0,[r0,#0]
000022  2340              MOVS     r3,#0x40
000024  4318              ORRS     r0,r0,r3
000026  680b              LDR      r3,[r1,#0]
000028  6018              STR      r0,[r3,#0]
;;;2322   
;;;2323         return HAL_OK;
00002a  2000              MOVS     r0,#0
                  |L43.44|
;;;2324       }
;;;2325       else
;;;2326       {
;;;2327         if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;2328         {
;;;2329           tmp = (uint16_t*) husart->pTxBuffPtr;
;;;2330           husart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;2331           husart->pTxBuffPtr += 2U;
;;;2332         }
;;;2333         else
;;;2334         {
;;;2335           husart->Instance->TDR = (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)0xFFU);
;;;2336         }
;;;2337   
;;;2338         husart->TxXferCount--;
;;;2339   
;;;2340         return HAL_OK;
;;;2341       }
;;;2342     }
;;;2343     else
;;;2344     {
;;;2345       return HAL_BUSY;
;;;2346     }
;;;2347   }
00002c  4770              BX       lr
                  |L43.46|
00002e  2301              MOVS     r3,#1                 ;2327
000030  031b              LSLS     r3,r3,#12             ;2327
000032  6888              LDR      r0,[r1,#8]            ;2327
000034  4298              CMP      r0,r3                 ;2327
000036  d10c              BNE      |L43.82|
000038  6908              LDR      r0,[r1,#0x10]         ;2327
00003a  2800              CMP      r0,#0                 ;2327
00003c  d109              BNE      |L43.82|
00003e  6a4a              LDR      r2,[r1,#0x24]         ;2329
000040  8810              LDRH     r0,[r2,#0]            ;2330
000042  05c0              LSLS     r0,r0,#23             ;2330
000044  0dc0              LSRS     r0,r0,#23             ;2330
000046  680b              LDR      r3,[r1,#0]            ;2330
000048  8518              STRH     r0,[r3,#0x28]         ;2330
00004a  6a48              LDR      r0,[r1,#0x24]         ;2331
00004c  1c80              ADDS     r0,r0,#2              ;2331
00004e  6248              STR      r0,[r1,#0x24]         ;2331
000050  e005              B        |L43.94|
                  |L43.82|
000052  6a4b              LDR      r3,[r1,#0x24]         ;2335
000054  1c58              ADDS     r0,r3,#1              ;2335
000056  6248              STR      r0,[r1,#0x24]         ;2335
000058  7818              LDRB     r0,[r3,#0]            ;2335
00005a  680b              LDR      r3,[r1,#0]            ;2335
00005c  8518              STRH     r0,[r3,#0x28]         ;2335
                  |L43.94|
00005e  8d48              LDRH     r0,[r1,#0x2a]         ;2338
000060  1e40              SUBS     r0,r0,#1              ;2338
000062  8548              STRH     r0,[r1,#0x2a]         ;2338
000064  2000              MOVS     r0,#0                 ;2340
000066  e7e1              B        |L43.44|
                  |L43.104|
000068  2002              MOVS     r0,#2                 ;2345
00006a  e7df              B        |L43.44|
;;;2348   
                          ENDP


                          AREA ||i.USART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  USART_WaitOnFlagUntilTimeout PROC
;;;2136     */
;;;2137   static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  b5ff              PUSH     {r0-r7,lr}
;;;2138   {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  9e0a              LDR      r6,[sp,#0x28]
;;;2139     /* Wait until flag is set */
;;;2140     while((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
00000c  e022              B        |L44.84|
                  |L44.14|
;;;2141     {
;;;2142       /* Check for the Timeout */
;;;2143       if(Timeout != HAL_MAX_DELAY)
00000e  1c70              ADDS     r0,r6,#1
000010  2800              CMP      r0,#0
000012  d01f              BEQ      |L44.84|
;;;2144       {
;;;2145         if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
000014  2e00              CMP      r6,#0
000016  d005              BEQ      |L44.36|
000018  f7fffffe          BL       HAL_GetTick
00001c  9904              LDR      r1,[sp,#0x10]
00001e  1a40              SUBS     r0,r0,r1
000020  42b0              CMP      r0,r6
000022  d917              BLS      |L44.84|
                  |L44.36|
;;;2146         {
;;;2147           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2148           CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  21ff              MOVS     r1,#0xff
00002a  31a1              ADDS     r1,r1,#0xa1
00002c  4388              BICS     r0,r0,r1
00002e  6821              LDR      r1,[r4,#0]
000030  6008              STR      r0,[r1,#0]
;;;2149           CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000032  6820              LDR      r0,[r4,#0]
000034  6880              LDR      r0,[r0,#8]
000036  0840              LSRS     r0,r0,#1
000038  0040              LSLS     r0,r0,#1
00003a  6821              LDR      r1,[r4,#0]
00003c  6088              STR      r0,[r1,#8]
;;;2150   
;;;2151           husart->State= HAL_USART_STATE_READY;
00003e  2101              MOVS     r1,#1
000040  2041              MOVS     r0,#0x41
000042  5501              STRB     r1,[r0,r4]
;;;2152   
;;;2153           /* Process Unlocked */
;;;2154           __HAL_UNLOCK(husart);
000044  bf00              NOP      
000046  2100              MOVS     r1,#0
000048  2040              MOVS     r0,#0x40
00004a  5501              STRB     r1,[r0,r4]
00004c  bf00              NOP      
;;;2155   
;;;2156           return HAL_TIMEOUT;
00004e  2003              MOVS     r0,#3
                  |L44.80|
;;;2157         }
;;;2158       }
;;;2159     }
;;;2160     return HAL_OK;
;;;2161   }
000050  b005              ADD      sp,sp,#0x14
000052  bdf0              POP      {r4-r7,pc}
                  |L44.84|
000054  6820              LDR      r0,[r4,#0]            ;2140
000056  69c0              LDR      r0,[r0,#0x1c]         ;2140
000058  4028              ANDS     r0,r0,r5              ;2140
00005a  42a8              CMP      r0,r5                 ;2140
00005c  d101              BNE      |L44.98|
00005e  2001              MOVS     r0,#1                 ;2140
000060  e000              B        |L44.100|
                  |L44.98|
000062  2000              MOVS     r0,#0                 ;2140
                  |L44.100|
000064  42b8              CMP      r0,r7                 ;2140
000066  d0d2              BEQ      |L44.14|
000068  2000              MOVS     r0,#0                 ;2160
00006a  e7f1              B        |L44.80|
;;;2162   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\stm32f03xx_HAL\\Src\\stm32f0xx_hal_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f0xx_hal_usart_c_32ae8742____REV16|
#line 388 "..\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___21_stm32f0xx_hal_usart_c_32ae8742____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f0xx_hal_usart_c_32ae8742____REVSH|
#line 402
|__asm___21_stm32f0xx_hal_usart_c_32ae8742____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
